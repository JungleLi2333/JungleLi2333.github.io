<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>淋中之虹</title>
  
  <subtitle>向来不知道该说些什么</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.junglezero.top/"/>
  <updated>2019-07-09T14:32:25.550Z</updated>
  <id>https://www.junglezero.top/</id>
  
  <author>
    <name>JungleZero</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java多线程学习7（Exchanger,StampedLock,Fork/join,Phaser）</title>
    <link href="https://www.junglezero.top/2019/07/09/java-mutiple-threading-7/"/>
    <id>https://www.junglezero.top/2019/07/09/java-mutiple-threading-7/</id>
    <published>2019-07-09T03:36:52.000Z</published>
    <updated>2019-07-09T14:32:25.550Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>A synchronization point at which threads can pair and swap elements within pairs. Each thread presents some object on entry to the exchange method, matches with a partner thread, and receives its partner’s object on return. An Exchanger may be viewed as a bidirectional form of a SynchronousQueue. Exchangers may be useful in applications such as genetic algorithms and pipeline designs. </p></blockquote><p>主要内容：提供一个同步点，使一对线程交换数据，可以使用在遗传算法和管道设计上</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><img src="/upload/pasted-351.png" alt="upload successful"><br>简要来说就是调用该方法的线程会进入等待状态，等待其他线程调用，若有其他线程调用，则交换两者数据（把参数中的object传过去，返回传回来的object），注意一个及时性，即使调用该方法后休眠，也不会影响交换，若非特殊情况下的阻断，则调用该方法会一直等下去，<br>若有超过两个线程都调用exchange方法，则先到交换点（先调用方法）的两个线程会交换数据，若第三个线程调用，则会等待第四个线程调用来交换数据</p><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Exchanger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置交换器</span></span><br><span class="line">        <span class="keyword">final</span> Exchanger&lt;String&gt; exchanger=<span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"开始运行。"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//模拟为该线程有的数据</span></span><br><span class="line">                    String myData=<span class="string">"123456789"</span>;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"交换之前的数据:"</span>+myData);</span><br><span class="line">                    <span class="comment">//调用交换器的exchange方法，并返回交换的结果（进入交换点等待另一个线程调用该方法）</span></span><br><span class="line">                    String exchangeResult=exchanger.exchange(myData);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"交换之后的数据:"</span>+exchangeResult);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"结束。"</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"开始运行。"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String myData=<span class="string">"987654321"</span>;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"交换之前的数据:"</span>+myData);</span><br><span class="line">                    String exchangeResult=exchanger.exchange(myData);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"交换之后的数据:"</span>+exchangeResult);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"结束。"</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="/upload/pasted-352.png" alt="upload successful"></p><h1 id="StamperdLock"><a href="#StamperdLock" class="headerlink" title="StamperdLock"></a>StamperdLock</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>这是java1.8新增加的锁（在JUC中），是对ReentrantReadWriteLock锁的一种改进:基于读的乐观锁<br>在Optimistic reading中，即使读线程获取到了读锁，写线程尝试获取写锁也不会阻塞，这相当于对读模式的优化，但是可能会导致数据不一致的问题。所以，当使用Optimistic reading获取到读锁时，必须对获取结果进行校验。</p><p><img src="/upload/pasted-353.png" alt="upload successful"></p><p>这里有一篇<a href="https://blog.overops.com/java-8-stampedlocks-vs-readwritelocks-and-synchronized/" target="_blank" rel="noopener">文章</a>,在这片文章中，作者讨论了synchronized,StampedLocks,和RWlock的效率对比，可以发现当读线程远多于写线程时，乐观锁的效率是最高的。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>可以使用StampededLock直接替代reentrantreadwritelock<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.StampedLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLockTest</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> StampedLock lock=<span class="keyword">new</span> StampedLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> List&lt;Long&gt; DATA=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ExecutorService executorService= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        Runnable readTask=<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (;;)</span><br><span class="line">                    read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable writeTask =<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (;;)</span><br><span class="line">                    write();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(writeTask);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//悲观式读取</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamped=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamped=lock.readLock();</span><br><span class="line">            <span class="comment">//模拟读取数据</span></span><br><span class="line">            System.out.println(DATA.toString());</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlockRead(stamped);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamp=lock.writeLock();</span><br><span class="line">            DATA.add(System.currentTimeMillis());</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而这个锁的改进就是对读加上乐观锁<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> stamped = lock.tryOptimisticRead();</span><br><span class="line">    <span class="keyword">if</span> (lock.validate(stamped)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamped = lock.readLock();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Exchanger&quot;&gt;&lt;a href=&quot;#Exchanger&quot; class=&quot;headerlink&quot; title=&quot;Exchanger&quot;&gt;&lt;/a&gt;Exchanger&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java语言基础知识和其他应该知道的东西</title>
    <link href="https://www.junglezero.top/2019/07/06/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://www.junglezero.top/2019/07/06/Java语言基础知识/</id>
    <published>2019-07-06T02:53:05.000Z</published>
    <updated>2019-07-06T09:41:45.215Z</updated>
    
    <content type="html"><![CDATA[<p># </p><h2 id="ArrayList和Linkedlist区别"><a href="#ArrayList和Linkedlist区别" class="headerlink" title="ArrayList和Linkedlist区别"></a>ArrayList和Linkedlist区别</h2><p>1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。<br>2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。<br>3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。<br>4．对ArrayList和LinkedList而言，在列表末尾增加一个元素所花的开销都是固定的。对ArrayList而言，主要是在内部数组中增加一项，指向所添加的元素，偶尔可能会导致对数组重新进行分配；而对LinkedList而言，这个开销是统一的，分配一个内部Entry对象。<br>5．在ArrayList的中间插入或删除一个元素意味着这个列表中剩余的元素都会被移动；而在LinkedList的中间插入或删除一个元素的开销是固定的。<br>6．LinkedList不支持高效的随机元素访问。<br>7．ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间 </p><h2 id="java方法“值传递”的理解"><a href="#java方法“值传递”的理解" class="headerlink" title="java方法“值传递”的理解"></a>java方法“值传递”的理解</h2><p>java中的数据类型有基本类型和引用类型，他们都是值传递方式。基本类型传递的是它的值，因此方法中的改变参数的值，不会影响方法外。引用类型传递的是一个地址，因为引用类型在生成对象实例时，里面的值是一个地址，指向了对象实例。在传值的时候实际上传的是一个地址，他们指向了同一块地址，所以在方法内的改变会影响方法外的参数。 这里比较乱人心的是包装类型，因为包装类型也是引用类型，这里应该就是和包装类型的实现有关了，在包装类型中，比如Integer a=1，有一个自动装箱的操作。其实a=1，如果现在令a=2，不会令2覆盖1（即1本身是不会变的），真正改变的是a被赋给了一个新地址，这个地址指向了2。因此方法内的改变包装类型的值就相当于改变了形参里面的地址，相当于重新new了一遍。而方法外面的实参仍旧指向含1的那个地址，一次方法内的改变不会影响方法外的实参。 </p><p><img src="/upload/pasted-320.png" alt="upload successful"></p><h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><p>Volatile：与锁相比，Volatile 变量是一种非常简单但同时又非常脆弱的同步机制，它在某些情况下将提供优于锁的性能和伸缩性。如果严格遵循 volatile 的使用条件 —— 即变量真正独立于其他变量和自己以前的值 —— 在某些情况下可以使用 volatile 代替 synchronized 来简化代码。然而，使用 volatile 的代码往往比使用锁的代码更加容易出错。<br>只能在有限的一些情形下使用 volatile 变量替代锁。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：</p><ul><li>（1）对变量的写操作不依赖于当前值。</li><li>（2）该变量没有包含在具有其他变量的不变式中。<br>实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。<br>第一个条件的限制使 volatile 变量不能用作线程安全计数器。虽然增量操作（x++）看上去类似一个单独操作，实际上它是一个由读取－修改－写入操作序列组成的组合操作，必须以原子方式执行，而 volatile 不能提供必须的原子特性。实现正确的操作需要使 x 的值在操作期间保持不变，而 volatile 变量无法实现这点。 </li></ul><h2 id="数组复制"><a href="#数组复制" class="headerlink" title="数组复制"></a>数组复制</h2><p>1.for循环<br>2.System.arraycopy<br>3.Arrays.copyOf<br>4.clone</p><h2 id="类的加载顺序"><a href="#类的加载顺序" class="headerlink" title="类的加载顺序"></a>类的加载顺序</h2><p>(1) 父类静态代码块(包括静态初始化块，静态属性，但不包括静态方法)<br>(2) 子类静态代码块(包括静态初始化块，静态属性，但不包括静态方法 )<br>(3) 父类非静态代码块( 包括非静态初始化块，非静态属性 )<br>(4) 父类构造函数<br>(5) 子类非静态代码块 ( 包括非静态初始化块，非静态属性 )<br>(6) 子类构造函数</p><h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p>1、不管有没有出现异常，finally块中代码都会执行；<br>2、当try和catch中有return时，finally仍然会执行；<br>3、finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，不管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值），所以函数返回值是在finally执行前确定的；<br>4、finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。</p><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="registerNatives"><a href="#registerNatives" class="headerlink" title="registerNatives()"></a>registerNatives()</h3><p>向JVM注册native方法<br>在类初始化的时候，会依次从父类到本类的类变量及类初始化块中的类变量及方法按照定义顺序放到 &lt; clinit&gt;方法中，这样可以保证父类的类变量及方法的初始化一定先于子类。所以当子类调用相应 native方法，比如计算 hashCode时，一定可以保证能够调用到 JVM的 native方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">       registerNatives();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h3 id="getClass"><a href="#getClass" class="headerlink" title="getClass()"></a>getClass()</h3><p>类加载的第一阶段类的加载就是将 .class文件加载到内存，并生成一个 java.lang.Class对象的过程。 getClass()方法就是获取这个对象，这是当前类的对象在运行时类的所有信息的集合。这个方法是反射三种方式之一。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure></p><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><p>这个方法返回一个int类型的hash值<br>在 Java应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改；<br>如果两个对象 x.equals(y) 方法返回 true，则 x、 y这两个对象的 hashCode必须相等。<br>如果两个对象 x.equals(y) 方法返回 false，则 x、 y这两个对象的 hashCode可以相等也可以不等。但是，为不相等的对象生成不同整数结果可以提高哈希表的性能。<br>默认的 hashCode是将内存地址转换为的 hash值，重写过后就是自定义的计算方式；也可以通过 System.identityHashCode(Object)来返回原本的 hashCode。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>计算 hashCode使用了31作为基础乘数，为什么使用31呢？result *31=(result&lt;&lt;5)-result。 JVM底层可以自动做优化为位运算，效率很高；还有因为 31计算的 hashCode冲突较少，利于 hash桶位的分布。</p><h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><p>用于比较当前对象与目标对象是否相等，默认是比较引用是否指向同一对象。为 public方法，子类可重写。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>重写equals的意义：<br>因为如果不重写equals方法，当将自定义对象放到 map或者 set中时；如果这时两个对象的 hashCode相同，就会调用 equals方法进行比较，这个时候会调用 Object中默认的 equals方法，而默认的 equals方法只是比较了两个对象的引用是否指向了同一个对象，显然大多数时候都不会指向，这样就会将重复对象存入 map或者 set中。这就破坏了 map与 set不能存储重复对象的特性，会造成内存溢出。</p><h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><p>这是一个 protected方法，提供给子类重写。但需要实现 Cloneable接口，这是一个标记接口，如果没有实现，当调用 object.clone()方法，会抛出 CloneNotSupportedException<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure></p><p>两个概念——<br>浅拷贝：创建一个新对象，然后将当前对象的非静态字段复制到该对象，如果字段类型是值类型（基本类型）的，那么对该字段进行复制；如果字段是引用类型的，则只复制该字段的引用而不复制引用指向的对象。此时新对象里面的引用类型字段相当于是原始对象里面引用类型字段的一个副本，原始对象与新对象里面的引用字段指向的是同一个对象。<br>说白了就是clone一个对象，将会创建一个新的对象，而对于其内部属性，比如一个String的引用类型，克隆对象和被克隆对象指向的是一个引用。换言之，如果克隆对象的属性发生了改变，则原对象也会发生改变<br>而深拷贝则是一个完全不同的拷贝的方式<br>深拷贝通过序列化(Serializable)实现</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="wait-相关方法"><a href="#wait-相关方法" class="headerlink" title="wait()相关方法"></a>wait()相关方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        timeout++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多线程情况下使用作用是阻塞进程</p><ul><li>此方法只能在当前线程获取到对象的锁监视器之后才能调用，否则会抛出 IllegalMonitorStateException异常。</li><li>调用 wait方法，线程会将锁监视器进行释放；而 Thread.sleep，Thread.yield()并不会释放锁。</li><li>wait方法会一直阻塞，直到其他线程调用当前对象的 notify()/notifyAll()方法将其唤醒；而 wait(long)是等待给定超时时间内（单位毫秒），如果还没有调用 notify()/nofiyAll()会自动唤醒； wait(long,int)如果第二个参数大于 0并且小于 999999，则第一个参数 +1作为超时时间；</li></ul><h3 id="notify-notifyAll"><a href="#notify-notifyAll" class="headerlink" title="notify()/notifyAll()"></a>notify()/notifyAll()</h3><p>如果当前线程获得了当前对象锁，调用 wait方法，将锁释放并阻塞；这时另一个线程获取到了此对象锁，并调用此对象的 notify()/notifyAll()方法将之前的线程唤醒。这些方法都是 publicfinal的，不可被重写。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>要点：<br>调用 notify()后，阻塞线程被唤醒，可以参与锁的竞争，但可能调用 notify()方法的线程还要继续做其他事，锁并未释放，所以我们看到的结果是，无论 notify()是在方法一开始调用，还是最后调用，阻塞线程都要等待当前线程结束才能开始。</p><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h3><p>jvm垃圾回收时进行调用</p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p><img src="/upload/pasted-321.png" alt="upload successful"></p><h2 id="和equals"><a href="#和equals" class="headerlink" title="==和equals"></a>==和equals</h2><p>==用来判断两个变量是否相等时，如果两个变量是基本类型变量，且都是数值类型(不要求数据类型严格相同)，则只要两个变量的值相等，就返回true；对于两个引用类型变量，必须指向同一个对象，==才会返回true。<br>equals方法用于比较两个独立对象的内容是否相同</p><h2 id="实例变量，局部变量，类变量，final变量"><a href="#实例变量，局部变量，类变量，final变量" class="headerlink" title="实例变量，局部变量，类变量，final变量"></a>实例变量，局部变量，类变量，final变量</h2><ul><li>实例变量：是定义在是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。分配了内存空间后会给所有的成员变量一次初始化，没有赋值的会给成员变量对应类型的值，数据类型不同则默认值不同。</li><li>局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。用的时候是直接入栈的，如果没有赋值，这个变量就没有初始值，也就无法操作，所以局部变量要初始化。</li><li>类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。</li><li>final变量，final 修饰的变量。如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li></ul><h2 id="Integer的赋值问题"><a href="#Integer的赋值问题" class="headerlink" title="Integer的赋值问题"></a>Integer的赋值问题</h2><p>在为Integer赋值的时候，java编译器会将其翻译成调用valueOf()方法。比如Integer i=127翻译为Integer i=Integer.valueOf(127)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//high为127</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= -<span class="number">128</span> &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + <span class="number">128</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，对于-128到127之间的数，Java会对其进行缓存。而超出这个范围则新建一个对象。</p><h2 id="throws和throw"><a href="#throws和throw" class="headerlink" title="throws和throw"></a>throws和throw</h2><p>1、throws出现在方法头，throw出现在方法体 2、throws表示出现异常的一种可能性，并不一定会发生异常；throw则是抛出了异常，执行throw则一定抛出了某种异常。 3、两者都是消极的异常处理方式，只是抛出或者可能抛出异常，是不会由函数处理，真正的处理异常由它的上层调用处理</p><h2 id="接口（Interface）"><a href="#接口（Interface）" class="headerlink" title="接口（Interface）"></a>接口（Interface）</h2><p>接口，比抽象类还要抽象的类。</p><ul><li>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract （只能是 public abstract，其他修饰符都会报错）。</li><li>接口中可以含有变量，但是接口中的变量会被隐式的指定为  public static final   变量（并且只能是 public，用 private 修饰会报编译错误。）</li><li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。 </li></ul><p>注：<br>接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。<br>接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字。<br>接口中的方法都是公有的。public</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>Reflection（反射）是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的內部信息，并能直接操作任意对象的内部属性及方法。</p><p>Java反射机制主要提供了以下功能：</p><ul><li>在运行时构造任意一个类的对象</li><li>在运行时获取任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的方法（属性）</li><li>生成动态代理</li></ul><ol><li><p>Class: 是一个类; 一个描述类的类.<br>　　封装了描述方法的 Method,描述字段的 Filed,描述构造器的 Constructor 等属性.</p><ol start="2"><li><p>如何得到 Class 对象:<br>　　2.1 Person.class<br>　　2.2 person.getClass()<br>　　2.3 Class.forName(“com.atguigu.javase.Person”)</p></li><li><p>关于 Method:<br>　　3.1 如何获取 Method:<br>　　　　1). getDeclaredMethods: 得到 Method 的数组.<br>　　　　2). getDeclaredMethod(String methondName, Class … parameterTypes)</p></li></ol><p>　　3.2 如何调用 Method<br>　　　　1). 如果方法时 private 修饰的, 需要先调用 Method 的　setAccessible(true), 使其变为可访问<br>　　　　2). method.invoke(obj, Object … args);</p><ol start="4"><li><p>关于 Field:<br>　　4.1 如何获取 Field: getField(String fieldName)<br>　　4.2 如何获取 Field 的值:<br>　　　　1). setAccessible(true)<br>　　　　2). field.get(Object obj)<br>　　4.3 如何设置 Field 的值:<br>　　　　field.set(Obejct obj, Object val)</p></li><li><p>了解 Constructor 和 Annotation </p></li><li><p>反射和泛型.<br>　　6.1 getGenericSuperClass: 获取带泛型参数的父类, 返回值为: BaseDao&lt;Employee, String&gt;<br>　　6.2 Type 的子接口: ParameterizedType<br>　　6.3 可以调用 ParameterizedType 的 Type[] getActualTypeArguments() 获取泛型参数的数组.<br><a href="https://www.cnblogs.com/tech-bird/p/3525336.html" target="_blank" rel="noopener">https://www.cnblogs.com/tech-bird/p/3525336.html</a></p></li></ol></li></ol><h2 id="AQS和CAS"><a href="#AQS和CAS" class="headerlink" title="AQS和CAS"></a>AQS和CAS</h2><p>抽象队列同步器AQS ( AbstractQueuedSychronizer ) , 如果说java.util.concurrent的基础是CAS的话,那么AQS就是整个Java并发包的核心了, ReentrantLock、CountDownLatch、Semaphore等都用到了它。AQS实际上以双向队列的形式连接所有的Entry ,比方说ReentrantLock ,所有等待的线程都被放在一个Entry中并连成双向队列,前面一个线程使用 ReentrantLock好了, 则双向队列实际上的第一个Entry开始运行。 AQS定 义了对双向队列所有的操作,而只开放了tryLock和tryRelease方法给开发者使用,开发者可以根据自己的实现重写tryLock和tryRelease方法,以实现自己的并发功能。</p><p>比较并替换CAS(Compare and Swap) ,假设有三个操作数:内存值V、旧的预期值A、要修改的值B ,当且仅当预期值A和内存值V相同时,才桧将内存值修改为B并返回true ,否则什么都不做并返回false ,整个比较并替换的操作是一个原子操作。CAS一定要volatile变量配合,这样才能保证每次拿到的变量是主内中最新的相应值,否则旧的预期值A对某条线程来说,永远是一个不会变的值A,只要某次CAS操作失败，下面永远都不可能成功。</p><p>CAS虽然比较高效的解决了原子操作问题,但仍存在三大问题。</p><ul><li>循环时间开销大</li><li>只能保证一个共享变量的原子操作</li><li>ABA问题</li></ul><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p> Condition是在java 1.5中才出现的，它用来替代传统的Object的wait()、notify()实现线程间的协作，相比使用Object的wait()、notify()，使用Condition1的await()、signal()这种方式实现线程间协作更加安全和高效。因此通常来说比较推荐使用Condition，在阻塞队列那一篇博文中就讲述到了，阻塞队列实际上是使用了Condition来模拟线程间协作。</p><ul><li>Condition是个接口，基本的方法就是await()和signal()方法；</li><li>Condition依赖于Lock接口，生成一个Condition的基本代码是lock.newCondition()</li><li>调用Condition的await()和signal()方法，都必须在lock保护之内，就是说必须在lock.lock()和lock.unlock之间才可以使用Conditon中的await()对应Object的wait()； Condition中的signal()对应Object的notify()； Condition中的signalAll()对应Object的notifyAll() </li></ul><h2 id="Spring-mvc执行流程"><a href="#Spring-mvc执行流程" class="headerlink" title="Spring mvc执行流程"></a>Spring mvc执行流程</h2><p><img src="/upload/pasted-323.png" alt="upload successful"><br><a href="https://www.cnblogs.com/jay36/p/7527039.html" target="_blank" rel="noopener">https://www.cnblogs.com/jay36/p/7527039.html</a></p><h2 id="AOP-IOC"><a href="#AOP-IOC" class="headerlink" title="AOP IOC"></a>AOP IOC</h2><p>AOP和IOC是Spring精华部分, AOP可以看做是对OOP的补充,对代码进行横向的扩展,通过代理模式实现,代理模式有静态代理,动态代理, Spring利用的是动态代理,在程序运行过程中将增强代码织入原代码中。IOC是 控制反转,将对象的控制权交给Spring框架,用户需要使用对象无需创建,直接使用即呵。AOP和IOC最可贵的是它们的思想。</p><h2 id="Hibernate-POJO"><a href="#Hibernate-POJO" class="headerlink" title="Hibernate POJO"></a>Hibernate POJO</h2><p>Hibernate Pojo的三态分别为transient（瞬时态）,persistent（持久态）,detached（游离态）</p><p>1、官方给出的三态与Session的关系如下：</p><p>transient: never persistent, not associated with any Session<br>persistent: associated with a unique Session<br>detached: previously persistent, not associated with any Session</p><p>2、三种状态间相互转换关系，及他们在数据库、session中的状态如下：<br>a.当我们new一个pojo时，它处于瞬时态，此时与session、数据库均无任何关联。<br>b.此后，我们获得session并开启hibernate事务，调用save(),persist(),saveOrUpdate()方法，将pojo转变为持久态，此时session中存有这个pojo，但直到transaction.commit()被调用时，sql语句才会执行，此后数据库中也才有此条数据。<br>c.但当commit()并且session.close()执行过后，pojo就变为了游离态，也就是说，数据库中有该记录，但session中不再有。<br>d.持久化状态的实例，也可以重新变成瞬时态，那就是调用delete()方法。<br>e.通过get()或load()方法得到的pojo是持久态的。<br>f.游离态的pojo可以通过update(),saveOrUpdate(),lock()和replicate()方法重新成为持久态。<br>g.调用merge()方法后，pojo维持原态，但内容会被更新到数据库</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>Java通过Executors提供四个静态方法创建四种线程池，分别为：</p><p>newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p><p>newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p><p>newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</p><p>newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</p><p>作用：<br>限定线程的个数，不会导致由于线程过多导致系统运行缓慢或崩溃</p><p>线程池不需要每次都去创建或销毁，节约了资源、</p><p>线程池不需要每次都去创建，响应时间更快。</p><h2 id="javaWeb"><a href="#javaWeb" class="headerlink" title="javaWeb"></a>javaWeb</h2><h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p><img src="/upload/pasted-324.png" alt="upload successful"><br>servlet是运行在服务器端的小应用程序，是接收网络服务的请求和产生响应的一种方式。<br>servlet的功能：接受http请求，产生动态http响应。<br>HttpServlet是GenericServlet的子类。<br>GenericServlet是个抽象类，必须给出子类才能实例化。它给 出了设计servlet的一些骨架，定义了servlet生命周期，还有一些得到名字、配置、初始化参数的方法，其设计的是和应用层协议无关的，也就是说 你有可能用非http协议实现它。<br>HttpServlet是子类，当然就具有GenericServlet的一切特性，还添加了doGet, doPost, doDelete, doPut, doTrace等方法对应处理http协议里的命令的请求响应过程。</p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>servlet有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。这个生存期由javax.servlet.Servlet接口的init,service和destroy方法表达。<br>加载Servlet的class—-&gt;实例化Servlet—–&gt;调用Servlet的init完成初始化—-&gt;响应请求（Servlet的service方法）—–&gt;Servlet容器关闭时(Servlet的destory方法)<br>Servlet启动时，开始加载servlet生命周期开始。Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候(服务器关闭)调用其destroy方法。</p><h4 id="forward-与redirect-的区别"><a href="#forward-与redirect-的区别" class="headerlink" title="forward() 与redirect()的区别"></a>forward() 与redirect()的区别</h4><p>forward是服务器端的转向而redirect是客户端的跳转。</p><p>使用forward浏览器的地址不会发生改变。而redirect会发生改变。</p><p>Forward是一次请求中完成。而redirect是重新发起请求。</p><p>Forward是在服务器端完成，而不用客户端重新发起请求，效率较高<br>一般没有特殊需要，自己写的Servlet都扩展HttpServlet 。</p><h4 id="JSP和Servlet有哪些相同点和不同点"><a href="#JSP和Servlet有哪些相同点和不同点" class="headerlink" title="JSP和Servlet有哪些相同点和不同点"></a>JSP和Servlet有哪些相同点和不同点</h4><p>JSP是Servlet技术的扩展，所有的jsp文件都会被翻译为一个继承HttpServlet的类。也就是jsp最终也是一个Servlet.这个Servlet对外提供服务。</p><p><img src="/upload/pasted-347.png" alt="upload successful"><br>Servlet和JSP最主要的不同点在于JSP侧重于视图，Servlet主要用于控制逻辑。<br>Servlet如果要实现html的功能，必须使用Writer输出对应的html,比较麻烦。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件,做界面展示比较方便而嵌入逻辑比较复杂</p><h4 id="jsp内置对象"><a href="#jsp内置对象" class="headerlink" title="jsp内置对象"></a>jsp内置对象</h4><p>request 用户端请求，此请求会包含来自GET/POST请求的参数</p><p>response 网页传回用户端的回应</p><p>pageContext 网页的属性是在这里管理</p><p>session 与请求有关的会话期</p><p>application servlet正在执行的内容</p><p>out 用来传送回应的输出</p><p>config servlet的构架部件</p><p>page JSP网页本身</p><p>exception 针对错误网页，未捕捉的例外</p><p>四大作用域：pageContext request session application 可以通过jstl从四大作用域中取值.</p><p>Jsp传递值request session application cookie也能传值</p><h3 id="http-get和post请求的区别"><a href="#http-get和post请求的区别" class="headerlink" title="http get和post请求的区别"></a>http get和post请求的区别</h3><p>GET和POST请求都是http的请求方式，用户通过不同的http的请求方式完成对资源（url）的不同操作。GET，POST，PUT，DELETE就对应着对这个资源的查 ，改 ，增 ，删 4个操作,具体点来讲GET一般用于获取/查询资源信息，而POST一般用于更新资源信息<br>1、Get请求提交的数据会在地址栏显示出来，而post请求不会再地址栏显示出来.</p><p>GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&amp;连接；POST提交：把提交的数据放置在是HTTP包的包体中。因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变</p><p>2、传输数据的大小</p><p>http Get请求由于浏览器对地址长度的限制而导致传输的数据有限制。而POST请求不会因为地址长度限制而导致传输数据限制。</p><p>3、安全性,POST的安全性要比GET的安全性高。由于数据是会在地址中呈现，所以可以通过历史记录找到密码等关键信息。</p><h3 id="Session-和-Cookie"><a href="#Session-和-Cookie" class="headerlink" title="Session 和 Cookie"></a>Session 和 Cookie</h3><p>Session和cookie都是会话(Seesion)跟踪技术。Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。但是Session的实现依赖于Cookie,sessionId(session的唯一标识需要存放在客户端).</p><p>cookie 和session 的区别：</p><p>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</p><p>2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗</p><p>   考虑到安全应当使用session。</p><p>3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用COOKIE。</p><p>4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p><p>5、所以个人建议：</p><p>   将登陆信息等重要信息存放为SESSION</p><p>   其他信息如果需要保留，可以放在COOKIE中，比如购物车</p><p>购物车最好使用cookie，但是cookie是可以在客户端禁用的，这时候我们要使用cookie+数据库的方式实现，当从cookie中不能取出数据时，就从数据库获取。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;# &lt;/p&gt;
&lt;h2 id=&quot;ArrayList和Linkedlist区别&quot;&gt;&lt;a href=&quot;#ArrayList和Linkedlist区别&quot; class=&quot;headerlink&quot; title=&quot;ArrayList和Linkedlist区别&quot;&gt;&lt;/a&gt;ArrayList和
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>结束是另一个开始</title>
    <link href="https://www.junglezero.top/2019/07/05/mething-Ends-Something-Begins-translate-cn/"/>
    <id>https://www.junglezero.top/2019/07/05/mething-Ends-Something-Begins-translate-cn/</id>
    <published>2019-07-05T15:05:25.000Z</published>
    <updated>2019-07-09T14:59:15.085Z</updated>
    
    <content type="html"><![CDATA[<p>翻译自外国的某个热心粉丝Something Ends, Something Begins <a href="https://witcher.fandom.com/wiki/Something_Ends,_Something_Begins_(unofficial_translation)" target="_blank" rel="noopener">https://witcher.fandom.com/wiki/Something_Ends,_Something_Begins_(unofficial_translation)</a><br>意思跑偏太正常了，这哥们把波兰语翻译成英语要跑偏一部分，我再把英语翻译成汉语又会跑偏一部分。对于这里面出现的一些人物，已经在第一次出现的地方链接到了猎魔人的wiki,有兴趣的朋友可以看一看。</p><hr><h1 id="I"><a href="#I" class="headerlink" title="I"></a>I</h1><p>太阳炽热的触须透过百叶窗的缝隙伸展开来，倾斜的阳光把房间横断开来，飞悬的尘埃在光线中跃动着，落在地板的熊皮上，在叶妮芙皮带扣炫目的闪光中渐渐消散。叶妮芙的腰带挂在高跟鞋上，高跟鞋在白色蕾丝内衣上，而内衣在黑色的裙子上。一只黑色长筒袜挂在雕刻成烟囱状的扶手椅上，另一只袜子和另一只高跟鞋却四处不见，杰洛特叹了口气。叶妮芙喜欢利索优雅的脱掉衣服，他必须开始习惯起来，他没别的选择。<br>他站起身来，打开窗子向外看去，湖面光滑如镜，迷迷蒙蒙中，岸边的桦树和赤杨的叶子上闪着露珠，远处的草地上覆盖着厚重的雾，沉默的压下来，犹如蛛网一般悬在草地之上</p><p>叶妮芙在毯子下嘟囔着什么，含糊不清。杰洛特叹了口气<br>“今天天气真好，叶。”<br>“嗯？你说什么？”<br>“今天天气很好，尤为的好”<br>她还是让他吃了一惊，女术士并没有像往常一样讽刺挖苦，也没有把头压在枕头下，而是坐起身来。用手梳理着头发，然后在床上找睡衣，杰洛特知道睡衣就在床头下面，就在她昨晚脱掉的地方，但是他一句话也没说，因为他知道，叶妮芙讨厌这种话。<br>女术士突然咒骂起来，她踢了踢毯子，举起手咬住手指，睡袍就从床前飞来，摆动着荷叶边，犹如一个可怕的幽灵，然后落在她的手上。杰洛特叹了口气。叶妮芙站起身来走到他跟前，抱住了他，咬了他的胳膊，杰洛特叹了口气，他不得不习惯的事似乎多的数不清。<br>“你没什么想说的吗？”，女术士眯着眼睛，问道<br>“并没有。”<br>“很好，今天的确很好，干的不错。”<br>“什么意思？”<br>叶妮芙还没来得及回答，就听见远处传来一声又高又长的叫喊声和喘息声。湖边，希瑞骑着一匹黑色的母马溅起一阵水花，这是一匹纯种马，长得很漂亮。杰洛特还记得它的上一个主人是个半精灵，这个半精灵轻率的凭第一印象错误的判断了这个白发的猎魔女，最终犯下大错。希瑞将这匹母马命名为“卡尔比”，在史凯利杰岛民的口中，这个意思是一种可怕的，胆大妄为的海的神灵，有时也会化身为马。这名字非常适合这匹母马。不久之前，有个半身人就因为某种艰难的方式了解到了，当他尝试偷走这匹马时，被这匹马猛地给了一脚，正中脸上，这半身人以前叫桑迪·弗洛莫顿，但自此以后人们就叫他“花椰菜”了。<br>“总有一天她会摔断脖子的”，叶妮芙叫喊道，看着希瑞在溅起的水花中飞奔，弯腰，牢牢的踩着马镫。“总有一天你这疯女儿会摔断脖子的。”<br>杰洛特转过头来，也不说话，就这么静静的看着女术士那双紫罗兰色的眼眸。<br>“好吧好吧，”叶妮芙目不转睛的微笑着，“对不起，我们的女儿。”<br>她又抱住他，紧紧地靠在他身上，又咬了下他的胳膊，然后亲吻她，接着又咬了下，杰洛特嘴唇触碰着她的头发，小心翼翼的把睡袍来到她的肩上。<br>然后最终他们还是又上了床，散乱的毯子，尚有余温，仍旧沉浸在梦中。他们开始互相寻找彼此，寻找的时间很长，也很耐心，他们都深知最终会找到彼此，充满欢喜的彼此，他们所做的一切都是欢愉的，尽管他们之间尚有很大的差异，他们也和往常一样想着，这种差异并不是将他们分割开来，而是紧紧的绑在一起的差异，就犹如房梁和屋脊，那才是房屋的诞生所在。这也犹如第一次，当他被她赤裸而强烈的欲望所迷住，而她被他的巧妙和感性所迷住，就像她第一次本想告诉他，但是他却只用了一个吻和一个安抚让她安宁下来，消除了其他的所有感觉，后来，当他想要告诉她时，他却一点声音也发不出来，再后来，欢愉被一块巨石压倒，他们的眼中只有那一刻的闪光，听到的只是无声的呼喊，世界犹如静止一般，结束了，开始了，然后是沉默，宁静的沉默【本段见小说第一本《白狼崛起》的“最后的愿望”】<br>还有无限的魅力。<br>世界又重新回到它的轨道上，这里还是一张充满梦幻和光亮的床，然后是一天，那样的一天……<br>“叶…”<br>“嗯？”<br>“当你说今天天气不错时，还说了句‘干得不错’，该不是……”<br>“是的”她承认道，伸展着双臂握紧毯子的边，使她的胸部在那一刻以这种方式展现出来，这使得猎魔人的下半身一阵颤动<br>“看啊，杰洛特，是我们打造出这样的天气，昨晚，我，<a href="http://witcher.huijiwiki.com/wiki/%E5%8D%97%E5%B0%BC%E5%85%8B" target="_blank" rel="noopener">南尼克</a>,特莉丝和<a href="http://witcher.huijiwiki.com/wiki/%E5%A4%9A%E7%91%9E%E5%8A%A0%E9%9B%B7" target="_blank" rel="noopener">多瑞加雷</a>,我不能冒险，今天必须是美好的一天……”<br>她一声不吭的用膝盖猛击了杰洛特一下。<br>“为什么？因为这是你生命中最重要的一天，傻东西。”【叶妮芙设定上会读心术，专读杰洛特的】</p><hr><h1 id="II"><a href="#II" class="headerlink" title="II"></a>II</h1><p>洛史洛格城堡矗立在湖中凸起的地带，亟需进行全面的修缮工作，绝对不仅仅是现在。说的好听一点，洛史洛格就是一片废墟，一个不规整的石头堆，铺满了常青藤，野葡萄，地衣和苔藓，说来说去也不过是这片烂沼泽地中的一个遗迹，四处满是蛤蟆，蝾螈和乌龟，当年这片土地给赫维格国王时，这已经就是一片废墟了，这个城堡以及周边的沼泽，更像是一份毕生的礼物，一份送给赫维格告别礼物。赫维格于12年前退位，以支持他的侄子“友善者”布伦南，杰洛特曾通过丹德里恩结识了这位前国王，因为赫维格国王为人和蔼，也喜好招待宾客，所以这位吟游诗人经常出入城堡。<br>当女术士排除了猎魔人所提供的所有地点参考时，丹德里恩就把赫维格国王的洛史洛格城堡提了上来，诡异的是，女术士马上就同意了这个提议，甚至连鼻子也没抽一下。<br>于是，杰洛特和叶妮芙的婚礼将在洛史洛格城堡举行</p><hr><h1 id="III"><a href="#III" class="headerlink" title="III"></a>III</h1><p>一开始，这场婚礼设定上是小型的，不那么引人注目的婚礼，可是因为各种原因，这是不可能实现的，所以很有必要找一个擅长组织的人。自然，叶妮芙是拒绝的，她不想张罗她自己的婚礼，杰洛特和希瑞，还有丹德里恩，那就不用说了，他们就没组织这个概念，于是他们向艾尔兰德的梅里泰莉神庙的大祭司南尼克求助，南尼克二话不说就来了，带着两个年轻的女祭司小爱若拉和尤妮德。<br>于是各种问题开始接踵而至。</p><hr><h1 id="IV"><a href="#IV" class="headerlink" title="IV"></a>IV</h1><p>“这可不行，杰洛特，”南尼克怒吼道，跺了跺脚，“婚礼和宴会要是出了什么岔子我可不负责。那片废墟，有些傻瓜竟然称之为一座城堡，那可是一点用也没有，那里的厨房都要塌了，舞厅也就能用来做个马厩，那个礼拜堂……那就不是个礼拜堂，至少你能告诉我那个瘸子赫维格信奉哪位神灵吗？”<br>“据我所知，他谁也不信奉，他还声称宗教不过是大众的精神毒品”<br>“哼，我就知道，”女祭司说道，丝毫没有掩饰自己的轻蔑，“那个礼拜堂里没有一座雕像，除了老鼠粪以外，就没有别的东西了，最重要的是，那个地方不过是一摊死水，杰洛特，你怎么不想在一个文明的国家举行婚礼呢，比如温格堡？”<br>“你知道的，叶是一个混血儿，你们的那些文明国家可不准许这种混合的婚姻”<br>“梅里泰莉女神在上！不过是四分之一的精灵血统，有什么问题吗？谁都或多或少的带点上古民族的血统，这只是个愚蠢的偏见！”<br>“那也不是我编出来的。”</p><hr><h1 id="V"><a href="#V" class="headerlink" title="V"></a>V</h1><p>邀请的客人名单实际上并不长，夫妇两人把名单汇总交给了丹德里恩，让他去发放邀请函，结果是这个吟游诗人还没来得及读完就给弄丢了，因为他羞于承认，于是他就耍了些花招：尽可能的邀请他所能邀请的任何人，当然，他对叶妮芙和杰洛特都很了解，所以没有落下任何一个重要的人，但是要是没有趁机邀请到更多的乱七八糟的形形色色的人的话，那他也就不是丹德里恩了。<br>于是，杰洛特的导师，来自凯尔莫罕的老维瑟米尔和杰洛特的童年伙伴，猎魔人艾斯卡尔就过来了<br>德鲁伊<a href="http://witcher.huijiwiki.com/wiki/%E8%8E%AB%E6%96%AF%E8%90%A8%E5%85%8B" target="_blank" rel="noopener">莫斯萨克</a>带着一个名叫芙蕾雅的金发女郎来了，芙蕾雅比他高一头，但是可比他年轻上百岁。来的还有<a href="http://witcher.huijiwiki.com/wiki/%E5%85%8B%E6%8B%89%E8%8C%A8%C2%B7%E5%AE%89%C2%B7%E5%85%8B%E8%8E%B1%E7%89%B9" target="_blank" rel="noopener">克拉茨·安·克莱特</a>,史凯利杰群岛的伯爵，带着他的两个儿子拉格纳和洛基，拉格纳骑马时，脚都快碰到地了，而洛基则像个精灵，也难怪他们兄弟两个，但是他们有着不同的母亲<br>来自布拉维坎的里夫·凯尔迪米恩和他女儿阿妮卡到了【出自《白狼崛起》的“勿以恶小”，布拉维坎屠夫的称号就是从这个地方得来的】，阿妮卡很有魅力但生性害羞。矮人<a href="http://witcher.huijiwiki.com/wiki/%E4%BA%9A%E5%B0%94%E6%BD%98%C2%B7%E9%BD%90%E6%A0%BC%E6%9E%97" target="_blank" rel="noopener">亚尔潘·齐格林</a>出现了，没有带着其他人，这很有意思，他一般都是带着他的长胡子同伙的。他是在半路上碰上了精灵<a href="http://witcher.huijiwiki.com/wiki/%E5%87%AF%E7%91%9E%E5%B0%94%E4%B8%B9" target="_blank" rel="noopener">凯瑞尔丹</a>一起来的，可见凯瑞尔丹在精灵中还是有些地位的，身边有几个默默无闻的精灵，无人知晓。<br>又来了一队吵吵嚷嚷的半身人，这群人里杰洛特只认识<a href="http://witcher.huijiwiki.com/wiki/%E4%B8%B9%E8%BF%AA%C2%B7%E6%AF%94%E4%BC%AF%E5%A8%81%E7%89%B9" target="_blank" rel="noopener">丹迪·比伯威特</a>，蓼草牧场的商人和牧马人,还有只是有所耳闻的，因好斗而出名的老婆加德尼娅·比伯威特，领头的还有一个不是半身人的半身人——著名的商人特里科·朗格瑞文克·勒托特，一个异形怪，伪装成名为“<a href="http://witcher.huijiwiki.com/wiki/%E5%98%9F%E5%98%9F" target="_blank" rel="noopener">嘟嘟</a>”的半身人。【见《宿命之剑》的“永恒之火”】<br>来自布洛克莱昂的<a href="http://witcher.huijiwiki.com/wiki/%E8%8F%B2%E6%96%AF%E5%A5%88%E7%89%B9" target="_blank" rel="noopener">菲斯奈特</a>男爵到了，带着他的妻子，高贵的树精布蕾恩，以及他们的五个女儿莫丽恩、希瑞菈、莫娜、艾思娜和卡什卡，莫丽恩15岁的样子，而卡什卡看上去只有五岁。她们都是一头红发，尽管菲斯奈特是黑发，布蕾恩是金发、布蕾恩明显怀有身孕。他的一群红发树精女儿彼此咯咯的笑着，菲斯奈特信誓旦旦的说，这次一定是个儿子【小说中说树精X非树精=女树精】而布蕾恩则笑着补充道，这个“儿子”就叫梅丽莎。【这两个人的故事见《宿命之剑》的“宿命之剑”】<br>独臂的<a href="http://witcher.huijiwiki.com/wiki/%E9%9B%85%E5%B0%94" target="_blank" rel="noopener">雅尔</a>也来了，这是一位年轻的牧师，编年史家，来自艾尔兰德，是南尼克的一个学徒，他来这里主要是因为他暗恋的希瑞，心疼的南尼克觉得，希瑞对于这个残疾青年的隐晦的调情似乎太过冷淡。<br>打头的不速之客是布利姆巫德的<a href="http://witcher.huijiwiki.com/wiki/%E8%89%BE%E6%A0%BC%E7%BD%97%E7%93%A6%E5%B0%94" target="_blank" rel="noopener">艾格罗瓦尔</a>王子，他的到来被视作为一个奇迹，因为他和杰洛特曾经毫不留情的公开鄙视对方，更奇怪的是，他是和他的妻子美人鱼<a href="http://witcher.huijiwiki.com/wiki/%E5%B8%8C%E6%81%A9%E5%A8%9C%E5%85%B9" target="_blank" rel="noopener">希恩娜兹</a>一起来的，尽管她为了一双异常漂亮的腿牺牲了自己的鱼尾，但人们都知道她从未离开过海岸，因为她对陆地充满恐惧【这段故事见《宿命之剑》的“一点牺牲”】<br>没人料到还会有其他的国王会对于此事比较上心——说来说去也没人邀请他们。尽管如此，还是有很多国王派发贺信，礼物，使者——或者以上的一并送出。他们应该是事先商量好了，因为他们的使者是组团来的，彼此都相互认识了。伊夫骑士代表埃塞因国王，领主苏力沃伊代表文斯拉夫国王，玛索尔姆爵士代表西吉斯蒙德国王，德弗卢爵士代表<a href="http://witcher.huijiwiki.com/wiki/%E9%9B%85%E5%A6%B2" target="_blank" rel="noopener">雅坦</a>王后，他们这几个人的旅行一定很愉快，因为伊夫的嘴唇被割破了，苏力沃伊的胳膊绑在板子上，玛索尔姆一瘸一拐的，而德弗卢醉的很厉害，几乎要从马上摔下来了。<br>没人能邀请金龙<a href="http://witcher.huijiwiki.com/wiki/%E5%8D%9A%E5%B0%94%E5%A5%87" target="_blank" rel="noopener">维纶特瑞坦梅斯</a>,因为没人知道怎么邀请他以及他到底在哪，令众人吃惊的是，他还是来了，自然是隐藏了真实的形态，是以骑士博尔奇“三只寒鸦”的身份来的，当然，有丹德里恩在的地方，就没有什么隐私可言，但是当吟游诗人指着这位卷发骑士声称他其实是一条金龙时，还是没什么人相信。<br>没人会料到还有一群各式各样的流浪人的到来，当然，也没人邀请他们。他们被登记为“丹德里恩的朋友和熟人”，主要是诗人，歌手和剧场演员，还有杂耍演员，职业骰子手，鳄鱼训练师以及四个浓妆艳抹的女人，其中三个毫无疑问就是妓女，而第四个虽然看上去不像，但毫无疑问也是，有两个算命的，其中一个还是个骗子，还有一个雕塑家，一个金发女郎，和一个醉酒的灵媒师，还有个麻子脸的侏儒，自称是舒滕巴赫<br>在一艘外形犹如一只天鹅背着一个巨大的枕头的魔法船上，术士团到了，他们比邀请的要少上4倍，但是比预期来的要多上三倍，正如传言所说的那样，叶妮芙的同行并不认同她会嫁给一个外人，还是个猎魔人，他们中的一部分人直接无视邀请，另一部分人则以没时间为由，说是要去参见一年一度的世界修道院集会，因此，在那艘被丹德里恩唤做“枕头鸟”的船上只有沃尔的多瑞加雷，牛堡的<a href="http://witcher.huijiwiki.com/wiki/%E8%8E%B1%E5%BE%B7%E5%85%8B%E9%87%8C%E5%A4%AB" target="_blank" rel="noopener">莱德克里夫</a>,以及一头栗色头发的特莉丝·梅利葛德</p><hr><h1 id="VI"><a href="#VI" class="headerlink" title="VI"></a>VI</h1><p>“是你邀请的特莉丝·梅利葛德？”<br>“没有的事，”猎魔人急忙摇了摇头，暗自庆幸自己的血液循环系统不会让自己脸红。“不是我，估计是丹德里恩，尽管他们都说他们是通过水晶占卜知道的。”<br>“我不希望特莉丝·梅利葛德出现在我的婚礼上！”<br>“为什么呀，她可是你的朋友。”<br>“不要把我当傻子，猎魔人！是个人就知道你跟她有一腿。”<br>“扯淡！”<br>叶妮芙的紫罗兰色眼睛危险的眯着。<br>“是真的”<br>“真不是”<br>“就是真的”<br>“够了，”他生气的把头扭向一边，“就是真的了，你想怎么样？”<br>女术士沉默了，摆弄着脖子上的黑曜石星星。<br>“也没什么，”女术士最终开了口，“我就是想让你承认罢了，不要冲我撒谎，杰洛特，永远也不要”</p><hr><h1 id="VII"><a href="#VII" class="headerlink" title="VII"></a>VII</h1><p>城堡的石墙散发出一股潮湿的气息，外加一股子药草的酸味。阳光照在褐色的泥水上，竟然拽出了沼泽地里某种植物的暖绿色和海狸百合闪闪发光的黄色<br>城堡也慢慢苏醒过来，渐渐有了生机。城堡西翼，有人打开百叶窗，放声大笑。有人用一种微弱的声音请求来一些泡菜卤水，丹德里恩的一位同事，一个盲诗人，一边挂着胡子，一边放声唱到：</p><p>干草仓后的栅栏上，<br>有只公鸡高声唱，<br>姑娘我会赶到你身旁，<br>来上一炮也无妨……</p><p>门吱扭一声开了，丹德里恩来到院子中，他伸了伸懒腰，揉了揉眼睛<br>“你好啊，新郎官，”他疲惫的说道。“如果你想要溜走，就只有现在了。”<br>“丹德里恩，你竟然成了早起的鸟儿。”<br>“我压根就没上床”，诗人嘟囔着，坐在猎魔人旁的石凳上，靠着长满藤蔓的石墙。“神啊，多么每美妙的夜晚，但不管怎么说，可不是每天都有好朋友要结婚，自然是要好好的庆祝一下。”<br>“婚礼的宴会是在今天，”杰洛特提醒道，“你能撑得过去吗？”<br>“你瞧不起我吗？”</p><p>艳阳高照，鸟儿在灌木丛中啾啾的叫着，湖上传来溅水声和咯咯的笑声，那是菲斯奈特的红发树精女儿们莫丽恩、希瑞菈、莫娜、艾思娜和卡什卡正和往常一样光着身子在湖中玩耍，特莉丝·梅利葛德和莫斯萨克的朋友芙蕾雅正看着她们。而城垛上，皇家的使者们，伊夫骑士，苏力沃伊领主，玛索尔姆爵士和德弗卢爵士却为了争抢一个望远镜而大打出手。</p><p>“玩得还好吗，丹德里恩？”<br>“别提了。”<br>“又出什么乱子了？”<br>“可是有那么几个。”</p><p>正如诗人所说，第一个争端是关于种族的。宴会开到一半时，特里科·朗格瑞文克·勒托特突然发作，说他已经忍受够了半身人的伪装，勒托特指着在坐的树精，精灵，半身人，美人鱼，和一个声称自己是舒滕巴赫的侏儒，说他们每个人都能做他们自己而只有他，特里科必须得伪装成别人的样子，这就是种歧视，然后他突然变回了自己自然模样，看到这一幕，加德尼娅·比伯威特当场晕了过去，艾格罗瓦尔王子差点被龙虾给噎着，而里夫·卡尔迪米恩的女儿阿妮卡则歇斯底里的叫了起来，这混乱场面最终还是靠着金龙维纶特瑞坦梅斯得以拯救，当然，是以骑士博尔奇“三只寒鸦”的形态。他淡淡的向勒托特解释道，说异形是一种天赐的恩惠，然而这种恩惠也要求他保持一种社会能够接受的形态，而且也是出于对东道主的礼仪。<br>可是勒托特指责维纶特瑞坦梅斯，说他的这番话完全就是种族主义，沙文主义以及站着说话不腰疼。因此受辱的维纶特瑞坦梅斯猛地变成了龙形，毁坏了几件家具，引得众人一阵恐慌，待局势稍微缓和下来时，一场激烈的争端就开始了，人类和非人种族在互相指责对方的不宽容，对方的种族歧视，这场争论意想不到的转折来自脸上长着雀斑的媚儿，就是那个不像妓女的妓女，她说这场争辩就是扯淡，对于“专业人士”来说，是不是人根本就没有关系，还说愿意当场证明（当然，钱要到位。）甚至包括处在自然形态下的维纶特瑞坦梅斯，在那片刻间的寂静中，众人听到那个灵媒师说她也愿意做同样的事，而且不收钱。维纶特瑞坦梅斯赶忙转换话题，开始讨论一些相对安全的话题，比如经济，政治，狩猎，钓鱼以及冒险。<br>其他的事情可能相对来说不那么暴力。莫斯萨克，莱德克里夫和多瑞加雷比他们谁能用意念控制更多的东西浮空。最终是多瑞加雷赢了，他成功的将两把椅子，一个水果盘，一碗汤，一个地球仪，一只猫，两只狗以及菲斯奈特和布蕾恩的女儿卡什卡悬在空中。<br>然后是菲斯奈特和布蕾恩的两个女儿，希瑞拉和莫娜扭打在一起，于是她们被要求返回自己的房间，不一会拉格纳和玛索尔姆爵士为菲斯奈特的大女儿莫林又打了起来。生气的菲斯奈特赶忙把自己的红发女儿们都关在了屋子里，然后自己兴冲冲的跑去参加由莫斯萨克的女友芙蕾雅组织的斗酒。很快，丹德里恩的朋友们，那些诗人和歌手，纷纷喝倒在桌子下，很明显芙蕾雅对于酒精有难以想象的抑制能力，近乎于免疫。但是菲斯奈特，克拉茨·安·克莱特，里夫·卡尔迪米恩仍然勇敢的战斗着，然后他们也败下阵来。术士莱德克里夫此时却还坚定的举着酒杯，直到人们发现他带着一个独角兽的角，拿掉之后，他一下子就不行了。有那么一段时间，桌子上都没人，然后就来了一个穿着老式服装的卡夫坦人，他脸色苍白，没人认识他。他和芙蕾雅喝了几个来回，过了一会，站了起来，晕晕乎乎的，礼貌的鞠了一躬，穿过一堵墙，就好像一阵雾，通过对大厅中的挂画的彻底搜查，人们认定他可能是几百年前在黑暗时代被谋杀的罗兹罗格的继承人“魔鬼”威廉姆。<br>这座古堡藏着各种各样的秘密，早些年，它以它的阴森可怕而闻名，但是人们都比较怀疑，毕竟并没有发生什么超自然的事。午夜时分，一只吸血鬼从开着的窗子飞来进来，一进来，就被矮人亚尔潘·齐格林扔了头大蒜，然后被他追着打。整个晚上，总能听见货真价实的鬼哭狼嚎，但没人在意，人们都觉得是丹德里恩和他的朋友在搞鬼。然而，楼梯上大量的外质表明，这的确就是货真价实的鬼魂，还有几个人滑到在上面。</p><p>有个影子跨过门槛，他眨着火一般的眼睛，淘气的捏了希恩娜兹的屁股一把，看来要想解决这些误会可能要有些难度了，因为希恩娜兹认定就是丹德里恩干的，这个鬼影立刻接着这个误会，四处捣乱，直到他被南尼克抓住并用驱魔术驱逐出去。<br>几个人声称自己看见了苍白夫人，传说中，她被活埋在洛史洛格城堡的地下墓穴中。而别的人则觉得这个不是苍白夫人，而是那个女灵媒师在画廊中走动着找酒喝<br>然后就开始有人失踪了，最开始失踪的是伊夫骑士和鳄鱼杀手，不一会人，人们发现拉格纳和年轻的女祭司尤妮德也没了。然后是加德尼娅·比伯威特，但后来才知道她去睡觉了。接着是独臂的雅尔和第二个年轻女祭司小爱若拉。虽然希瑞对雅尔没什么感情可言，但还是有些担心，但很显然，这个年轻人不小心摔在了阴沟里，在里面睡着了。而小爱若拉则是在楼梯口被发现了，旁边还有精灵凯瑞尔丹。特莉丝·梅利葛德和来自凯尔莫罕的猎魔人艾斯卡尔被发现了消失在花园的凉亭附近。早上，有人声称看见了在凉亭那里看见了变形怪特里科，人们就在议论纷纷，琢磨着这个异形怪到底变成了谁的模样，甚至有人觉得这里有两个异形怪。他们想向金龙维纶特瑞坦梅斯征求下意见，毕竟他也是个变形专家，结果这条龙也不见了，妓女媚儿和他在一起。<br>第二个妓女也没了，同时消失的还有一个算命的，剩下的一个算命的说太才是真的那个，但是没人能证明。同时，那个自称是舒滕巴赫的侏儒也不见了。</p><p>“你大概已经后悔了，”吟游诗人打了个大大的哈欠，“你不在真的是太遗憾了，那可是相当的精彩。”<br>“我的确挺后悔的，”猎魔人感叹道，“但是你懂得……我不能,因为叶妮芙……总之你应该是最了解的。”<br>“那是肯定的，”丹德里恩赞成到，“所以我才不会傻到去结婚。”</p><hr><h1 id="VIII"><a href="#VIII" class="headerlink" title="VIII"></a>VIII</h1><p>城堡的厨房中传来了平底锅的叮当声，快乐的笑声以及哼哼的小调声。要为这么多客人提供盛宴是个问题，因为赫维格国王平日几乎就没什么客人。术士的到来并没有解决任何问题，出于对于食品安全的考量，食物都得是自然的东西，不掺杂一点魔法，所以南尼克到处助抓人打下手。一开始并不简单，因为被拉过来的人一点厨房的常识也没有，而那些会做饭的早就跑掉了。然而还是jia带着一群半身人过来帮忙。令人吃惊的是，丹德里恩招来的那四个妓女都是出乎意料的厨房能手。<br>供给方面也没有问题fei和ai组织了一场狩猎，打来了不少鹿肉，布蕾恩和他的女儿们只用了两个小时就打来了足够多的野味，众所周知树精大多箭术惊人，就连小女儿卡什卡弯弓搭箭也很流畅。热衷钓鱼的老国王赫维格一早就到湖上打鱼去了。带回了梭子鱼，狭鳕鱼还有好大只的贝斯鱼。ke的小儿子洛基跟他一同去的，岛民出身的他驾船打鱼样样精通，并且他也是早上为数不多能派上用场的，因为他和赫维格国王一样不沾酒。<br>在变形怪特里科的驱使下，dan和他的亲戚们开始打扫大厅和各个房间，他们又赶着两个算命的，鳄鱼杀手，雕塑家还有喝的烂醉的灵媒师一同打扫清理。<br>看管地下室的酒水的工作一开始交给了丹德里恩和他的朋友们，后来被证明这是一个灾难性的决定，于是这些诗人们就被赶了出去，钥匙交到mo的女朋友芙蕾雅手中。但是丹德里恩和他的朋友们还赖着不走了，试图用抒情诗打动芙蕾雅，可这位岛民却像抵制酒精那样抵制他们的诗歌。<br>杰洛特猛地抬起头来，他被从石子路上传来的马蹄声惊醒了，卡尔比从墙边的灌木丛中冲出，是希瑞来了，她穿着她的黑色皮革护甲，背上背着把剑，正是名剑格维尔，是她从科洛奇沙漠的地下墓穴中得到的。<br>有那么一会他们就要彼此对视，也不说话。女孩驾着马向前，卡尔比向着杰洛特咬了过去，却被希瑞猛地拉了回来。<br>“就是今天了，”猎魔女说道，“是今天，杰洛特。”<br>“是今天，”猎魔人背靠着墙，确认到。<br>“我很高兴”，她的声音中有种不确定，“我想……我不太肯定你们两个会不会幸福，但我还是很高兴。”<br>“希瑞，下马，我们得谈谈。”<br>女孩甩了下头，把头发甩到了后面。杰洛特看见了一道又宽又丑的伤疤——这是一段不堪回首的往事，希瑞就是为了遮住伤疤才将头发蓄长，但是她总是忘了挡住伤疤。<br>“我要走了，杰洛特”她告诉猎魔人，“宴会之后，立马上路。”<br>“下马，希瑞。”<br>猎魔女跳下马来，坐在他身旁，杰洛特抱住了她，希瑞靠在他的肩上。<br>“我要离开了，”她又说了一遍。<br>他什么也没说，话到嘴边，但是他觉得不合适，或者说不必要。他什么也没说。<br>“我知道你在想什么，”她慢慢的说道，“你觉得我是要逃跑，的确是这样。”<br>他还是沉默着，他的确明白。<br>“毕竟，在经历了这么多风风雨雨，你终于和叶结婚了，你理应幸福，理应有一个安定的家，但是这一切却令我感到害怕，杰洛特，所以……我要逃这一切。”<br>他还是沉默着，他想起了自己的逃跑。<br>“宴会结束马上就走，”希瑞又说了一遍。“我想……我想要再次感受策马急行的风，我想眺望地平线上的星星，我想要晚上吹丹德里恩歌谣的调调，我渴求战斗，渴求用剑一决胜负，渴求冒险，渴求胜利带给我的喜悦，并且我渴求孤孤单单的一个人，你能明白我的意思吗？”<br>“明白，”杰洛特悲伤的笑了笑，“我当然明白，你是我的宿命，你是个猎魔人，你要去做你必须要做的，但我必须要告诉你一件事，你不能一走了之，尽管你在不停的尝试。”<br>“我知道，”她回应到，紧紧的抱住他，“我也希望有一天，如果我不停的等待，如果我有足够的耐心，我大概也有像你这样的一天……如此好的一天……即使……”<br>“即使什么，希瑞？”<br>“我很丑，而且还有那样一道难看的伤疤……”<br>“希瑞！”他打断她，“你是世上最漂亮的女孩……当然只是在叶之后。”<br>“杰洛特……”<br>“你不信的话，去问丹德里恩。”<br>“杰洛特，我……”<br>“说起来，他死哪里去了……”<br>“我要去南方，”她打断了他，不敢直视他。“战后仍然不安定，那里的人们需要保护，我会派上用场的，还要去科洛奇……还有尼弗迦德，我和格威尔在那里还有未了结的事。”<br>她突然沉默了，脸变得冷漠起来。绿色的眼睛眯了起来，嘴角挂满了仇恨。我记得，杰洛特，我还记得，就像现在一样。上一次他们并肩在吕思勋城堡作战。楼梯上已经血流成河，他们就站在血泊当中。狼和猫，两个冷血的杀人机器，非人的速度和非人的冷漠，围上来的尼弗迦德人慢慢的后退。一只出奇冷静的狼和一只出奇疯狂的猫，闪烁的刀锋，哭喊声，四处迸溅的鲜血，以及遍地凋零的生命……就像那样，就像上一次那样。<br>希瑞将头发向后甩去，灰白的头发在太阳穴处一阵震荡。<br>“我还用未竟之事，”她冷冷的说道，“为了<a href="http://witcher.huijiwiki.com/wiki/%E7%B1%B3%E5%B8%8C%E5%B0%94" target="_blank" rel="noopener">米希尔</a>,为了我的米希尔，我已经为她报了仇，但是只杀一个人是不够的。”<br><a href="http://witcher.huijiwiki.com/wiki/%E7%B1%B3%E5%B8%8C%E5%B0%94" target="_blank" rel="noopener">雷欧·邦纳特</a>，她杀了他，为她报了仇。希瑞啊希瑞，你现在已经处在深渊边缘，女儿，即使杀了上千人也换不回你的米希尔，要提防仇恨啊，那种堪比癌症的情感。<br>“你要当心你自己啊。”他低沉的说。<br>“我宁愿让别人当心，”她讽刺的笑了笑，“这样回报更多，也更加有意义。”<br>我再也见不到她了，他想，如果她走了，我不会再见到她了。<br>“还会再见的，”她出乎意料的回答道，脸上挂着一个女术士而非猎魔人的微笑。“还会再见的，杰洛特。”<br>她如一个男孩般跑开了，敏捷的跳上马鞍。<br>“架，卡尔比！！”<br>【以上对话涉及的人的确是后面小说中的人物，但是故事的发展稍微不太一样】<br>马蹄铁踏在路上，迸溅出火花。丹德里恩不知从哪里冒出来了，他把鲁特琴挂在肩上，腾出手来，一手拿着一大罐啤酒。</p><p>“来，喝一杯”他说着，坐在他身边，“这对你有好处。”<br>“我不太确定，叶妮芙警告我，如果他在我身上闻到酒味”<br>“嚼些欧芹就行了，喝吧，你这妻管严。”</p><p>他们静静的坐了好长时间，慢悠悠的喝着啤酒，丹德里恩叹了口气。<br>“希瑞要走了，是吗？”<br>“嗯。”<br>“我觉得也是，杰洛特，听我说两句……”<br>“丹德里恩，你还是闭嘴吧。”<br>“哦。好吧。”<br>他们又沉默了。厨房传来了一股烤鹿肉的香味，刺柏的味道很浓。<br>“……结束了（Something ends），”杰洛特艰难的说，“都结束了。”<br>“可不是这样，”诗人严肃的反驳道，“是开始了（Something begins）”</p><hr><h1 id="IX"><a href="#IX" class="headerlink" title="IX"></a>IX</h1><p>下午是在一片哭声中度过的，一切都是从美之灵药开始的，这种灵药，更准确的说是一种软膏，在古老的习俗中，也被称作“格拉玛耶”，据说可以使女性变得更加漂亮，更加引人注目。在各个主妇的要求下，te准备了大量的药膏。于是在场的女士们开始按照习俗涂抹。但是，在锁死的门后传来了希瑞菈、莫娜、艾思娜和卡什卡的哭声，她们不允许使用格拉玛耶，只有大女儿莫丽恩才能享受这一殊荣。哭的最响的是卡什卡，在她的上一层，莉莉正在哇哇的哭，她是dan的女儿，因为她发现和大多数魔法物品一样，格拉玛耶对半身人不起作用，在花园中瞎逛的灵媒师只是嗅了嗅，可她不知道的是嗅上一口就提神醒脑的后果，她陷入了无尽的忧郁当中。城堡的西翼，里夫·卡尔迪米恩的女儿阿妮卡也哭了起来，她不知道格拉玛耶是要涂在眼睛下面的，却吃了那药膏，现在正在腹泻。希瑞也拿了她那一份，涂在了卡尔比的眼下。<br>女祭司小爱若拉和尤妮德也哭了，因为叶妮芙拒绝穿她们为她精心制作的白色婚纱，甚至南尼克在一旁劝也没用，叶妮芙骂骂咧咧，还把盘子给摔了，大声喊着他穿上这玩意就像一个他妈的白衣处女，南尼克也生气了，大声骂着她的行为比三个该死处女还糟糕。叶妮芙也没有回骂回去，直接放了一道闪电，打穿了塔楼的屋顶。这一举措还是有好的一面的，突如其来的巨响让卡尔迪米恩的女儿一惊，竟然吓好了她的腹泻。<br>又有人看见特莉丝和猎魔人艾斯卡尔溜进了花园的小亭子，两人还手牵着手，毫无疑问，这次两人都是本人，因为变形怪特里科正在和dan和金龙维纶特瑞坦梅斯喝酒。<br>人们又仔仔细细的找了一遍，还是没找到那个自称是舒滕巴赫侏儒。</p><hr><h1 id="X"><a href="#X" class="headerlink" title="X"></a>X</h1><p>“叶……”<br>她看上去心情激动，她那黑色的波浪般的卷发，被一个金色的发饰扣住，垂在肩头，乌黑亮丽。镶着黑色条纹的白色长裙闪闪发光，紧身衣上的紫色丝带写满了荣雅。<br>“花，别忘了花”，特莉丝在一旁提醒道，她一身深蓝色的装扮，递给新娘一束白玫瑰，“哦，叶。我太开心了……”<br>“特莉丝，亲爱的……”叶妮芙突然抽泣起来，两个女术士紧紧地拥抱在一起，亲吻着彼此的钻石耳环。<br>“意思意思就行了”南尼克在一旁不耐烦的提醒道，顺手抚平洁白的祭祀服上的褶皱。“走，我们去教堂，爱若拉，尤妮德，托着她的裙子，否则她会在楼梯口自杀的。”</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;翻译自外国的某个热心粉丝Something Ends, Something Begins &lt;a href=&quot;https://witcher.fandom.com/wiki/Something_Ends,_Something_Begins_(unofficial_transl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java多线程学习6（CAS，原子类，CountDownLatch，CyclicBarrier，Semaphore）</title>
    <link href="https://www.junglezero.top/2019/07/02/ithreading-6/"/>
    <id>https://www.junglezero.top/2019/07/02/ithreading-6/</id>
    <published>2019-07-02T01:08:13.000Z</published>
    <updated>2019-07-05T07:23:46.615Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CAS通常是指（Compare And Swap或 Compare And Set）是硬件操作系统级别提供的具有原子性的原语指令，利用它可以在多线程中取得和同步一样的效果。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>基于<a href="https://www.junglezero.top/2019/04/23/%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81-1/#more">乐观锁</a>。以i++为例子举例，一般情况下是三步操作，分别是取值，+操作，存值，但是如果是多线程操作，就会存在线程安全的问题，对于CAS，首先获取旧的预期值，在准备保存时，和当前内存中的值进行对比（compare）,如果两个值相等，说明这个值没有发生改变，此时就存入新值（swap），如果发生改变，说明这个值已经被别的线程修改，此时当前线程不会进行操作，或者循环几个周期</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>因为加锁花销太大了（悲观锁）<br>结合上一个多线程的学习（AQS）,包括下面的原子类型，就可以发现实际上CAS是java并发包主要应用的一个方法</p><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>既然是基于乐观锁，那么势必会有ABA问题，所谓ABA问题，就是在当前线程准备存储过程中，如果这个值从A变成了B又变回了A，则对于当前线程，值是没有发生改变的，虽然从结果来看没什么影响，但是这实际上是个潜在的问题，解决的方法在上面的那个链接已经说明，就是添加一个版本号，或者时间戳</p><h3 id="自旋式循环"><a href="#自旋式循环" class="headerlink" title="自旋式循环"></a>自旋式循环</h3><p>当存值失败时，就有可能进入循环状态（自旋），如果多次失败，就会有效率上的问题</p><h1 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h1><p>java并发包下提供了java.util.concurrent.atomic包，包中包含了16个类（java8）</p><p><img src="/upload/pasted-339.png" alt="upload successful"></p><h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>摘录自API文档</p><blockquote><p>A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.</p></blockquote><blockquote><p>A CountDownLatch is initialized with a given count. The await methods block until the current count reaches zero due to invocations of the countDown() method, after which all waiting threads are released and any subsequent invocations of await return immediately. This is a one-shot phenomenon – the count cannot be reset. If you need a version that resets the count, consider using a CyclicBarrier.</p><p>A CountDownLatch is a versatile synchronization tool and can be used for a number of purposes. A CountDownLatch initialized with a count of one serves as a simple on/off latch, or gate: all threads invoking await wait at the gate until it is opened by a thread invoking countDown(). A CountDownLatch initialized to N can be used to make one thread wait until N threads have completed some action, or some action has been completed N times.</p><p>A useful property of a CountDownLatch is that it doesn’t require that threads calling countDown wait for the count to reach zero before proceeding, it simply prevents any thread from proceeding past an await until all threads could pass. </p></blockquote><p>从上面的描述中，得知几个事情</p><ul><li>这是一个计数器，用来使一个或者多个线程等待其他线程完成其操作</li><li>使用一个数值初始化，调用await使【当前线程】进入等待状态，当被等待的线程完成其任务时调用countDown()使计数–，直到减到0时【当前线程】不再等待</li><li>可以把countDownLatch理解为一个开关或者，只有【被等待线程】调用countDown()，await的线程才能“从大门进去”</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>文档中给到了一个Driver-Worker的实例<br>使用两个CountDownLatch，第一个在driver准备就绪之前，阻止worker执行，第二个使driver等待直到worker执行完<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123; <span class="comment">// ...</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     CountDownLatch startSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">     CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="comment">// create and start threads</span></span><br><span class="line">       <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(startSignal, doneSignal)).start();</span><br><span class="line"></span><br><span class="line">     doSomethingElse();            <span class="comment">// driver先执行</span></span><br><span class="line">     startSignal.countDown();      <span class="comment">// 调用countDown使startSignal归0</span></span><br><span class="line">     doSomethingElse();</span><br><span class="line">     doneSignal.await();           <span class="comment">// 使driver等着worker的线程执行完（等待doneSignal归0）</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startSignal;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line">   Worker(CountDownLatch startSignal, CountDownLatch doneSignal) &#123;</span><br><span class="line">     <span class="keyword">this</span>.startSignal = startSignal;</span><br><span class="line">     <span class="keyword">this</span>.doneSignal = doneSignal;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//等待startSignal归0</span></span><br><span class="line">       startSignal.await();</span><br><span class="line">       doWork();</span><br><span class="line">       <span class="comment">//worker线程每执行完，调用countdown，是doneSignal减1</span></span><br><span class="line">       doneSignal.countDown();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;&#125; <span class="comment">// return;</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>文档中还给到了一个另一个实例：<br>将一个问题分成多个部分，然后每个线程运行一部分<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver2</span> </span>&#123; <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N);</span><br><span class="line">    Executor e = ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="comment">// create and start threads</span></span><br><span class="line">      e.execute(<span class="keyword">new</span> WorkerRunnable(doneSignal, i));</span><br><span class="line"></span><br><span class="line">    doneSignal.await();           <span class="comment">// wait for all to finish</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkerRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> i;</span><br><span class="line">  WorkerRunnable(CountDownLatch doneSignal, <span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">this</span>.doneSignal = doneSignal;</span><br><span class="line">    <span class="keyword">this</span>.i = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      doWork(i);</span><br><span class="line">      doneSignal.countDown();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;&#125; <span class="comment">// return;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>和上面的CountDownLatch类似，但还是有区别的</p><blockquote><p>A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point. CyclicBarriers are useful in programs involving a fixed sized party of threads that must occasionally wait for each other. The barrier is called cyclic because it can be re-used after the waiting threads are released.</p><p>A CyclicBarrier supports an optional Runnable command that is run once per barrier point, after the last thread in the party arrives, but before any threads are released. This barrier action is useful for updating shared-state before any of the parties continue.</p></blockquote><p>这个强调的是“使一套线程等待彼此，直到所有的线程都到达了检查点（barrier point）”，相比于上面的CountDownLatch，它不需要执行线程去调用变化（countdown）</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>有两个构造方法<br><img src="/upload/pasted-340.png" alt="upload successful"><br>第一个方法的参数是这一组需要互相等待的线程的数量<br>当输入的数量大于需要运行的线程的数量时，由于到达检查点的线程（运行await）的数量小于预定的，所以会一直等待<br>当输入的参数小于需要进行互相等待的数量时，先到者优先，没有抢到的只能顺序运行<br>第二个方法还多一个Runnable对象，包括上面也说到了，这个线程的参数是指当所有的线程到达检查点时，并不会立刻运行，会先跑传入的参数的这个线程，这个线程完了，其他到检查点的线程才会解除等待状态</p><p><img src="/upload/pasted-341.png" alt="upload successful"><br>调用await时，有几个情况会使等待线程不再等待：</p><ul><li>最后一个线程到达检查点</li><li>超时</li><li>别的线程打断当前线程</li><li>别的线程打断别的等待线程（到达检查点的线程）</li><li>别的线程超时</li><li>对于当前的检查点，别的线程调用了它的reset方法</li></ul><p>CylicBarrier比countDownLatch优越在reset上，因为可以重复使用</p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>假设有一个使用场景，需要计算四个地方的值，然后进行汇总，计算部分的值单开一个线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建线程数量为4的检查点，四个线程到达检查点后，运行this的run</span></span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier c=<span class="keyword">new</span> CyclicBarrier(<span class="number">4</span>,<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//假设有4个需要计算的表，启动四个线程</span></span><br><span class="line">    <span class="keyword">private</span> Executor executor= Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">//保存结果</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;String,Integer&gt; results=<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//假设计算结果为1</span></span><br><span class="line">                    results.put(Thread.currentThread().getName(),<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//计算完毕后，在检查点等着</span></span><br><span class="line">                        c.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">"结果计算完毕，"</span>+Thread.currentThread().getName()+<span class="string">"溜了"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String,Integer&gt; sheet:results.entrySet())&#123;</span><br><span class="line">            result+=sheet.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"输出计算结果："</span>+result);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrierTest c=<span class="keyword">new</span> CyclicBarrierTest();</span><br><span class="line">        c.count();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：</p><p><img src="/upload/pasted-342.png" alt="upload successful"></p><h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><h2 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h2><p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。</p><blockquote><p>A counting semaphore. Conceptually, a semaphore maintains a set of permits. Each acquire() blocks if necessary until a permit is available, and then takes it. Each release() adds a permit, potentially releasing a blocking acquirer. However, no actual permit objects are used; the Semaphore just keeps a count of the number available and acts accordingly.</p></blockquote><p>关键点：Semaphore维持一个“许可证”（permit）来控制线程访问数量。通过acquire()获取许可，通过release()释放<br>要想理解其方法的实现，一定要知道一个重要的事情，这个工具是基于AQS实现的，通过观察源码可以发现不管是公平不公平的acquire还是release，都是基于内部自己继承<a href="https://www.junglezero.top/2019/06/28/va%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%88Lock%EF%BC%8CAQS-ReentrantLock%EF%BC%89/">AQS</a>的一个内部类Sync实现的</p><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><p>构造方法：<br><img src="/upload/pasted-343.png" alt="upload successful"><br>两个参数，一个是许可证的数量，再一个是允不允许公平（AQS那一套），默认不公平的</p><p><img src="/upload/pasted-344.png" alt="upload successful"><br>如果还有许可证就马上返回，许可证数量减1，如果没有许可证则进入阻塞序列直到有其他线程调用release或者被打断</p><h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><p>文档中给到了一个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_AVAILABLE = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Semaphore available = <span class="keyword">new</span> Semaphore(MAX_AVAILABLE, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getItem</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    available.acquire();</span><br><span class="line">    <span class="keyword">return</span> getNextAvailableItem();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putItem</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (markAsUnused(x))</span><br><span class="line">      available.release();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not a particularly efficient data structure; just for demo</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> Object[] items = ... whatever kinds of items being managed</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[MAX_AVAILABLE];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Object <span class="title">getNextAvailableItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">         used[i] = <span class="keyword">true</span>;</span><br><span class="line">         <span class="keyword">return</span> items[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// not reached</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">markAsUnused</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (item == items[i]) &#123;</span><br><span class="line">         <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">           used[i] = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个例子实际上并没有很显示的应用在多线程中，但还是有一点要说的，要是看的仔细，就会发现acquire，release方法并没有外面上锁，这是因为Semaphore，内部维持着一个实现AQS的内部类</p><p>当许可证的数量设置为1时，这时Semaphore就成为了一个互斥锁，但是和一般的锁不同的是这个Semaphore可以被其他线程调用（因为Semaphore没有拥有者的概念），这个特性可以用在解决死锁上（文档中说的）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SemaphoreLock lock=<span class="keyword">new</span> SemaphoreLock();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.lock();</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">"抢到了锁"</span>);</span><br><span class="line">                            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"释放了锁"</span>);</span><br><span class="line">                        lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreLock</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Semaphore semaphore=<span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> semaphore.tryAcquire();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;CAS&quot;&gt;&lt;a href=&quot;#CAS&quot; class=&quot;headerlink&quot; title=&quot;CAS&quot;&gt;&lt;/a&gt;CAS&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>字符串专题</title>
    <link href="https://www.junglezero.top/2019/06/30/StringProblemsCollection/"/>
    <id>https://www.junglezero.top/2019/06/30/StringProblemsCollection/</id>
    <published>2019-06-30T12:48:01.000Z</published>
    <updated>2019-06-30T13:00:57.415Z</updated>
    
    <content type="html"><![CDATA[<h1 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>题目描述：输入一个矩阵，按照从外向里以顺时针打印出每一个数字，例如：输入如下矩阵，则依次打印出的数字为：1、2、3、4、8、12、16、15、14、13、9、5、6、7、11、10.<br><img src="/upload/pasted-336.png" alt="upload successful"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Problem20</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] array=&#123;</span><br><span class="line">                &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,&#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;,&#123;<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>&#125;&#125;;</span><br><span class="line">        Problem20 testCircle=<span class="keyword">new</span> Problem20();</span><br><span class="line">        testCircle.printMatixClockwisely(array);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMatixClockwisely</span><span class="params">(<span class="keyword">int</span>[][] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(array[<span class="number">0</span>].length&gt;start*<span class="number">2</span>&amp;&amp;array.length&gt;start*<span class="number">2</span>)&#123;</span><br><span class="line">            printOneCircle(array,start);</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printOneCircle</span><span class="params">(<span class="keyword">int</span>[][] array, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;array[<span class="number">0</span>].length-start;i++)&#123;</span><br><span class="line">            System.out.print(array[start][i]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(array.length-<span class="number">1</span>-start&gt;start)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=start+<span class="number">1</span>;i&lt;array.length-start-<span class="number">1</span>;i++)&#123;</span><br><span class="line">                System.out.print(array[i][array[<span class="number">0</span>].length-<span class="number">1</span>-start]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(array[<span class="number">0</span>].length-start-<span class="number">1</span>&gt;start &amp;&amp;</span><br><span class="line">                array.length-start-<span class="number">1</span>&gt;start)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=array.length-start-<span class="number">1</span>;i&gt;start;i--)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(array[array.length-start-<span class="number">1</span>][i]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(array.length-<span class="number">1</span>-start&gt;start &amp;&amp;</span><br><span class="line">                array[<span class="number">0</span>].length-<span class="number">1</span>-start&gt;start)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=array.length-start-<span class="number">1</span>;i&gt;start;i--)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(array[i][start]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;顺时针打印矩阵&quot;&gt;&lt;a href=&quot;#顺时针打印矩阵&quot; class=&quot;headerlink&quot; title=&quot;顺时针打印矩阵&quot;&gt;&lt;/a&gt;顺时针打印矩阵&lt;/h1&gt;&lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>树（二叉树）专题</title>
    <link href="https://www.junglezero.top/2019/06/30/%E9%A2%98/"/>
    <id>https://www.junglezero.top/2019/06/30/题/</id>
    <published>2019-06-30T12:42:06.000Z</published>
    <updated>2019-07-08T10:49:04.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本结构（实现）"><a href="#基本结构（实现）" class="headerlink" title="基本结构（实现）"></a>基本结构（实现）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h1><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p>是一种先访问根结点，再访问左子节点，再访问右子结点的访问方式，用递归方式很容易实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preorderTraverse</span><span class="params">(TreeNode t)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(t!=<span class="keyword">null</span>)&#123;</span><br><span class="line">         System.out.println(t.val+<span class="string">""</span>);</span><br><span class="line">         preorderTraverse(t.left);</span><br><span class="line">         preorderTraverse(t.right);</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环的方法实现：<br>对于当前结点，首先访问，然后访问其左子结点，若其左子结点为空（即“访问到头了”）就要访问其右子结点，这个时候，就需要栈来记录其没有访问右子结点的父结点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderTraverse2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    TreeNode pNode = root;</span><br><span class="line">    <span class="comment">//栈不为空表示还有没有访问右结点的父结点存在</span></span><br><span class="line">    <span class="keyword">while</span> (pNode != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//若结点不为空，直接访问，下一步循环其左结点，并将该结点入栈，以便访问其右结点</span></span><br><span class="line">        <span class="keyword">if</span> (pNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(pNode.val+<span class="string">"  "</span>);</span><br><span class="line">            stack.push(pNode);</span><br><span class="line">            pNode = pNode.left;</span><br><span class="line">            <span class="comment">//左节点为空，即“到头”了，此时要从栈中找出没有访问右结点的父结点，出栈，访问其右结点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//pNode == null &amp;&amp; !stack.isEmpty()</span></span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            pNode = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>先访问左子结点，再访问父结点，再访问右子结点<br>递归方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderTraverse1</span><span class="params">(TreeNode node)</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;  </span><br><span class="line">           inOrderTraverse1(root.left);  </span><br><span class="line">           System.out.print(root.val+<span class="string">"  "</span>);  </span><br><span class="line">           inOrderTraverse1(root.right);  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>非递归方式：和之前差不多，只不过这次是在某个结点出栈的时候进行访问<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderTraverse2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    TreeNode pNode = root;</span><br><span class="line">    <span class="keyword">while</span> (pNode != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(pNode);</span><br><span class="line">            pNode = pNode.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//pNode == null &amp;&amp; !stack.isEmpty()</span></span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            System.out.print(node.val + <span class="string">"  "</span>);</span><br><span class="line">            pNode = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p>先访问左结点，再放问右结点，最后访问根结点<br>递归方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrderTraverse1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        postOrderTraverse1(root.left);</span><br><span class="line">        postOrderTraverse1(root.right);</span><br><span class="line">        System.out.print(root.val+<span class="string">"  "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>非递归方法：<br>初始根结点入栈，对于栈顶结点，如果其有左子结点或者右子结点且没有被访问，则按照右子结点，左子结点的顺序入栈，如果是叶子节点名，则出栈，直接访问，并用标记<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="常见题目"><a href="#常见题目" class="headerlink" title="常见题目"></a>常见题目</h1><h2 id="根据前序和中序遍历构造二叉树（假设不包含重复数字）"><a href="#根据前序和中序遍历构造二叉树（假设不包含重复数字）" class="headerlink" title="根据前序和中序遍历构造二叉树（假设不包含重复数字）"></a>根据前序和中序遍历构造二叉树（假设不包含重复数字）</h2><p>重点：</p><p><img src="/upload/pasted-317.png" alt="upload successful"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in)</span> </span>&#123;</span><br><span class="line">TreeNode root = reConstructBinaryTree(pre, <span class="number">0</span>, pre.length - <span class="number">1</span>, in, <span class="number">0</span>, in.length - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序遍历&#123;1,2,4,7,3,5,6,8&#125;和中序遍历序列&#123;4,7,2,1,5,3,8,6&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span> startPre, <span class="keyword">int</span> endPre, <span class="keyword">int</span>[] in, <span class="keyword">int</span> startIn, <span class="keyword">int</span> endIn)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (startPre &gt; endPre || startIn &gt; endIn) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode root = <span class="keyword">new</span> TreeNode(pre[startPre]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = startIn; i &lt;= endIn; i++)</span><br><span class="line"><span class="keyword">if</span> (in[i] == pre[startPre]) &#123;</span><br><span class="line">root.left = reConstructBinaryTree(pre, startPre + <span class="number">1</span>, startPre + i - startIn, in, startIn, i - <span class="number">1</span>);</span><br><span class="line">root.right = reConstructBinaryTree(pre, i - startIn + startPre + <span class="number">1</span>, endPre, in, i + <span class="number">1</span>, endIn);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先在树1中找到树2的根结点，然后在比较左子树和右子树</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树的子结构</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasSubTree</span><span class="params">(TreeNode t1,TreeNode t2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result=<span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1!=<span class="keyword">null</span>&amp;&amp;t2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1==t2)</span><br><span class="line">            result=checkSubTree(t1,t2);</span><br><span class="line">        <span class="keyword">if</span> (!result)</span><br><span class="line">            hasSubTree(t1.left,t2);</span><br><span class="line">        <span class="keyword">if</span> (!result)</span><br><span class="line">            hasSubTree(t1.right,t2);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkSubTree</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t2==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1.val!=t2.val)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> checkSubTree(t1.left,t2.left)&amp;&amp;checkSubTree(t1.right,t2.right);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="镜像二叉树"><a href="#镜像二叉树" class="headerlink" title="镜像二叉树"></a>镜像二叉树</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>输入一个二叉树，输出它的镜像</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p><img src="/upload/pasted-335.png" alt="upload successful"><br>通过示例图可以看出，输出镜像结点的方法就是从根结点开始，交换左右孩子…不断递归知道到达叶子结点<br>需要注意的是递归</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span> <span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    TreeNode temp = root.left;</span><br><span class="line">    root.left=root.right;</span><br><span class="line">    root.right=temp;</span><br><span class="line"></span><br><span class="line">    mirrorTree(root.left);</span><br><span class="line">    mirrorTree(root.right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>输入一个树，判断是不是对称的，即这棵树是不是和他的镜像树相同</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>注意找到递归的突破口</p><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对称二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode t1)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isSymmetrical(t1,t1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t1==<span class="keyword">null</span>&amp;&amp;t2==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1==<span class="keyword">null</span>||t2==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1.val!=t2.val)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (t1.left.val==t2.right.val)&amp;&amp;(t1.right.val==t2.left.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归方法，用栈实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root.left);</span><br><span class="line">    stack.push(root.right);</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">        TreeNode n1 = stack.pop(), n2 = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (n1 == <span class="keyword">null</span> &amp;&amp; n2 == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (n1 == <span class="keyword">null</span> || n2 == <span class="keyword">null</span> || n1.val != n2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        stack.push(n1.left);</span><br><span class="line">        stack.push(n2.right);</span><br><span class="line">        stack.push(n1.right);</span><br><span class="line">        stack.push(n2.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="从上到下打印二叉树"><a href="#从上到下打印二叉树" class="headerlink" title="从上到下打印二叉树"></a>从上到下打印二叉树</h1><h2 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h2><p>从上到下打印一棵二叉树，同一层的结点按照从左到右的顺序打印</p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>利用一个队列放下一系列需要打印的结点</p><h2 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从上到下打印二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTreeTopToBottom</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; q=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>||root.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        q.add(root.left);</span><br><span class="line">        q.add(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(root.val);</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span> (q.peek().left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            q.add(q.peek().left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q.peek().right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            q.add(q.peek().right);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(q.poll().val);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分行从上到下打印二叉树"><a href="#分行从上到下打印二叉树" class="headerlink" title="分行从上到下打印二叉树"></a>分行从上到下打印二叉树</h1><h2 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h2><p>上一道题的一种变式</p><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>添加两个变量，分别对当前行和下一行计数</p><h2 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTreeTopToBottomByLine</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; q=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.add(root);</span><br><span class="line">    <span class="keyword">int</span> currentLine=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> nextLine=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span> (q.peek().left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            q.add(q.peek().left);</span><br><span class="line">            nextLine++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q.peek().right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            q.add(q.peek().right);</span><br><span class="line">            nextLine++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(q.poll().val);</span><br><span class="line">        currentLine--;</span><br><span class="line">        <span class="keyword">if</span> (currentLine==<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println();</span><br><span class="line">            currentLine=nextLine;</span><br><span class="line">            nextLine=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="之字形打印二叉树"><a href="#之字形打印二叉树" class="headerlink" title="之字形打印二叉树"></a>之字形打印二叉树</h1><h2 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h2><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左往右的顺序，第二行从右往左，第三行从左往右依次类推</p><h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><p>有了上两道题的铺垫，我们对于这道题，首先可以看出这也需要逐行的分析，也就是偶数行需要从左往右打印，奇数行需要从右向左（从第0行开始），同样也用队列当做容器</p><h2 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h2><p>LeetCode第103题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">int</span> level=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> num=queue.size();</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(level%<span class="number">2</span>!=<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (queue.peek().left!=<span class="keyword">null</span>)queue.offer(queue.peek().left);</span><br><span class="line">                <span class="keyword">if</span> (queue.peek().right != <span class="keyword">null</span>) queue.offer(queue.peek().right);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (queue.peek().right != <span class="keyword">null</span>) queue.offer(queue.peek().right);</span><br><span class="line">                <span class="keyword">if</span> (queue.peek().left!=<span class="keyword">null</span>)queue.offer(queue.peek().left);</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(queue.poll().val);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(list);</span><br><span class="line">        level++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="二叉搜索树的后续遍历序列"><a href="#二叉搜索树的后续遍历序列" class="headerlink" title="二叉搜索树的后续遍历序列"></a>二叉搜索树的后续遍历序列</h1><h2 id="描述-6"><a href="#描述-6" class="headerlink" title="描述"></a>描述</h2><p>输入一个整数数组，判断该数组是不是某二叉搜素树后续遍历的结果，假设输入的数都各不相同</p><h2 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h2><p>应当抓住<a href="https://www.junglezero.top/2018/02/14/%EF%BC%882%EF%BC%89/">二叉搜索树</a>的特点,即对于根结点，左子树的结点数值都比根结点小，右子树的结点数值都比根结点大，然后递归的方式寻找</p><h2 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的后续遍历序列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence, <span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sequence==<span class="keyword">null</span>||sequence.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> root=sequence[sequence.length-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i=start;</span><br><span class="line">    <span class="comment">//确定左子树边界</span></span><br><span class="line">    <span class="keyword">for</span> (;i&lt;end;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (sequence[i]&gt;root)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j=i;</span><br><span class="line">    <span class="comment">//在右子树中，如果存在小于根结点的值，则说明这个序列不是个搜索树的后续遍历</span></span><br><span class="line">    <span class="keyword">for</span> (;j&lt;end;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (sequence[j]&lt;root)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归判断左子树</span></span><br><span class="line">    <span class="keyword">boolean</span> left=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        left=isSquenceOfBST(sequence,<span class="number">0</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归判断右子树</span></span><br><span class="line">    <span class="keyword">boolean</span> right=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;end)&#123;</span><br><span class="line">        right=isSquenceOfBST(sequence,i,end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left&amp;&amp;right;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h1><h2 id="描述-7"><a href="#描述-7" class="headerlink" title="描述"></a>描述</h2><p>输入一个二叉树和一个整数，打印二叉树中结点的值的和为输入整数的所有路径，从根结点一直到尾结点为一个路径</p><h2 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h2><p>这个题很明显想到用回溯法，用一个栈来存放结点</p><h2 id="实现-8"><a href="#实现-8" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树中和为某一值的路径</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findPath</span><span class="params">(TreeNode root,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root==<span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       <span class="keyword">int</span> curentNum=<span class="number">0</span>;</span><br><span class="line">       findPath(root,num,stack,curentNum);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findPath</span><span class="params">(TreeNode root, <span class="keyword">int</span> num, Stack&lt;Integer&gt; stack, <span class="keyword">int</span> curentNum)</span> </span>&#123;</span><br><span class="line">       curentNum+=root.val;</span><br><span class="line">       stack.push(root.val);</span><br><span class="line">       <span class="keyword">if</span> (root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span> (curentNum==num)&#123;</span><br><span class="line">               System.out.println(<span class="string">"找到一条路径："</span>);</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> n:stack)&#123;</span><br><span class="line">                   System.out.print(n+<span class="string">" "</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (root.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           findPath(root.left,num,stack,curentNum);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (root.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           findPath(root.right,num,stack,curentNum);</span><br><span class="line">       &#125;</span><br><span class="line">       stack.pop();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="二叉搜素树和双向链表"><a href="#二叉搜素树和双向链表" class="headerlink" title="二叉搜素树和双向链表"></a>二叉搜素树和双向链表</h1><h2 id="描述-8"><a href="#描述-8" class="headerlink" title="描述"></a>描述</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求<br>不能创建任何新的结点，只能调整树中结点指针的指向</p><h2 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h2><p>还是要抓住二叉搜素树的特点<br><img src="/upload/pasted-349.png" alt="upload successful"><br>中序遍历恰好可以使一棵二叉搜索树按顺序输出<br><img src="/upload/pasted-350.png" alt="upload successful"><br>按照中序遍历的顺序，当我们遍历到根结点时，它的左子树已经转换成一个排序的好的双向链表了，并且处在链表中最后一个的结点是当前值最大的结点。我们把值为8的结点和根结点链接起来，10就成了最后一个结点，接着我们就去遍历右子树，并把根结点和右子树中最小的结点链接起来。</p><h2 id="实现-9"><a href="#实现-9" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRootOfTree == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(pRootOfTree.left == <span class="keyword">null</span> &amp;&amp; pRootOfTree.right == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">    </span><br><span class="line">    TreeNode leftNode = Convert(pRootOfTree.left);</span><br><span class="line">    TreeNode curNode = leftNode;</span><br><span class="line">    <span class="comment">//找到左子树最右边的叶子节点</span></span><br><span class="line">    <span class="keyword">while</span>(curNode != <span class="keyword">null</span> &amp;&amp; curNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        curNode = curNode.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接根节点与左子树的最右叶子节点</span></span><br><span class="line">    <span class="keyword">if</span>(leftNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        pRootOfTree.left = curNode;</span><br><span class="line">        curNode.right = pRootOfTree;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//右子树的最左叶子节点</span></span><br><span class="line">    TreeNode rightNode = Convert(pRootOfTree.right);</span><br><span class="line">    <span class="comment">//连接根节点与右子树的最左叶子节点</span></span><br><span class="line">    <span class="keyword">if</span>(rightNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        pRootOfTree.right = rightNode;</span><br><span class="line">        rightNode.left = pRootOfTree;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//考虑没有左子树的情况</span></span><br><span class="line">    <span class="keyword">return</span> leftNode==<span class="keyword">null</span>?pRootOfTree:leftNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h1><h2 id="描述-9"><a href="#描述-9" class="headerlink" title="描述"></a>描述</h2><p>请实现两个函数，分别用来序列化和反序列化二叉树</p><h2 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h2><p>二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（$）</p><p>二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p><h2 id="实现-10"><a href="#实现-10" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">Serialize</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    StringBuilder b=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    circleSerialize(root,b);</span><br><span class="line">    <span class="keyword">return</span> b.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">circleSerialize</span><span class="params">(TreeNode root, StringBuilder b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>)</span><br><span class="line">        b.append(<span class="string">"$,"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    b.append(root.val+<span class="string">","</span>);</span><br><span class="line">    circleSerialize(root.left,b);</span><br><span class="line">    circleSerialize(root.right,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反序列化（根据前序遍历结果）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">DeSeriablize</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">   String[] s= str.split(<span class="string">","</span>);</span><br><span class="line">   <span class="keyword">int</span> index=-<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">return</span> DeSeriablizeCore(str,index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">DeSeriablizeCore</span><span class="params">(String str, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    String[]s=str.split(<span class="string">","</span>);</span><br><span class="line">    TreeNode node=<span class="keyword">null</span>;</span><br><span class="line">    index++;</span><br><span class="line">    <span class="keyword">if</span> (!s[index].equals(<span class="string">"$"</span>)) &#123;</span><br><span class="line">        node = <span class="keyword">new</span> TreeNode(Integer.parseInt(s[index]));</span><br><span class="line">        node.left=DeSeriablizeCore(str,index);</span><br><span class="line">        node.right=DeSeriablizeCore(str,index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本结构（实现）&quot;&gt;&lt;a href=&quot;#基本结构（实现）&quot; class=&quot;headerlink&quot; title=&quot;基本结构（实现）&quot;&gt;&lt;/a&gt;基本结构（实现）&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
      <category term="[object Object]" scheme="https://www.junglezero.top/categories/object-Object/"/>
    
    
      <category term="数据结构" scheme="https://www.junglezero.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="https://www.junglezero.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程学习5（Lock，AQS，ReentrantLock，ReentrantReadWriteLock，Condition）</title>
    <link href="https://www.junglezero.top/2019/06/28/va%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%88Lock%EF%BC%8CAQS-ReentrantLock%EF%BC%89/"/>
    <id>https://www.junglezero.top/2019/06/28/va多线程学习（Lock，AQS-ReentrantLock）/</id>
    <published>2019-06-28T08:09:00.000Z</published>
    <updated>2019-07-02T01:02:07.394Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Lock-接口"><a href="#Lock-接口" class="headerlink" title="Lock 接口"></a>Lock 接口</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Java程序是靠synchronized关键字实现锁功能的，而Java SE 5之后，并发包中新增<br>了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized关键字类似的同步功<br>能，只是在使用时需要显式地获取和释放锁。虽然它缺少了（通过synchronized块或者方法所提<br>供的）隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以<br>及超时获取锁等多种synchronized关键字所不具备的同步特性</p><p>相比于Synchronized，Lock具有以下几个特性</p><p><img src="/upload/pasted-331.png" alt="upload successful"></p><h2 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h2><h3 id="void-lock-void-unlock"><a href="#void-lock-void-unlock" class="headerlink" title="void lock(),void unlock()"></a>void lock(),void unlock()</h3><p>这两个方法一个是上锁，一个是解锁<br>基本相当于synchronized关键字，具体使用方法如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="void-lockInterruptibly-throws-InterruptedException"><a href="#void-lockInterruptibly-throws-InterruptedException" class="headerlink" title="void lockInterruptibly() throws InterruptedException;"></a>void lockInterruptibly() throws InterruptedException;</h3><p>这个方法可以中断的获取锁，这就是和synchronized（lock()）很大的一个不同，即在抢锁的过程中可以中断该线程</p><p>演示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">validLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"Thread-"</span>+Thread.currentThread().getName()+<span class="string">"takes the synlock"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">        e.printStackTrace();;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>   <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String arg[])</span></span>&#123;</span><br><span class="line">    Thread t1=<span class="keyword">new</span> Thread()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            validLock();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Thread t2 =<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            validLock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t2.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个例子中，线程2是不会响应中断的</p><p>然而<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">validLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"Thread-"</span>+Thread.currentThread().getName()+<span class="string">"takes the synlock"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">        e.printStackTrace();;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>   <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String arg[])</span></span>&#123;</span><br><span class="line">    Thread t1=<span class="keyword">new</span> Thread()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                validLock();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Thread t2 =<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                validLock();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t2.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个实例中。t2会响应中断</p><h3 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock()"></a>tryLock()</h3><p>通过这个方式可以非阻塞的获取锁，即，即使抢不到锁，该线程也不会进入block状态，tryLock()的返回值是boolean,获取锁成功返回true，没获取锁返回false</p><p>具体用法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">TestTryLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lock.tryLock())&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"抢不到锁，溜了溜了（反正绝对不堵着）"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="boolean-tryLock-long-time-TimeUnit-unit-throws-InterruptedException"><a href="#boolean-tryLock-long-time-TimeUnit-unit-throws-InterruptedException" class="headerlink" title="boolean tryLock(long time, TimeUnit unit) throws InterruptedException;"></a>boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</h3><p>这个就是超时获取锁的体现，如果在指定时间内没有获取锁，就退出，在这个指定的时间内，也可以中断</p><h3 id="Condition-newCondition"><a href="#Condition-newCondition" class="headerlink" title="Condition newCondition();"></a>Condition newCondition();</h3><p>用来创建一个基于当前同步器的Condition对象，下文会介绍Condition</p><h1 id="AQS-AbstractQueuedSynchronizer"><a href="#AQS-AbstractQueuedSynchronizer" class="headerlink" title="AQS(AbstractQueuedSynchronizer)"></a>AQS(AbstractQueuedSynchronizer)</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>队列同步器AbstractQueuedSynchronizer（以下简称同步器），是用来构建锁或者其他同步组<br>件的基础框架，它使用了一个int成员变量（一个atomic int value）表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作，所以说AQS是JUC锁的灵魂所在</p><h2 id="各种概念"><a href="#各种概念" class="headerlink" title="各种概念"></a>各种概念</h2><h3 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h3><p>同步器依赖内部的同步队列（一个FIFO双向队列）来完成同步状态的管理，当前线程获取<br>同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node）并将其<br>加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再<br>次尝试获取同步状态。</p><p>同步器包含了两个节点类型的引用，一个指向头节点，而另一个指向尾节点。<br>试想一下，当一个线程成功地获取了同步状态（或者锁），其他线程将无法获取到同步状态，转<br>而被构造成为节点并加入到同步队列中，而这个加入队列的过程必须要保证线程安全，因此同步器提供了一个基于CAS的设置尾节点的方法：compareAndSetTail(Node expect,Node<br>update)，它需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式<br>与之前的尾节点建立关联</p><p><img src="/upload/pasted-332.png" alt="upload successful"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="独占锁的的实现"><a href="#独占锁的的实现" class="headerlink" title="独占锁的的实现"></a>独占锁的的实现</h3><h4 id="我们要做的"><a href="#我们要做的" class="headerlink" title="我们要做的"></a>我们要做的</h4><p>在API文档中，提到这么一句</p><blockquote><p>Subclasses should be defined as non-public internal helper classes that are used to implement the synchronization properties of their enclosing class. </p></blockquote><p>也就是说在使用上，要把AQS的继承类写在阻塞队列的内部，作为一个内部类出现<br>官方文档中还提到：<br>要想实现一个自定义同步器，就要实现以下几种方法，并且对于线程的状态，运用 getState(), setState(int) and/or compareAndSetState(int, int): </p><ul><li>tryAcquire(int)</li><li>tryRelease(int)</li><li>tryAcquireShared(int)</li><li>tryReleaseShared(int)</li><li>isHeldExclusively(</li></ul><p>API文档中也给了一个非重入式互斥独占锁的实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要自定义的锁</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 上文提到的内部类</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">     <span class="comment">// Reports whether in locked state</span></span><br><span class="line">     <span class="comment">//返回是否独占当前锁（0表示为占用锁，1表示锁已经被占用）</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Acquires the lock if state is zero</span></span><br><span class="line">     <span class="comment">//状态为0时尝试获取锁</span></span><br><span class="line">     <span class="comment">//重点要实现的方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//意思是传入的accauires的值必须要是1，要是不是1就退出了</span></span><br><span class="line">       <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">       <span class="comment">//这是一个原子操作</span></span><br><span class="line">       <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">         <span class="comment">//如果成功将状态从0变成了1，说明抢到锁，并且排他的（Exclusive）占用这把锁（独占）</span></span><br><span class="line">         <span class="comment">//并不用考虑这两个动作会不会发生同步问题，因为该方法是accquire调用的，其内部已经实现了某种竞争机制</span></span><br><span class="line">         setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Releases the lock by setting state to zero</span></span><br><span class="line">     <span class="comment">//将状态设为0来释放锁</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">       <span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">       <span class="comment">//将独占锁的线程设置为空</span></span><br><span class="line">       setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">       <span class="comment">//将状态设置为0</span></span><br><span class="line">       setState(<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Provides a Condition</span></span><br><span class="line">     <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject(); &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Deserializes properly</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">       s.defaultReadObject();</span><br><span class="line">       setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//上面就是几个重要方法的实现，具体使用如下</span></span><br><span class="line">   <span class="comment">// The sync object does all the hard work. We just forward to it.</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//调用Accquire</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>                </span>&#123; sync.acquire(<span class="number">1</span>); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>          </span>&#123; <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>              </span>&#123; sync.release(<span class="number">1</span>); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> sync.newCondition(); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span>         </span>&#123; <span class="keyword">return</span> sync.isHeldExclusively(); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sync.hasQueuedThreads(); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h4 id="细节理解"><a href="#细节理解" class="headerlink" title="细节理解"></a>细节理解</h4><h5 id="acquire"><a href="#acquire" class="headerlink" title="acquire()"></a>acquire()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryAcquire(int arg):线程安全的获取同步状态<br>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)：构造同步节点（独占式<br>Node.EXCLUSIVE，同一时刻只能有一个线程成功获取同步状态）并通过addWaiter(Node node)<br>方法将该节点加入到同步队列的尾部，最后调用acquireQueued(Node node,int arg)方法，使得该<br>节点以“死循环”的方式获取同步状态<br>…<br>。。。<br>…<br>。。。</p><p><img src="/upload/pasted-333.png" alt="upload successful"></p><h3 id="共享锁的实现"><a href="#共享锁的实现" class="headerlink" title="共享锁的实现"></a>共享锁的实现</h3><p>一个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwinsLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//依然是内部类的方式实现</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//状态用“0,1,2”进行标记</span></span><br><span class="line">        Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count must large than zero."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//实现tryAcquireShared</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> reduceCount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();<span class="keyword">int</span> newCount = current - reduceCount;</span><br><span class="line">                <span class="keyword">if</span> (newCount &lt; <span class="number">0</span> || compareAndSetState(current,</span><br><span class="line">                        newCount)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> newCount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//实现tryReleaseShared</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> returnCount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="keyword">int</span> newCount = current + returnCount;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, newCount)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他接口方法略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是一个允许最多两个线程同时访问的共享锁，因而实现的方法是shared那些。同步器会先计算出获取后的同步状态，然后通过CAS确保状态的正确设置，当tryAcquireShared(int reduceCount)方法返回值大于等于0时，当前线程才获取同步状态，对于上层的TwinsLock而言，则表示当前线程获得了锁</p><h1 id="ReentrantLock（重入锁）"><a href="#ReentrantLock（重入锁）" class="headerlink" title="ReentrantLock（重入锁）"></a>ReentrantLock（重入锁）</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>根据其名字，可以知道，这个锁是可“重复使用”的（synchronized也是支持重入的），一般情况下（如上文实现的互斥独占锁），如果让一个已经上锁的线程尝试再次上锁，那么它就会被自己所阻塞，最终进入阻塞状态它实际上，是Lock的一种实现，另外，还涉及到一个公平的问题</p><h2 id="细节分析"><a href="#细节分析" class="headerlink" title="细节分析"></a>细节分析</h2><h3 id="重进入的实现"><a href="#重进入的实现" class="headerlink" title="重进入的实现"></a>重进入的实现</h3><p>锁的获取：<br>识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理重进入的过程</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>锁的释放：<br>重复获取锁n次，就需要重复释放锁n次（有一个计数器）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//每次释放，都要做减法，只有状态值为0才能释放出去，允许其他线程抢</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="公平和不公平"><a href="#公平和不公平" class="headerlink" title="公平和不公平"></a>公平和不公平</h3><p>所谓公平和不公平，是指能不按照运行的绝对时间获取锁，即FIFO<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">    <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">    <span class="comment">// thread is first in queue.</span></span><br><span class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过观察我们可以返现相比于上文的nofair方法，这个方法多了一个hasQueuedPredecessors()，上面也附上了这个方法的实现，可以了解到“公平”就是通过同步器队列实现的，查看当前线程是否有前置结点，如果没有前置结点，则获得锁。<br>有一点要记住：默认的ReentrantLock中的require是非公平的方法，因为其效率更高</p><h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>读写锁在之前已经自己实现过一次了<br><a href="https://www.junglezero.top/2019/04/16/%E7%BA%BF%E7%A8%8B%E8%AF%BB%E5%86%99%E9%94%81%E5%88%86%E7%A6%BB/">自己实现的读写锁</a><br>根据以前的总结，读写锁需要注意的是：读进程和读进程可以同时进行，但是读进程和写进程是互斥的</p><p>API文档介绍了这个类的几个特性：</p><ul><li>支持公平不公平的抢锁（默认是不公平的）</li><li>可重入</li><li>可以从写锁降级至读锁，但不能从读锁升级为写锁</li><li>获取过程可以被打断</li><li>支持Condition</li></ul><h3 id="细节分析-1"><a href="#细节分析-1" class="headerlink" title="细节分析"></a>细节分析</h3><h4 id="读写状态的确定"><a href="#读写状态的确定" class="headerlink" title="读写状态的确定"></a>读写状态的确定</h4><p>实现时，采用了一个整型变量进行维护读写两种状态</p><p><img src="/upload/pasted-334.png" alt="upload successful"><br>当前同步状态值为S，写状态等于S&amp;0x0000FFFF（将高16位全部抹去），读状态等于S&gt;&gt;&gt;16（无符号补0右移<br>16位）。当写状态增加1时，等于S+1，当读状态增加1时，等于S+(1&lt;&lt;16)，也就是<br>S+0x00010000。<br>S不等于0时，当写状态（S&amp;0x0000FFFF）等于0时，则读状态（S&gt;&gt;&gt;16）大于0，即读锁已被获取。</p><h4 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 存在读锁或者当前获取线程不是已经获取写锁的线程</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读写锁要确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞</p><h4 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">int</span> nextc = c + (<span class="number">1</span> &lt;&lt; <span class="number">16</span>);</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; c)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp; owner != Thread.currentThread())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。</p><h4 id="写锁降级"><a href="#写锁降级" class="headerlink" title="写锁降级"></a>写锁降级</h4><p>API文档中给到了一个降级锁的实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CachedData</span> </span>&#123;</span><br><span class="line">  Object data;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">boolean</span> cacheValid;</span><br><span class="line">  <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">processCachedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rwl.readLock().lock();</span><br><span class="line">    <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">      <span class="comment">// Must release read lock before acquiring write lock</span></span><br><span class="line">      rwl.readLock().unlock();</span><br><span class="line">      rwl.writeLock().lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Recheck state because another thread might have</span></span><br><span class="line">        <span class="comment">// acquired write lock and changed state before we did.</span></span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">          data = ...</span><br><span class="line">          cacheValid = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Downgrade by acquiring read lock before releasing write lock</span></span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        rwl.writeLock().unlock(); <span class="comment">// Unlock write, still hold read</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      use(data);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      rwl.readLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>API文档已经说明了适合使用在数据量较大的容器，读操作比写操作更多的情况下，也给到了一个实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RWDictionary</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Data&gt; m = <span class="keyword">new</span> TreeMap&lt;String, Data&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Lock r = rwl.readLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Lock w = rwl.writeLock();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Data <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    r.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.get(key); &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; r.unlock(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String[] allKeys() &#123;</span><br><span class="line">    r.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.keySet().toArray(); &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; r.unlock(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Data <span class="title">put</span><span class="params">(String key, Data value)</span> </span>&#123;</span><br><span class="line">    w.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.put(key, value); &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; w.unlock(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    w.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123; m.clear(); &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; w.unlock(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意，读锁和写锁都有最大值的限制：65535</p><h2 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><p>用官方文档的话来说，Condition的作用就是用来替代object监视器的wait，notify，notifyAll方法，并且，A Condition instance is intrinsically bound to a lock.要想生成一种condition，调用lock方法的new condition创建。<br>下面用一个官方API文档中写的例子讲解用法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">final</span> Condition notFull  = lock.newCondition(); </span><br><span class="line">  <span class="keyword">final</span> Condition notEmpty = lock.newCondition(); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">  <span class="keyword">int</span> putptr, takeptr, count;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (count == items.length)</span><br><span class="line">        notFull.await();</span><br><span class="line">      items[putptr] = x;</span><br><span class="line">      <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">      ++count;</span><br><span class="line">      notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">        notEmpty.await();</span><br><span class="line">      Object x = items[takeptr];</span><br><span class="line">      <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;</span><br><span class="line">      --count;</span><br><span class="line">      notFull.signal();</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个例子实现的是一个有界缓存，类似于<a href="https://www.junglezero.top/2019/03/29/a%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%883%EF%BC%89/">生产者/消费者</a>，当缓存不为空时，消费者就可以拿取数据，当缓存不满时，生产者就可以放入数据，唯一不同的是这里的锁不是synchronized，而监视器用的也不是object</p><h3 id="细节分析-2"><a href="#细节分析-2" class="headerlink" title="细节分析"></a>细节分析</h3><p>一个Condition包含一个FIFO等待队列，队列中的结点都包含一个线程的引用，如果一个线程调用了Condition.await()方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态，对于一个Lock（同步器），其包含一个阻塞队列和多个等待队列（一个Condition对应一个）</p><h4 id="等待await"><a href="#等待await" class="headerlink" title="等待await"></a>等待await</h4><p><img src="/upload/pasted-337.png" alt="upload successful"><br>该方法的线程成功获取了锁的线程，也就是同步队列中的首节点，该方法会将当前线程构造成节点并加入等待队列中，然后释放同步状态，唤醒同步队列中的后继节点，然后当前线程会进入等待状态。<br>等待队列中的节点被唤醒，则唤醒节点的线程开始尝试获取同步状态。如果不是通过其他线程调用Condition.signal()方法唤醒，而是对等待线程进行中断，则会抛出InterruptedException。</p><h4 id="通知signal"><a href="#通知signal" class="headerlink" title="通知signal"></a>通知signal</h4><p><img src="/upload/pasted-338.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Lock-接口&quot;&gt;&lt;a href=&quot;#Lock-接口&quot; class=&quot;headerlink&quot; title=&quot;Lock 接口&quot;&gt;&lt;/a&gt;Lock 接口&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简
      
    
    </summary>
    
    
      <category term="java多线程" scheme="https://www.junglezero.top/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>链表专题</title>
    <link href="https://www.junglezero.top/2019/06/24/%E4%B8%93%E9%A2%98/"/>
    <id>https://www.junglezero.top/2019/06/24/专题/</id>
    <published>2019-06-24T08:15:00.000Z</published>
    <updated>2019-07-07T02:48:13.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在O-1-删除链表中的结点"><a href="#在O-1-删除链表中的结点" class="headerlink" title="在O(1)删除链表中的结点"></a>在O(1)删除链表中的结点</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定单链表的头指针和一个节点指针，定义一个函数在O(1)时间删除该节点</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一般的链表删除结点都是从头结点遍历，找到要删除的结点然后进行删除，但是这个题目由于给了要删除结点的位置，就可以采取一些别的措施<br><img src="/upload/pasted-325.png" alt="upload successful"><br>这里的一个思路就是看重了结点的值：把要删除结点的下一个结点的值赋给要删除的结点，此时在删除要删除结点的下一个结点（如c）<br>但是还要注意特殊情况：</p><ul><li>要删除的结点是尾结点：此时只能从头结点顺序遍历，然后找到尾结点的前一个结点，然后再删除</li><li>要删除的链表只有一个结点，直接将头结点设为空</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除链表中的结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(ListNode first,ListNode deleteNode)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        first=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (deleteNode.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode l=first;</span><br><span class="line">        <span class="keyword">while</span> (l.next!=deleteNode)&#123;</span><br><span class="line">            l=l.next;</span><br><span class="line">        &#125;</span><br><span class="line">        l.next=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    deleteNode.val=deleteNode.next.val;</span><br><span class="line">    deleteNode.next=deleteNode.next.next;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链表中倒数第K个结点"><a href="#链表中倒数第K个结点" class="headerlink" title="链表中倒数第K个结点"></a>链表中倒数第K个结点</h1><h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><p>输入一个链表，输出该链表中倒数第k个结点。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>一般思路：向后找n-k+1个结点，需要两次遍历，第一次遍历找到n<br>更好的想法：两个指针，第一个指针首先移动k-1然后第二指针开始从头移动，此时两个指针同时移动，当第一个指针到达尾结点时，第二个指针所指就是要找到点<br>但是仍然要注意一些特殊的情况：</p><ul><li>输入的头结点为空：结果返回null</li><li>链表数小于k:无意义，结果返回null</li><li>k为0:无意义，结果返回null</li></ul><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">findKthNodeInLinkedList</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (head==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode Ahead=head;</span><br><span class="line">    ListNode Behind=head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (Ahead.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            Ahead=Ahead.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (Ahead!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        Ahead=Ahead.next;</span><br><span class="line">        Behind=Behind.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Behind;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链表中环的入口结点"><a href="#链表中环的入口结点" class="headerlink" title="链表中环的入口结点"></a>链表中环的入口结点</h1><h2 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h2><p>输入一个链表如果有环，返回其入口结点</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>第一步：确定链表有环：用两个指针，一个一次移动一步，另一个一次移动两步，若两个指针在移动中相等，则证明有环<br>第二步，找到环的长度：从两个指针相遇的地方开始，再次回到这个点的计数就是环的长度<br>第三步，找到入口，在知道了环的长度以后，就和上面的题一样了</p><h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//链表中环的入口结点</span></span><br><span class="line">    <span class="function">ListNode <span class="title">findEntryInCircle</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode slow=head;</span><br><span class="line">        ListNode fast=head;</span><br><span class="line">        ListNode meetingNode=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用快慢指针判断是否有环</span></span><br><span class="line">        <span class="keyword">while</span> (slow!=<span class="keyword">null</span>&amp;&amp;fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">            <span class="comment">//记录相遇结点</span></span><br><span class="line">            <span class="keyword">if</span> (slow==fast)</span><br><span class="line">                meetingNode=slow;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//fast到了null时，一定无环</span></span><br><span class="line">        <span class="keyword">if</span> (fast==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> circleLen=<span class="number">1</span>;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">        <span class="comment">//从相遇结点出发，再次回到相遇结点，计数，找出环的长度</span></span><br><span class="line">        <span class="keyword">while</span> (slow!=meetingNode)&#123;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            circleLen++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//两个指针，一个先走n（环的长度），当两个指针相遇时，就是环的入口</span></span><br><span class="line">        ListNode Ahead=head;</span><br><span class="line">        ListNode Behind=head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;circleLen;i++)&#123;</span><br><span class="line">            Ahead=Ahead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (Ahead!=Behind)&#123;</span><br><span class="line">            Ahead=Ahead.next;</span><br><span class="line">            Behind=Behind.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Ahead;</span><br><span class="line">.</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><h2 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h2><p>输入一个链表，反转链表后，输出新链表的表头。</p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>设置三个指针，head为当前节点，pre为当前节点的前一个节点，next为当前节点的下一个节点，需要pre和next的目的是让当前节点从pre-&gt;head-&gt;next1-&gt;next2变成pre<-head next1->next2的过程中，用pre让节点反转所指方向，next节点保存next1节点防止链表断开<br>仍然要注意特殊输入</-head></p><h2 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反转链表</span></span><br><span class="line"> <span class="function">ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">     ListNode ReverseHead=<span class="keyword">null</span>;</span><br><span class="line">     ListNode node=head;</span><br><span class="line">     ListNode pre=<span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">while</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="comment">//先获取当前结点的下一个结点</span></span><br><span class="line">         ListNode Next=node.next;</span><br><span class="line">         <span class="comment">//若下一个结点为空，则证明到头了</span></span><br><span class="line">         <span class="keyword">if</span> (Next==<span class="keyword">null</span>)</span><br><span class="line">             ReverseHead=node;</span><br><span class="line">         <span class="comment">//修改当前结点的下一个结点</span></span><br><span class="line">         node.next=pre;</span><br><span class="line">         <span class="comment">//当前结点成为新的pre</span></span><br><span class="line">         pre=node;</span><br><span class="line">         <span class="comment">//下一个结点成为新的当前结点</span></span><br><span class="line">         node=Next;</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ReverseHead;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h1><h2 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h2><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>注意处理两个链表为空的情况</p><h2 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//合并两个排序链表</span></span><br><span class="line"><span class="function">ListNode <span class="title">Merge</span><span class="params">(ListNode l1,ListNode l2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    ListNode node1=l1;</span><br><span class="line">    ListNode node2=l2;</span><br><span class="line">    ListNode MergeList =<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (l1.val&gt;l2.val)&#123;</span><br><span class="line">        MergeList=l1;</span><br><span class="line">        MergeList.next=Merge(l1.next,l2);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        MergeList=l2;</span><br><span class="line">        MergeList.next=Merge(l1,l2.next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MergeList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h1><h2 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h2><p>实现函数复制一个复杂链表。在复杂链表中，每个结点除了有一个 next，指针指向下一个结点外，还有一个指向链表中任意结点或 null。</p><h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><p>照猫画虎法，<br>先在每个结点后生成其复制结点，下一步是最关键的复杂指针的复制，就是照猫画虎，不管指针有多么的复杂，都会有A1.random=A.random.next，B1.random=B.random.next，C1.random=C.random.next，这样就解决了这个题的难点，最后把链表拆分。</p><h2 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复杂链表的复制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ComplicatedLinkedListNode <span class="title">copyComplicatiedLinkedList</span><span class="params">(ComplicatedLinkedListNode firstNode)</span></span>&#123;</span><br><span class="line">    <span class="comment">//第一步，在每个结点后面复制其自身的结点</span></span><br><span class="line">    ComplicatedLinkedListNode node=firstNode;</span><br><span class="line">    <span class="keyword">while</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        ComplicatedLinkedListNode newNode=<span class="keyword">new</span> ComplicatedLinkedListNode(node.val);</span><br><span class="line">        newNode.next=node.next;</span><br><span class="line">        node.next=newNode;</span><br><span class="line">        node=newNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二步，复制复杂指针，依照A1.random=A.random.next</span></span><br><span class="line">    ComplicatedLinkedListNode node2=firstNode;</span><br><span class="line">    node=firstNode.next;</span><br><span class="line">    <span class="keyword">while</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        node.random=node2.random.next;</span><br><span class="line">        node=node.next.next;</span><br><span class="line">        node2=node2.next.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三步。拆分出目标链表</span></span><br><span class="line">    node=firstNode.next;</span><br><span class="line">    node2=node.next;</span><br><span class="line">    <span class="keyword">while</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        node.next=node2.next;</span><br><span class="line">        node2=node.next.next;</span><br><span class="line">        node=node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ComplicatedLinkedListNode ans=firstNode.next;</span><br><span class="line">    firstNode.next=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;在O-1-删除链表中的结点&quot;&gt;&lt;a href=&quot;#在O-1-删除链表中的结点&quot; class=&quot;headerlink&quot; title=&quot;在O(1)删除链表中的结点&quot;&gt;&lt;/a&gt;在O(1)删除链表中的结点&lt;/h1&gt;&lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; cla
      
    
    </summary>
    
      <category term="刷算法题" scheme="https://www.junglezero.top/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="数据结构" scheme="https://www.junglezero.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="链表" scheme="https://www.junglezero.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数值算法题整理</title>
    <link href="https://www.junglezero.top/2019/06/24/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <id>https://www.junglezero.top/2019/06/24/算法题/</id>
    <published>2019-06-24T01:07:00.000Z</published>
    <updated>2019-06-24T10:06:09.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>分清各种情况：</p><ul><li>指数为负：需要将底数求倒数然后再将指数取正</li><li>指数为最小的负数（Integer.MIN_VALUE），此时不能直接取正，直接二分递归再取正</li><li>底数为0，指数为负：会出现对0求倒数情况，要特殊处理</li><li>指数为0：无论底数，结果为1</li><li>可以用二分的思想减少运算</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"底数为0无意义"</span>);</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        x=<span class="number">1</span>/x;</span><br><span class="line">        n=-n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == Integer.MIN_VALUE)</span><br><span class="line">        <span class="keyword">return</span> myPow(x*x, -(n/<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n%<span class="number">2</span>==<span class="number">0</span>?myPow(x*x,n/<span class="number">2</span>):x*myPow(x*x,n/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="打印从1到最大的n位数"><a href="#打印从1到最大的n位数" class="headerlink" title="打印从1到最大的n位数"></a>打印从1到最大的n位数</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>输入数字n,按顺序打印出从1到最大的n位十进制数，比如输入3,则打印出1,2,3一直到最大的3位数即999</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这个题看似白给，实际容易被白给，因为当n特别特别大时，要是想直接输出数，是不可能的，因此要想到大数模拟，而大数从1到999…999递增的输出，用String模拟就又是一个问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//打印从1到最大的N位数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintOneToMaxNthDigits</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">char</span>[]num=<span class="keyword">new</span> <span class="keyword">char</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//从第一位开始初始化</span></span><br><span class="line">    num[<span class="number">0</span>]=<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        num[<span class="number">0</span>]=(<span class="keyword">char</span>) (i+<span class="string">'0'</span>);</span><br><span class="line">        <span class="comment">//进入递归方法</span></span><br><span class="line">        print1ToMaxOfNDigitsRecursely(num,n,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print1ToMaxOfNDigitsRecursely</span><span class="params">(<span class="keyword">char</span>[] num, <span class="keyword">int</span> n, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//递归终止条件 ：已经填充到了最后一位</span></span><br><span class="line">    <span class="keyword">if</span> (index==n)&#123;</span><br><span class="line">        printNum(num);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前位从0-9依次填充</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        num[index+<span class="number">1</span>]=(<span class="keyword">char</span>)(i+<span class="string">'0'</span>);</span><br><span class="line">        <span class="comment">//递归到下一位</span></span><br><span class="line">        print1ToMaxOfNDigitsRecursely(num,n,index+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印从num中第一个非0位到第0位</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNum</span><span class="params">(<span class="keyword">char</span>[] num)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=num.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span> (num[i]!=<span class="string">'0'</span>)&#123;</span><br><span class="line">            start=i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=start;j++)</span><br><span class="line">        System.out.print(num[j]);</span><br><span class="line"></span><br><span class="line">    System.out.print(<span class="string">"    "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数值的整数次方&quot;&gt;&lt;a href=&quot;#数值的整数次方&quot; class=&quot;headerlink&quot; title=&quot;数值的整数次方&quot;&gt;&lt;/a&gt;数值的整数次方&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题
      
    
    </summary>
    
      <category term="刷算法题" scheme="https://www.junglezero.top/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="数据结构" scheme="https://www.junglezero.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>编程常识（各种杂七杂八的东西）</title>
    <link href="https://www.junglezero.top/2019/06/20/%E5%B8%B8%E8%AF%86%EF%BC%88%E5%90%84%E7%A7%8D%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E4%B8%9C%E8%A5%BF%EF%BC%89/"/>
    <id>https://www.junglezero.top/2019/06/20/常识（各种杂七杂八的东西）/</id>
    <published>2019-06-20T12:33:33.000Z</published>
    <updated>2019-06-20T12:36:08.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="各种编码"><a href="#各种编码" class="headerlink" title="各种编码"></a>各种编码</h1><p> 很多人都把Unicode编码挂在嘴边，其实咱们现实生活中遇到的编码基本都是Unicode的</p><p>因为Unicode兼容了大多数老版本的编码规范例如 ASCII</p><p>Unicode编码定义了这个世界上几乎所有字符（就是你眼睛看到的长那个样子的符号）的数字表示</p><p>也就是说Unicode为每个字符发了一张身份证，这张身份证上有一串唯一的数字ID确定了这个字符</p><p>在这个纷乱世界上存在的唯一性。Unicode给这串数字ID起了个名字叫［码点］（Code Point）</p><p>而很多人说的编码其实是想表达［Unicode转换格式］（即UTF，Unicode Transformation Formats）</p><p>有没有觉得眼前一亮豁然开朗？没错 这就是我们看到的UTF-8/UTF-16/UTF-32的前缀来源</p><p>这个［Unicode转换格式］的存在是为了解决［码点］在计算机中的二进制表现形式而设计的</p><p>毕竟我们的机内表示涉及存储位宽，兼容古老编码格式，码点是数值过大的罕见字符等问题</p><p>［码点］经过映射后得到的二进制串的转换格式单位称之为［码元］（Code Unit）。也就是说如果有一种UTF的码点二进制表示有n字节，其码元为8位（1个byte），那么其拥有码元n个。每种UTF的码元都不同，其宽度被作为区分写在了UTF的后缀——这就是UTF-8/UTF-16/UTF-32的由来。UTF-8的码元是8位的，UTF-16的码元是16位的。大部分的编程语言采用16位的码元作为机内表示。这就是我们在各种语言中调用获取一个字符串中character的数量时会出现这么多混乱的原因。事实上我们调用这些方法时取得的不是字符个数，而是码元个数！一旦我们的字符串中包含了位于基本平面之外的码点，那么就会需要更多的码元来表示，这个时候就会出现测试时常见的困惑——为何return的字符数比实际字符数要多？所以实际写代码时要特别注意这个问题。</p><p>采取不同的映射方式可以得到不同格式的二进制串，但是他们背后所表示的［码点］永远是一致的就好像你换身份证但是身份证号不变一样。由于平时人们误把［转换格式］也称为［编码］，所以造成今天Unicode／UTF傻傻分不清楚且遣词造句运用混乱的悲桑局面。</p><p>Unicode 编码 发展到今天 扩展到了 21 位（从 U+0000 到 U+10FFFF ）。这一点很重要： Unicode 不是 16 位的编码， 它是 21 位的。这 21 位提供了 1,114,112 个码点，其中，只有大概 10% 正在使用，所以还有相当大的扩充空间。</p><p>编码空间被分成 17 个平面（plane），每个平面有 65,536 个字符（正好填充2个字节，16位）。0 号平面叫做「基本多文种平面」（ BMP, Basic Multilingual Plane ），涵盖了几乎所有你能遇到的字符，除了 emoji（emoji位于1号平面 - -）。其它平面叫做补充平面，大多是空的。</p><p>总结一下各种编码格式的特质：</p><p>UTF-32</p><p>最清楚明了的一个 UTF 就是 UTF-32 ：它在每个码点上使用整 32 位。32 大于 21，因此每一个 UTF-32 值都可以直接表示对应的码点。尽管简单，UTF-32却几乎从来不在实际中使用，因为每个字符占用 4 字节太浪费空间了。</p><p>UTF-16 以及「代理对」（ Surrogate Pairs ）的概念</p><p>UTF-16要常见得多，它是根据有 16 位固定长度的码元（ code units ）定义的。UTF-16 本身是一种长度可变的编码。基本多文种平面（BMP）中的每一个码点都直接与一个码元相映射。鉴于 BMP 几乎囊括了所有常见字符，UTF-16 一般只需要 UTF-32 一半的空间。其它平面里很少使用的码点都是用两个 16 位的码元来编码的，这两个合起来表示一个码点的码元就叫做代理对（ surrogate pair ）。</p><p>UTF-8</p><p>UTF-8 使用一到四个字节来编码一个码点。从 0 到 127 的这些码点直接映射成 1 个字节（对于只包含这个范围字符的文本来说，这一点使得 UTF-8 和 ASCII 完全相同）。接下来的 1,920 个码点映射成 2 个字节，在 BMP 里所有剩下的码点需要 3 个字节。Unicode 的其他平面里的码点则需要 4 个字节。UTF-8 是基于 8 位的码元的，因此它并不需要关心字节顺序（不过仍有一些程序会在 UTF-8 文件里加上多余的 BOM）。</p><p>有效率的空间使用（仅就西方语言来讲），以及不需要操心字节顺序问题使得 UTF-8 成为存储和交流 Unicode 文本方面的最佳编码。它也已经是文件格式、网络协议以及 Web API 领域里事实上的标准了。</p><p>我们的JVM中保存码点是UTF16的转换格式，从char的位宽为16位也可以看得出来。由于绝大部分编码的码点位于基本平面，所以使用16位可以几乎表示所有常用字符。这就是许多语言编译器或运行时都使用UTF16的原因。英文在使用UTF16时也是2字节表示的。当我们想要使用其他平面的字符时，码元超过2个字节，就需要使用代理对在语言中的特定表示方式，譬如‘\U112233’之类的。</p><p>使用UTF8时，常用的Alphabet和Numeric都在前127字节，被有效率地用一个字节表示。而我们的中文由于排在1920个码点之后，所以使用3个字节表示，这方面就比UTF16转换格式耗费更多空间。</p><p>最后，不论使用哪种UTF转换格式，都是程序员自己可以选择的一种表达方式而已。我们可以通过Java方便的API进行自如转换。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;各种编码&quot;&gt;&lt;a href=&quot;#各种编码&quot; class=&quot;headerlink&quot; title=&quot;各种编码&quot;&gt;&lt;/a&gt;各种编码&lt;/h1&gt;&lt;p&gt; 很多人都把Unicode编码挂在嘴边，其实咱们现实生活中遇到的编码基本都是Unicode的&lt;/p&gt;
&lt;p&gt;因为Unicod
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>栈和队列专题</title>
    <link href="https://www.junglezero.top/2019/06/18/%E9%98%9F%E5%88%97%E4%B8%93%E9%A2%98/"/>
    <id>https://www.junglezero.top/2019/06/18/队列专题/</id>
    <published>2019-06-18T07:33:00.000Z</published>
    <updated>2019-07-02T03:00:16.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h1><p>栈和队列一个先进后出，一个先进先出，因此应当想办法“逆转”一下，这就是第二个栈的作用<br><img src="/upload/pasted-318.png" alt="upload successful"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">TwoStackToQueue</span></span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; s1=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; s2=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Qoffer</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        s1.push(num);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">pull</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!s2.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> s2.pop();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s1.isEmpty())&#123;</span><br><span class="line">                s2.push(s1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!s2.isEmpty())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"queue is empty"</span>);</span><br><span class="line">            <span class="keyword">return</span> s2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="用两个队列模拟栈"><a href="#用两个队列模拟栈" class="headerlink" title="用两个队列模拟栈"></a>用两个队列模拟栈</h1><p>对于入栈操作，直接加入队列即可。而对于出栈操作，应当知道对于模拟的情况，是删除队尾元素，而队列又是先入先出的，因此，应当先将队列前的元素移到另外一个栈，然后再“弹栈”</p><p><img src="/upload/pasted-319.png" alt="upload successful"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> Integer <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!q1.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (q1.size() != <span class="number">1</span>) &#123;</span><br><span class="line">                q2.offer(q1.poll());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (Integer) q1.poll();</span><br><span class="line">        &#125;<span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">if</span> (!q2.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">while</span> (q2.size()!=<span class="number">1</span>)&#123;</span><br><span class="line">                    q1.offer(q2.poll());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> (Integer) q2.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"栈为空"</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>定义一个栈，其中有一个获取最小值的方法，在这个栈中，调用push,pop,min的时间复杂度都是O(1)</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这个题的难点就在于如何对于任何入栈出栈，如何实时的维持最小值，应当知道最小值相关的操作都是和入栈出栈操作是同步的，这个时候想到应当维持一个和主栈同步的辅助栈用来维持每个位置的最小值</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  Stack&lt;Integer&gt; mainStack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; helperStack;</span><br><span class="line">    MinStack()&#123;</span><br><span class="line">        mainStack=<span class="keyword">new</span> Stack();</span><br><span class="line">        helperStack=<span class="keyword">new</span> Stack();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        helperStack.pop();</span><br><span class="line">        <span class="keyword">return</span> mainStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Integer i)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i&lt;helperStack.peek())&#123;</span><br><span class="line">            helperStack.push(i);</span><br><span class="line">        &#125;<span class="keyword">else</span> </span><br><span class="line">            helperStack.push(helperStack.peek());</span><br><span class="line">        mainStack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helperStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h1><h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><p>给定两个序列，一个是入栈的序列，一个是出栈的序列，判断出栈序列是否满足前面的入栈序列</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>按照实际的手动操作进行分析：对于入栈序列，如果和出栈序列的第一数相同，说明这个数一进栈就出栈了，所以可以省略进栈这个过程；如果这个数和出栈数不相同，因此这个数入栈，进行下一个数的对比……当入栈序列已经判断完毕，这个时候就要判断栈中的数，这就比较简单了</p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈的压入弹出序列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPopOrder</span><span class="params">(<span class="keyword">int</span>[]pushOrder,<span class="keyword">int</span>[] popOrder)</span></span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j&lt;pushOrder.length)&#123;</span><br><span class="line">        <span class="keyword">if</span> (pushOrder[j]!=popOrder[i]||stack.peek()!=popOrder[i])&#123;</span><br><span class="line">            stack.push(pushOrder[j]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (pushOrder[j]==popOrder[i])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (stack.peek()==popOrder[i])&#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.peek()!=popOrder[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;用两个栈实现队列&quot;&gt;&lt;a href=&quot;#用两个栈实现队列&quot; class=&quot;headerlink&quot; title=&quot;用两个栈实现队列&quot;&gt;&lt;/a&gt;用两个栈实现队列&lt;/h1&gt;&lt;p&gt;栈和队列一个先进后出，一个先进先出，因此应当想办法“逆转”一下，这就是第二个栈的作用&lt;br&gt;
      
    
    </summary>
    
      <category term="刷算法题" scheme="https://www.junglezero.top/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="数据结构" scheme="https://www.junglezero.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="栈和队列" scheme="https://www.junglezero.top/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>《算法分析》课程整理</title>
    <link href="https://www.junglezero.top/2019/06/06/%E6%B3%95%E5%88%86%E6%9E%90%E3%80%8B%E8%AF%BE%E7%A8%8B%E6%95%B4%E7%90%86-1/"/>
    <id>https://www.junglezero.top/2019/06/06/法分析》课程整理-1/</id>
    <published>2019-06-06T01:53:00.000Z</published>
    <updated>2019-06-24T10:09:44.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="递归和分治"><a href="#递归和分治" class="headerlink" title="递归和分治"></a>递归和分治</h1><h2 id="整数划分问题"><a href="#整数划分问题" class="headerlink" title="整数划分问题"></a>整数划分问题</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>任何一个大于1的自然数，总可以拆分为若干个小于n的自然数之和，试求n的所有拆分，将最大拆分数不超过m的划分个数记做去q(n,m)</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>根据n和m的情况，可以分为以下几种情况：<br>根据n和m的关系，考虑以下几种情况： </p><ol><li>当n=1时，不论m的值为多少（m&gt;0)，只有一种划分即{1}; </li><li>当m=1时，不论n的值为多少，只有一种划分即n个1，{1,1,1,…,1}; </li><li>当n=m时，根据划分中是否包含n，可以分为两种情况：<br> (1) 划分中包含n的情况，只有一个即{n}；<br> (2) 划分中不包含n的情况，这时划分中最大的数字也一定比n小，即n的所有(n-1)划分。因此 f(n,n) =1 + f(n,n-1); </li><li>当n&lt;m时，由于划分中不可能出现负数，因此就相当于f(n,n); </li><li>但n&gt;m时，根据划分中是否包含最大值m，可以分为两种情况：<br> (1) 划分中包含m的情况，即{m, {x1,x2,…xi}}, 其中{x1,x2,… xi} 的和为n-m，可能再次出现m，因此是（n-m）的m划分，因此这种划分个数为f(n-m, m);<br> (2) 划分中不包含m的情况，则划分中所有值都比m小，即n的(m-1)划分，个数为f(n,m-1);因此 f(n, m) = f(n-m, m)+f(n,m-1);</li></ol><p>通过以上规律，得到递推公式：</p><ul><li>f(n, m)= 1; (n=1 or m=1)</li><li>f(n, m)=f(n, n); (n&lt;m)</li><li>1+ f(n, m-1); (n=m)</li><li>f(n-m,m)+f(n,m-1); (n&gt;m)</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/函数：q(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span><br><span class="line"><span class="comment">//作用：用来得到正整数n，最大加数不大于m的划分个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">q</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="comment">//若正整数或最大加数小于1，则返回0</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">1</span>||m&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//若正整数或最大加数等于1，则划分个数为1（n个1相加）</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>||m==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//若最大加数实际上不能大于正整数n，若大于则划分个数等于最大加数为n的划分个数</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;m) <span class="keyword">return</span> q(n,n);</span><br><span class="line">    <span class="comment">//若正整数等于最大加数，则划分个数等于</span></span><br><span class="line">    <span class="keyword">if</span> (n==m) <span class="keyword">return</span> <span class="number">1</span>+q(n,n-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> q(n,m-<span class="number">1</span>)+q(n-m,m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Strassen矩阵乘法"><a href="#Strassen矩阵乘法" class="headerlink" title="Strassen矩阵乘法"></a>Strassen矩阵乘法</h2><h3 id="一般的矩阵乘法思路"><a href="#一般的矩阵乘法思路" class="headerlink" title="一般的矩阵乘法思路"></a>一般的矩阵乘法思路</h3><p><img src="/upload/pasted-297.png" alt="upload successful"><br>复杂度为O(n3)</p><h3 id="一种改进方法"><a href="#一种改进方法" class="headerlink" title="一种改进方法"></a>一种改进方法</h3><p><img src="/upload/pasted-298.png" alt="upload successful"></p><h3 id="Strassen方法"><a href="#Strassen方法" class="headerlink" title="Strassen方法"></a>Strassen方法</h3><p><img src="/upload/pasted-299.png" alt="upload successful"></p><p><img src="/upload/pasted-300.png" alt="upload successful"><br>这个方法的特点就是减少了一次乘法，虽然多了14次加法，但是加法计算基本没有成本<br>时间复杂度：</p><p><img src="/upload/pasted-301.png" alt="upload successful"></p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h2><ul><li>动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题。</li><li>但是经分解得到的子问题往往不是互相独立的。不同子问题的数目常常只有多项式量级。在用分治法求解时，有些子问题被重复计算了许多次。</li><li>如果能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，就可以避免大量重复计算，从而得到多项式时间算法。</li></ul><h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><ul><li>找出最优解的性质，并刻划其结构特征。</li><li>递归地定义最优值。</li><li>以自底向上的方式计算出最优值。</li><li>根据计算最优值时得到的信息，构造最优解</li></ul><h2 id="矩阵连乘问题"><a href="#矩阵连乘问题" class="headerlink" title="矩阵连乘问题"></a>矩阵连乘问题</h2><h3 id="基本内容-1"><a href="#基本内容-1" class="headerlink" title="基本内容"></a>基本内容</h3><p>对于一般的矩阵乘法来说，如矩阵A(m,n)与矩阵B(n,p)相乘需要进行的加法次数为m<em>n</em>p次乘法。</p><p>由于矩阵乘法满足结合律，因此矩阵相乘的结合性，会影响整个计算表达式的乘法执行次数。</p><p>如下面的例子，其中A(10,5)、B(5,20)、C(20,3)：</p><p>　　　　(1) ((AB)C) 执行乘法次数为1300次</p><p>　　　　(2) (A(BC)) 执行乘法次数为450次</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>预处理：<br>将矩阵连乘积AiAi+1…Aj简记为A[i:j]，这里i≤j。<br>考察计算A[i:j]的最优计算次序。设这个计算次序在矩阵Ak和Ak+1之间将矩阵链断开，i≤k&lt;j，则其相应完全加括号方式为（AiAi+1… Ak）（Ak+1 Ak+2… Aj ）。<br>计算量：A[i:k]的计算量加上A[k+1:j]的计算量，再加上A[i:k]和A[k+1:j]相乘的计算量。<br>分析最优解的结构<br>特征：计算A[i:j]的最优次序所包含的计算矩阵子链 A[i:k]和A[k+1:j]的次序也是最优的。<br>矩阵连乘计算次序问题的最优解包含着其子问题的最优解。这种性质称为最优子结构性质。问题的最优子结构性质是该问题可用动态规划算法求解的显著特征。<br>设计算A[i:j]，1≤i≤j≤n，所需要的最少数乘次数m[i,j]，则原问题的最优值为m[1,n]。<br>当i=j时，A[i:j]=Ai，因此，m[i,i]=0，i=1,2,…,n。<br>当i&lt;j时，m[i,j]=m[i,k]+m[k+1,j]+pi-1pkpj，这里Ai的维数为pi-1×pi。<br>可以递归地定义m[i,j]为：<br> <img src="/upload/pasted-306.png" alt="upload successful"><br>k的位置只有j-i种可能。</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MatrixChain</span><span class="params">(<span class="keyword">int</span> [] p，<span class="keyword">int</span> n，<span class="keyword">int</span> [] []m，<span class="keyword">int</span> [][]s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//当m[i][j]中i==j时，m[i][j]==0</span></span><br><span class="line">　<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) m[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//从m[1][2],m[2][3],m[3][4]开始计算</span></span><br><span class="line">　<span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">2</span>; r &lt;= n; r++)</span><br><span class="line">　　<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - r+<span class="number">1</span>; i++) &#123;</span><br><span class="line">　　　<span class="keyword">int</span> j=i+r-<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//先将m[i][j]初始化，即当k=i的时候</span></span><br><span class="line">　　　m[i][j] = m[i+<span class="number">1</span>][j]+ p[i-<span class="number">1</span>]*p[i]*p[j];</span><br><span class="line">            <span class="comment">//初始化s[i][j]</span></span><br><span class="line">　　　s[i][j] = i;</span><br><span class="line">            <span class="comment">//依次遍历k的每一个取值，按照递推公式，取最小值作为m[i][j],此时的k作为s[i][j]的值</span></span><br><span class="line">　　　<span class="keyword">for</span> (<span class="keyword">int</span> k = i+<span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">　　　　<span class="keyword">int</span> t = m[i][k] + m[k+<span class="number">1</span>][j] + p[i-<span class="number">1</span>]*p[k]*p[j];</span><br><span class="line">    <span class="comment">//遍历过程中，若发现 当前k的选择拥有最小的m，则记录m和k的值，此时的k即为拆分的位置</span></span><br><span class="line">　　　　<span class="keyword">if</span> (t &lt; m[i][j]) &#123; m[i][j] = t; s[i][j] = k;&#125;</span><br><span class="line">　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><h3 id="基本内容-2"><a href="#基本内容-2" class="headerlink" title="基本内容"></a>基本内容</h3><p>给定两个字符串，求解这两个字符串的最长公共子序列（Longest Common Sequence）。比如字符串1：BDCABA；字符串2：ABCBDAB</p><p>则这两个字符串的最长公共子序列长度为4，最长公共子序列是：BCBA</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>①最优子结构</p><p>设 X=(x1,x2,…..xn) 和 Y={y1,y2,…..ym} 是两个序列，将 X 和 Y 的最长公共子序列记为LCS(X,Y)</p><p>找出LCS(X,Y)就是一个最优化问题。因为，我们需要找到X 和 Y中最长的那个公共子序列。而要找X 和 Y的LCS，首先考虑X的最后一个元素和Y的最后一个元素。</p><p>1）如果 xn=ym，即X的最后一个元素与Y的最后一个元素相同，这说明该元素一定位于公共子序列中。因此，现在只需要找：LCS(Xn-1，Ym-1)<br>LCS(Xn-1，Ym-1)就是原问题的一个子问题。</p><p>2）如果xn != ym，产生了两个子问题：LCS(Xn-1，Ym) 和 LCS(Xn，Ym-1)</p><p>因为序列X 和 序列Y 的最后一个元素不相等嘛，那说明最后一个元素不可能是最长公共子序列中的元素嘛。</p><p>LCS(Xn-1，Ym)表示：最长公共序列可以在(x1,x2,….x(n-1)) 和 (y1,y2,…yn)中找。<br>LCS(Xn，Ym-1)表示：最长公共序列可以在(x1,x2,….xn) 和 (y1,y2,…y(n-1))中找。<br>求解上面两个子问题，得到的公共子序列谁最长，那谁就是 LCS（X,Y）。用数学表示就是：<br>LCS=max{LCS(Xn-1，Ym)，LCS(Xn，Ym-1)}</p><p>由于条件 1)  和  2)  考虑到了所有可能的情况。因此，我们成功地把原问题 转化 成了 三个规模更小的子问题。</p><p>②重叠子问题<br>重叠子问题是啥？就是说原问题 转化 成子问题后，  子问题中有相同的问题。咦？我怎么没有发现上面的三个子问题中有相同的啊？？？？</p><p>OK，来看看，原问题是：LCS(X,Y)。子问题有 ❶LCS(Xn-1，Ym-1)    ❷LCS(Xn-1，Ym)    ❸LCS(Xn，Ym-1)</p><p>初一看，这三个子问题是不重叠的。可本质上它们是重叠的，因为它们只重叠了一大部分。举例：</p><p>第二个子问题：LCS(Xn-1，Ym) 就包含了：问题❶LCS(Xn-1，Ym-1)，为什么？</p><p>因为，当Xn-1 和 Ym 的最后一个元素不相同时，我们又需要将LCS(Xn-1，Ym)进行分解：分解成：LCS(Xn-1，Ym-1) 和 LCS(Xn-2，Ym)</p><p>也就是说：在子问题的继续分解中，有些问题是重叠的。<br>递推公式：</p><p><img src="/upload/pasted-296.png" alt="upload successful"></p><p>c[i,j]表示：(x1,x2….xi) 和 (y1,y2…yj) 的最长公共子序列的长度</p><p>③得到最长公共子序列的具体内容</p><p><img src="/upload/pasted-303.png" alt="upload successful"><br>由问题的分析可知，我们找最长公共子序列，是比较两个字符串的最后一位，若最后一位相等，则这个字符肯定是最长公共子序列的内容，因此此时，按照递推公式的描述，“斜向上”移动，当两个字符不相等时，此时根据前面的分析，可以是第一个字符串前移，也可以是第二个字符串前移，两种方式都可以，规定一种就好</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findLCS</span><span class="params">(String A, <span class="keyword">int</span> n, String B, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            dp[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A.charAt(i - <span class="number">1</span>) == B.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] &gt; dp[i][j - <span class="number">1</span>] ? dp[i - <span class="number">1</span>][j] : dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h2><h3 id="基本内容-3"><a href="#基本内容-3" class="headerlink" title="基本内容"></a>基本内容</h3><p>求一个序列的最大子段和即最大连续子序列之和。例如序列[4, -3, 5, -2, -1, 2, 6, -2]的最大子段和为11=[4+(-3)+5+(-2)+(-1)+(2)+(6)]。</p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>设前边界为1，后边界为i，且C(i)是子序列A[1,..i]必须包含元素A[i]的向前连续延伸的最大子段和：</p><p>遍历所有以i (1≤i≤n)为后边界的最大子段和Ci得出最优解：</p><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSumDyn</span><span class="params">( <span class="keyword">int</span> array[],<span class="keyword">int</span> len )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( b &gt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            b += array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            b = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( b &gt; sum )</span><br><span class="line">        &#123;</span><br><span class="line">            sum = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多边形游戏"><a href="#多边形游戏" class="headerlink" title="多边形游戏"></a>多边形游戏</h2><h3 id="基本内容-4"><a href="#基本内容-4" class="headerlink" title="基本内容"></a>基本内容</h3><h2 id="图像压缩"><a href="#图像压缩" class="headerlink" title="图像压缩"></a>图像压缩</h2><p>在计算机中，常用像素点的灰度值序列{p1,p1,……pn}表示图像。其中整数pi,1&lt;=i&lt;=n，表示像素点i的灰度值。通常灰度值的范围是0~255。因此最多需要8位表示一个像素。</p><p>压缩的原理就是把序列{p1,p1,……pn}进行设断点，将其分割成一段一段的。分段的过程就是要找出断点，让一段里面的像素的最大灰度值比较小，那么这一段像素(本来需要8位)就可以用较少的位(比如7位)来表示，从而减少存储空间。</p><p>b代表bits,l代表length,分段是，b[i]表示每段一个像素点需要的最少存储空间(少于8位才有意义)，l[i]表示每段里面有多少个像素点，s[i]表示从0到i压缩为一共占多少存储空间。</p><p> 如果限制l[i]&lt;=255,则需要8位来表示l[i]。而b[i]&lt;=8，需要3位表示b[i]。所以每段所需的存储空间为l[i]*b[i]+11位。假设将原图像分成m段，那么需要</p><p><img src="/upload/pasted-304.png" alt="upload successful"><br>图像压缩问题的本质就是要确定像素序列{p1,p1,……pn}的最优分段，使得依此分段所需的存储空间最小</p><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>最优子结构<br>设l[i],b[i],1&lt;=i&lt;=m是{p1,p1,……pn}的一个最优分段，则l[1],b[1]是{p1,……,pl[1]}的一个最优分段，且l[i],b[i],2&lt;=i&lt;=m是{pl[1]+1,……,pn}的一个最优分段。即图像压缩问题满足最优子结构性质。<br>动态规划方程<br> 设s[i],1&lt;=i&lt;=n是像素序列{p1,p1,……pi}的最优分段所需的存储位数，则s[i]为前i-k个的存储位数加上后k个的存储空间。由最优子结构性质可得：</p><p><img src="/upload/pasted-307.png" alt="upload successful"></p><p><img src="/upload/pasted-308.png" alt="upload successful"></p><h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Compress</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> p[],<span class="keyword">int</span> s[],<span class="keyword">int</span> l[],<span class="keyword">int</span> b[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> Lmax = <span class="number">256</span>,header = <span class="number">11</span>;  </span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        b[i] = length(p[i]);<span class="comment">//计算像素点p需要的存储位数  </span></span><br><span class="line">        <span class="keyword">int</span> bmax = b[i];  </span><br><span class="line">        s[i] = s[i<span class="number">-1</span>] + bmax;  </span><br><span class="line">        l[i] = <span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>; j&lt;=i &amp;&amp; j&lt;=Lmax;j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span>(bmax&lt;b[i-j+<span class="number">1</span>])  </span><br><span class="line">            &#123;  </span><br><span class="line">                bmax = b[i-j+<span class="number">1</span>];  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span>(s[i]&gt;s[i-j]+j*bmax)  </span><br><span class="line">            &#123;  </span><br><span class="line">                s[i] = s[i-j] + j*bmax;  </span><br><span class="line">                l[i] = j;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        s[i] += header;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">(<span class="keyword">int</span> i)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">1</span>;  </span><br><span class="line">    i = i/<span class="number">2</span>;  </span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        k++;  </span><br><span class="line">        i=i/<span class="number">2</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> k;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Traceback</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span>&amp; i,<span class="keyword">int</span> s[],<span class="keyword">int</span> l[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    Traceback(n-l[n],i,s,l);  </span><br><span class="line">    s[i++]=n-l[n];<span class="comment">//重新为s[]数组赋值，用来存储分段位置  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="电路布线问题"><a href="#电路布线问题" class="headerlink" title="电路布线问题"></a>电路布线问题</h2><h3 id="基本内容-5"><a href="#基本内容-5" class="headerlink" title="基本内容"></a>基本内容</h3><p>在一块电路板的上、下两端分别有n个接线柱。根据电路设计，要求用导线(i,π(i)) 将上端接线柱i与下端接线柱π(i)相连，如下图。其中，π(i),1≤ i ≤n,是｛1,2,…,n｝的一个排列。导线(I, π(i))称为该电路板上的第i条连线。对于任何1 ≤ i ≤ j ≤n,第i条连线和第j条连线相交的充要条件是π(i)&gt; π(j).</p><p><img src="/upload/pasted-309.png" alt="upload successful"><br>在制作电路板时，要求将这n条连线分布到若干绝缘层上。在同一层上的连线不相交。电路布线问题要确定将哪些连线安排在第一层上，使得该层上有尽可能多的连线。换句话说，该问题要求确定导线集Nets = ｛i，π(i)，1 ≤ i ≤ n｝的最大不相交子集。 </p><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>记N(i,j) = {t|(t, π(t)) ∈ Nets,t ≤ i, π(t) ≤ j }. N(i,j)的最大不相交子集为MNS（i,j）Size(i,j)=|MNS(i,j)|。<br>(1)当i = 1时</p><p><img src="/upload/pasted-310.png" alt="upload successful"><br>(2)当i &gt;1时</p><p>① j &lt;π(i)。此时，(i,π(i)) 不属于N(i,j)。故在这种情况下，N(i,j) = N(i-1,j)，从而Size(i,j)=Size(i-1,j)。</p><p>② j ≥π(i)。此时，若(i, π(i))∈MNS(i,j)，则对任意(t, π(t))∈MNS(i,j)有t &lt; i且π(t)&lt; π(i)；否则，(t, π(t))与(i, π(i))相交。在这种情况下MNS(i,j)-{(i, π(i))}是N(i-1, π(i)-1)的最大不相交子集。否则，子集MNS(i-1, π(i)-1)∪{(i, π(i))}包含于N(i,j)是比MNS(i,j)更大的N(i,j)的不相交子集。这与MNS(i,j)的定义相矛盾。</p><p>若(i, π(i))不属于MNS(i,j)，则对任意(t, π(t))∈MNS(i,j)，有t&lt;i。从而MNS(i,j)包含于N(i-1,j)，因此，Size(i,j)≤Size(i-1,j)。<br>另一方面，MNS(i-1,j)包含于N(i,j),故又有Size(i,j) ≥Size(i-1,j)，从而Size（i,j）= Size(i-1,j)。</p><p><img src="/upload/pasted-311.png" alt="upload successful"><br>电路布线问题的最优值为Size(n,n)。由该问题的最优子结构性质可知，子问题最优值的递归关系如下：</p><p><img src="/upload/pasted-312.png" alt="upload successful"></p><p>根据递归方程得到如下二维表</p><p><img src="/upload/pasted-313.png" alt="upload successful"></p><h2 id="0-1背包问题（动态规划）"><a href="#0-1背包问题（动态规划）" class="headerlink" title="0-1背包问题（动态规划）"></a>0-1背包问题（动态规划）</h2><h3 id="基本内容-6"><a href="#基本内容-6" class="headerlink" title="基本内容"></a>基本内容</h3><p>给定种物品和一个容量为的背包，物品的重量是，其价值为，背包问题是如何使选择装入背包内的物品，使得装入背包中的物品的总价值最大。其中，每种物品只有全部装入背包或不装入背包两种选择。</p><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>在解决问题之前，为描述方便，首先定义一些变量：Vi表示第 i 个物品的价值，Wi表示第 i 个物品的体积，定义V(i,j)：当前背包容量 j，前 i 个物品最佳组合对应的价值，同时背包问题抽象化（X1，X2，…，Xn，其中 Xi 取0或1，表示第 i 个物品选或不选）。<br>1、建立模型，即求max(V1X1+V2X2+…+VnXn)；<br>2、寻找约束条件，W1X1+W2X2+…+WnXn&lt;capacity；<br>3、寻找递推关系式，面对当前商品有两种可能性：</p><ul><li>包的容量比该商品体积小，装不下，此时的价值与前i-1个的价值是一样的，即V(i,j)=V(i-1,j)；</li><li>还有足够的容量可以装该商品，但装了也不一定达到当前最优价值，所以在装与不装之间选择最优的一个，即V(i,j)=max｛V(i-1,j)，V(i-1,j-w(i))+v(i)｝。<br>其中V(i-1,j)表示不装，V(i-1,j-w(i))+v(i) 表示装了第i个商品，背包容量减少w(i)，但价值增加了v(i)；<br>由此可以得出递推关系式：</li><li>j&lt;w(i)      V(i,j)=V(i-1,j)</li><li>j&gt;=w(i)     V(i,j)=max｛V(i-1,j)，V(i-1,j-w(i))+v(i)｝</li></ul><p>然后就是填表，根据递推公式，填完如下<br>w(2,3,4,5) v(3,4,5,6) cap=8</p><p>根据动态规划函数，v[4,8]就是最大价值<br><img src="/upload/pasted-314.png" alt="upload successful"><br><img src="/upload/pasted-315.png" alt="upload successful"><br><img src="/upload/pasted-316.png" alt="upload successful"></p><h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><h2 id="剪绳子（动态规划）"><a href="#剪绳子（动态规划）" class="headerlink" title="剪绳子（动态规划）"></a>剪绳子（动态规划）</h2><h3 id="基本内容-7"><a href="#基本内容-7" class="headerlink" title="基本内容"></a>基本内容</h3><p>给你一根长度为n绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m≥1）。每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0]<em>k[1]</em>…*k[m]可能的最大乘积是多少？例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18。</p><h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><p>如果不能发现最优子结构，可以自小向大推：绳子长度为1时，最大乘积只能是0，绳子长度为2时，切成1和1，结果也是1，绳子长度为3时，切成1和2，结果是2，绳子长度为4时，可以分为1<em>1</em>1<em>1，1</em>2<em>1，1</em>3，2<em>2，最大乘积为4，因此可以发现最优子结构f(n)=max(f(i)</em>f(n-i))</p><h3 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h3><p>在实现时，可以从下到上实现，利用数组存储中间结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cutRoats</span><span class="params">(<span class="keyword">int</span>  length)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"长度不合法"</span>);</span><br><span class="line">    <span class="keyword">if</span> (length&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (length==<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (length==<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>  []  product=<span class="keyword">new</span> <span class="keyword">int</span>[length+<span class="number">1</span>];</span><br><span class="line">    product[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    product[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    product[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">    product[<span class="number">3</span>]=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">4</span>;i&lt;=length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i/<span class="number">2</span>;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (max &lt; product[j] * product[i - j])</span><br><span class="line">                max = product[j] * product[i - j];</span><br><span class="line">        &#125;</span><br><span class="line">        product[i]=max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> product[length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="剪绳子（贪心算法）"><a href="#剪绳子（贪心算法）" class="headerlink" title="剪绳子（贪心算法）"></a>剪绳子（贪心算法）</h2><h3 id="基本内容-8"><a href="#基本内容-8" class="headerlink" title="基本内容"></a>基本内容</h3><p>给你一根长度为n绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m≥1）。每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0]<em>k[1]</em>…*k[m]可能的最大乘积是多少？例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18</p><h3 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h3><p>多数情况下，贪心算法是得不到最优解的，但是本题依赖于一个数学证明：当绳子长度大于5时，尽可能的剪出长度为3的绳子是最优解</p><h3 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProductAfterCutting_solution2</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> timesOf3 = length / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> timesOf2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (length - timesOf3 * <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        timesOf3--;</span><br><span class="line">        <span class="comment">// timesOf2=2;  //错误！</span></span><br><span class="line">    &#125;</span><br><span class="line">    timesOf2 = (length - timesOf3 * <span class="number">3</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) (Math.pow(<span class="number">3</span>, timesOf3) * Math.pow(<span class="number">2</span>, timesOf2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;递归和分治&quot;&gt;&lt;a href=&quot;#递归和分治&quot; class=&quot;headerlink&quot; title=&quot;递归和分治&quot;&gt;&lt;/a&gt;递归和分治&lt;/h1&gt;&lt;h2 id=&quot;整数划分问题&quot;&gt;&lt;a href=&quot;#整数划分问题&quot; class=&quot;headerlink&quot; title=&quot;整
      
    
    </summary>
    
      <category term="刷算法题" scheme="https://www.junglezero.top/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="课程整理" scheme="https://www.junglezero.top/tags/%E8%AF%BE%E7%A8%8B%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>无向图</title>
    <link href="https://www.junglezero.top/2019/04/25/%E5%9B%BE/"/>
    <id>https://www.junglezero.top/2019/04/25/图/</id>
    <published>2019-04-25T01:00:24.000Z</published>
    <updated>2019-06-04T04:45:18.998Z</updated>
    
    <content type="html"><![CDATA[<p>…省略掉图在离散数学中的许多定义</p><h1 id="无向图的数据结构"><a href="#无向图的数据结构" class="headerlink" title="无向图的数据结构"></a>无向图的数据结构</h1><p>这里使用邻接表数组表示</p><p><img src="/upload/pasted-295.png" alt="upload successful"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> V; <span class="comment">//定点数目</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> E;       <span class="comment">//边的数目</span></span><br><span class="line">    <span class="keyword">private</span> Bag&lt;Integer&gt;[] adj; <span class="comment">//邻接表</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以V(定点的个数为依据进行初始化)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  V number of vertices</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> V &lt; 0&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> V)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (V &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Number of vertices must be nonnegative"</span>);</span><br><span class="line">        <span class="keyword">this</span>.V = V;</span><br><span class="line">        <span class="keyword">this</span>.E = <span class="number">0</span>;</span><br><span class="line">        adj = (Bag&lt;Integer&gt;[]) <span class="keyword">new</span> Bag[V];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">            adj[v] = <span class="keyword">new</span> Bag&lt;Integer&gt;();<span class="comment">//初始化所有链表为空</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes a new graph that is a deep copy of &#123;<span class="doctag">@code</span> G&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  G the graph to copy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(Graph G)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(G.V());</span><br><span class="line">        <span class="keyword">this</span>.E = G.E();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++) &#123;</span><br><span class="line">            <span class="comment">// reverse so that adjacency list is in same order as original</span></span><br><span class="line">            Stack&lt;Integer&gt; reverse = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : G.adj[v]) &#123;</span><br><span class="line">                reverse.push(w);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : reverse) &#123;</span><br><span class="line">                adj[v].add(w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回图中结点个数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of vertices in this graph</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of edges in this graph.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of edges in this graph</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">E</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// throw an IllegalArgumentException unless &#123;@code 0 &lt;= v &lt; V&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateVertex</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= V)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"vertex "</span> + v + <span class="string">" is not between 0 and "</span> + (V-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向图中加入v-w边</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  v one vertex in the edge</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  w the other vertex in the edge</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless both &#123;<span class="doctag">@code</span> 0 &lt;= v &lt; V&#125; and &#123;<span class="doctag">@code</span> 0 &lt;= w &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        validateVertex(v);</span><br><span class="line">        validateVertex(w);</span><br><span class="line">        E++;</span><br><span class="line">        adj[v].add(w);</span><br><span class="line">        adj[w].add(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回某结点的邻接表集.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  v the vertex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the vertices adjacent to vertex &#123;<span class="doctag">@code</span> v&#125;, as an iterable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= v &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        validateVertex(v);</span><br><span class="line">        <span class="keyword">return</span> adj[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回结点的个数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  v the vertex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the degree of vertex &#123;<span class="doctag">@code</span> v&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= v &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">degree</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        validateVertex(v);</span><br><span class="line">        <span class="keyword">return</span> adj[v].size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a string representation of this graph.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of vertices &lt;em&gt;V&lt;/em&gt;, followed by the number of edges &lt;em&gt;E&lt;/em&gt;,</span></span><br><span class="line"><span class="comment">     *         followed by the &lt;em&gt;V&lt;/em&gt; adjacency lists</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s.append(V + <span class="string">" vertices, "</span> + E + <span class="string">" edges "</span> + NEWLINE);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">            s.append(v + <span class="string">": "</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : adj[v]) &#123;</span><br><span class="line">                s.append(w + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            s.append(NEWLINE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="深度优先搜索-Depth-First-Search"><a href="#深度优先搜索-Depth-First-Search" class="headerlink" title="深度优先搜索(Depth-First Search)"></a>深度优先搜索(Depth-First Search)</h1><p>深度优先搜索可以理解为拿着一根绳子走迷宫，开始选择一条没有走过的路，每到一个路口，就对当前位置进行标记，当再次到达标记位置时，利用绳子回退到上一个路口，如此往复，循环渐进<br>而实现的程序上描述起来就更为简单：在访问一个顶点时，把当前的结点进行标记，然后递归的访问没有标记的顶点</p><p><img src="/upload/DFS.gif" alt="upload successful"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepthFirstPaths</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;    <span class="comment">// 标记顶点是否被标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] edgeTo;        <span class="comment">// edgeTo[v] = s到v的路径上最后一条边的起点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> s;         <span class="comment">// 搜索的起点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始进行广度优先麦搜索</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> G the graph</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s the source vertex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= s &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DepthFirstPaths</span><span class="params">(Graph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        edgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        <span class="comment">//验证s是否合法</span></span><br><span class="line">        validateVertex(s);</span><br><span class="line">        dfs(G, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键递归步骤</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将当前访问的顶点标记为已访问</span></span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//依次递归访问当前结点的所有相邻结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w : G.adj(v)) &#123;</span><br><span class="line">            <span class="comment">//如果未访问，则访问该顶点</span></span><br><span class="line">            <span class="keyword">if</span> (!marked[w]) &#123;</span><br><span class="line">                edgeTo[w] = v;</span><br><span class="line">                dfs(G, w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判定源结点s和当前结点是有通路</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v the vertex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if there is a path, &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= v &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        validateVertex(v);</span><br><span class="line">        <span class="keyword">return</span> marked[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回源结点s和当前结点v的一条通路路径，如果不存在该路径，则返回null</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  v the vertex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the sequence of vertices on a path between the source vertex</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> s&#125; and vertex &#123;<span class="doctag">@code</span> v&#125;, as an Iterable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= v &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        validateVertex(v);</span><br><span class="line">        <span class="keyword">if</span> (!hasPathTo(v)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Stack&lt;Integer&gt; path = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = v; x != s; x = edgeTo[x])</span><br><span class="line">            path.push(x);</span><br><span class="line">        path.push(s);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// throw an IllegalArgumentException unless &#123;@code 0 &lt;= v &lt; V&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateVertex</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> V = marked.length;</span><br><span class="line">        <span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= V)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"vertex "</span> + v + <span class="string">" is not between 0 and "</span> + (V-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h1><h2 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h2><p><img src="/upload/BFS2.gif" alt="upload successful"><br><strong>引入</strong>：单点路径问题，在一个图中，给定两个结点，找出这两点之间是否存在路径，如果存在，找出最短路径<br><strong>分析</strong>：dfs并不能解决这个问题，因为其遍历整个图的顺序和找出最短路径没有关系,而相比之下，广度优先搜索正是为了这个目标而出现的，要找到s到v的最短路径。从s开始，找到距离s为1条边的点，如果找不到，就在距离为2的边中查找直到找到为止，如果把深度优先搜索比作为一个人拿着绳子走迷宫，那么，那么广度优先搜索就好像一群人向着各个方向走<br><strong>实现</strong>：使用一个队列保存已经被标记但是其邻接表还未进行检查的顶点，先将起点放入队列，然后重复以下步骤知道队列为空</p><ul><li>取队列中下一个顶点v并进行访问标记</li><li>将与v相邻的所有未被标记过的顶点</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  The &#123;<span class="doctag">@code</span> BreadthFirstPaths&#125; class represents a data type for finding</span></span><br><span class="line"><span class="comment"> *  shortest paths (number of edges) from a source vertex &lt;em&gt;s&lt;/em&gt;</span></span><br><span class="line"><span class="comment"> *  (or a set of source vertices)</span></span><br><span class="line"><span class="comment"> *  to every other vertex in an undirected graph.</span></span><br><span class="line"><span class="comment"> *  &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *  This implementation uses breadth-first search.</span></span><br><span class="line"><span class="comment"> *  The constructor takes time proportional to &lt;em&gt;V&lt;/em&gt; + &lt;em&gt;E&lt;/em&gt;,</span></span><br><span class="line"><span class="comment"> *  where &lt;em&gt;V&lt;/em&gt; is the number of vertices and &lt;em&gt;E&lt;/em&gt; is the number of edges.</span></span><br><span class="line"><span class="comment"> *  Each call to &#123;<span class="doctag">@link</span> #distTo(int)&#125; and &#123;<span class="doctag">@link</span> #hasPathTo(int)&#125; takes constant time;</span></span><br><span class="line"><span class="comment"> *  each call to &#123;<span class="doctag">@link</span> #pathTo(int)&#125; takes time proportional to the length</span></span><br><span class="line"><span class="comment"> *  of the path.</span></span><br><span class="line"><span class="comment"> *  It uses extra space (not including the graph) proportional to &lt;em&gt;V&lt;/em&gt;.</span></span><br><span class="line"><span class="comment"> *  &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *  For additional documentation,</span></span><br><span class="line"><span class="comment"> *  see &lt;a href="https://algs4.cs.princeton.edu/41graph"&gt;Section 4.1&lt;/a&gt;   </span></span><br><span class="line"><span class="comment"> *  of &lt;i&gt;Algorithms, 4th Edition&lt;/i&gt; by Robert Sedgewick and Kevin Wayne.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span> Robert Sedgewick</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span> Kevin Wayne</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BreadthFirstPaths</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INFINITY = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;  <span class="comment">// marked[v] = 标记s和v之间有通路</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] edgeTo;      <span class="comment">// edgeTo[v] = previous edge on shortest s-v path</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] distTo;      <span class="comment">// distTo[v] = number of edges shortest s-v path</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">     * Computes the shortest path between the source vertex &#123;<span class="doctag">@code</span> s&#125;</span></span><br><span class="line"><span class="comment">     * and every other vertex in the graph &#123;<span class="doctag">@code</span> G&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> G the graph</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s the source vertex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= s &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BreadthFirstPaths</span><span class="params">(Graph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        distTo = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        edgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        validateVertex(s);</span><br><span class="line">        bfs(G, s);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">check</span><span class="params">(G, s)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes the shortest path between any one of the source vertices in &#123;<span class="doctag">@code</span> sources&#125;</span></span><br><span class="line"><span class="comment">     * and every other vertex in graph &#123;<span class="doctag">@code</span> G&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> G the graph</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sources the source vertices</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= s &lt; V&#125; for each vertex</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> s&#125; in &#123;<span class="doctag">@code</span> sources&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BreadthFirstPaths</span><span class="params">(Graph G, Iterable&lt;Integer&gt; sources)</span> </span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        distTo = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        edgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++)</span><br><span class="line">            distTo[v] = INFINITY;</span><br><span class="line">        validateVertices(sources);</span><br><span class="line">        bfs(G, sources);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// breadth-first search from a single source</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Graph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> Queue&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++)</span><br><span class="line">            distTo[v] = INFINITY;</span><br><span class="line">        distTo[s] = <span class="number">0</span>;</span><br><span class="line">        marked[s] = <span class="keyword">true</span>;</span><br><span class="line">        q.enqueue(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = q.dequeue();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : G.adj(v)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!marked[w]) &#123;</span><br><span class="line">                    edgeTo[w] = v;</span><br><span class="line">                    distTo[w] = distTo[v] + <span class="number">1</span>;</span><br><span class="line">                    marked[w] = <span class="keyword">true</span>;</span><br><span class="line">                    q.enqueue(w);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// breadth-first search from multiple sources</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Graph G, Iterable&lt;Integer&gt; sources)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> Queue&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s : sources) &#123;</span><br><span class="line">            marked[s] = <span class="keyword">true</span>;</span><br><span class="line">            distTo[s] = <span class="number">0</span>;</span><br><span class="line">            q.enqueue(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = q.dequeue();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : G.adj(v)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!marked[w]) &#123;</span><br><span class="line">                    edgeTo[w] = v;</span><br><span class="line">                    distTo[w] = distTo[v] + <span class="number">1</span>;</span><br><span class="line">                    marked[w] = <span class="keyword">true</span>;</span><br><span class="line">                    q.enqueue(w);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Is there a path between the source vertex &#123;<span class="doctag">@code</span> s&#125; (or sources) and vertex &#123;<span class="doctag">@code</span> v&#125;?</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v the vertex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if there is a path, and &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= v &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        validateVertex(v);</span><br><span class="line">        <span class="keyword">return</span> marked[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of edges in a shortest path between the source vertex &#123;<span class="doctag">@code</span> s&#125;</span></span><br><span class="line"><span class="comment">     * (or sources) and vertex &#123;<span class="doctag">@code</span> v&#125;?</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v the vertex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of edges in a shortest path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= v &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">distTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        validateVertex(v);</span><br><span class="line">        <span class="keyword">return</span> distTo[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a shortest path between the source vertex &#123;<span class="doctag">@code</span> s&#125; (or sources)</span></span><br><span class="line"><span class="comment">     * and &#123;<span class="doctag">@code</span> v&#125;, or &#123;<span class="doctag">@code</span> null&#125; if no such path.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  v the vertex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the sequence of vertices on a shortest path, as an Iterable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= v &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        validateVertex(v);</span><br><span class="line">        <span class="keyword">if</span> (!hasPathTo(v)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Stack&lt;Integer&gt; path = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">for</span> (x = v; distTo[x] != <span class="number">0</span>; x = edgeTo[x])</span><br><span class="line">            path.push(x);</span><br><span class="line">        path.push(x);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// check optimality conditions for single source</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(Graph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check that the distance of s = 0</span></span><br><span class="line">        <span class="keyword">if</span> (distTo[s] != <span class="number">0</span>) &#123;</span><br><span class="line">            StdOut.println(<span class="string">"distance of source "</span> + s + <span class="string">" to itself = "</span> + distTo[s]);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check that for each edge v-w dist[w] &lt;= dist[v] + 1</span></span><br><span class="line">        <span class="comment">// provided v is reachable from s</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : G.adj(v)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hasPathTo(v) != hasPathTo(w)) &#123;</span><br><span class="line">                    StdOut.println(<span class="string">"edge "</span> + v + <span class="string">"-"</span> + w);</span><br><span class="line">                    StdOut.println(<span class="string">"hasPathTo("</span> + v + <span class="string">") = "</span> + hasPathTo(v));</span><br><span class="line">                    StdOut.println(<span class="string">"hasPathTo("</span> + w + <span class="string">") = "</span> + hasPathTo(w));</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (hasPathTo(v) &amp;&amp; (distTo[w] &gt; distTo[v] + <span class="number">1</span>)) &#123;</span><br><span class="line">                    StdOut.println(<span class="string">"edge "</span> + v + <span class="string">"-"</span> + w);</span><br><span class="line">                    StdOut.println(<span class="string">"distTo["</span> + v + <span class="string">"] = "</span> + distTo[v]);</span><br><span class="line">                    StdOut.println(<span class="string">"distTo["</span> + w + <span class="string">"] = "</span> + distTo[w]);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check that v = edgeTo[w] satisfies distTo[w] = distTo[v] + 1</span></span><br><span class="line">        <span class="comment">// provided v is reachable from s</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; G.V(); w++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasPathTo(w) || w == s) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> v = edgeTo[w];</span><br><span class="line">            <span class="keyword">if</span> (distTo[w] != distTo[v] + <span class="number">1</span>) &#123;</span><br><span class="line">                StdOut.println(<span class="string">"shortest path edge "</span> + v + <span class="string">"-"</span> + w);</span><br><span class="line">                StdOut.println(<span class="string">"distTo["</span> + v + <span class="string">"] = "</span> + distTo[v]);</span><br><span class="line">                StdOut.println(<span class="string">"distTo["</span> + w + <span class="string">"] = "</span> + distTo[w]);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// throw an IllegalArgumentException unless &#123;@code 0 &lt;= v &lt; V&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateVertex</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> V = marked.length;</span><br><span class="line">        <span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= V)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"vertex "</span> + v + <span class="string">" is not between 0 and "</span> + (V-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// throw an IllegalArgumentException unless &#123;@code 0 &lt;= v &lt; V&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateVertices</span><span class="params">(Iterable&lt;Integer&gt; vertices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (vertices == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument is null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> V = marked.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : vertices) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= V) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"vertex "</span> + v + <span class="string">" is not between 0 and "</span> + (V-<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Unit tests the &#123;<span class="doctag">@code</span> BreadthFirstPaths&#125; data type.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args the command-line arguments</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        In in = <span class="keyword">new</span> In(args[<span class="number">0</span>]);</span><br><span class="line">        Graph G = <span class="keyword">new</span> Graph(in);</span><br><span class="line">        <span class="comment">// StdOut.println(G);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> s = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">        BreadthFirstPaths bfs = <span class="keyword">new</span> BreadthFirstPaths(G, s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bfs.hasPathTo(v)) &#123;</span><br><span class="line">                StdOut.printf(<span class="string">"%d to %d (%d):  "</span>, s, v, bfs.distTo(v));</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x : bfs.pathTo(v)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (x == s) StdOut.print(x);</span><br><span class="line">                    <span class="keyword">else</span>        StdOut.print(<span class="string">"-"</span> + x);</span><br><span class="line">                &#125;</span><br><span class="line">                StdOut.println();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                StdOut.printf(<span class="string">"%d to %d (-):  not connected\n"</span>, s, v);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;…省略掉图在离散数学中的许多定义&lt;/p&gt;
&lt;h1 id=&quot;无向图的数据结构&quot;&gt;&lt;a href=&quot;#无向图的数据结构&quot; class=&quot;headerlink&quot; title=&quot;无向图的数据结构&quot;&gt;&lt;/a&gt;无向图的数据结构&lt;/h1&gt;&lt;p&gt;这里使用邻接表数组表示&lt;/p&gt;
&lt;p&gt;&lt;im
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>乐观锁和悲观锁</title>
    <link href="https://www.junglezero.top/2019/04/23/%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81-1/"/>
    <id>https://www.junglezero.top/2019/04/23/锁和悲观锁-1/</id>
    <published>2019-04-23T06:07:00.000Z</published>
    <updated>2019-04-23T06:14:46.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>当我们要对一个数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。</p><p>这种借助数据库锁机制在修改数据之前先锁定，再修改的方式被称之为悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）。</p><p>之所以叫做悲观锁，是因为这是一种对数据的修改抱有悲观态度的并发控制方式。我们一般认为数据被并发修改的概率比较大，所以需要在修改之前先加锁。</p><p>悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。</p><p>但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，还会降低并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。</p><p><img src="/upload/pasted-285.png" alt="upload successful"></p><p>Java里面的同步原语synchronized关键字的实现也是悲观锁。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>以MySQL为例<br>要使用悲观锁，必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set autocommit=0;<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//0.开始事务</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"></span><br><span class="line">//1.查询出商品库存信息</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> quantity <span class="keyword">from</span> items <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line">//2.修改商品库存为2</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> items <span class="keyword">set</span> quantity=<span class="number">2</span> <span class="keyword">where</span> <span class="keyword">id</span>= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">//3.提交事务</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></p><p>以上，在对id = 1的记录修改前，先通过for update的方式进行加锁，然后再进行修改。这就是比较典型的悲观锁策略。</p><p>如果以上修改库存的代码发生并发，同一时间只有一个线程可以开启事务并获得id=1的锁，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。</p><p>上面我们提到，使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意</p><h1 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p>乐观锁（ Optimistic Locking ） 是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。</p><p>相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。</p><p><img src="/upload/pasted-292.png" alt="upload successful"><br>乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。</p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>使用乐观锁就不需要借助数据库的锁机制了。</p><p>乐观锁的概念中其实已经阐述了他的具体实现细节：主要就是两个步骤：冲突检测和数据更新。其实现方式有一种比较典型的就是Compare and Swap(CAS)。</p><p>CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p><p>比如前面的扣减库存问题，通过乐观锁可以实现如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//查询出商品库存信息，quantity = 3</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> quantity <span class="keyword">from</span> items <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">//修改商品库存为<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> items <span class="keyword">set</span> quantity=<span class="number">2</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">and</span> quantity = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></p><p>以上，我们在更新之前，先查询一下库存表中当前库存数（quantity），然后在做update的时候，以库存数作为一个修改条件。当我们提交更新的时候，判断数据库表对应记录的当前库存数与第一次取出来的库存数进行比对，如果数据库表当前库存数与第一次取出来的库存数相等，则予以更新，否则认为是过期数据。</p><p>以上更新语句存在一个比较重要的问题，即传说中的ABA问题。</p><p>比如说一个线程one从数据库中取出库存数3，这时候另一个线程two也从数据库中库存数3，并且two进行了一些操作变成了2，然后two又将库存数变成3，这时候线程one进行CAS操作发现数据库中仍然是3，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。</p><p><img src="/upload/pasted-293.png" alt="upload successful"><br>有一个比较好的办法可以解决ABA问题，那就是通过一个单独的可以顺序递增的version字段。改为以下方式即可：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//查询出商品信息，version = 1</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">version</span> <span class="keyword">from</span> items <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">//修改商品库存为<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> items <span class="keyword">set</span> quantity=<span class="number">2</span>,<span class="keyword">version</span>= <span class="number">3</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">and</span> <span class="keyword">version</span>= <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p><p>乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现ABA问题，因为版本号只会增加不会减少。</p><p><img src="/upload/pasted-294.png" alt="upload successful"></p><p>以上SQL其实还是有一定的问题的，就是一旦发上高并发的时候，就只有一个线程可以修改成功，那么就会存在大量的失败。</p><p>对于像淘宝这样的电商网站，高并发是常有的事，总让用户感知到失败显然是不合理的。所以，还是要想办法减少乐观锁的粒度的。</p><p>有一条比较好的建议，可以减小乐观锁力度，最大程度的提升吞吐率，提高并发能力！如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//修改商品库存</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> item</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> quantity=quantity - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">and</span> quantity - <span class="number">1</span>&gt; <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>以上SQL语句中，如果用户下单数为1，则通过quantity - 1 &gt; 0的方式进行乐观锁控制。</p><p>以上update语句，在执行过程中，会在一次原子操作中自己查询一遍quantity的值，并将其扣减掉1。</p><h1 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h1><p>在乐观锁与悲观锁的选择上面，主要看下两者的区别以及适用场景就可以了。</p><p>1、乐观锁并未真正加锁，效率高。一旦锁的粒度掌握不好，更新失败的概率就会比较高，容易发生业务失败。</p><p>2、悲观锁依赖数据库锁，效率低。更新失败的概率比较低。</p><p>随着互联网三高架构（高并发、高性能、高可用）的提出，悲观锁已经越来越少的被使用到生产环境中了，尤其是并发量比较大的业务场景。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;悲观锁&quot;&gt;&lt;a href=&quot;#悲观锁&quot; class=&quot;headerlink&quot; title=&quot;悲观锁&quot;&gt;&lt;/a&gt;悲观锁&lt;/h1&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概
      
    
    </summary>
    
      <category term="数据库相关" scheme="https://www.junglezero.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/"/>
    
      <category term="java多线程学习" scheme="https://www.junglezero.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="java多线程" scheme="https://www.junglezero.top/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="数据库" scheme="https://www.junglezero.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>多线程上下文设计模式</title>
    <link href="https://www.junglezero.top/2019/04/22/%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.junglezero.top/2019/04/22/程上下文设计模式/</id>
    <published>2019-04-22T10:17:38.000Z</published>
    <updated>2019-04-22T10:49:02.938Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>上下文是贯穿整个系统或阶段生命周期的对象，其包含了系统全局的一些信息，比如登录之后的用户信息，账号信息以及程序每一个阶段运行时的数据。<br>在有些时候，单个线程执行的任务步骤会非常多，后一个步骤的输入有可能是前一个步骤的输出，比如在单个线程多步骤执行时，为了使得功能单一，有时候我们会采用GOF职责链设计模式。</p><p><img src="/upload/pasted-284.png" alt="upload successful"></p><h1 id="利用ThreadLocal实现"><a href="#利用ThreadLocal实现" class="headerlink" title="利用ThreadLocal实现"></a>利用ThreadLocal实现</h1><p>某个任务，需要分别从数据库和http查询内容<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutionTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> QueryFromDBAction queryAction = <span class="keyword">new</span> QueryFromDBAction();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> QueryFromHttpAction httpAction = <span class="keyword">new</span> QueryFromHttpAction();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接执行不用传参</span></span><br><span class="line">        queryAction.execute();</span><br><span class="line">        System.out.println(<span class="string">"The name query successful"</span>);</span><br><span class="line">        httpAction.execute();</span><br><span class="line">        System.out.println(<span class="string">"The card id query successful"</span>);</span><br><span class="line"></span><br><span class="line">        Context context = ActionContext.getActionContext().getContext();</span><br><span class="line">        System.out.println(<span class="string">"The Name is "</span> + context.getName() + <span class="string">" and CardId "</span> + context.getCardId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上下文类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String cardId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCardId</span><span class="params">(String cardId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cardId = cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCardId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cardId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>全局管理上下文<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Context&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;Context&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Context <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Context();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//嵌套内部类单例模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ActionContext actionContext = <span class="keyword">new</span> ActionContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ActionContext <span class="title">getActionContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ContextHolder.actionContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Context <span class="title">getContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ActionContext</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>任务中具体内容执行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryFromDBAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">            String name = <span class="string">"Alex "</span> + Thread.currentThread().getName();</span><br><span class="line">            <span class="comment">//调用全局context，并直接修改context</span></span><br><span class="line">            ActionContext.getActionContext().getContext().setName(name);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryFromHttpAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个任务就分为两步，首先获取name，从context中，然后再根据name获取cardID，存入context</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Context context = ActionContext.getActionContext().getContext();</span><br><span class="line">        String name = context.getName();</span><br><span class="line">        String cardId = getCardId(name);</span><br><span class="line">        context.setCardId(cardId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getCardId</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"435467523543"</span> + Thread.currentThread().getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;上下文是贯穿整个系统或阶段生命周期的对象，其包含了系统全局的一些信息，比如登录之后的用户信息，账号信息以及程序每一个阶段运行
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ThreadLocal的理解与使用</title>
    <link href="https://www.junglezero.top/2019/04/18/readLocal%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.junglezero.top/2019/04/18/readLocal的理解与使用/</id>
    <published>2019-04-18T03:05:35.000Z</published>
    <updated>2019-04-19T00:47:11.465Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本理解"><a href="#基本理解" class="headerlink" title="基本理解"></a>基本理解</h1><p>ThreadLocal是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。</p><p><img src="/upload/pasted-282.png" alt="upload successful"></p><p>从上面的ThreadLocal结构图中，可以发现</p><ul><li>每个Thread线程内部都有一个Map。</li><li>Map里面存储线程本地对象（key）和线程的变量副本（value）</li><li>但是，Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值。、</li><li>所以对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰。</li></ul><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>在Thread中的ThreadLocalMap由ThreadLocal类维护</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment">     * by the ThreadLocal class. */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal提供的三个核心方法</p><blockquote><p><strong>public T get()</strong></p></blockquote><p>Returns the value in the current thread’s copy of this thread-local variable. If the variable has no value for the current thread, it is first initialized to the value returned by an invocation of the initialValue() method.</p><blockquote></blockquote><p><strong>Returns:</strong><br>    the current thread’s value of this thread-local </p><p>简单来说，该方法就是获得当前线程副本的变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value in the current thread's copy of this</span></span><br><span class="line"><span class="comment"> * thread-local variable.  If the variable has no value for the</span></span><br><span class="line"><span class="comment"> * current thread, it is first initialized to the value returned</span></span><br><span class="line"><span class="comment"> * by an invocation of the &#123;<span class="doctag">@link</span> #initialValue&#125; method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the current thread's value of this thread-local</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> (T)e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本过程：<br>1.获取当前线程的ThreadLocalMap对象threadLocals<br>2.从map中获取线程存储的K-V Entry节点。<br>3.从Entry节点获取存储的Value副本值返回。<br>4.map为空的话返回初始值null，即线程变量副本为null，在使用时需要注意判断NullPointerException。</p><blockquote><p><strong>public void set(T value)</strong></p></blockquote><p>Sets the current thread’s copy of this thread-local variable to the specified value. Most subclasses will have no need to override this method, relying solely on the initialValue() method to set the values of thread-locals.</p><blockquote></blockquote><p><strong>Parameters:</strong><br>    value - the value to be stored in the current thread’s copy of this thread-local.</p><p>set()方法用于保存当前线程的副本变量值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the current thread's copy of this thread-local variable</span></span><br><span class="line"><span class="comment"> * to the specified value.  Most subclasses will have no need to</span></span><br><span class="line"><span class="comment"> * override this method, relying solely on the &#123;<span class="doctag">@link</span> #initialValue&#125;</span></span><br><span class="line"><span class="comment"> * method to set the values of thread-locals.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to be stored in the current thread's copy of</span></span><br><span class="line"><span class="comment"> *        this thread-local.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>remove</strong></p></blockquote><blockquote><p>public void remove()</p></blockquote><p>  Removes the current thread’s value for this thread-local variable. If this thread-local variable is subsequently read by the current thread, its value will be reinitialized by invoking its initialValue() method, unless its value is set by the current thread in the interim. This may result in multiple invocations of the initialValue method in the current thread.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the current thread's value for this thread-local</span></span><br><span class="line"><span class="comment"> * variable.  If this thread-local variable is subsequently</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@linkplain</span> #get read&#125; by the current thread, its value will be</span></span><br><span class="line"><span class="comment"> * reinitialized by invoking its &#123;<span class="doctag">@link</span> #initialValue&#125; method,</span></span><br><span class="line"><span class="comment"> * unless its value is &#123;<span class="doctag">@linkplain</span> #set set&#125; by the current thread</span></span><br><span class="line"><span class="comment"> * in the interim.  This may result in multiple invocations of the</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;initialValue&lt;/tt&gt; method in the current thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line"> <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">     m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadLocalMap的问题"><a href="#ThreadLocalMap的问题" class="headerlink" title="ThreadLocalMap的问题"></a>ThreadLocalMap的问题</h2><p>ThreadLocalMap是ThreadLocal的内部类，没有实现Map接口，用独立的方式实现了Map的功能，其内部的Entry也独立实现。</p><p><img src="/upload/pasted-283.png" alt="upload successful"><br>由于ThreadLocalMap的key是弱引用，而Value是强引用。这就导致了一个问题，ThreadLocal在没有外部对象强引用时，发生GC时弱引用Key会被回收，而Value不会回收，如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露</p><p>避免：<br>既然Key是弱引用，那么我们要做的事，就是在调用ThreadLocal的get()、set()方法时完成后再调用remove方法，将Entry节点和Map的引用关系移除，这样整个Entry对象在GC Roots分析后就变成不可达了，下次GC的时候就可以被回收。<br>如果使用ThreadLocal的set方法之后，没有显示的调用remove方法，就有可能发生内存泄露，所以养成良好的编程习惯十分重要，使用完ThreadLocal之后，记得调用remove方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;Session&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;Session&gt;();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    threadLocal.set(<span class="keyword">new</span> Session(<span class="number">1</span>, <span class="string">"Misout的博客"</span>));</span><br><span class="line">    <span class="comment">// 其它业务逻辑</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    threadLocal.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>数据库连接：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder = <span class="keyword">new</span> ThreadLocal&lt;Connection&gt;() &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">initialValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(DB_URL);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> connectionHolder.get();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Session:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal threadSession = <span class="keyword">new</span> ThreadLocal();  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getSession</span><span class="params">()</span> <span class="keyword">throws</span> InfrastructureException </span>&#123;  </span><br><span class="line">    Session s = (Session) threadSession.get();  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            s = getSessionFactory().openSession();  </span><br><span class="line">            threadSession.set(s);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (HibernateException ex) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InfrastructureException(ex);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> s;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本理解&quot;&gt;&lt;a href=&quot;#基本理解&quot; class=&quot;headerlink&quot; title=&quot;基本理解&quot;&gt;&lt;/a&gt;基本理解&lt;/h1&gt;&lt;p&gt;ThreadLocal是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>确保挂起设计模式（Guarded Suspension）</title>
    <link href="https://www.junglezero.top/2019/04/18/%E6%8C%82%E8%B5%B7%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88Guarded-Suspension-%EF%BC%89/"/>
    <id>https://www.junglezero.top/2019/04/18/挂起设计模式（Guarded-Suspension-）/</id>
    <published>2019-04-18T01:41:00.000Z</published>
    <updated>2019-04-18T02:24:22.470Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本含义"><a href="#基本含义" class="headerlink" title="基本含义"></a>基本含义</h1><p>Guarded Suspension意为保护暂停，其核心思想是仅当服务进程准备好时，才提供服务。设想一种场景，服务器可能会在很短时间内承受大量的客户端请求，客户端请求的数量可能超过服务器本身的即时处理能力，而服务端程序又不能丢弃任何一个客户请求。此时，最佳的处理方案莫过于让客户端要求进行排队，由服务端程序一个接一个处理。这样，既保证了所有的客户端请求均不丢失，同时也避免了服务器由于同时处理太多的请求而崩溃</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>request类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代表可能会有很多的请求类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Request</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>请求队列：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求等待队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Request&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得等待队列的一个request，当没有request时，线程进行等待</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Request <span class="title">getRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Request request = queue.removeFirst();</span><br><span class="line">            <span class="keyword">return</span> request;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在队列中加入新的请求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">            queue.addLast(request);</span><br><span class="line">            <span class="comment">//唤醒等待线程</span></span><br><span class="line">            queue.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端线程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RequestQueue queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Random random;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String sendValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClientThread</span><span class="params">(RequestQueue queue, String sendValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">        <span class="keyword">this</span>.sendValue = sendValue;</span><br><span class="line">        random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//假设是10条请求</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Client -&gt; request "</span> + sendValue);</span><br><span class="line">            queue.putRequest(<span class="keyword">new</span> Request(sendValue));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//模拟花费时间</span></span><br><span class="line">                Thread.sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>服务端线程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RequestQueue queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Random random;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerThread</span><span class="params">(RequestQueue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">        random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!closed) &#123;</span><br><span class="line">            Request request = queue.getRequest();</span><br><span class="line">            <span class="comment">//当请求为空时，跳出本次循环</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == request) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Received the empty request."</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Server -&gt;"</span> + request.getValue());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">//中断时，跳出run方法</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.closed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试线程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuspensionClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> RequestQueue queue = <span class="keyword">new</span> RequestQueue();</span><br><span class="line">        <span class="keyword">new</span> ClientThread(queue, <span class="string">"Alex"</span>).start();</span><br><span class="line">        ServerThread serverThread = <span class="keyword">new</span> ServerThread(queue);</span><br><span class="line">        serverThread.start();</span><br><span class="line">        <span class="comment">//serverThread.join();</span></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        serverThread.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Client -&gt; request Alex</span><br><span class="line">Server -&gt;Alex</span><br><span class="line">Client -&gt; request Alex</span><br><span class="line">Server -&gt;Alex</span><br><span class="line">Client -&gt; request Alex</span><br><span class="line">Server -&gt;Alex</span><br><span class="line">Client -&gt; request Alex</span><br><span class="line">Server -&gt;Alex</span><br><span class="line">Client -&gt; request Alex</span><br><span class="line">Server -&gt;Alex</span><br><span class="line">Client -&gt; request Alex</span><br><span class="line">Server -&gt;Alex</span><br><span class="line">Client -&gt; request Alex</span><br><span class="line">Server -&gt;Alex</span><br><span class="line">Client -&gt; request Alex</span><br><span class="line">Server -&gt;Alex</span><br><span class="line">Client -&gt; request Alex</span><br><span class="line">Server -&gt;Alex</span><br><span class="line">Client -&gt; request Alex</span><br><span class="line">Server -&gt;Alex</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本含义&quot;&gt;&lt;a href=&quot;#基本含义&quot; class=&quot;headerlink&quot; title=&quot;基本含义&quot;&gt;&lt;/a&gt;基本含义&lt;/h1&gt;&lt;p&gt;Guarded Suspension意为保护暂停，其核心思想是仅当服务进程准备好时，才提供服务。设想一种场景，服务器可能会在
      
    
    </summary>
    
      <category term="java多线程学习" scheme="https://www.junglezero.top/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="java多线程" scheme="https://www.junglezero.top/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程future设计模式</title>
    <link href="https://www.junglezero.top/2019/04/17/%E7%A8%8Bfuture%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.junglezero.top/2019/04/17/程future设计模式/</id>
    <published>2019-04-17T02:49:00.000Z</published>
    <updated>2019-04-17T07:56:23.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>future设计模式实际上相当一个异步完成任务充分利用本应当的等待时间，有点类似于商品订单。比如在网购时，当看中某一件商品时就可以提交订单，当订单处理完成后，在家里等待商品送货上门即可。或者说更形象的我们发送Ajax请求时，页面是异步进行后台处理，用户无需一直等待请求结果，可以继续浏览或操作其他内容<br>类似于下面的一个商品订单的时序图</p><p><img src="/upload/pasted-280.png" alt="upload successful"><br>客户端发送一个长时间的请求，服务端不需等待该数据处理完成便立即返回一个伪造的代理数据（相当于商品订单，不是商品本身），用户也无需等待，先去执行其他的若干操作后，再去调用服务器已经完成组装的真实数据。该模型充分利用了等待的时间片段。</p><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p><img src="/upload/pasted-281.png" alt="upload successful"><br>Main：启动系统，调用Client发出请求；</p><p>Client：返回Data对象，理解返回FutureData，并开启ClientThread线程装配RealData；</p><p>Data：返回数据的接口；</p><p>FutureData：Future数据，构造很快，但是是一个虚拟的数据，需要装配RealData；</p><p>RealData：真实数据，构造比较慢。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>具体实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Client client = <span class="keyword">new</span> Client();</span><br><span class="line"><span class="comment">//理解返回一个FutureData</span></span><br><span class="line">Data data = client.request(<span class="string">"name"</span>);</span><br><span class="line">System.out.println(<span class="string">"请求完毕！"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理其他业务</span></span><br><span class="line"><span class="comment">//这个过程中，真是数据RealData组装完成，重复利用等待时间</span></span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真实数据</span></span><br><span class="line">System.out.println(<span class="string">"数据 = "</span>+ data.getResult());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>client:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Data <span class="title">request</span><span class="params">(<span class="keyword">final</span> String queryStr)</span></span>&#123;</span><br><span class="line"><span class="keyword">final</span> FutureData future = <span class="keyword">new</span> FutureData();</span><br><span class="line"><span class="comment">//开启一个新的线程来构造真实数据</span></span><br><span class="line"><span class="keyword">new</span> Thread()&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">RealData realData = <span class="keyword">new</span> RealData(queryStr);</span><br><span class="line">future.setRealData(realData);&#125;</span><br><span class="line">&#125;.start();</span><br><span class="line"><span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Data:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span>  String <span class="title">getResult</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>FutureData<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是对RealData的一个包装</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> limin</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureData</span> <span class="keyword">implements</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span> RealData realData =<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> isReady = <span class="keyword">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setRealData</span><span class="params">(RealData realData)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(isReady)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.realData=realData;</span><br><span class="line">isReady=<span class="keyword">true</span>;</span><br><span class="line">notifyAll();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">synchronized</span>  String <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(!isReady)&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">wait();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> realData.result;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>RealData:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealData</span> <span class="keyword">implements</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line"><span class="keyword">protected</span>  String  result;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RealData</span><span class="params">(String para)</span></span>&#123;</span><br><span class="line"> <span class="comment">//构造比较慢</span></span><br><span class="line">StringBuffer sb= <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">sb.append(para);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">result= sb.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;future设计模式实际上相当一个异步完成任务充分利用本应当的等待时间，有点类似于商品订单。比如在网购时，当看中某一件商品时
      
    
    </summary>
    
      <category term="java多线程学习" scheme="https://www.junglezero.top/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="java多线程" scheme="https://www.junglezero.top/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>绘卷水浒传 20周年企划 第六章 翻译</title>
    <link href="https://www.junglezero.top/2019/04/16/%E7%BB%98%E5%8D%B7%E6%B0%B4%E6%B5%92%E4%BC%A0-20%E5%91%A8%E5%B9%B4%E4%BC%81%E5%88%92-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E7%BF%BB%E8%AF%91/"/>
    <id>https://www.junglezero.top/2019/04/16/绘卷水浒传-20周年企划-第六章-翻译/</id>
    <published>2019-04-16T13:47:00.000Z</published>
    <updated>2019-04-26T03:56:17.479Z</updated>
    
    <content type="html"><![CDATA[<hr><p><font color="#FF0000">原文作者 森下翠和插画作者 正子公也 版权所有<br><br>个人翻译<br><br>仅供个人娱乐及同好者欣赏<br></font><br><br><br><a href="http://suikoden.com/" target="_blank" rel="noopener">原文地址</a></p><hr><h1 id="第六章-月下天堂"><a href="#第六章-月下天堂" class="headerlink" title="第六章 月下天堂"></a>第六章 月下天堂</h1><p>史进眺望着对面激扬而起的水花<br>手持长枪，稳稳的站着，这长枪，来自于死在逃亡路上的武器贩子“乌鸦嘴”，这些买卖人到生命的尽头都带着自己兜售的商品<br>史进感觉到了阵阵凉风<br>身旁站着的是金山大师和鲁智深<br>史进回头看了看背后的石窟，然后继续观察着对岸的走向<br>突然跃动起来，背上的龙，呼之欲出<br>（时候未到）<br>史进舔了舔干燥的嘴唇<br>现在，即使是这种等待，也是战斗</p><p>这个时候，石秀却潜伏在对岸<br>黎明之前，他在伊水上游渡河，绕过南岸的岩山<br>这是由石秀，李忠，陈达，杨春以及众亲近弟兄组成的敢死队，总计一百多人，他们留下了在正面战场的史进和鲁智深，只带了善于奇袭的梁山弟兄<br>杨春从岩石后面探出身子，窥视着北面<br>“一半的敌军正在渡河，另一半都在岸边待命”<br>石秀点了点头<br>“剩下的，正是守护林灵素的道士军，共计一万五千人”<br>官军打算躺过伊水，一口气消灭僧众，他们依仗人数上的优势，现在正全神贯注的集中在北岸<br>就趁着这个机会，奇袭敌后<br>因而留在北岸的史进众人也没发起攻击，正在等着恰到好处的机会<br>石秀他们的目标正是官军的统帅——“通真达灵元妙先生”林灵素<br>林灵素才是掀起这场法难的元凶，只要杀掉他，剩下的道士就会做鸟兽散<br>（皇帝也会清醒过来吧，即使没有，杀掉他也是大快人心）<br>昨晚王定六等人已经侦察到了敌人的本阵的帅旗是巨大的“太极旗”，石秀等人确认的在朝霞中飘展的太极旗后，就缓缓的下了岩山<br>他们沿着路一点点的向下，已经看不见敌人的大军了，在岩山脚下，依然徘徊者清晨的气息，石秀等人止住气息，慎重的前行着，依据太阳掌握着大致的方向<br>周围都是岩石和树林，地形错综复杂，穿过这里，不久就会到达本阵，实际上，已经可以感觉到从雾霭的另一端大军的气息<br>但是，不管怎么走，都看不见那太极旗，也无法接近敌军阵地<br>李忠注意到<br>“这地上的脚印可不是官军的，是哪里来的啊”<br>众人自己的脚比划了比划<br>“这不是我们自己的吗？”<br>“还真是”<br>陈达叫了一声<br>“迷路了，不，不对”<br>陈达和杨春认同的点了点头<br>“这是幻术”</p><p><img src="http://10.28.0.10/cache/10/04/suikoden.com/d149518e96e2253cfea93f01e3af74e6/108%20Outlaws-133.jpg" alt="陈达和杨春"><br>石秀并不认同<br>“林灵素就是个徒有虚名的玩意”<br>“话是这么说，事不是这个事啊”<br>陈达郁闷的摸了摸被露水沾湿的络腮胡子，看着周围的杂树林<br>陈达和杨春是“神机军师”朱武的兄弟，朱武擅长布阵，不管是八卦阵还是摩诃兵法，都很精通，当年兄弟几人也和史进在芒砀山和“混世魔王”樊瑞战斗过<br>“这周遭就是当时那股子气息”<br>石秀沉默了，石秀也曾在梁山泊的芦苇荡迷瞪过，当年三打祝家庄时，也勿入了迷宫<br>“他妈的，怎么就这么倒霉”<br>石秀看着地上的纷乱的脚印<br>“史进众兄弟还在等着我们的奇袭”<br>抬头望望天，却被郁郁葱葱的树林遮住了，连太阳也看不见了</p><hr><p>金山大师正在北岸，面对着渡河而来的洛阳军<br>身上法衣已经血迹斑斑，也被刀刃划拨，在风中丝丝缕缕的飘荡着<br>鲁智深脱了光膀。杵着禅杖<br>两位大师站在反射着朝阳的河岸边上<br>鲁智深健壮的脊梁上，正闪耀着一朵盛开的红牡丹，金山大师察觉到了，一手握着般若雷，一手向着那朵牡丹行礼<br>“‘一切众生皆有佛性’——佛在人心”</p><p>鲁智深的禅杖激起一朵巨大的水花<br>战斗已经开始了<br><img src="http://10.28.0.10/cache/12/04/suikoden.com/fd8e6db1a0b60ff46e69fe7e4c755ee9/108%20Outlaws-134.jpg" alt="2"><br>禅杖挥向了冲在前面的官军，毫不费力的将他们打翻在水中，丐帮的众人也怪叫着冲向前去，他们的武器各式各样，有棍子，有斧头，有农具，有扁担，还有不知在哪里捡到了的破败的兵器，虽然他们很瘦弱，但是手脚的力量也不可小觑，这凶猛的气势好像发狂的野狗一般<br>南北少林的武僧们正用精湛的拳法毫不留情的打倒眼前的官军，失去了“白光尊师”的护国禅僧们还有八人幸存，每当他们手持禅杖跃动时，便会有数十敌人应声而倒<br>两军曾在少林寺交过手，最终结果是率领洛阳军的宇文将军战死，半数的士兵失去战斗力，因而正都指挥使出征，然而此时他正在林灵素的本阵待命，实际的指挥则是手下的部将们<br>莫志正专心的射箭，可以说百发百中，毫无例外的穿过敌人的喉咙<br>（人和鸟没什么区别）<br>莫志一支一支的搭着箭，只是轻轻一瞄就出手了，轻快的弓弦音震动着耳膜，莫志不知不觉嘴角露出笑意<br>伊水已经一片血红，横尸遍野<br>岸边的佛像仁慈的微笑着，俯视着一片鲜红的战场<br>鲁智深背对着佛的微笑，在人群中厮杀着<br>人生在世，本是奇迹般的偶然重叠而生<br>“尽管如此，可死起来却这么的容易”<br>鲁智深砍翻眼前的敌人，大喊一声<br>“南无、阿弥陀佛！”</p><p>史进等人坚守在岸边，迎击着渡河而来的官军，背后的岩洞中是负伤者和诵经的僧尼<br>史进面前，有源源不断的官军涌来，枪出，弯折，猛跃，敌倒。史进的耳畔，只有自己的心跳和呼吸的声音<br>敌人众多，把史进团团围住，史进的枪已经断了<br>史进拾起已经倒下的少林武僧的棒子，继续战斗着，折断之后，就又用脚尖挑起一根，从来没有停下来<br>“石秀那边什么情况”<br>敌人还在一个劲的增加着<br>“奇袭还没开始吗？”<br>本想看看对岸的情况，却被袭击而来的敌人打断了<br>敌人包围史进，从四面八方出枪，史进闪身躲了过去，敌人又从身后砍过来，王定六的匕首，又在背后暗杀了袭击的敌人<br>“看来是赶不上了”<br>匕首闪闪发光，杀死了一个又一个敌人，无论倒下多少，都没有到头<br>洛阳军已经上岸了，禁军也正在赶过来，已经看不见河水了，放眼望去，全是敌军<br>王定六观察着这场战斗的去向，身上肩负着回报梁山泊的任务，但是，他也早已把生死抛在了脑后</p><p>官军正在陆陆续续的上岸<br>兵法云“半渡而击之”，可是，因为一直在等着石秀等人发起的奇袭，已经错过了出击的最好机会。已经让不少人上了岸。史进等人正在被逼后退，身后就是石窟，后面是陡峭的岩山，他们已经没有退路了，藏在石窟中的伤员和尼姑拼了命的投掷他们能拿到手的东西，不管是贡品台，还是破败的佛像的头，一道道弧线在空中划过，念经声响彻天地<br>白马寺的高僧们围着圣典《四十二章经》，一心求着佛的救赎，官军不知何时放出火矢，燃起了熊熊烈火，不小心也点燃了佛教传入这个国度最初的经典，顷刻间化为灰烬<br>僧侣们悲叹起来<br>“这就是末世吗？”<br>在这最后时刻，众僧尼已经做好了死的觉悟，但是，金山大师并没有放弃生的希望，舞动的般若雷，正是他的意志。旁边的鲁智深挥舞着禅杖，虽然被团团围住，但是他没在后退，脚就如定在地上一般<br>鲁智深等人站在最前面，承受着大军压境的巨大压力<br>龙门石窟旁卷起惊涛骇浪<br>“禁军已经上岸了！”<br>继先锋五千的洛阳军，一万名禁军登录伊水北岸<br>在对岸，还有一万五千道士军待命<br>莫志为了寻找退路而仰望着山顶，如果有机会爬上山的话大概还有机会逃命，就在这个时候，他好像看到了什么<br>悬崖上出现了“宋”的旗帜<br>“这里还有敌军出现吗？”<br>甚至伊水下游袭来的船队，也打着“宋”的旗帜<br>“敌人的援军！”<br>这回莫志彻底的绝望了，如果是官军的援军到了，那毫无疑问是节度使“药师”徐京和“老风流”王焕的军队——那些节度使终于响应了出征的命令<br>莫志慌了神，赶忙找到作为最后希望支柱的金山大师<br>金山大师沉吟不语，般若雷掷地有声<br>身后的巨大的卢遮那佛，仍然保持着慈悲的微笑<br>（大概就要终结了吧）<br>莫志仰望着卢遮那佛<br>打破不杀生戒的自己，是会得到宽恕还是最终会堕入地狱的轮回，那样的话，金山大师和天穹和尚都一样的<br>最终一起堕入地狱<br>莫志只求一死，手中握着最后一支箭，把箭头抵在脖子上，莫志看了看史进，又看向了鲁智深<br>（都要下地狱了，那个和尚怎么还在笑）<br>鲁智深兴高采烈的战斗着，血的殷红，背上牡丹的鲜红，健壮的肌肉闪耀着耀眼的光芒。他发出响彻四方的呐喊<br>“定能取胜！都爬起来，爬起来打倒他们！！”<br>本打算一死了事的莫志停了下来，一幅震惊的画面映入本要放弃的眼睛中<br>（那是流星吗——）<br><img src="http://10.28.0.10/cache/11/04/suikoden.com/9933f36c14c4de49cb87ecc5b5cb51c0/108%20Outlaws-135.jpg" alt="feijian"><br>苍穹之中，看到了五道闪耀的光芒，他马上意识到那是箭，这五支从天而来的箭，在空中画出五道美丽的银线，五名官兵中箭而倒<br>莫志发现那是从下游杀入的船队射过来的，一个壮年武者精神抖擞的站在船头。秀丽的身姿，华丽的甲胄，还有那手中朱红色的弓<br>（那是！）<br><img src="http://10.28.0.10/cache/2/04/suikoden.com/e7dec8aea56ec6a6b0232e1734330c39/108%20Outlaws-136.jpg" alt="huarong"><br>梁山泊席位第九，绰号“小李广”，正是花荣，爱弓朱雁的弦正在清吟着，花荣再次放箭，又有五个官军倒下。下游的船队一个个的靠岸了，上来的“宋军”，袭击了到达北岸的禁军，冲在最前面的是挥舞着双板斧的黑大汉<br><img src="http://10.28.0.10/cache/5/04/suikoden.com/0bd826d5518146cc56cf2d56f8976dcf/108%20Outlaws-137.jpg" alt="likui"><br>“黑旋风”李逵，梁山泊席位第二十二，是专为杀人而生的天杀之星<br>山上下来的“宋军”也向北岸的洛阳军发起攻击<br>“冲上去！”<br><img src="http://10.28.0.10/cache/7/04/suikoden.com/d30bc494ac015c39b25092476a6db865/108%20Outlaws-138.jpg" alt="wusong"><br>从山上打着“宋”的旗号新加入战场的军队，领头的是“行者”武松，他正是江湖上赫赫有名的在景阳冈打虎的壮士，接下来是清风山的头领，“锦毛虎”燕顺，以及“打虎将”李忠的结拜兄弟，桃花山上的好汉“小霸王”周通，他们向着正在袭击手无寸铁的僧尼的洛阳军发起了冲锋<br>驾船而来的，正是“立地太岁”阮小二，“玉幡竿”孟康，光着膀子的汉子们陆续从船上下来，船头，作为“向导”的“鼓上蚤”时迁挥着胳膊，给同伴发出信号<br>“赶上了！！”<br>原来这些打着“宋”的旗号的军队，正是在山东秘密集结的梁山泊军<br>岩山上也出现了旗帜<br>石窟东面的岩山上，出现了一支骑兵队，一个禁军军官举着剑<br><img src="http://10.28.0.10/cache/6/04/suikoden.com/1874bd111eb51e219230c68cc65cf2c2/108%20Outlaws-139.jpg" alt="yangzhi1"><br>官军的援军——可是鲁智深却制止了打算迎击的武僧们<br>“等一下”<br>鲁智深很熟悉那张脸，覆盖半张脸的青斑是不可能弄错的——“青面兽”杨志<br><img src="http://10.28.0.10/cache/3/04/suikoden.com/6df497cbd875a186fc0efe8774f64b01/108%20Outlaws-140.jpg" alt="yangzhi2"><br>梁山泊席次第十七，正是传说的英雄“杨无敌”杨令公的子孙，手持家传宝剑吹毛剑的无双剑客<br>杨志展现着当年那个“杨制使”的身姿，身边率领的军队脱下官军的伪装<br>而右边站着的，是“金枪手”徐宁<br><img src="http://10.28.0.10/cache/9/04/suikoden.com/6c0b21ed94fa719b6f21e936050f7e8b/108%20Outlaws-141.jpg" alt="xuning"><br>梁山泊席次第十八，本是禁军中金枪班的教头，是钩镰枪的传承者，身着祖传宝铠“賽唐猊”的英豪<br>左边的是梁山泊席位第十五的“风流双枪将”董平，背后挂着书写着“英雄双枪将”，“无双万户侯”的旗子，手持着标志性的双枪<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-142.jpg" alt="dongping"><br>他是一个自负文武双全的英俊<br>二人华丽的甲胄，正在战场上闪耀着<br>他们分散着离开梁山泊，向西行进，途中从官军那里夺走伪装，根据“智多星”吴用料事如神的智谋，又有两山泊完整的情报网，“梁山泊军”就在这个恰当的时候出现了<br>狼藉的战场上空，一只乌鸦正在空中盘旋，“锦豹子”杨林把分散出动的梁山泊同伴们引导到此<br>“看来重要角色已经到齐了，那么好戏就此开场了”</p><p>梁山泊的骑兵从山上冲刺而下<br>这个时候，史进也觉察到了战场上形势的变化<br>“那边，卢员外也到了吗？”<br>殿军的将领，正是坐第二把交椅的“玉麒麟”卢俊义，曾经是大名府的富豪，也被人称作“河北三绝”，本身也是武艺高强，养子“浪子”燕青，正拉着马嘴<br>卢俊义抬头看着由侯健缝制的“宋”的蓝旗<br>本来，宋军的旗帜为红色，相传宋国的本命颜色便是红<br>这里的“宋”指代的是梁山泊头领“及时雨”宋江的“宋”<br>那是比蓝天还有蓝的旗帜<br>“很不巧宋江大哥很忙，准备上吧，燕青！”<br><img src="http://10.28.0.10/cache/8/04/suikoden.com/29c2f72158b1ac58e62f704c8299febe/108%20Outlaws-143.jpg" alt="lujunyi"><br>“交给我吧”<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-144.jpg" alt="yanqing"><br>燕青扛着旗子从山上跑下来</p><hr><p>这个时候，石秀感到视野一片模糊，眼前一片重重叠叠的景象<br>“能看见路了！”<br>如同阳光照在阴暗处一般，道路出现在密集的丛林当中<br>“可以继续前进了”<br>石秀跑了起来，他早已经听见了战场的喧嚣声，心急如焚<br>“等一下”<br>李忠想要阻止他<br>“这是幻想吧”<br>“那也顾不上了！”<br>陈达追着石秀，石秀就在一片晃动的视野中狂奔着<br>突然，眼前出现了几个黑衣道士，众人都手持铜剑<br>“敌人！”<br>石秀挥手就要砍，道士也开始迎击，顿时火花迸溅，视野突然一片晃动，听见了一个老者的声音<br>“你看错了，我们不是敌人”<br>石秀停了下来，道士们也四下散开<br>“看破！”<br>道士们跳向树梢，用剑尖刺穿了贴在树干上的咒符。这是用血写的咒符。一个白胡子老者出现在一脸茫然的石秀众人面前<br>“结界削弱了……这都是幻术，你们不要惊慌了”<br>石秀盯着老者<br>“你是哪里来的？”<br>“贫道来自华山”<br>华山是河南道教的最高峰，他们是山里的无醉长老以及被唤作“华山十子”的众弟子，他们因憎恨林灵素的恶行，特地赶到这里支援<br>无醉长老高举着拂尘，挥去了头上的虚空<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-145.jpg" alt="wuzuizhanglao"><br>只见无数燃烧的符咒纷纷落地，突然间，视野犹如被清洗过一般明亮起来，森林终于有了尽头，道路展开了，远处，可以看见林灵素的太极旗在飘扬<br>石秀情不自禁的笑了<br>“你们也是道士吧？”<br>“‘德不孤，必有邻’——这是儒教的一句话，‘正义’无门”<br>“这样的话就不和你客气了”<br>就这样，石秀等人穿过丛林，向着道士军的背后发起奇袭，林灵素的本阵，被一万五千道士军团守护着，这些人基本都是武者和军人出身的野心家，为了投机，投身于道教<br>他们也发现了北岸事态的变化，但是并没有动摇，只要保护好林灵素，即使洛阳军，禁军全灭，取胜也没什么问题<br>“敌袭，保护‘通真达灵元妙先生’！”<br>金甲道士们迎击石秀众人而上，走在前面的是一个军人出身的壮汉，他出身于军中，手持大刀，看了看石秀众人<br>“就这么些人吗？一口气消灭掉吧”<br>石秀咂了咂舌，本来他们的目标是以少量兵力引起敌方本阵的混乱，然后趁机偷袭林灵素，现在可倒好，周围都很明朗，石秀等人光天化日之下，实力被看的一清二楚<br>为首的壮汉嚎叫着挥着大刀发出进攻，然而，他正在叫唤的头猛的飞在空中<br>石秀一惊，紧接着冷笑起来<br>将此人斩首的是一个面呈菜色的独臂男子<br>梁山泊席位第三十二——石秀的义兄，薊州的“砍头杨雄”，正是“病关索”杨雄<br>“让你久等了，石秀”<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-146.jpg" alt="yangxiong"><br>“我可是一直在等着啊”<br>杨雄和石秀并肩杀入道士中<br>道士们突然乱了起来，这些自称“六甲神兵”的一万五千道士，基本都是“临时道士”，一看对面攻势凶猛，根本就没想过作战，他们不过是借此机会接近林灵素<br>道士们一哄而散，众人也不知道是什么情况，只是感觉一片混乱，觉得被大军奇袭了后方，石秀杨雄等人奋勇作战，再加上华山道士们的支持<br>“这是大军的奇袭！”<br>“我们中出了叛徒！”<br>官军动摇的情况，也传到了北岸作战的金山大师和史进那里<br>金山大师向着陷入迷茫的众僧人大喝一声<br>“勿失战机！”<br>大师鼓舞着众人，进行反击，般若雷轰鸣着，向敌人迈出一步<br>可那一步却未能迈出，有人从背后刺了一剑，“张神剑”大叫起来<br>“是那个混蛋”<br>叛徒满天星混入了信徒当中<br>“赶快把《精武大宝经典》给我交出来”<br>金山大师踢向背后，可是满天星却犹如妖狐一般闪身到了金山大师身前<br>“《精武大宝经典》到手了！！”<br>满天星抓着法衣的领子，正准备砍向金山大师，可他的刀，却被一根棒子止住<br>“我‘九纹龙’当你的对手”<br>“你打不过我的”<br>史进飞快的旋转棒子，向满天星发起攻击，这边满天星也不示弱，挥刀向着史进正面砍去，史进避开了满天星的大刀，向后纵身，虽然紧紧握着棒子，但是由于满天星的大刀挡着，无法发起攻击<br>“你赢不了的！”<br>满天星又使出一层力，突然间，一阵风起，满天星停了下来<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-147.jpg" alt="shijin2"><br>“夕照流星”——史进的棒子贯穿了满天星的胸口<br>就这样，满天星倒在了金山大师脚旁<br>大师从倒下的满天星手中拿走一卷古老的经典<br>“你了解这个吗？”<br>“这是武林宝典……上面写了制霸天下的秘籍？”<br>“正是”<br>大师把秘经按在额头上<br>“这是在敦煌沙漠中发觉的天竺经典，是磨砺灵魂 ，锻炼身体，提升悟性的宝典——那个时候武人还是一无是处”<br>满天星在地上微微呻吟，大师语速平缓，继续说道<br>“无明无尽——没有武力高下，岂有强弱之分？你这么想看，就给你看看吧”<br>“那些最终断绝消息的武者？”<br>“他们最终都选择了落发为僧”<br>满天星用空洞的目光望着史进<br>“梁山泊的‘九纹龙’……受教了，亦无遗憾”<br>金山大师合上了已经断气的年轻人的眼，沉吟道<br>“这世上还没有能领悟《精武大宝藏经》的人啊”<br>般若雷从大师手中脱落，脚下已经鲜血如柱。</p><p>战斗还在继续着<br>史进抓起一匹马，跳上马背，向着伊水河奔去<br>“林灵素现在何处？”<br>踏着水花跃上南岸，就可以看见林灵素的本营，已经受到了石秀等人的袭击，太极旗已经倾斜，可以看见众官军将领正在守着两个道士，一个身着潇洒的道服，另一个头上裹着布<br>史进朝着道士看去<br>“那是林灵素！”<br>就在这时，怪道士从衣服下面投出弯刀，史进躲开弯刀，向着林灵素砍去<br>听到了石秀的声音<br>“史进，注意后面！”<br>可是为时已晚，本来飞出去的弯刀，又折返回来，已经可以感受到刀锋的迫近，却又无法防御，就在史进马上就要被割断喉咙的时候，不知从哪里飞来一只棒子，敲到了弯刀<br>史进看见了那根飞来的棒子<br>（师父！）<br>可是，四下里敌我混杂，找不到那个身影</p><p>太极旗轰然折断<br>林灵素慌乱的叫了起来<br>“这些是什么人，现在什么情况？”<br>只见一个黑大汉双手持板斧，犹如暴风雨一般迫近，林灵素胸中燃起了无名的怒火<br>（这些贱种，又怎么能杀了我！）<br>林灵素手抓着背后安坐在莲花座的怪道士<br>“想些办法吧！！”<br>林灵素双手抓住怪道士的头<br>“把他们杀掉！”<br>在说出这句话的同时，不知哪里来的强大邪恶力量，从林灵素的口中流入体内，一股漆黑的力量萦绕着林灵素的身体，禁锢着灵魂，阻断了自由<br>林灵素呆住了，感受到了某种“存在”，怪道士正充斥着他的身体<br>（你——）<br>林灵素自称道士，但是他深知所谓法术不过是障眼法，但是此时此刻他清楚的感觉到了自己已经成了那个法力的奴隶<br>林灵素头顶生出一道青烟，天空中出现了一个巨大神灵的身影，只见他身着蓝衣，双眸闪烁着群青色的光芒。那是冷酷的杀戮之光。手上握着触天长冰杖，风雪呼啸。道士们胆战心惊地叫出了那个名字。<br>“青华帝君！”<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-148.jpg" alt="qinghuadijun"><br>是拥有无穷神力的万能之神，只要遵循，就无所畏惧<br>只见他默默抬起双眼，那个神的面孔，正是“通真达灵元妙先生”林灵素，身边的六甲神兵突然放出光芒，本来在战场节节败退的他们，突然发起了猛攻<br>而这背后真正的支配者，正站在“青华帝君”的头上，怪道士——“金华魔人”包道乙——终于显现出真正的力量<br><img src="http://10.28.0.10/cache/13/04/suikoden.com/03e886f278bb8b76e6feea2533f6b1f6/108%20Outlaws-149.jpg" alt="baodaoyi"><br>“你不是想成为神吗，那就把身体献给‘力量’吧”</p><hr><p>僧侣们纷纷抛下武器，伏在地上<br>战斗中的僧侣知道自己距离地狱的轮回已经不远了<br>终于来“迎接”他们了<br>不是乘着七彩云彩而来的菩萨，而是踏着火焰的恶鬼<br>“佛法将尽，世界将末”<br>随着“青华帝君”的出现，六甲神兵的大军也渡过伊水<br>他们目睹着卢遮那佛在烈火中燃烧，身体已经崩坏，僧侣们四下奔逃，诵经声已经变成了悲鸣，僧侣们已经走到临头<br>“大师啊，救救我们吧”<br>金山大师是众人最后的希望，用法力和武术来阻止这个恶魔神吧<br>年轻的见习僧人莫志也默念着经文，手中握着弓箭，母亲的希冀，龙门大禅师的教诲都在心中，可是，眼前的生命却无法挽回<br>救济众生的弥勒佛降世，那已经是五十六亿七千万年后的事了<br>【《菩萨处胎经》：“弥勒当知，汝复受记，五十六亿七千万岁于此树王下成无上等正觉。”】<br>莫志咬紧牙关，瞄准“青华帝君”的眼，放了一箭，不过，他只是张了张嘴，箭就像树叶一样被吞没了<br>护卫伤者的“张神剑”，已经被人砍断了腿倒下了<br>“青华帝君”拄着拐杖，向卢遮那佛前进。<br>就在这时，金山大师站了出来，挡在前面<br>“退下，天魔”<br>没有兵器，没有扈从，只是张开手掌，伸出双手<br>“青华帝君”的手杖刺进了他的胸膛<br>史进感觉周围突然变的一片昏暗，鲁智深看着天空，噼里啪啦的迸发出火花<br>一瞬间，所有人的呼吸都止住了<br>所有人所发出的情感——恐惧，已经到了极点<br>突然一个大爆炸，雷声轰鸣<br>什么也听不见了<br>那是覆天盖地，前所未有的轰鸣</p><hr><p>雷鸣撼动了天空<br>林灵素的意识，被包道乙支配着，只知道自己化身“青华帝君”，正向着金山大师发起攻击，不知是谁喊了一句<br>“林灵素杀死了金山大师！”<br>林灵素感到支配自己的包道乙微微一笑，同时，他也感到了无数人的愤怒<br>这些愤怒横穿天空，撕裂了风，化作落雷冲入金山大师的胸膛，金色光芒四散，闪耀在整个龙门<br>光芒在旋涡中回旋，金山大师所释放的光芒，不断流转，竟化身为龙，龙猛的跃起，缠绕在石窟中毘沙门天像上<br>“啊……!”<br>人们屏住呼吸<br>毘沙门天突然睁开了眼睛<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-150.jpg" alt="pishamentian"><br>只见神王双目燃着怒火，龙化作神火，缠绕在剑上，燃起的火直冲天空，毘沙门天正在行进着。【真神仙打架】<br>左手端着宝塔，右手拿着剑，就这么从悬崖上跳了下来，注视着“青华帝君”，“青华帝君”已经准备好逃走，却被从乌云中涌出的黄金魔人挡住了去路<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-151.jpg" alt="sharu"><br>毘沙门天挥舞着剑，向着失去退路的“青华帝君”的头顶砍了一刀，直至鸠尾。<br>“青华帝君”的蓝色身体开始剥落，里面是一片虚无，在这片虚无中，一朵莲花开始绽放<br>莲花向着四周发出金色光芒，茎正在慢慢的延伸，直达天际，伴随清脆的响声花开了，盛开的莲花顶端，出现了一个白眉白须，满面慈爱笑容的老神仙，道士们看着手中的拂尘，七寸的耳朵，额头三道皱纹，不禁叫出声来<br>“道德天尊——太上老君！”<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-152.jpg" alt="taishanglaojun"><br>正是道教的先祖——老子，化身神仙的身影<br>毘沙门天又开始行进，举着宝塔，卢遮那佛崩塌了，从碎石中，浮现出正在安详微笑的圣者释迦的身姿，坐在黄金莲花上，只见他飞向空中，在七彩云彩的伴随下，和老子并排而坐<br><img src="http://10.28.0.10/cache/9/04/suikoden.com/87d37bcb724215de9baeee34c784ecd3/108%20Outlaws-153.jpg" alt="shijia"><br>两人都是圣母诞下，历经凡人的坎坷，最终化身为神的人<br>抬头仰望着被光环包围的二尊的人们，恍惚间听见了仙女和天人演奏的乐曲<br>敌我无言</p><hr><p>“入云龙”公孙胜伫立在云雾缭绕的岩山之巅，虽然双目紧闭，但是脑海中“怪道士”包道乙的身姿却异常清晰<br><img src="http://10.28.0.10/cache/4/04/suikoden.com/46daee42760df523f41608cde06b3e1c/108%20Outlaws-154.jpg" alt="gongsunsheng"><br>（外法道士——已经死了吗？）<br>包道乙被公孙胜猛烈的法力所击倒，吐血而卧<br>公孙胜收起龙杖，转过身去<br>法力在空气中消散，包道乙终于可以活动了<br>他刚才在屏住气息装死<br>（这是二仙山的森罗万象之气）<br>但是，却还有一个气息<br>（暗中做法操控黄金魔人的……）<br>所谓二仙山的法戒，应当是容不下相异的外法的<br>包道乙只觉得自己里力量全部消散了，有人，不，周围的一切夺走了他的气<br>这种力量的真实面目是在金华山修行的老道，因为有着优秀的潜质，为了追求终极的法力，故涉猎了外法，他的力量，并不是天然的气，而是根据人心增幅的力量<br>身旁，觉得“怪道士”的法术更好的林灵素慌了神<br>“跟这种法力相比，你实在算不得什么啊”<br>包道乙匍匐着，混在重叠的尸体中逃走了<br>二仙山的术，才是真正的法术，并不是映照人内心的恐惧，而是实际存在的自然之气，通常可以感觉的到，只不过人们熟视无睹<br>那是只有达到“无我”境地，与世界融为一体才可以驾驭的力量<br>（必须赶紧逃走了，罗真人看不了那么远，向南……然后）<br>怪道士眼中发出怪异的光芒<br>（需要更强大的依附）<br>更加强大的人——</p><hr><p>林灵素清醒过来，站起身来环顾四周<br>（是一场梦吗？）<br>不知不觉，神佛已经消散不见，地上的人们呆立着不知所措<br>大家都莫名其妙的忘了自己要做到事<br>梁山泊的好汉，也莫名其妙的消失了<br>这个时候，石窟的上方，岩山的顶端，出现了色彩鲜艳的旌旗，是皇室的龙旗，举着旗子的仪仗走了过来，郎朗的声音在空中回响<br>“奉天承运，皇帝诏曰——众人下跪受旨”<br>这是一个让人难以相信的声音，压过了战场的喧嚣，响彻四方<br>在场的数万人，无论远近，听得一清二楚<br>岩山上，皇帝的亲卫军排起了长队，那是青年将校曹晟率领的五十轻骑，全是华丽的金吾卫装束，不过，却显得一片灰尘，他们是从东京疾驰而来，赶赴龙门<br><img src="http://10.28.0.10/cache/7/04/suikoden.com/26f0ed771dbb82b3743064b7a1ce8f1e/108%20Outlaws-155.jpg" alt="qinweijun"><br>曹晟身边并排的是金奴公主——银树。史进等人也没能马上认出来，并不是因为扎着头发，穿着公主的装束，而是因为被禁卫军环绕的银树，脸色苍白，一脸刚毅<br>身边白马的侍从，正是发出响彻千里的声音的人<br>“荣德公主殿下！”<br>在众人的注视下，银树在曹将军的帮助下从马上下来，就这样强支撑这身体，向着悬崖边走去<br>她深吸一口气<br>“战争，已经结束了！”</p><p>接着侍从的声音响彻天地<br>“废佛令停止了，赶快放下武器！”<br>银树双手拿着诏书，这是盖有皇帝玉玺的亲笔诏书<br>她的眼睛在战场上徘徊，在数万人中，寻找着那个熟悉的身影，她发现了正在叫唤的太白<br>“薛永，还活着！”<br><img src="http://10.28.0.10/cache/8/04/suikoden.com/0b485f6f0ecf17ce5106c67cff642240/108%20Outlaws-156.jpg" alt="xueyong"><br>银树大声的呼唤着那个名字<br>“薛永！”<br>薛永虽然受了伤，但是听见银树的声音，猛地站起身来<br>那时，他为了守护银树，孤身一人与追兵战斗，就在战斗到极限时，薛永发现自己并不是一个人——铁锹，铁算盘，铁笛，铁棒，保护着薛永<br>“——黄门四怪！”<br><img src="http://10.28.0.10/cache/11/04/suikoden.com/2aba100ebee3c2a8d8c5db4e50dc06c6/108%20Outlaws-157.jpg" alt="huangmensiguai"><br>“九尾龟”陶宗旺、“神算子”蒋敬、“铁笛仙”马麟、以及“摩云金翅”欧鹏，默默无言的战斗着<br>记忆逐渐模糊<br>回过神来，薛永正在陶宗旺的马上，马麟正在给他疗伤，告诉他他们正要前往龙门<br>银树正在招手，一切都不是幻觉！<br>公主身边的侍从，是“铁叫子”乐和，银树的侍从，正是梁山泊——不，应当说是整个大宋嗓子最好的“铁叫子”乐和<br>他受吴用之命接近王都尉，为了解救智真长老而四处奔走<br>一行人中，也有作为传令在东京和梁山泊之间奔走的“神行太保”戴宗<br>（梁山泊的众兄弟救了银树）<br>薛永凝视着彼方的银树，目光如炬<br>公主庄严华丽的打扮，佩戴的珍贵宝石，真的好耀眼，还有那温暖人心的笑容<br>（太好了！）<br>虽然这样想着，却好像看见了幻象，薛永也无法回首</p><p>林灵素只感觉世界一下子崩塌了<br>只觉得一片空虚，脚下隐约有黑暗的深渊张着嘴——明明自己没有施展过法术，却看到了那种幻影<br>郭道士赶到林灵素身边，得知事情有变，他火速赶了过来<br>“‘通真达灵元妙先生’，接下来如何？”<br>“——杀！”<br>林灵素听到了自己心底的声音<br>“公主也好，金吾卫也罢，统统杀掉吧”<br>然后再把责任归结于“叛军”，自己再率军平定他们<br>直到现在，林灵素都还没有认清形势，更没有看透自己。也许耳边慕容贵妃的声音正在回响<br>金吾将军曹晟对林灵素不放心，于是让手下侍卫护卫金奴公主<br>“林元帅，赶快下达撤军的命令”<br>林灵素冷冷的看着曹晟，只有五十护卫，听命林灵素的道士军团“六甲神兵”还残留着数千人<br>这个时候，两个密探赶了过来，一个是催促节度使出兵的使者，另一个是监视慕容贵妃的密探<br>一个使者告诉他<br>“王焕已经离开了宅邸！”<br>“现在才赶过来吗？”<br>“身边的随从都在念着‘南无阿弥陀佛’”<br>“什么？”<br>监视慕容贵妃的密探向困惑的林灵素又低语道<br>“慕容贵妃已经越过国境，到达辽国，辽国大军已经在沙漠中布阵了”<br>面对意想不到的报告，林灵素终于反应过来<br>密探之所以这么迟，是因为慕容贵妃去了辽国<br>（那女人成了辽国的走狗吗？）<br>这下就全都能说通了，猫儿一直催促节度使发兵的理由也能理解了，守卫边境的节度使一旦出动，辽国就有机可乘<br>（大宋若亡，成了国师又有什么意义）<br>林灵素终于做出了正确的选择<br>“——贫道林灵素受旨”<br>他仰望着金奴公主，跪了下来</p><p>战斗已经结束，道士们扔下武器<br>银树把后续事情交给曹将军处理，急忙赶到临终的金山大师身边<br>银树在东京时，她跟随王都尉到了艮岳，银树提到了关于慕容贵妃的事情，王都尉马上意识到还有比“法难”更加严峻的事，他同时收到了辽军在山西边境活动的报告，如果节度使受命镇压“叛乱”，那辽军就要攻过来了——向皇帝进言速做决断<br>皇帝选择相信自己的女儿<br>听闻了金山大师并没有反叛之心，他放心了<br>此时大师正躺在地上，周围有僧侣守护着，银树紧紧地握住金山大师的手，已经冰凉，她靠近大师的耳朵，把一切告诉他<br>“废佛已经停息，马上将在全国范围内下令，智真长老也平安无事”<br>听完银树的话，金山大师也终于走到了生命的尽头<br>没有什么奇迹<br>不见百只翔鹤，也不见七彩祥云<br>只是人们感觉到了河畔吹来的清爽的风，注意到阳光下焕发的生机<br>一只白鸽悠然的飞过天空<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-158.jpg" alt="baige"></p><hr><p>与此同时，山西代州郊外，国境附近<br>天空中一直海东青正在盘旋，那是来自北方的猛禽<br>面对视线南方围堵的长城，辽国大贵族，大将军兀颜光目光锐利<br><img src="http://10.28.0.10/cache/3/04/suikoden.com/e1281a84b654852da0ac1ab6fe167e82/108%20Outlaws-159.jpg" alt="wuyanguang"><br>风沙中行进的那人，是一个金发碧眼的壮汉，身着厚重的盔甲，正在马上等着“回报”<br>正在焦急的等待着狼烟升起<br>他的身后，是契丹的三万精锐骑兵<br>他们计划一看到信号，就攻入雁门关，越过长城，侵入山西，南下方向有五台山，这一带由于智真长老受难，反宋气焰日益高涨，举着“护法”的旗帜，进攻起来应该很容易吧<br>防守的关键，是两个节度使，太原的“药师”徐京和洛阳的“老风流”王焕。辽军是不怕宋军的，虽然数量和装备都占优，但是士兵怯懦，即使百人，也不敌契丹一骑<br>（但是，“节度使”可是不一样的）<br>徐京，王焕两个猛人养出的兵士，一直坚定的阻挡着辽国的进攻<br>现在这两人应该已经发兵龙门了<br>兀颜光所等待的，就是“节度使已经出兵”的回报<br>若是他们不在驻扎地，就立刻发起攻击，打下太原府，然后向西与后续部队会和攻下洛阳，就可以将宋国的西面纳入怀中，周边是西夏，大理，吐蕃等佛教国家，应当会支持“救佛”这个大义名分<br>（宋国的幼稚皇帝是真的愚蠢）<br>当然，辽国也是佛教国家，从皇帝到平民都是虔诚的佛教徒，兀颜光受辽国皇帝之命出征，发起一场救济僧侣和扩张领土一举两得的战争<br>一个探子疾驰而来<br>“报！”<br>探子在兀颜光面向跪下<br>“徐京，王焕两节度使并没有发兵的迹象”<br>探子汇报了侦察的结果，虽然东京方面多次下令出战，但两个节度使却迟迟没有出兵<br>兀颜光一脸沮丧<br>（可惜了，看来那个女人也立不了功了）<br>不久，又有探子回报龙门的战斗已经结束，法难也已经结束的消息<br>兀颜光注视着军队后方，一群青衣侍女护卫的马车，也许是已经察觉到情况有变，正要撤离<br>不知何时，这个女人出现在辽国，凭借其美貌和才能进入宫廷，现在已经上位到出入朝廷的地步，但是她的来历依旧成谜<br>兀颜光回转马头<br>“虽说是场面话，但两国尚有盟约，被宋军盯上了就麻烦了”<br>兀颜光拔出宝剑<br>“全军，撤回燕京”<br>兀颜光率领辽军如风般的撤走了，西北荒野又陷入一片寂静</p><hr><p>老风流”王焕正在骑马奔驰<br>“看我一人斩杀他千名无道道士！”<br>当龙门映入眼帘时，王焕一声吼叫，止住了马<br>“怎么，已经结束了吗？”<br>王焕在马上捋着长长的胡须，手中横着爱用的长枪<br><img src="http://10.28.0.10/cache/11/04/suikoden.com/9da873729199d5184104b07f37cc9fdd/108%20Outlaws-160.jpg" alt="王焕"><br>“真是窝囊，再坚持一下就好了”<br>他的身后是一批同样长须飘飘的老者，他们身着已经褪了色的铠甲，但仍不失英勇的气概，这些人是已经卸甲还乡的老将，有的是和王焕并肩作战的战友，有的是当年他的手下，他们曾在战场并肩杀敌，虽然已经退休，但是仍然保留着当年的情报网，一得知王焕出走的消息，他们纷纷拿出已经多年不穿的战甲，重新披挂上阵，前来支援<br>石窟周边，伊水河畔，无数的尸体，僧侣和尼姑不分敌我的看护着正在呻吟的人们<br>在微笑的卢遮那佛旁边，色彩鲜艳的“宋”的旗帜合着上供的鲜花，毫无疑问，护法军胜利了<br>王焕放声大笑<br>“这是佛罚，是佛罚啊”<br>王焕亡故的爱妻，贺玲玲，是当年洛阳闻名的美女【名妓，嗯】，年轻时，某个清明，两人在白马寺相遇，从此便私定终生，但是却被某个高官阻拦，王焕沦落不得不投身山贼，但他依旧虔诚，总到寺院参拜，坚信两人一定终成眷属，最终实现了愿望<br>【出自元杂剧《逞风流王焕百花亭》】<br>他想起了薄命佳人临终遗言<br>“即使战乱，也不要毁坏佛寺”<br>他拿出爱妻遗留的梳子<br>“我王焕，即使对君不忠，也不会违背和女人的约定”<br>王焕的白须在空中飘扬，哈哈大笑<br>国家无道，便落草为寇，这种念头，从青春之日就不断在王焕心中生长<br>“那么。就回去吧，女人们该担心了”<br>“只要将军一句话，即使奉上白发首级，我等也在所不辞”<br>即使节度使未出兵支援，即使王焕“秘密叛逃”，这次也没有任何人前来问罪<br>之后，王焕命令这些曾经的部下前往那些堆满了金银的道观征收“保护费”，重建被烧毁的诸寺<br>法难结束，害怕寺院报复的道士们，都纷纷表示“合作”</p><p>伊水岸边，孟康的船停泊着，等待着归来的客人<br>“铁叫子”乐和已经上了船<br>在这不算太热的初夏时节，乘船出游大概是一件美事，乐和本想放声歌唱一曲，但是想了想却又作罢<br>龙门的战场，还有无数的生命正在飘忽不定的闪烁，各种各样的想法交错，他不知道应该唱一首什么样的歌<br>取而代之的是，他向着河岸的石秀打了声招呼<br>“石秀大哥还不打算回去吗”<br>“哥，你怎么说”<br>石秀问坐在身边的杨雄<br>“洛阳不是大哥的故乡吗，要不顺道去看看吧”<br>“不，不用了，这一道下来太累了，我已经受够了”<br>“那咱们就回去吧”<br>石秀背着杨雄，猛地跳上了船，水花飞溅，孟康嘟嘟囔囔的发了句牢骚<br>“船夫哥，赶快开船吧”<br>石秀一身疲惫的躺在甲板上<br>船离开龙门<br>风景渐行渐远，但蓝天依旧湛蓝</p><p>史进手持小木龙，仰望着石窟<br>“——那我们就回去了”<br>“张神剑”拄着一把枪，牵着一匹失去主人的军马，手下也有几人幸存，也还带着从达摩堂领来的赏钱<br>“虽然这次很亏本，但想来可以和子孙后代炫耀，也还算不错”<br>“张神剑”举着长剑，那正是他绰号的由来<br>“再见了，‘史进’”</p><p>史进在僧侣和石窟之间寻找着，但是不见木龙行者和王进的身影<br>在一个无人的小石窟中，刚好可以容纳一个木龙，石窟的佛像正在雕刻中，脸还没有刻好<br>“这就是师父”<br>史进相信王进就在龙门<br>“好像又离开了”<br>李忠一脸疲惫的走向史进<br>受伤的脚上缠着布，李忠安慰道<br>“你已经掌握了师父的一切本领，如果没什么可教的了，师父自然会默默离开”<br>“再也见不到他了吗？”<br>“所谓‘恩师’，大抵如此”<br>陈达杨春也过来了，带着从道士和官军那里的战利品，陈达怀里鼓鼓囊囊<br>“给朱大哥带上一份土特产，回去就没那么多说教了”<br>“土特产的话，还有更好的哦”<br>大家朝着伊水岸边望去<br><img src="http://10.28.0.10/cache/10/04/suikoden.com/68be8fd8e1b7950e5b3dae5a3fb275c2/108%20Outlaws-161.jpg" alt="123"><br>蓝天下，两人（一狗）的身影，如画一般</p><hr><p>“父亲已经准许我不用再当尼姑了”<br>银树抓着薛永的手，公主的打扮，楚楚动人<br>“薛永，你也不用当什么艺人了，我已经拜托父亲，让他封你为将军”<br>薛永笑了笑<br>“这个”<br>他解开挂在脖子上的玉护符，挂在了银树脖子上<br>“给我吗？”<br>银树笑靥如花，薛永却转移了视线<br>“看，大家都在等着你呢”<br>银树松开了薛永的手<br>“是啊”<br>她作为“特使”很忙，除了战后的善后工作，还要为彭尼等伤员请来太医，并命令侍从准备金山大师的灵柩，也派遣曹晟将军寻找慕容贵妃<br>但是，不可思议的是，银树已经不那么在乎她了<br>那个坏人，是不可能善终的<br>“薛永，你在这等我，随我回东京”<br>“嗯”<br>“一定”<br>“嗯，一定”<br>银树被众多护卫守卫着离去，回过头了，笑着挥手<br><img src="http://10.28.0.10/cache/2/04/suikoden.com/de31347ab8003e995324af63ef2ed88c/108%20Outlaws-162.jpg" alt="yinshu"><br>“好汉不会说谎的”</p><p>史进呼唤着在岸边发呆的薛永<br>“嘿，美男子”<br>“史进大哥”<br>“你喜欢吧”<br>“不要再拿我开玩笑了，人家可是……”<br>薛永自顾自的说着<br>“可是堂堂的公主”<br>史进抓住薛永的手腕<br>“这样那咱们就绑她上山”<br>“什么？”<br>“赚她上山，然后你娶了她”<br>薛永沉默不语，两人哈哈大笑<br>船正在岸边等着，史进向着船走去，薛永也跟了过来<br>“史进大哥找到师父了吗？”<br>“啊，见到了”<br>史进握着木龙，抬头仰望着龙门的蓝天<br>他看见彭尼被人，手中握着一朵鲜艳的红曼珠沙华<br>史进深吸了一口凉爽的河风<br>“回去了!”<br>阮小二架着船离开了岸边<br>岸边的石佛们微笑着送一行人离去，薛永一直望着龙门，望着已经快要消失的银树的身影<br>声音已经传不到了<br>可是那笑容，却照亮了七里的距离<br>“再见，祝你幸福”</p><hr><p>在混乱的人群中，莫志寻找着史进<br>莫志手中拿着天穹和尚赐予的弓——“破烦恼宝弓”——不管天穹和尚是怎么想的，这个弓至少解开了年轻的莫志的疑惑<br>可是却怎么也找不见史进，死伤者中也不见，叫了名字也没人答应<br>取而代之的是，莫志遇到了以前白马寺的僧侣们，他们是护卫着《四十二章经》一同前来龙门的和尚，虽然白马寺的至宝《四十二章经》已经没了，但是他们都幸存了下来<br>那些和尚盯着莫志手中的弓<br>“莫志啊，你破了杀戒，竟然没用堕入地狱？”<br>“没有”<br>莫志毫不羞涩的回答道，也不打算反驳<br>只是，他清楚的说道<br>“我已经不是‘莫志’了，我有我的志向”<br>莫志昂首挺胸，举着手中的弓<br>“我要和一切不正当战斗，用我的弓消灭一切不公”<br>并且，他也要超越“梁山泊的花荣”，成为大宋第一，不，应该是世界第一的优秀神弓手<br>年轻的射手燃着热血，抛弃了僧衣，手中握着弓，拿着沾着鲜血的《精武大宝藏经》<br>“我要还俗，恢复本名，我的本名是——庞万春”</p><hr><p>岩山之巅，立着两个怪人<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-163.jpg" alt="1"><br>是一个黑衣道士和一个三眼的异形者<br>这是“幻魔君”乔道清和他的弟子“神驹子”马灵——他们是在山西揭竿而起，自封为晋王的田虎麾下重臣，他们建立晋国，企图推翻宋的统治<br>他们混在道士中招募有用的人才，并且依仗林灵素判断打败宋的可能性<br>他们对此相当失望<br>“林灵素什么的真是不够看啊”<br>乔道清咒骂道<br>“不过是一个夸夸其谈的混账玩意，搞了这么一出无聊的闹剧”<br>“师父，方才那个怪人，是什么来历？”<br>“大概是金华山一带的邪教徒吧”<br>“咱们这次帮着宋这一边真的好吗？”<br>阻挡“青华帝君”撤退的金色魔人，正是“幻魔君”乔道清施法召唤的<br>“好不容易跑来一趟，稍微玩一下也没什么问题，话说回来，契丹若是打过来，对我们建国也没好处啊”<br>正是因为辽国窥视着山西的领土，徐京王焕的防守重点在国境，田虎也才能发展起来<br>“妄图以宋国内乱制造机会的想法还是不要再提了，果然，国运只能依靠力量，稳健派的卞祥等人大概会厌恶吧”<br>乔道清觉得，需要更强大的人入伙<br>这样想着，一个名叫包道乙的怪道士，正拖着受伤的身体匆匆离去<br>“回去吧，马灵”<br>马灵看了看天空，已经不见云彩<br>“那个毘沙门天……”<br>马灵的额头抽搐着，第三只眼可以感觉到空气中残留的“气”<br>乔道清也感受到了如此强烈的波动<br>“只怕是二仙山的五雷天心正法，不，不对，应该是公孙一清——‘入云龙’”<br>“一清道人已经入伙梁山了”<br>“即使他们打着‘宋’的旗子，也瞒不过我，那伙人就是梁山的”<br>梁山泊为何会站在僧侣这一边，乔道清也想不明白<br>（那伙人不知在搞什么阴谋）<br>乔道清只感觉后背一阵战栗，可不能惹恼了这伙人啊<br>“‘梁山泊’——还是通报‘龙公’孙安一声吧”<br>不安的风，正围着乔道清的漆黑法衣打转</p><hr><p>东京开封——中心的皇城<br>那棵树至今仍在宫中一角，已经长起来了，只是不受欢迎，被遗忘在庭院中<br>柔软的树干、艳丽的绿叶、星光般的白色花朵。银木犀的甜蜜香味在微风中散发出来。<br>银树——赵金奴，穿着公主的装束，再次站在树下<br>十年前在绝望中离开，十年后又重回起点，也看见了已经长大成人的亲哥哥，可是金奴，永德公主这些称呼，在她看来却相当陌生<br>“公主殿下，圣上有请”<br>“我问你们，有个叫薛永的，来没来”<br>金奴这一天中已经不知道问了多少次<br>“他带着只大狗……约定好回来的”<br>“公主殿下，并没有这样的人”<br>金奴告别了怀念的庭院<br>纵使闭上双眼，也再也见不到儿时的梦幻世界<br>金奴离开了没有了母亲的身影的后宫，在侍女的陪伴下，前往自己的父亲身边，身为太子的哥哥和智真长老也在那里<br>虽然智真长老因为断食而消瘦，但身体还算硬朗<br>在皇帝多次的劝说下，智真长老终于做了上座<br>皇帝为自己被人蒙蔽而道歉，慰问长老，并且安排禁卫护送长老返回五台山<br>金奴走到智真长老面前<br>她还有想要确认的事，关于无法从金山大师那里得知的自己的命运<br>“我真的是个‘不吉之子’吗？”<br>长老拿着念珠，注视着公主的眼睛<br>“‘天有三日，望月辉耀’——公主啊，你的命运，就犹如被三轮太阳一同照射般一样残酷，但是，即使被太阳璀璨的大地，也会有清凉的夜晚降临，云端之上，满月也会闪耀，不管以后发生什么，请公主柔韧，坚强的活下去”<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-164.jpg" alt="1"><br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-165.jpg" alt="2"><br>荣德公主赵金奴在宋国被金国灭亡后，就被掳到了金国，父亲，哥哥几乎所有的皇族，都成了俘虏，境遇相当残酷，在艰难的北上之旅中，不少公主，后妃丧命<br>金奴在二十五岁那年，在这场动乱中活了下来，失去了丈夫左卫将军曹晟，成了金国皇族完颜昌的侧室，但最终却在金国的政变中所杀<br>最终，以皇后的礼遇下葬，终结了波澜的一生</p><hr><p>出征河南的好汉们都回来了，梁山泊又恢复了往日的平静<br>中秋之夜，又是前头领晁盖的忌日，大家聚首聚义厅，举行着大规模的宴会<br>在山中待命的好汉们，都想听听史进这次的遭遇，就都围在史进身边，史进和大家聊着自己的各种遭遇，大家都痛快的开怀畅饮，座位上，还有一个为不在这里的人准备的酒杯<br>史进喝的酩酊大醉，为了醒酒来到外面，月亮正圆<br>湖面上，满月的影子清晰可见，薛永和太白正在那边<br>“好生快活啊”<br>听见一声感叹，薛永回头一笑<br>“的确是啊”<br>宴会仍在继续<br>史进也上前来，望着湖面上浮现的月光<br>想来师父王进，也在某处享受着一时的静谧吧<br>也一定正在享受着一杯酒，和某人一同赏月吧<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-166.jpg" alt="1"><br>宣和年间——那是大宋和梁山泊最后一个安宁的时期</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;&lt;font color=&quot;#FF0000&quot;&gt;原文作者 森下翠和插画作者 正子公也 版权所有&lt;br&gt;&lt;br&gt;个人翻译&lt;br&gt;&lt;br&gt;仅供个人娱乐及同好者欣赏&lt;br&gt;&lt;/font&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;a href=&quot;http://suikoden.com/&quot; t
      
    
    </summary>
    
      <category term="绘卷水浒传" scheme="https://www.junglezero.top/categories/%E7%BB%98%E5%8D%B7%E6%B0%B4%E6%B5%92%E4%BC%A0/"/>
    
    
      <category term="绘卷水浒传 二十周年番外" scheme="https://www.junglezero.top/tags/%E7%BB%98%E5%8D%B7%E6%B0%B4%E6%B5%92%E4%BC%A0-%E4%BA%8C%E5%8D%81%E5%91%A8%E5%B9%B4%E7%95%AA%E5%A4%96/"/>
    
  </entry>
  
  <entry>
    <title>java的String三剑客（String，StringBuilder，StringBuffer）</title>
    <link href="https://www.junglezero.top/2019/04/16/va%E7%9A%84String%E4%B8%89%E5%89%91%E5%AE%A2%EF%BC%88String%EF%BC%8CStringBuilder%EF%BC%8CStringBuffer-%EF%BC%89/"/>
    <id>https://www.junglezero.top/2019/04/16/va的String三剑客（String，StringBuilder，StringBuffer-）/</id>
    <published>2019-04-16T07:53:00.000Z</published>
    <updated>2019-07-06T01:57:32.953Z</updated>
    
    <content type="html"><![CDATA[<p>在有了不可变对象和不可变类的概念以后，就可以分析一下java中String，StringBuilder，StringBuffer三个概念<br>网上有一篇很简单明了的<a href="https://www.cnblogs.com/su-feng/p/6659064.html" target="_blank" rel="noopener">教程</a></p><h1 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h1><p>运行速度，或者说是执行速度，在这方面运行速度快慢为：<strong>StringBuilder &gt; StringBuffer &gt; String</strong><br>而原因就是在于String是不可变的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="string">"abc"</span>;</span><br><span class="line">System.out.println(str);</span><br><span class="line">str=str.replace(<span class="string">"c"</span>,<span class="string">"mn"</span>);</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure><p>有人会说，这样str不是变了吗？<br>要想解释这个问题，首先我们要知道String类属于不可变类，而它的对象属于不可变对象<br>然后看一部分replace方法的源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Replaces each substring of this string that matches the literal target</span></span><br><span class="line"><span class="comment">     * sequence with the specified literal replacement sequence. The</span></span><br><span class="line"><span class="comment">     * replacement proceeds from the beginning of the string to the end, for</span></span><br><span class="line"><span class="comment">     * example, replacing "aa" with "b" in the string "aaa" will result in</span></span><br><span class="line"><span class="comment">     * "ba" rather than "ab".</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  target The sequence of char values to be replaced</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  replacement The replacement sequence of char values</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  The resulting string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span> </span>&#123;</span><br><span class="line">        String tgtStr = target.toString();</span><br><span class="line">        String replStr = replacement.toString();</span><br><span class="line">        <span class="keyword">int</span> j = indexOf(tgtStr);</span><br><span class="line">        <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tgtLen = tgtStr.length();</span><br><span class="line">        <span class="keyword">int</span> tgtLen1 = Math.max(tgtLen, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> thisLen = length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> newLenHint = thisLen - tgtLen + replStr.length();</span><br><span class="line">        <span class="keyword">if</span> (newLenHint &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(newLenHint);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            sb.append(<span class="keyword">this</span>, i, j).append(replStr);</span><br><span class="line">            i = j + tgtLen;</span><br><span class="line">        &#125; <span class="keyword">while</span> (j &lt; thisLen &amp;&amp; (j = indexOf(tgtStr, j + tgtLen1)) &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.append(<span class="keyword">this</span>, i, thisLen).toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>可以发现，底层应用的实际是StringBuilder，而且问题的关键是，由于是不可变对象，所以一切所谓的“改变”，都会创建新的对象<br>而对于StringBuilder和StringBuffer，他们都是可变对象<br>而StringBuillder StringBuffer,是内容可以改变的字符串。StringBuillder StringBuffer底层使用的可变的字符数组（没有使用final来修饰）</p><p><img src="/upload/pasted-346.png" alt="upload successful"></p><p>因而发生改变时不需要额外创建新的对象，所以速度更快</p><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>String自不必说，因为不可变对象一定是线程安全的<br>对于StringBuffer，如果观看源码的话，会发现涉及改变的操作都上了锁（synchronized 关键字）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, Object obj)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.insert(offset, String.valueOf(obj));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, String str)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.insert(offset, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而StringBuilder却没有<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(StringBuffer sb)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.append(sb);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(CharSequence s)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.append(s);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>根据其特点，可以总结出具体应用场景:</p><p>String：适用于少量的字符串操作的情况</p><p>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况<br>　　<br>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在有了不可变对象和不可变类的概念以后，就可以分析一下java中String，StringBuilder，StringBuffer三个概念&lt;br&gt;网上有一篇很简单明了的&lt;a href=&quot;https://www.cnblogs.com/su-feng/p/6659064.htm
      
    
    </summary>
    
      <category term="java基础知识" scheme="https://www.junglezero.top/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="java基础" scheme="https://www.junglezero.top/tags/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="java常用类" scheme="https://www.junglezero.top/tags/java%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
    
  </entry>
  
</feed>
