<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>淋中之虹</title>
  
  <subtitle>向来不知道该说些什么</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.junglezero.top/"/>
  <updated>2019-07-25T14:55:04.376Z</updated>
  <id>https://www.junglezero.top/</id>
  
  <author>
    <name>JungleZero</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式总结（2）【】</title>
    <link href="https://www.junglezero.top/2019/07/25/signpattern2/"/>
    <id>https://www.junglezero.top/2019/07/25/signpattern2/</id>
    <published>2019-07-25T14:27:09.000Z</published>
    <updated>2019-07-25T14:55:04.376Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.3dmgame.com/uploads/images/thumbpicfirst/20190219/1550567116_731464.jpg" width="70%"></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.3dmgame.com/uploads/images/thumbpicfirst/20190219/1550567116_731464.jpg&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式总结（1）【单例模式，三种工厂模式】</title>
    <link href="https://www.junglezero.top/2019/07/25/sign-pattern/"/>
    <id>https://www.junglezero.top/2019/07/25/sign-pattern/</id>
    <published>2019-07-25T14:21:02.000Z</published>
    <updated>2019-07-25T14:50:01.202Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/upload/pasted-433.png" width="70%"></p><a id="more"></a><hr><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>单例模式属于创建型设计模式。</p><p>确保一个类只有一个实例，并提供该实例的全局访问点。</p><p>实现: <strong>使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现</strong>。</p><h2 id="二、结构"><a href="#二、结构" class="headerlink" title="二、结构"></a>二、结构</h2><p>类图:</p><p><img src="/upload/14_singleton.png" alt="14_singleton.png"></p><p><strong>私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量</strong>。</p><h2 id="三、几类经典单例模式实现"><a href="#三、几类经典单例模式实现" class="headerlink" title="三、几类经典单例模式实现"></a>三、几类经典单例模式实现</h2><h3 id="1、懒汉式-线程不安全"><a href="#1、懒汉式-线程不安全" class="headerlink" title="1、懒汉式-线程不安全"></a>1、懒汉式-线程不安全</h3><p>所谓懒汉式，就是说等到用的时候再进行创建</p><p>这种实现方法线程不安全，如果多个线程能够同时进入 <code>if (uniqueInstance == null)</code> ，并且此时 <code>uniqueInstance == null</code>，那么会有多个线程执行 <code>uniqueInstance = new Singleton();</code> 语句，这将导致实例化多次 <code>uniqueInstance</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式: 线程不安全</span></span><br><span class="line"><span class="comment">// 有延迟加载: 不是在类加载的时候就创建了，而是在调用newStance()的时候才会创建</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有静态实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、懒汉式-线程安全-性能不好"><a href="#2、懒汉式-线程安全-性能不好" class="headerlink" title="2、懒汉式-线程安全-性能不好"></a>2、懒汉式-线程安全-性能不好</h3><p>解决上面线程不安全的最直接方法就是上锁</p><p>但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待，即使 <code>uniqueInstance</code> 已经被实例化了。这会让线程阻塞时间过长，因此该方法有性能问题<br><strong>不推荐使用</strong>。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">newInstance</span><span class="params">()</span></span>&#123;<span class="comment">//在上面的基础上加了synchronized</span></span><br><span class="line">    <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)</span><br><span class="line">        uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、饿汉式-线程安全-无延迟加载"><a href="#3、饿汉式-线程安全-无延迟加载" class="headerlink" title="3、饿汉式-线程安全-无延迟加载"></a>3、饿汉式-线程安全-无延迟加载</h3><p>饿汉式：类一初始化就进行实例的创建（等不及了）</p><p>这种方式比较常用，但容易产生垃圾对象(丢失了延迟实例化(<code>lazy loading</code>)带来的节约资源的好处)。</p><p>它基于 <strong>classloader机制</strong>避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， <strong>但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazyloading 的效果</strong>。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、双重校验锁-线程安全"><a href="#4、双重校验锁-线程安全" class="headerlink" title="4、双重校验锁-线程安全"></a>4、双重校验锁-线程安全</h3><p><code>uniqueInstance</code> 只需要被实例化一次，之后就可以直接使用了。这种线程安全的优化方式就是缩小加锁的范围，只有当<code>uniqueInstance</code> 没有被实例化时，才需要进行加锁。</p><p>双重校锁：<br><strong>第一次校验：</strong>由于单例模式只需要创建一次实例，如果后面再次调用getInstance方法时，则直接返回之前创建的实例，因此大部分时间不需要执行同步方法里面的代码，大大提高了性能。如果不加第一次校验的话，那跟上面的懒汉模式没什么区别，每次都要去竞争锁。<br><strong>第二次校验：</strong>如果没有第二次校验，假设线程t1执行了第一次校验后，判断为null，这时t2也获取了CPU执行权，也执行了第一次校验，判断也为null。接下来t2获得锁，创建实例。这时t1又获得CPU执行权，由于之前已经进行了第一次校验，结果为null（不会再次判断），获得锁后，直接创建实例。结果就会导致创建多个实例。所以需要在同步代码里面进行第二次校验，如果实例为空，则进行创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双重加锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不需要先实例化</span></span><br><span class="line">    <span class="comment">// 使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一次校验</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// //第二次校验</span></span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p><ul><li>1)、为 <code>uniqueInstance</code> 分配内存空间；</li><li>2)、初始化 <code>uniqueInstance</code>；</li><li>3)、将 <code>uniqueInstance</code> 指向分配的内存地址；</li></ul><p>但是由于 JVM 具有<strong>指令重排</strong>的特性，执行顺序有可能变成 <code>1&gt;3&gt;2</code>。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 <code>T1</code> 执行了 1 和 3，此时 <code>T2</code>调用 <code>newInstance()</code> 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code>，但此时 <code>uniqueInstance</code> 还未被初始化。</p><p><strong>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行</strong>。</p><h3 id="5、静态内部类实现"><a href="#5、静态内部类实现" class="headerlink" title="5、静态内部类实现"></a>5、静态内部类实现</h3><p>当 <code>Singleton</code> 类加载时，<strong>静态内部类 Holder 没有被加载进内存</strong>。只有当调用 <code>newInstance()</code> 方法从而触发 <code>Holder.uniqueInstance</code> 时 <code>Holder</code>才会被加载，此时初始化<code>uniqueInstance</code> 实例，并且 JVM 能确保 <code>uniqueInstance</code> 只被实例化一次。</p><p>这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。</p><blockquote><p>这种方式是 Singleton 类被装载了，<code>uniqueInstance</code> 不一定被初始化。因为 <code>Holder</code>s 类没有被主动使用，只有通过显式调用 <code>newInstance()</code>方法时，才会显式装载 Holder 类，从而实例化<code>uniqueInstance</code>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、枚举实现"><a href="#6、枚举实现" class="headerlink" title="6、枚举实现"></a>6、枚举实现</h3><p>这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。</p><p>该实现在多次序列化再进行反序列化之后，不会得到多个实例。而其它实现需要使用 <code>transient</code> 修饰所有字段，并且实现序列化和反序列化的方法。</p><p>枚举实现单例 (+测试):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Sing.INSTANCE.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> Sing &#123;</span><br><span class="line"></span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//jvm guarantee only run once</span></span><br><span class="line">        Sing() &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Singleton <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line"></span><br><span class="line">        Set&lt;Singleton&gt;set = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;&gt;());<span class="comment">//注意set也要加锁</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line"></span><br><span class="line">                    set.add(Singleton.newInstance());</span><br><span class="line"></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">        System.out.println(set.size());<span class="comment">//1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于序列化和反序列化:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 单例测试</span></span><br><span class="line">        Singleton s1 = Singleton.INSTANCE;</span><br><span class="line">        s1.setName(<span class="string">"firstName"</span>);</span><br><span class="line">        System.out.println(<span class="string">"s1.getName(): "</span> + s1.getName());</span><br><span class="line"></span><br><span class="line">        Singleton s2 = Singleton.INSTANCE;</span><br><span class="line">        s2.setName(<span class="string">"secondName"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意我这里输出s1 ，但是已经变成了 secondName</span></span><br><span class="line">        System.out.println(<span class="string">"s1.getName(): "</span> + s1.getName());</span><br><span class="line">        System.out.println(<span class="string">"s2.getName(): "</span> + s2.getName());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反射获取实例测试</span></span><br><span class="line">        Singleton[] enumConstants = Singleton.class.getEnumConstants();</span><br><span class="line">        <span class="keyword">for</span> (Singleton enumConstant : enumConstants)</span><br><span class="line">            System.out.println(enumConstant.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1.getName(): firstName</span><br><span class="line">s1.getName(): secondName</span><br><span class="line">s2.getName(): secondName</span><br><span class="line">-----------------</span><br><span class="line">secondName</span><br></pre></td></tr></table></figure><blockquote><p>该实现可以防止反射攻击。在其它实现中，通过 <code>setAccessible()</code>(反射中的强制访问私有属性方法) 方法可以将私有构造函数的访问级别设置为 public，然后调用构造函数从而实例化对象，如果要防止这种攻击，需要在构造函数中添加防止多次实例化的代码。该实现是由 JVM 保证只会实例化一次，因此不会出现上述的反射攻击。</p></blockquote><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>一般情况下，<strong>不建议使用懒汉方式</strong>，建议使用饿汉方式。</p><p>只有在要明确实现 <code>lazy loading</code> 效果时，才会使用<strong>静态内部类方式</strong>。</p><p>如果涉及到<strong>反序列化创建对象</strong>时，可以尝试使用枚举方式。</p><p>如果有其他特殊的需求，可以考虑使用双检锁方式。</p><h2 id="五、应用实例"><a href="#五、应用实例" class="headerlink" title="五、应用实例"></a>五、应用实例</h2><p>Spring下默认的bean均为singleton，可以通过singleton=“true|false” 或者 scope=“？”来指定<br>这样做可以减少cpu内存的浪费。可能有人觉得多用户走多线程只运行一个实例肯定会引发线程安全问题，但在这里应当理解线程安全问题的本质：全局变量，公共变量被多个线程同时操作。虽然spring对象是单例的，但类里面方法对每个线程来说都是独立运行的，不存在多线程问题，只有成员变量有多线程问题，所以方法里面如果有用到成员变量就要考虑用安全的数据结构。对于有着特殊状态值（一定意义上的全局变量）的单例对象，spring使用ThreadLocal维护线程安全，不过这是另一个问题了。<br><a href="https://blog.csdn.net/zengdeqing2012/article/details/77098994" target="_blank" rel="noopener">https://blog.csdn.net/zengdeqing2012/article/details/77098994</a><br>在java JDK中</p><p>java.lang.Runtime#getRuntime()<br>java.awt.Desktop#getDesktop()<br>java.lang.System#getSecurityManager()<br>使用的都是单例模式，为什么？因为只要一个就够了。</p><h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><h2 id="一、基本概念-1"><a href="#一、基本概念-1" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p><strong>简单工厂模式是类的创建模式，又叫做静态工厂方法（Static Factory Method）模式。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例</strong>。</p><p>在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。<br>这个模式严格来讲是下面工厂方法模式的一个特例</p><h2 id="二、结构-1"><a href="#二、结构-1" class="headerlink" title="二、结构"></a>二、结构</h2><p>简单工厂把实例化的操作单独放到一个类中，这个类就是简单工厂类(Simple Factory)，<strong>让简单工厂类来决定应该用哪个具体子类来实例化 (而不是在客户端中决定)</strong>。</p><p>这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。</p><p>客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。</p><p>结构:</p><p><img src="/upload/04_simple_01.png" alt="04_simple_01.png"></p><h2 id="三、案例"><a href="#三、案例" class="headerlink" title="三、案例"></a>三、案例</h2><blockquote><p>模拟在<code>type == 1</code>的时候创建<code>ConcreteProduct1</code>、在<code>type == 2</code>的时候创建<code>ConcreteProduct2</code>、其他时候创建<code>ConcreteProduct</code>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们按照下面的方式创建，则我们在客户端包含了这些需要判断条件的实例化代码，则可以将这些实例化代码放到简单工厂中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不好的设计</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> type = <span class="number">1</span>;</span><br><span class="line">        Product product;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">            product = <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">            product = <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            product = <span class="keyword">new</span> ConcreteProduct();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// do something with the product</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是我们可以增加一个简单工厂类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以将createProduct写成静态的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们的测试类可以写成下面的样子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleFactory simpleFactory = <span class="keyword">new</span> SimpleFactory();</span><br><span class="line">        Product product = simpleFactory.createProduct(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// do something with product</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样既让客户端和具体类解耦，而且在客户端也看不到具体的繁杂的实例化代码。</p><h2 id="四、总结-1"><a href="#四、总结-1" class="headerlink" title="四、总结"></a>四、总结</h2><p>缺点 : 这个工厂类集中了所有的创建逻辑，当有复杂的多层次等级结构时，所有的业务逻辑都在这个工厂类中实现。什么时候它不能工作了，整个系统都会受到影响。</p><p>我们强调<strong>职责单一</strong>原则，一个类只提供一种功能。</p><h2 id="五、应用实例-1"><a href="#五、应用实例-1" class="headerlink" title="五、应用实例"></a>五、应用实例</h2><p>spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。如下配置，就是在 HelloItxxz 类中创建一个 itxxzBean。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"singletonBean"</span> <span class="attr">class</span>=<span class="string">"com.itxxz.HelloItxxz"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>Hello! 这是singletonBean!value&gt;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/ <span class="attr">bean</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"itxxzBean"</span> <span class="attr">class</span>=<span class="string">"com.itxxz.HelloItxxz"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">singleton</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>Hello! 这是itxxzBean! value&gt;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在juc中，类Executors就是一个典型的简单工厂方法类，在这类下，提供了创建多种ExecutorService的静态方法，在使用时直接调用这个类的静态方法创建不同的ExecutorService即可，而不需要再在客户端创建不同的实例</p><h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><h2 id="一、基本概念-2"><a href="#一、基本概念-2" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p><strong>工厂方法模式是类的创建模式，又叫做虚拟构造子(Virtual Constructor)模式或者多态性工厂（Polymorphic Factory）模式</strong>。<br>工厂方法模式的用意是<strong>定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中</strong>。</p><p>或者说引入工厂模式的目的就是我们需要多个工厂，但是每个工厂内部又要划分情况，如果只用一个工厂的话，会产生多种复合的情况。</p><p>比如说我们有两个工厂，每个工厂有3种情况，如果用简单工厂模式，要分为 <code>3 * 2 = 6</code>种情况，所以可以用工厂方法模式解决。</p><h2 id="二、结构-2"><a href="#二、结构-2" class="headerlink" title="二、结构"></a>二、结构</h2><p>在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由大工厂的子类(或者实现类)来创建对象。</p><p>即上面有一个大工厂，下面是分类的工厂。</p><p><img src="/upload/05_method_03.png" alt="05_method_03.png"></p><h2 id="三、案例-1"><a href="#三、案例-1" class="headerlink" title="三、案例"></a>三、案例</h2><blockquote><p>案例，模拟需要生成中国食物A，中国食物B，美国食物A，美国食物B。</p></blockquote><p>代码逻辑结构图:</p><p><img src="/upload/05_method_01.png" alt="05_method_01.png"></p><p>基本结构图:</p><p><img src="/upload/04_method_02.png" alt="04_method_02.png"></p><p>先给出这些食物(<code>Product</code>):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmericanFoodA</span> <span class="keyword">implements</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmericanFoodB</span> <span class="keyword">implements</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChineseFoodA</span> <span class="keyword">implements</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChineseFoodB</span> <span class="keyword">implements</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是抽象工厂:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FoodFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Food <span class="title">makeFood</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是两个子工厂:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChineseFoodFactory</span> <span class="keyword">implements</span> <span class="title">FoodFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">makeFood</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">"A"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ChineseFoodA();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">"B"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ChineseFoodB();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmericanFoodFactory</span> <span class="keyword">implements</span> <span class="title">FoodFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">makeFood</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">"A"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AmericanFoodA();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">"B"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AmericanFoodB();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先选择一个具体的工厂</span></span><br><span class="line">        FoodFactory factory = <span class="keyword">new</span> ChineseFoodFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由第一步的工厂产生具体的对象，不同的工厂造出不一样的对象</span></span><br><span class="line">        Food food = factory.makeFood(<span class="string">"A"</span>); <span class="comment">//  chineseFood * A</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、总结-2"><a href="#四、总结-2" class="headerlink" title="四、总结"></a>四、总结</h2><p>工厂方法模式和简单工厂模式在结构上的不同很明显。</p><p><strong>工厂方法模式的核心是一个抽象工厂类，而简单工厂模式把核心放在一个具体类上</strong>。</p><p>工厂方法模式退化后可以变得很像简单工厂模式。设想如果非常确定一个系统只需要一个具体工厂类，那么不妨把抽象工厂类合并到具体工厂类中去。由于只有一个具体工厂类，所以不妨将工厂方法改为静态方法，这时候就得到了简单工厂模式。</p><h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><h2 id="一、基本概念-3"><a href="#一、基本概念-3" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>当涉及到<strong>产品族</strong>的时候，就需要引入抽象工厂模式了。</p><p>每一个模式都是针对一定问题的解决方案。抽象工厂模式与工厂方法模式的最大区别就在于，<strong>工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则需要面对多个产品等级结构</strong>。</p><p>在学习抽象工厂具体实例之前，应该明白两个重要的概念：产品族和产品等级。</p><p>所谓产品族，是指位于不同产品等级结构中，功能相关联的产品组成的家族。比如AMD的主板、芯片组、CPU组成一个家族，Intel的主板、芯片组、CPU组成一个家族。而这两个家族都来自于三个产品等级：主板、芯片组、CPU。一个等级结构是由相同的结构的产品组成，示意图如下：</p><p><img src="/upload/06_abstract_06.png" alt="06_abstract_06.png"></p><h2 id="二、案例"><a href="#二、案例" class="headerlink" title="二、案例"></a>二、案例</h2><p>一个经典的例子是造一台电脑。我们先不引入抽象工厂模式，看看怎么实现。</p><p>因为电脑是由许多的构件组成的，我们将 CPU 和主板进行抽象，然后 CPU 由 CPUFactory 生产，主板由 MainBoardFactory 生产，然后，我们再将 CPU 和主板搭配起来组合在一起，如下:</p><p><img src="/upload/06_abstract_01.png" alt="06_abstract_01.png"></p><p>代码组织结构:</p><p><img src="/upload/06_abstract_02.png" alt="06_abstract_02.png"></p><p>这个时候的客户端调用是这样的（测试类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 得到 Intel 的 CPU</span></span><br><span class="line">        CPUFactory intelCPUFactory = <span class="keyword">new</span> IntelCPUFactory();</span><br><span class="line">        CPU cpu = intelCPUFactory.makeCPU();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到 AMD 的主板</span></span><br><span class="line">        MainBoardFactory mainBoardFactory = <span class="keyword">new</span> AmdMainBoardFactory();</span><br><span class="line">        MainBoard mainBoard = mainBoardFactory.makeMB();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 组装 CPU 和主板</span></span><br><span class="line">        Computer computer = <span class="keyword">new</span> Computer(cpu, mainBoard);</span><br><span class="line">        System.out.println(computer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体的完整代码可以看<a href="https://github.com/ZXZxin/ZXNotes/tree/master/%E6%9D%82%E9%A1%B9/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/factory" target="_blank" rel="noopener">这里</a></strong></p><p>单独看 CPU 工厂和主板工厂，它们分别是前面我们说的<strong>工厂模式</strong>。</p><p>这种方式也容易扩展，因为要给电脑加硬盘的话，只需要加一个 HardDiskFactory 和相应的实现即可，不需要修改现有的工厂。</p><p>但是，这种方式有一个问题，那就是如果 <strong>Intel 家产的 CPU 和 AMD 产的主板不能兼容使用</strong>，那么这代码就容易出错，因为客户端并不知道它们不兼容，也就会错误地出现随意组合。</p><p>下面就是我们要说的<strong>产品族</strong>的概念，它代表了组成某个产品的一系列附件的集合：</p><p><img src="/upload/06_abstract_03.png" alt="06_abstract_03.png"></p><p>当涉及到这种产品族的问题的时候，就需要抽象工厂模式来支持了。我们不再定义 CPU 工厂、主板工厂、硬盘工厂、显示屏工厂等等，<strong>我们直接定义电脑工厂，每个电脑工厂负责生产所有的设备，这样能保证肯定不存在兼容问题</strong>。</p><p><img src="/upload/06_abstract_04.png" alt="06_abstract_04.png"></p><p>这个时候，对于客户端来说，不再需要单独挑选 CPU厂商、主板厂商、硬盘厂商等，直接选择一家品牌工厂，品牌工厂会负责生产所有的东西，而且能保证肯定是兼容可用的。</p><p>改装的抽象工厂模式代码组织结构如下:</p><p><img src="/upload/06_abstract_05.png" alt="06_abstract_05.png"></p><p>主要的代码:</p><p>三个工厂:(一个超类工厂<code>PCFactory</code>，两个大厂工厂<code>AmdFactory</code>、<code>InterFactory</code>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PCFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">CPU <span class="title">makeCPU</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">MainBoard <span class="title">makeMB</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// HardDisk makeHD();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmdFactory</span> <span class="keyword">implements</span> <span class="title">PCFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CPU <span class="title">makeCPU</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AmdCPU();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MainBoard <span class="title">makeMB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AmdMainBoard();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntelFactory</span> <span class="keyword">implements</span> <span class="title">PCFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CPU <span class="title">makeCPU</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IntelCPU();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MainBoard <span class="title">makeMB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IntelMainBoard();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的测试类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 第一步就要选定一个“大厂”</span></span><br><span class="line">        PCFactory cf = <span class="keyword">new</span> AmdFactory();</span><br><span class="line">        <span class="comment">// 从这个大厂造 CPU</span></span><br><span class="line">        CPU cpu = cf.makeCPU();</span><br><span class="line">        <span class="comment">// 从这个大厂造主板</span></span><br><span class="line">        MainBoard board = cf.makeMB();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//... 从这个大厂造硬盘。等等</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将同一个厂子出来的 CPU、主板、硬盘组装在一起</span></span><br><span class="line">        Computer computer = <span class="keyword">new</span> Computer(cpu, board);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>当然，抽象工厂的问题也是显而易见的，比如我们要加个显示器，就需要修改所有的工厂，给所有的工厂都加上制造显示器的方法。这有点违反了<strong>对修改关闭，对扩展开放</strong>这个设计原则。</p><h1 id="三种工厂方法对比"><a href="#三种工厂方法对比" class="headerlink" title="三种工厂方法对比"></a>三种工厂方法对比</h1><p><img src="/upload/pasted-470.png" alt="06_abstract_03.png"><br><img src="/upload/pasted-472.png" alt="06_abstract_03.png"><br><img src="/upload/pasted-473.png" alt="06_abstract_03.png"><br><img src="/upload/pasted-474.png" alt="06_abstract_03.png"><br><img src="/upload/pasted-475.png" alt="06_abstract_03.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/upload/pasted-433.png&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL深入学习（3）【ID策略，横向扩展】</title>
    <link href="https://www.junglezero.top/2019/07/23/SQLDeepLearn3/"/>
    <id>https://www.junglezero.top/2019/07/23/SQLDeepLearn3/</id>
    <published>2019-07-23T00:58:56.000Z</published>
    <updated>2019-07-23T07:47:07.490Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img2.ali213.net/picfile/News/2015/05/14/2015051494057329.jpg" width="70%"><br><a id="more"></a></p><h1 id="ID策略"><a href="#ID策略" class="headerlink" title="ID策略"></a>ID策略</h1><ol><li><p>利用数据库自增ID<br>优点：最简单。 缺点：单点风险、单机性能瓶颈。</p></li><li><p>利用数据库集群并设置相应的步长（Flickr方案）<br>优点：高可用、ID较简洁。 缺点：需要单独的数据库集群。</p></li><li><p>Twitter Snowflake<br>优点：高性能高可用、易拓展。 缺点：需要独立的集群以及ZK。</p></li><li><p>一大波GUID、Random算法<br>优点：简单。 缺点：生成ID较长，有重复几率。</p></li></ol><h1 id="横向扩展MySQL服务器"><a href="#横向扩展MySQL服务器" class="headerlink" title="横向扩展MySQL服务器"></a>横向扩展MySQL服务器</h1><p>由多台MySQL服务器，提供数据存储服务器。<br>横向扩展是根本提升数据库服务器性能的手段！受限于单台计算机的硬件处理能力，去使用多台计算机完成同一个服务的支持。<br>比较典型的概念：<br>读写分离，负载均衡。<br>需要用到的技术，MySQL复制技术，负载均衡中间件。</p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。</p><ul><li>binlog 线程 ：负责将主服务器上的数据更改写入二进制文件（binlog）中。</li><li>I/O 线程 ：负责从主服务器上读取二进制日志文件，并写入从服务器的中继日志中。</li><li>SQL 线程 ：负责读取中继日志并重放其中的 SQL 语句。</li></ul><p><img src="/upload/pasted-453.png" alt="upload successful"></p><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>主服务器用来处理写操作以及实时性要求比较高的读操作，而从服务器用来处理读操作。<br>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个<br>服务器。<br>MySQL 读写分离能提高性能的原因在于：<br>主从服务器负责各自的读和写，极大程度缓解了锁的争用；<br>从服务器可以配置 MyISAM 引擎，提升查询性能以及节约系统开销；<br>增加冗余，提高可用性。</p><p><img src="/upload/pasted-452.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img2.ali213.net/picfile/News/2015/05/14/2015051494057329.jpg&quot; width=&quot;70%&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL深入研究（2）【查询优化，分区，分表】</title>
    <link href="https://www.junglezero.top/2019/07/21/QLDeepLearn/"/>
    <id>https://www.junglezero.top/2019/07/21/QLDeepLearn/</id>
    <published>2019-07-21T09:24:00.000Z</published>
    <updated>2019-07-23T07:10:10.234Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://images.ali213.net/picfile/pic/2017/10/27/927_2017102712122202.jpg" width="70%"><br><a id="more"></a></p><h1 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h1><h2 id="减少请求的数据量"><a href="#减少请求的数据量" class="headerlink" title="减少请求的数据量"></a>减少请求的数据量</h2><p>（一）只返回必要的列<br>最好不要使用 SELECT * 语句。<br>（二）只返回必要的行<br>使用 WHERE 语句进行查询过滤，有时候也需要使用 LIMIT 语句来限制返回的数据。<br>（三）缓存重复查询的数据<br>使用缓存可以避免在数据库中进行查询，特别要查询的数据经常被重复查询，缓存可以带来的查询性能提升将会是非常明显的。<br>若想要应用缓存，首先在my.ini或者my.cnf中配置query_cache_type，1表示默认缓存，需要sql_no_cache提示为不缓存，2表示默认不缓存，需要sql_cache主动缓存，0表示不缓存 。query_cache_size配置缓存大小<br>对于配置为2选项，若要进行缓存<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">SQL_CACHE</span> *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student</span><br></pre></td></tr></table></figure></p><p>调用reset query cache 可以清空缓存<br>当数据表改动时，基于整个表的缓存就会被删除<br>动态数据无法缓存</p><h2 id="重构查询方式"><a href="#重构查询方式" class="headerlink" title="重构查询方式"></a>重构查询方式</h2><h3 id="切分大查询"><a href="#切分大查询" class="headerlink" title="切分大查询"></a>切分大查询</h3><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。因此，可以把一个大范围操作切分为一个小范围操作<br>一个全范围的删除操作，可以切分为多个小段删除操作<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">messages</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">CREATE</span> &lt; <span class="keyword">DATE_SUB</span>(<span class="keyword">NOW</span>(), <span class="built_in">INTERVAL</span> <span class="number">3</span> <span class="keyword">MONTH</span>);</span><br></pre></td></tr></table></figure></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rows_affected = 0</span><br><span class="line"><span class="keyword">DO</span></span><br><span class="line">&#123; rows_affected = do_query (</span><br><span class="line"><span class="string">"DELETE FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 M</span></span><br><span class="line"><span class="string">ONTH) LIMIT 10000"</span></span><br><span class="line">) &#125;</span><br><span class="line"><span class="keyword">WHILE</span> rows_affected &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="分解大的连接查询"><a href="#分解大的连接查询" class="headerlink" title="分解大的连接查询"></a>分解大的连接查询</h3><ol start="2"><li>分解大连接查询<br>将一个大连接查询（JOIN）分解成对每一个表进行一次单表查询，然后将结果在应用程序中<br>进行关联，这样做的好处有：</li></ol><ul><li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li><li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li><li>减少锁竞争；</li><li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可扩展。</li><li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">tab</span><br><span class="line"><span class="keyword">JOIN</span> tag_post <span class="keyword">ON</span> tag_post.tag_id = tag.id</span><br><span class="line"><span class="keyword">JOIN</span> post <span class="keyword">ON</span> tag_post.post_id = post.id</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">tag.tag = <span class="string">'mysql'</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag <span class="keyword">WHERE</span> tag=<span class="string">'mysql'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag_post <span class="keyword">WHERE</span> tag_id=<span class="number">1234</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> post <span class="keyword">WHERE</span> post.id <span class="keyword">IN</span> (<span class="number">123</span>,<span class="number">456</span>,<span class="number">567</span>,<span class="number">9098</span>,<span class="number">8904</span>);</span><br></pre></td></tr></table></figure><h1 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>将一个表中的数据和索引，分散到不同的文件中进行存储，称之为分区操作，划分出来到文件就是不同的分区<br>分区的意义是将一个具有大量数据的表，将其分散到不同的数据和索引文件中进行储存<br>对于Innodb来说，相当于一个表对应对个ibd文件<br>分散之后，每个文件对应的数据量显著减少，保证单个文件的执行速度<br>一般情况就是根据id主键字段进行分区，或者为主键，唯一键的一个子集，在创建表时，利用partition进行设定<br>例如下面，就是利用id字段，使用hash算法，将数据分布在10个分区中<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t2 (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> auto_increment promary <span class="keyword">key</span>,</span><br><span class="line">col2 <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">col3 <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">col4 <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (col1),</span><br><span class="line"><span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> (col3)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">HASH</span>(<span class="keyword">id</span>)</span><br><span class="line"><span class="keyword">PARTITIONS</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure></p><p>分区完成后，客户端看上去还是一张表。</p><h2 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h2><p>range分区：基于一个给定的连续区间范围(区间要求连续并且不能重叠)，把数据分配到不同的分区<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t2 (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> auto_increment promary <span class="keyword">key</span>,</span><br><span class="line">col2 <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">col3 <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">pubtime <span class="built_in">INT</span> ,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>,pubtime),</span><br><span class="line"><span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> (col3)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>(pubtime)(</span><br><span class="line"><span class="keyword">PARTITION</span> p201907 <span class="keyword">VALUES</span> <span class="keyword">less</span> <span class="keyword">than</span> (<span class="number">1509665599</span>) <span class="comment">-- 某个时间的时间戳</span></span><br><span class="line"><span class="keyword">PARTITION</span> p201907 <span class="keyword">VALUES</span> <span class="keyword">less</span> <span class="keyword">than</span> (<span class="number">1512355599</span>) <span class="comment">-- 某个时间的时间戳</span></span><br><span class="line"><span class="keyword">PARTITION</span> p201907 <span class="keyword">VALUES</span> <span class="keyword">less</span> <span class="keyword">than</span> (<span class="number">1540765599</span>) <span class="comment">-- 某个时间的时间戳</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>条件只能用小于，更小的时间戳要放在前面<br>list分区：类似于range分区，区别在于list分区是居于枚举出的值列表分区，range是基于给定的连续区间范围分区，使用 in(值列表)<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t2 (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> auto_increment promary <span class="keyword">key</span>,</span><br><span class="line">col2 <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">col3 <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">status</span> <span class="built_in">INT</span> ,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>,pubtime),</span><br><span class="line"><span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> (col3)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>(<span class="keyword">status</span>)(</span><br><span class="line"><span class="keyword">PARTITION</span> p1 <span class="keyword">VALUES</span> <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>),</span><br><span class="line"><span class="keyword">PARTITION</span> p2 <span class="keyword">VALUES</span> <span class="keyword">in</span> (<span class="number">3</span>,<span class="number">4</span>),</span><br><span class="line"><span class="keyword">PARTITION</span> p3 <span class="keyword">VALUES</span> <span class="keyword">in</span> (<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>hash分区：基于给定的分区个数，把数据分配到不同的分区，采取的是求余方案，所谓hash算法，就是对于输入，得到某个特定的输出，要求如果输入相同的值应当得到相同的输出。这种算法在业务逻辑上表现为均匀分配<br>key分区：类似于hash分区，在hash中，只能对整数进行分区，但是key可以使用非整数类型进行分区（如字符串）</p><h2 id="分区管理"><a href="#分区管理" class="headerlink" title="分区管理"></a>分区管理</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除list或者range分区(同时删除分区对应的数据)</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> &lt;<span class="keyword">table</span>&gt; <span class="keyword">drop</span> <span class="keyword">partition</span> &lt;分区名称&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 新增分区</span></span><br><span class="line"><span class="comment">-- range添加新分区</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> &lt;<span class="keyword">table</span>&gt; <span class="keyword">add</span> <span class="keyword">partition</span>(<span class="keyword">partition</span> p4 <span class="keyword">values</span> <span class="keyword">less</span> <span class="keyword">than</span> MAXVALUE);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- list添加新分区</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> &lt;<span class="keyword">table</span>&gt; <span class="keyword">add</span> <span class="keyword">partition</span>(<span class="keyword">partition</span> p4 <span class="keyword">values</span> <span class="keyword">in</span> (<span class="number">25</span>,<span class="number">26</span>,<span class="number">28</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- hash重新分区</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> &lt;<span class="keyword">table</span>&gt; <span class="keyword">add</span> <span class="keyword">partition</span> <span class="keyword">partitions</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- key重新分区</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> &lt;<span class="keyword">table</span>&gt; <span class="keyword">add</span> <span class="keyword">partition</span> <span class="keyword">partitions</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 子分区添加新分区，虽然我没有指定子分区，但是系统会给子分区命名的</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> &lt;<span class="keyword">table</span>&gt; <span class="keyword">add</span> <span class="keyword">partition</span>(<span class="keyword">partition</span> p3 <span class="keyword">values</span> <span class="keyword">less</span> <span class="keyword">than</span> MAXVALUE);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- range重新分区</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> REORGANIZE <span class="keyword">PARTITION</span> p0,p1,p2,p3,p4 <span class="keyword">INTO</span> (<span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> MAXVALUE);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- list重新分区</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;<span class="keyword">table</span>&gt; REORGANIZE <span class="keyword">PARTITION</span> p0,p1,p2,p3,p4 <span class="keyword">INTO</span> (<span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在客户端程序不变的情况下，将服务器端的数据分布到不同的物理文件中，进而提供数据表的处理能力<br>当数据量比较大时，分区可以提升效率<br>且只有检索字段为分区字段时，分区效率才会明显提高</p><h1 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h1><p>如果一个表的每条记录的内容很大，那么就需要更多的IO操作，如果字段值比较大，而使用频率相对比较低，可以将大字段移到另一张表中，当查询不查大字段的时候，这样就减少了I/O操作<br>如果一个表的数据量很少，那么查询就很快；如果表的数据量非常非常大，那么查询就变的比较慢；也就是表的数据量影响这查询的性能。<br>表中的数据本来就有独立性，例如分别记录各个地区的数据或者不同时期的数据，特别是有些数据常用，而另外一些数据不常用。</p><p>通过应用程序，把数据划分到不同的表中存储，分表的操作会在客户端出现多张表<br>水平切分：<br><img src="/upload/pasted-450.png" alt="upload successful"><br>水平切分类似于分区，但是它是实实在在的把一个大表分成两个小表，可以根据某个查询值分块来把表水平切分</p><p>垂直切分：<br><img src="/upload/pasted-451.png" alt="upload successful"><br>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。 垂直分割一般用于拆分大字段和访问频率低的字段，分离冷热数据。</p><p>垂直分割适用于记录不是非常多的，但是字段却很多，这样占用空间比较大，检索时需要执行大量的I/O，严重降低了性能，这个时候需要把大的自读那拆分到另一个表中，并且该表与源表时一对一关系。<br>垂直拆分的优点： 可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。<br>垂直拆分的缺点： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://images.ali213.net/picfile/pic/2017/10/27/927_2017102712122202.jpg&quot; width=&quot;70%&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL深入研究（1）【字段设计，存储引擎介绍，锁机制，索引】</title>
    <link href="https://www.junglezero.top/2019/07/20/MySQLDeepLearn/"/>
    <id>https://www.junglezero.top/2019/07/20/MySQLDeepLearn/</id>
    <published>2019-07-19T23:24:42.000Z</published>
    <updated>2019-07-22T04:15:11.574Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.3dmgame.com/uploads/images/thumbpicfirst/20180830/1535616414_320863.jpg" width="70%"><br><a id="more"></a></p><h1 id="字段的设计"><a href="#字段的设计" class="headerlink" title="字段的设计"></a>字段的设计</h1><h2 id="优先使用符合业务需要的最小的数据类型"><a href="#优先使用符合业务需要的最小的数据类型" class="headerlink" title="优先使用符合业务需要的最小的数据类型"></a>优先使用符合业务需要的最小的数据类型</h2><p>1.比如ip地址，可以用无符号整型数直接储存（MySQL内置函数INET_ATON(字符串)和INTE_NTOA(整数)分别是把ip地址转换为整型和把整型转换为字符串）<br>2.对于非负数的存储，就没必要用一般的int形，用无符号就可以解决<br>3.不要用TEXT，BLOB，或者把他们都分离到单独的扩展表中<br>4.对于一些选择项，可以用数字代替原来的字符串</p><h2 id="用关联表替代枚举"><a href="#用关联表替代枚举" class="headerlink" title="用关联表替代枚举"></a>用关联表替代枚举</h2><p>枚举若发生改变，可能会对整张表造成影响，修改的思路是把性别抽离出来单独成一张关联表</p><h2 id="金额类型的存储"><a href="#金额类型的存储" class="headerlink" title="金额类型的存储"></a>金额类型的存储</h2><p>涉及到对精度的要求，应当用Decimal，另外的思路就是小金额大数据，用一个bigint存，这个思路就是消除小数点，消除关于精度的问题</p><h2 id="not-null"><a href="#not-null" class="headerlink" title="not null"></a>not null</h2><p>对于任何字段，应当尽量使其存储内容不为null，应当用数据域不会出现的某个值来替代。</p><h2 id="表中字段数量不宜过多"><a href="#表中字段数量不宜过多" class="headerlink" title="表中字段数量不宜过多"></a>表中字段数量不宜过多</h2><p>利用第三范式将表细化，减少表中字段数量</p><h2 id="表间关系设计"><a href="#表间关系设计" class="headerlink" title="表间关系设计"></a>表间关系设计</h2><p>利用合理的外键将表串联</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>只有很大内容上的需求采用text<br>字符串列的最大长度比平均长度大很多;列的更新很少（所以碎片不是问题）;使用了像UTF8这样的字符集（每个字符都使用不同的字节数进行存储）这个时候用varchar<br>很短，或者所有值都接近同一个长度（如MD5）;列经常变更，这个时候用char</p><h2 id="日期时间注意"><a href="#日期时间注意" class="headerlink" title="日期时间注意"></a>日期时间注意</h2><p>不要用字符串存储日期型数据，浪费空间<br>DATE能保存从1001到9999年，精度为秒，他把日期和时间封装到格式为YYYYMMDDHHMMSS的整数中，使用8字节<br>TIMESTAMP保存了从1970年以来的秒数，和Unix时间戳相同，只能保存1970到2038,使用4字节<br>FROM_UNIXTIME()和UNIX_TIMESTAMP()两个函数转换日期和Unix时间戳<br>通常用TIMESTAMP，空间效率高<br>MYSQL没有提供比秒更小粒度的日期和时间值，如果需要，可以用BIGINT存储微妙级别的时间戳，或用DOUBLE存储秒之后的小数部分</p><h1 id="数据引擎"><a href="#数据引擎" class="headerlink" title="数据引擎"></a>数据引擎</h1><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>MyISAM 设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操<br>作，则依然可以使用 MyISAM。<br>MyISAM 提供了大量的特性，包括压缩表、空间数据索引等。<br>不支持事务。<br>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加<br>排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入<br>（CONCURRENT INSERT）。<br>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数<br>据丢失，而且修复操作是非常慢的。<br>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据<br>写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应<br>的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成<br>索引损坏，需要执行修复操作</p><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>InnoDB 是 MySQL 默认的事务型存储引擎，只有在需要 InnoDB 不支持的特性时，才考虑使<br>用其它存储引擎。<br>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离<br>级别下，通过多版本并发控制（MVCC）+ 间隙锁（next-key locking）防止幻影读。<br>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的<br>提升。<br>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建<br>的自适应哈希索引、能够加速插入操作的插入缓冲区等。支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有<br>表的写入，而在读写混合场景中，停止写入可能也意味着停止读取</p><h1 id="MySQL的锁"><a href="#MySQL的锁" class="headerlink" title="MySQL的锁"></a>MySQL的锁</h1><p>MySQL的锁的初衷和java中的锁出发点是一样的，是计算机协调多个进程或线程并发访问某一资源的机制<br>在数据库中，除传统的 计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一 个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。</p><h2 id="一般描述"><a href="#一般描述" class="headerlink" title="一般描述"></a>一般描述</h2><p>MySQL不同的存储引擎所使用的锁的情况不太一样，但是大体分为三类：</p><ul><li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。 </li><li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。 </li><li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般<h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3>MyISAM主要采用的就是表锁，有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）。<br>对于这种读写锁分离设计，可以结合java的读写锁来进行理解<br>举例：当一个上了写锁时,其他读和写都会被阻塞<br><img src="/upload/pasted-431.png" alt="upload successful"></li></ul><p>当一个上了读锁时，和java中的有些区别：一个session使用LOCK TABLE命令给表film_text加了读锁，这个session可以查询锁定表中的记录，但更新或访问其他表都会提示错误；同时，另外一个session可以查询表中的记录，但更新就会出现锁等待。 </p><p><img src="/upload/pasted-436.png" alt="upload successful"></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作 （UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁</p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>MyISAM存储引擎有一个系统变量concurrent_insert，专门用以控制其并发插入的行为，其值分别可以为0、1或2。<br>当concurrent_insert设置为0时，不允许并发插入。<br>当concurrent_insert设置为1时，如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录。这也是MySQL的默认设置。<br>当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录。</p><p><img src="/upload/pasted-440.png" alt="upload successful"></p><h2 id="InnoDB锁"><a href="#InnoDB锁" class="headerlink" title="InnoDB锁"></a>InnoDB锁</h2><p>众所周知，Innodb支持事务<br>因此先了解下事务</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务是由一组sql语句组成的逻辑处理单元，具有ACID属性</p><p><img src="/upload/pasted-437.png" alt="upload successful"></p><ul><li>原子性（Actomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。</li><li>一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以操持完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。</li><li>隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。</li><li>持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。<br>实际上，这些特性并不是一种同级关系</li><li>只有满足一致性，事务的执行结果才是正确的。</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时要只要能满足原子性，就</li><li>一定能满足一致性。</li><li>在并发的情况下，多个事务并发执行，事务不仅要满足原子性，还需要满足隔离性，才能</li><li>满足一致性。事务满足持久化是为了能应对数据库奔溃的情况</li></ul><p><img src="/upload/pasted-438.png" alt="upload successful"></p><h3 id="事务并发的问题"><a href="#事务并发的问题" class="headerlink" title="事务并发的问题"></a>事务并发的问题</h3><p>和java中的并发一样，事务的并发也会带来读写的问题</p><ul><li>丢失更新(Lost Update)<br>由于事务之间是不知道彼此的存在的，因此当两个事务同时对同一个数据进行修改时，可能会发生先修改的数据被后修改的所覆盖的问题<br><img src="/upload/pasted-441.png" alt="upload successful"></li><li>脏读（Dirty Reads）：<br>一个事务正在对一条记录做修改，在这个事务并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做“脏读”。<br><img src="/upload/pasted-442.png" alt="upload successful"></li><li>不可重复读（Non-Repeatable Reads）：<br>一个事务在读取某些数据已经发生了改变、或某些记录已经被删除了！这种现象叫做“不可重复读”。<br><img src="/upload/pasted-443.png" alt="upload successful"></li><li>幻读（Phantom Reads）：<br>一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”</li></ul><p><img src="/upload/pasted-444.png" alt="upload successful"></p><h3 id="问题的解决"><a href="#问题的解决" class="headerlink" title="问题的解决"></a>问题的解决</h3><p>在并发事务处理带来的问题中，“更新丢失”通常应该是完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。</p><p>“脏读”、“不可重复读”和“幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。数据库实现事务隔离的方式，基本可以分为以下两种。</p><p>一种是在读取数据前，对其加锁，阻止其他事务对数据进行修改。<br>另一种是不用加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot），并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户的角度，好像是数据库可以提供同一数据的多个版本，因此，这种技术叫做数据多版本并发控制（ＭultiVersion Concurrency Control，简称MVCC或MCC），也经常称为多版本数据库。</p><p>在MVCC并发控制中，读操作可以分成两类：快照读 (snapshot read)与当前读 (current read)。快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。<br>在一个支持MVCC并发控制的系统中，哪些读操作是快照读？哪些操作又是当前读呢？以MySQL InnoDB为例：</p><ul><li><p>快照读：<br>简单的select操作，属于快照读，不加锁。(当然，也有例外)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ?;</span><br></pre></td></tr></table></figure></li><li><p>当前读：<br>特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。<br>下面语句都属于当前读，读取记录的最新版本。并且，读取之后，还需要保证其他并发事务不能修改当前记录，对读取记录加锁。其中，除了第一条语句，对读取记录加S锁 (共享锁)外，其他的操作，都加的是X锁 (排它锁)。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="keyword">values</span> (…);</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> <span class="keyword">set</span> ? <span class="keyword">where</span> ?;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ?;</span><br></pre></td></tr></table></figure></li></ul><p>为了解决“隔离”与“并发”的矛盾，ISO/ANSI SQL92定义了4个事务隔离级别，每个级别的隔离程度不同，允许出现的副作用也不同，应用可以根据自己的业务逻辑要求，通过选择不同的隔离级别来平衡 “隔离”与“并发”的矛盾。下表很好地概括了这4个隔离级别的特性</p><p><img src="/upload/pasted-445.png" alt="upload successful"></p><h3 id="InnoDB的行级锁"><a href="#InnoDB的行级锁" class="headerlink" title="InnoDB的行级锁"></a>InnoDB的行级锁</h3><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><ul><li>排它锁（Exclusive），简写为 X 锁，又称写锁。<br>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li><li>共享锁（Shared），简写为 S 锁，又称读锁。<br>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁</li></ul><h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p><ul><li>意向共享锁（IS）：事务打算给数据行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</li><li>意向排他锁（IX）：事务打算给数据行加排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</li></ul><p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务<br>对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。<br>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的<br>某个数据行上加 X 锁或 S 锁。有以下两个规定：</p><ul><li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li><li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。<br>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了<br>X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T<br>加 X 锁失败。<h4 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h4>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的 索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁 （Next-Key锁）。<br>利用这种锁可以解决幻读的问题，但是对于频繁插入的业务会造成严重的阻塞<br>比如以下例子</li></ul><p><img src="/upload/pasted-449.png" alt="upload successful"></p><h4 id="锁的使用"><a href="#锁的使用" class="headerlink" title="锁的使用"></a>锁的使用</h4><p>意向锁是InnoDB自动加的，不需用户干预。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁。<br>事务可以通过以下语句显式给记录集加共享锁或排他锁：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ... <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br></pre></td></tr></table></figure></p><h4 id="具体情况"><a href="#具体情况" class="headerlink" title="具体情况"></a>具体情况</h4><p>只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！<br>对一个没有创建索引的表进行查询</p><p><img src="/upload/pasted-446.png" alt="upload successful"><br>在上面的例子中，看起来session_1只给一行加了排他锁，但session_2在请求其他行的排他锁时，却出现了锁等待！原因就是在没有索引的情况下，InnoDB只能使用表锁</p><p>创建索引后<br><img src="/upload/pasted-447.png" alt="upload successful"></p><p>访问相同的索引并加锁就会阻塞</p><p><img src="/upload/pasted-448.png" alt="upload successful"></p><h1 id="MySQL的索引"><a href="#MySQL的索引" class="headerlink" title="MySQL的索引"></a>MySQL的索引</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>索引是一种可以加快数据查询速度的一种数据结构<br>虽然索引可以加快查询速度，提高 MySQL 的处理性能，但是过多地使用索引也会造成以下弊端：</p><ul><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li><li>除了数据表占数据空间之外，每一个索引还要占一定的物理空间。如果要建立聚簇索引，那么需要的空间就会更大。</li><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。<br>因此，索引的不能随便创建，应当结合具体情况具体分析</li></ul><p>根据数据结构划分，可以把索引划分为B树索引以及哈希索引</p><h2 id="B树索引"><a href="#B树索引" class="headerlink" title="B树索引"></a>B树索引</h2><p>这是比较常见的索引形式，是基于B树的数据结构，需要注意的就是这种索引遵循左边前缀原则，即索引的查找要从被选定为索引的最左边一列查询。<br>可以根据索引选择性判断是否需要创建索引<br>所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值：<br>Index Selectivity = Cardinality / #T<br>显然选择性的取值范围为(0, 1]，选择性越高的索引价值越大，这是由B+Tree的性质决定的。<br>有一种与索引选择性有关的索引优化策略叫做前缀索引，就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。<br>在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。(基于Innodb的聚集索引)</p><p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a><br>这篇文章讲的非常好</p><h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h2><p>哈希索引也称为散列索引或 HASH 索引。MySQL 目前仅有 MEMORY 存储引擎和 HEAP 存储引擎支持这类索引。其中，MEMORY 存储引擎可以支持 B- 树索引和 HASH 索引，且将 HASH 当成默认索引。<br>HASH 索引不是基于树形的数据结构查找数据，而是根据索引列对应的哈希值的方法获取表的记录行。哈希索引的最大特点是访问速度快，但也存在下面的一些缺点：</p><ul><li>MySQL 需要读取表中索引列的值来参与散列计算，散列计算是一个比较耗时的操作。也就是说，相对于 B- 树索引来说，建立哈希索引会耗费更多的时间。</li><li>不能使用 HASH 索引排序。</li><li>HASH 索引只支持等值比较，如“=”“IN()”或“&lt;=&gt;”。</li><li>HASH 索引不支持键的部分匹配，因为在计算 HASH 值的时候是通过整个索引值来计算的。</li></ul><h2 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h2><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查<br>找条件使用 MATCH AGAINST，而不是普通的 WHERE。<br>全文索引一般使用倒排索引实现，它记录着关键词到其所在文档的映射。<br>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p><h2 id="空间数据索引（R-tree）"><a href="#空间数据索引（R-tree）" class="headerlink" title="空间数据索引（R-tree）"></a>空间数据索引（R-tree）</h2><p>MyISAM 存储引擎支持空间数据索引，可以用于地理数据存储。空间数据索引会从所有维度<br>来索引数据，可以有效地使用任意维度来进行组合查询。<br>必须使用 GIS 相关的函数来维护数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.3dmgame.com/uploads/images/thumbpicfirst/20180830/1535616414_320863.jpg&quot; width=&quot;70%&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库SQL部分复习（4）【自定义函数，存储过程，触发器，依赖和三范式】</title>
    <link href="https://www.junglezero.top/2019/07/18/tabasereview4/"/>
    <id>https://www.junglezero.top/2019/07/18/tabasereview4/</id>
    <published>2019-07-18T14:13:28.000Z</published>
    <updated>2019-07-19T06:45:56.565Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/upload/pasted-279.png" width="70%"><br><a id="more"></a></p><h1 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>函数由一系列sql语句组成，调用函数就是一次性执行这些语句。所以函数可以降低语句重复。【但注意的是函数注重返回值，不注重执行过程，所以一些语句无法执行。所以函数并不是单纯的sql语句集合。】<br>函数只能返回单个值而不能返回一整个结果集。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> selectMAXgrade (sub <span class="built_in">VARCHAR</span>(<span class="number">10</span>)) <span class="keyword">RETURNS</span> <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DECLARE</span> c <span class="built_in">INT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">MAX</span>(grade)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">sc</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">cno = sub <span class="keyword">INTO</span> c;</span><br><span class="line"></span><br><span class="line">RETURN c;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">selectMAXgrade (<span class="string">'1001'</span>);</span><br></pre></td></tr></table></figure><h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p>存储过程是一组为了完成特定功能的 SQL 语句集合。使用存储过程的目的是将常用或复杂的工作预先用 SQL 语句写好并用一个指定名称存储起来，这个过程经编译和优化后存储在数据库服务器中，因此称为存储过程。当以后需要数据库提供与已定义好的存储过程的功能相同的服务时，只需调用“CALL存储过程名字”即可自动完成<br>存储过程有如下优点：<br>1) 封装性<br>存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的 SQL 语句，并且数据库专业人员可以随时对存储过程进行修改，而不会影响到调用它的应用程序源代码。<br>2) 可增强 SQL 语句的功能和灵活性<br>存储过程可以用流程控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。<br>3) 可减少网络流量<br>由于存储过程是在服务器端运行的，且执行速度快，因此当客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而可降低网络负载。<br>4) 高性能<br>存储过程执行一次后，产生的二进制代码就驻留在缓冲区，在以后的调用中，只需要从缓冲区中执行二进制代码即可，从而提高了系统的效率和性能。<br>5) 提高数据库的安全性和数据的完整性<br>使用存储过程可以完成所有数据库操作，并且可以通过编程的方式控制数据库信息访问的权限。</p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>找出给定的学科编号的考的90分以上的学生姓名<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">delimiter //</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> showOver90Stu (sub <span class="built_in">VARCHAR</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sno <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sno</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">sc</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">cno = sub</span><br><span class="line"><span class="keyword">AND</span> grade &gt; <span class="number">90</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">END</span> //</span><br><span class="line">    </span><br><span class="line"><span class="keyword">call</span> showOver90Stu(<span class="string">'1001'</span>)</span><br></pre></td></tr></table></figure></p><p>需要注意的是，在begin和end之间定义的sql结尾要加；，但是为了让语句不会提前运行，需要自定义终止字符，调用delimiter //，//表示希望作为终止符的符号。</p><h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><h2 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h2><p>MySQL 数据库中触发器是一个特殊的存储过程，不同的是执行存储过程要使用 CALL 语句来调用，而触发器的执行不需要使用 CALL 语句来调用，也不需要手工启动，只要一个预定义的事件发生就会被 MySQL自动调用</p><p>在实际使用中，MySQL 所支持的触发器有三种：INSERT 触发器、UPDATE 触发器和 DELETE 触发器。<br>1) INSERT 触发器<br>在 INSERT 语句执行之前或之后响应的触发器。<br>使用 INSERT 触发器需要注意以下几点：</p><ul><li>在 INSERT 触发器代码内，可引用一个名为 NEW（不区分大小写）的虚拟表来访问被插入的行。</li><li>在 BEFORE INSERT 触发器中，NEW 中的值也可以被更新，即允许更改被插入的值（只要具有对应的操作权限）。</li><li>对于 AUTO_INCREMENT 列，NEW 在 INSERT 执行之前包含的值是 0，在 INSERT 执行之后将包含新的自动生成值。</li></ul><p>2) UPDATE 触发器<br>在 UPDATE 语句执行之前或之后响应的触发器。<br>使用 UPDATE 触发器需要注意以下几点：</p><ul><li>在 UPDATE 触发器代码内，可引用一个名为 NEW（不区分大小写）的虚拟表来访问更新的值。</li><li>在 UPDATE 触发器代码内，可引用一个名为 OLD（不区分大小写）的虚拟表来访问 UPDATE 语句执行前的值。</li><li>在 BEFORE UPDATE 触发器中，NEW 中的值可能也被更新，即允许更改将要用于 UPDATE 语句中的值（只要具有对应的操作权限）。</li><li>OLD 中的值全部是只读的，不能被更新。</li></ul><p>3) DELETE 触发器<br>在 DELETE 语句执行之前或之后响应的触发器。<br>使用 DELETE 触发器需要注意以下几点：</p><ul><li>在 DELETE 触发器代码内，可以引用一个名为 OLD（不区分大小写）的虚拟表来访问被删除的行。</li><li>OLD 中的值全部是只读的，不能被更新。</li></ul><h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><p>当删除某个学生时，同时删除他的成绩等<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> deleteSc <span class="keyword">AFTER</span> <span class="keyword">DELETE</span> <span class="keyword">ON</span> student <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">sc</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sno = old.sno ;</span><br><span class="line"><span class="keyword">END</span> $$</span><br></pre></td></tr></table></figure></p><h1 id="依赖和三范式"><a href="#依赖和三范式" class="headerlink" title="依赖和三范式"></a>依赖和三范式</h1><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>设R(U)是一个属性集U上的关系模式，X和Y是U的子集。<br>若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等， 而在Y上的属性值不等， 则称 “X函数确定Y” 或  “Y函数依赖于X”。记作X→Y。<br>对于这个概念，可以这么理解：要是学号定了，确定了某个人，那么性别，姓名就都确定了</p><ul><li><p>平凡依赖和非平凡依赖<br><img src="/upload/pasted-432.png" alt="upload successful"><br>例如在sc中，<br>平凡函数依赖：(Sno, Cno) → Sno<br>非平凡依赖：(Sno, Cno) → Grade</p></li><li><p>完全依赖和部分依赖：<br><img src="/upload/pasted-434.png" alt="upload successful"><br>可以这么理解：只有全部的关系才能决定下一个属性，这就是完全依赖，如果其中一个就可以决定下一个属性，那么就是部分依赖<br>例如grade完全依赖于sno和cno，而由于sname依赖于sno，则sname部分依赖于sno和cno</p></li><li><p>传递依赖<br><img src="/upload/pasted-435.png" alt="upload successful"><br>比如对于关系，Std(Sno, Sdept, Mname)<br>sno决定sdept,sdept决定Mname,则相当于Mname传递依赖于sno</p></li></ul><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><h3 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h3><p>如果一个关系模式R的所有属性都是不可分的基本数据项，则R∈1NF。<br>意思是对于任意一个数据项，都能没有歧义存入数据库，比如说一个关系学生（学生信息），这就不满足第一范式</p><h3 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h3><p>若关系模式R∈1NF，并且每一个非主属性都完全函数依赖于R的码，则R∈2NF。<br>就是说只要主键确定了，别的数据项就都能确定了<br>对于关系scn(sno,cno,sname,grade)<br>grade对于主键(sno,cno)是完全依赖的，而sname对于（sno,cno）是部分依赖的，因此若要满足第二范式，则需要将原表拆成sc(sno,cno,grade),s(sno,sname)</p><h3 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h3><p><img src="/upload/pasted-439.png" alt="upload successful"><br>如S1（SNO，SNAME，DNO，DNAME，LOCATION） 各属性分别代表学号，姓名，所在系，系名称，系地址。<br>关系中存在传递依赖。即SNO -&gt; DNO。 而DNO -&gt; SNO却不存在，DNO -&gt; LOCATION, 因此关键字 SNO 对 LOCATION 函数决定是通过传递依赖 DNO -&gt; LOCATION 实现的。也就是说，SNO不直接决定非主属性LOCATION。<br>因此需要拆成两个关系<br>S（SNO，SNAME，DNO），D（DNO，DNAME，LOCATION）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/upload/pasted-279.png&quot; width=&quot;70%&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库SQL部分复习（3）【数据更新，视图，查询练习】</title>
    <link href="https://www.junglezero.top/2019/07/17/tabasereview/"/>
    <id>https://www.junglezero.top/2019/07/17/tabasereview/</id>
    <published>2019-07-17T11:29:36.000Z</published>
    <updated>2019-07-18T08:45:46.198Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/upload/pasted-430.png" width="70%"></p><a id="more"></a><h1 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h1><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>一般的插入<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SC (Sno,Cno)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">' 200215128 '</span> , <span class="string">' 1 '</span>)</span><br></pre></td></tr></table></figure></p><p>插入查询结果<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Deptage (Sdept, Avgage) <span class="keyword">SELECT</span></span><br><span class="line">Sdept,</span><br><span class="line"><span class="keyword">AVG</span>(Sage)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">Student</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">Sdept</span><br></pre></td></tr></table></figure></p><p>插入多条结果<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSERTINTO table_name (col_one, col_two)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">'c1'</span>, <span class="string">'c2'</span>),</span><br><span class="line">(<span class="string">'c3'</span>, <span class="string">'c4'</span>)</span><br></pre></td></tr></table></figure></p><p>这种方式只能在mysql里面写</p><h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><p>一般修改<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Student</span><br><span class="line"><span class="keyword">SET</span> Sage = <span class="number">22</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">Sno = <span class="string">' 200215121 '</span></span><br></pre></td></tr></table></figure></p><p>批量修改<br>若不设置条件，则是针对全部<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> sc</span><br><span class="line"><span class="keyword">SET</span> grade = grade + <span class="number">1</span></span><br></pre></td></tr></table></figure></p><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">S</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">Sno = <span class="string">'200215125'</span></span><br></pre></td></tr></table></figure><h1 id="视图（View）"><a href="#视图（View）" class="headerlink" title="视图（View）"></a>视图（View）</h1><p>视图是一个虚拟表，其内容由查询定义。同真实表一样，视图包含一系列带有名称的列和行数据，但视图并不是数据库真实存储的数据表。<br>视图是从一个、多个表或者视图中导出的表，包含一系列带有名称的数据列和若干条数据行。<br>视图并不同于数据表，它们的区别在于以下几点：</p><ul><li>视图不是数据库中真实的表，而是一张虚拟表，其结构和数据是建立在对数据中真实表的查询基础上的。</li><li>存储在数据库中的查询操作 SQL 语句定义了视图的内容，列数据和行数据来自于视图查询所引用的实际表，引用视图时动态生成这些数据。</li><li>视图没有实际的物理记录，不是以数据集的形式存储在数据库中的，它所对应的数据实际上是存储在视图所引用的真实表中的。</li><li>视图是数据的窗口，而表是内容。表是实际数据的存放单位，而视图只是以不同的显示方式展示数据，其数据来源还是实际表。</li><li>视图是查看数据表的一种方法，可以查询数据表中某些字段构成的数据，只是一些 SQL 语句的集合。从安全的角度来看，视图的数据安全性更高，使用视图的用户不接触数据表，不知道表结构。</li><li>视图的建立和删除只影响视图本身，不影响对应的基本表。</li></ul><h1 id="查询题目练习"><a href="#查询题目练习" class="headerlink" title="查询题目练习"></a>查询题目练习</h1><p>设有三个关系：<br>S(sno,sname,sex,age)<br>SC(sno,cno,grade)<br>C(cno,cname,teacher)</p><ol><li><p>查询LIU老师所授课程的课程号和课程名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">cno,</span><br><span class="line">cname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">C</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">teacher = <span class="string">'LIU'</span></span><br></pre></td></tr></table></figure></li><li><p>查询年龄大于23岁的男学生的学号和姓名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sno,</span><br><span class="line">sname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">S</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">age &gt; <span class="number">23</span></span><br><span class="line"><span class="keyword">AND</span> sex = <span class="string">'M'</span></span><br></pre></td></tr></table></figure></li><li><p>查询学号为S3学生所学课程的课程名与任课教师名<br>连接查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">cname,</span><br><span class="line">teacher</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">SC,</span><br><span class="line">C</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">SC.cno = C.cno</span><br><span class="line"><span class="keyword">AND</span> sno = <span class="string">'S3'</span></span><br></pre></td></tr></table></figure></li></ol><p>嵌套查询<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">cname,</span><br><span class="line">teacher</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">C</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">cno <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">cno</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">SC</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sno = <span class="string">'S3'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><ol start="4"><li>查询至少选修LIU老师所授课程中一门课程的女学生姓名<br>连接查询<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">S,</span><br><span class="line">SC,</span><br><span class="line">C</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">S.sno = SC.sno</span><br><span class="line"><span class="keyword">AND</span> SC.cno = C.cno</span><br><span class="line"><span class="keyword">AND</span> sex = <span class="string">'F'</span></span><br><span class="line"><span class="keyword">AND</span> teacher = <span class="string">'LIU'</span></span><br></pre></td></tr></table></figure></li></ol><p>嵌套查询<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">S</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sex = ‘F’</span><br><span class="line"><span class="keyword">AND</span> sno <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sno</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">SC</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">cno <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">cno</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">C</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">teacher = ‘LIU’</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><ol start="5"><li><p>查询WANG同学不学的课程的课程号<br>NOT EXISTS嵌套查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">cno</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">C</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">S,</span><br><span class="line">SC</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">S.sno = SC.sno</span><br><span class="line"><span class="keyword">AND</span> SC.cno = C.cno</span><br><span class="line"><span class="keyword">AND</span> sname = ‘WANG’</span><br><span class="line">)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>查询至少选修两门课的学生学号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sno</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">sno</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line"><span class="keyword">count</span>(*) &gt;= <span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>统计每门课程的学生选修人数（超过10人的课程才统计）。要求显示课程号和人数，查询结果按人数降序排列，若人数相同，按课程号升序排列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">cno,</span><br><span class="line"><span class="keyword">count</span>(sno)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">cno</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line"><span class="keyword">count</span>(*) &gt; <span class="number">10</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line"><span class="keyword">count</span>(sno) <span class="keyword">DESC</span>,</span><br><span class="line">cno</span><br></pre></td></tr></table></figure></li><li><p>求LIU老师所授课程的每门课程的平均成绩</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> C.cno,<span class="keyword">avg</span>(grade) </span><br><span class="line"><span class="keyword">from</span> SC,C</span><br><span class="line"><span class="keyword">where</span> SC.cno=C.cno </span><br><span class="line">    <span class="keyword">and</span> teacher=‘LIU’ </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> C.cno</span><br></pre></td></tr></table></figure></li><li><p>检索姓名以L打头的所有学生的姓名和年龄</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sname,</span><br><span class="line">age</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">S</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sname <span class="keyword">LIKE</span> <span class="string">'L%'</span></span><br></pre></td></tr></table></figure></li><li><p>求年龄大于所有女同学年龄的男学生姓名和年龄</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sname,</span><br><span class="line">age</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">S</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sex = ‘M’</span><br><span class="line"><span class="keyword">AND</span> age &gt; <span class="keyword">ALL</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">age</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">S</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sex = ‘F’</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/upload/pasted-430.png&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库SQL部分复习(2)【约束，数据类型，查询，连接查询，嵌套查询】</title>
    <link href="https://www.junglezero.top/2019/07/16/tabaseSQLReview-2/"/>
    <id>https://www.junglezero.top/2019/07/16/tabaseSQLReview-2/</id>
    <published>2019-07-16T08:22:35.000Z</published>
    <updated>2019-07-19T06:49:49.922Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/upload/pasted-427.png" width="70%"></p><a id="more"></a><hr><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><h2 id="模式（SCHEMA）-数据库（DATABASE）相关"><a href="#模式（SCHEMA）-数据库（DATABASE）相关" class="headerlink" title="模式（SCHEMA）,数据库（DATABASE）相关"></a>模式（SCHEMA）,数据库（DATABASE）相关</h2><p>MySQL官方文档指出，从概念上讲，模式是一组相互关联的数据库对象，如表，表列，列的数据类型，索引，外键等等。但是从物理层面上来说，模式与数据库是同义的。你可以在MySQL的SQL语法中用关键字SCHEMA替代DATABASE，例如使用CREATE SCHEMA来代替CREATE DATABASE。<br>也就是说，一个SCHEMA就是一套关系<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">SCHEMA</span> <span class="number">123</span></span><br></pre></td></tr></table></figure></p><p>就可以创建出一个新的数据库（DATABASE）</p><h2 id="表（TABLE）相关"><a href="#表（TABLE）相关" class="headerlink" title="表（TABLE）相关"></a>表（TABLE）相关</h2><h3 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h3><ul><li>主键约束（PRIMARY KEY)<br>主键约束是用来保证表中记录唯一可区分的列。一个表可以通过一列或列组合的数据来唯一标识表中的每一条记录。</li><li>唯一约束（UNIQUE)<br>规定一条记录的一个字段值或几个字段的组合值不得与其他记录的相同字段或字段组合的值重复，将这种限制成为“唯一约束”。</li><li>外键约束 (FOREIGN KEY)<br>1）外键列可以由是一个列或多个列组成。<br>2）外键列的取值可以为空，可以有重复值，但必须是它所引用列的列值之一。引用列必须是创建了主键约束或唯一约束的列。</li><li><p>检查约束 （CHECK)<br>检查约束是用来检查一个字段或多个字段的输入值是否满足指定的约束条件。</p></li><li><p>默认值约束（DEFAULT)<br>在用户定义数据类型的情况下，如果使用默认值约束，则默认值被插入到使用这个自定义数据的所有字段中。</p></li><li><p>空值约束（NULL)<br>空值约束就是指尚不知道或不确定的数据值，它不等同于0或空格。</p></li></ul><h3 id="数据库的基本数据类型（以MySQL为标准）"><a href="#数据库的基本数据类型（以MySQL为标准）" class="headerlink" title="数据库的基本数据类型（以MySQL为标准）"></a>数据库的基本数据类型（以MySQL为标准）</h3><h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><p>MySQL中提供了以下几种整数类型，可以设置自增约束</p><p><img src="/upload/pasted-414.png" alt="upload successful"><br>各个整数类型范围如下<br><img src="/upload/pasted-415.png" alt="upload successful"></p><h4 id="小数类型"><a href="#小数类型" class="headerlink" title="小数类型"></a>小数类型</h4><p>MySQL 中使用浮点数和定点数来表示小数。<br>浮点类型有两种，分别是单精度浮点数（FLOAT）和双精度浮点数（DOUBLE）；定点类型只有一种，就是 DECIMAL<br>两种类型都可以用（M,D）表示，其中M称为精度，表示总共的位数；D称为标度，表示小数的位数。<br>浮点数类型的取值范围为 M（1～255）和 D（1～30，且不能大于 M-2）DECIMAL 的默认 D 值为 0、M 值为 10<br> FLOAT 和 DOUBLE 在不指定精度时，默认会按照实际的精度（由计算机硬件和操作系统决定），DECIMAL 如果不指定精度，默认为（10，0）。<br> 不论是定点还是浮点类型，如果用户指定的精度超出精度范围，则会四舍五入进行处理。</p><p><img src="/upload/pasted-416.png" alt="upload successful"><br> 在 MySQL 中，定点数以字符串形式存储，在对精度要求比较高的时候（如货币、科学数据），使用 DECIMAL 的类型比较好，另外两个浮点数进行减法和比较运算时也容易出问题，所以在使用浮点数时需要注意，并尽量避免做浮点数比较。</p><h4 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h4><p>MySQL 中表示日期的数据类型：YEAR、TIME、DATE、DTAETIME、TIMESTAMP。当只记录年信息的时候，可以只使用 YEAR 类型。<br>当指定确定不合法的值时，系统将“零”值插入数据库中</p><p><img src="/upload/pasted-417.png" alt="upload successful"><br>对于YEAR,除了整数外也可以匹配形如YYYY的四位字符串或者两位字符串，对于两位的数字和字符串，0-69回转化为2001-2069，而70-99会转化为1970-1999<br>对于TIME,小时部分之所以会大出一部分的原因是可以用TIME表示某件事发展的时长，除了给定的格式外，可以用HHMMSS表示，但是对于这种输入，MySQL是从秒开始处理的。对于非法的输入，则储存0时间<br>对于DATE基本和上面有相似的规则，可以调用CURRENT_DATE 或者 NOW()，插入当前系统日期</p><p>DATETIME 在存储日期数据时，按实际输入的格式存储，即输入什么就存储什么，与时区无关；<br>TIMESTAMP 值的存储是以 UTC（世界标准时间）格式保存的，存储时对当前时区进行转换，检索时再转换回当前时区。即查询时，根据当前时区的不同，显示的时间值是不同的。</p><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p>MySQL 中的字符串类型有 CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、ENUM、SET 等。</p><p><img src="/upload/pasted-418.png" alt="upload successful"><br>char是定长字符串类型，即不管要储存的字符串多长，它只储存规定的长度，不管多短，会用空格补齐剩下的，而varchar是变长的，只能规定最大长度，其实际的储存空间为字符串占的空间+1（字符串结束标识）</p><p><img src="/upload/pasted-419.png" alt="upload successful"><br>ENUM是MySQL内的枚举类型，每个具体字符串对应一个索引值，ENUM 类型的字段在取值时，能在指定的枚举列表中获取，而且一次只能取一个。如果创建的成员中有空格，尾部的空格将自动被删除。ENUM 列总有一个默认值。如果将 ENUM 列声明为 NULL，NULL 值则为该列的一个有效值，并且默认值为 NULL。如果 ENUM 列被声明为 NOT NULL，其默认值为允许的值列表的第 1 个元素。<br>SET是一个加强版的枚举，可以选择多个值加入</p><h4 id="二进制类型"><a href="#二进制类型" class="headerlink" title="二进制类型"></a>二进制类型</h4><p>MySQL 中的二进制字符串有 BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。</p><p><img src="/upload/pasted-420.png" alt="upload successful"></p><h3 id="表的创建"><a href="#表的创建" class="headerlink" title="表的创建"></a>表的创建</h3><p>建立一个“学生选课”表SC，它由学号Sno、课程号Cno，修课成绩Grade组成，其中(Sno, Cno)为主码。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">(    Sno <span class="built_in">CHAR</span>(<span class="number">5</span>) ,</span><br><span class="line">     Cno <span class="built_in">CHAR</span>(<span class="number">3</span>) , </span><br><span class="line">     Grade   <span class="built_in">int</span>,</span><br><span class="line">     Primary <span class="keyword">key</span> (Sno, Cno),</span><br><span class="line">     <span class="keyword">Foreign</span> <span class="keyword">key</span> (sno) <span class="keyword">References</span> student (sno),</span><br><span class="line">     <span class="keyword">Foreign</span> <span class="keyword">key</span> (cno) <span class="keyword">References</span> course (cno)  );</span><br></pre></td></tr></table></figure><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="查询全部"><a href="#查询全部" class="headerlink" title="查询全部"></a>查询全部</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> STUDENT</span><br></pre></td></tr></table></figure><h3 id="查询某一列"><a href="#查询某一列" class="headerlink" title="查询某一列"></a>查询某一列</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sno <span class="keyword">FROM</span> STUDENT</span><br></pre></td></tr></table></figure><h3 id="查询经过计算结果"><a href="#查询经过计算结果" class="headerlink" title="查询经过计算结果"></a>查询经过计算结果</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title,</span><br><span class="line">price * <span class="number">50</span> <span class="keyword">AS</span> <span class="number">50</span>price</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film_list</span><br></pre></td></tr></table></figure><h3 id="利用case-when替换查询结果"><a href="#利用case-when替换查询结果" class="headerlink" title="利用case when替换查询结果"></a>利用case when替换查询结果</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title,</span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> price &gt; <span class="number">0.99</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="string">'ex'</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line"><span class="string">'chep'</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">AS</span> price</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film_list</span><br></pre></td></tr></table></figure><h3 id="利用CONCAT连接查询结果，利用cast转化结果"><a href="#利用CONCAT连接查询结果，利用cast转化结果" class="headerlink" title="利用CONCAT连接查询结果，利用cast转化结果"></a>利用CONCAT连接查询结果，利用cast转化结果</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">CONCAT</span>(title,<span class="string">'的票价是'</span>,<span class="keyword">CAST</span>(price <span class="keyword">AS</span> <span class="built_in">char</span>)) <span class="keyword">as</span> 价格说明</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film_list</span><br></pre></td></tr></table></figure><h3 id="查询结果返回大小写，字符串长度"><a href="#查询结果返回大小写，字符串长度" class="headerlink" title="查询结果返回大小写，字符串长度"></a>查询结果返回大小写，字符串长度</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">LOWER</span>(title),</span><br><span class="line"><span class="keyword">UPPER</span>(title),</span><br><span class="line"><span class="keyword">LENGTH</span>(title)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film_list</span><br></pre></td></tr></table></figure><h3 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h3><p>1、left(str,length) 从左边截取length<br>2、right(str,length)从右边截取length<br>3、substring(str,index)当index&gt;0从左边开始截取直到结束  当index&lt;0从右边开始截取直到结束  当index=0返回空<br>4、substring(str,index,len) 截取str,从index开始，截取len长度<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">left</span>(title,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film_list</span><br></pre></td></tr></table></figure></p><h3 id="日期相关函数"><a href="#日期相关函数" class="headerlink" title="日期相关函数"></a>日期相关函数</h3><p>now()获取当前的日期和时间<br>current_timestamp() 获取当前时间戳<br>date_format(date,format), time_format(time,format) 转换时间形式<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">DATE_FORMAT</span>(last_update, <span class="string">'%y%m%d%h%i%s'</span>) <span class="keyword">AS</span> <span class="string">'时间序列'</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br></pre></td></tr></table></figure></p><p>（日期、天数）转换函数：to_days(date), from_days(days)<br>（时间、秒）转换函数：time_to_sec(time), sec_to_time(seconds)<br>拼凑日期、时间函数：makdedate(year,dayofyear), maketime(hour,minute,second)<br>（Unix 时间戳、日期）转换函数</p><h3 id="集合，范围查询"><a href="#集合，范围查询" class="headerlink" title="集合，范围查询"></a>集合，范围查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> rating <span class="keyword">in</span> (<span class="string">'PG'</span>,<span class="string">'R'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">customer_id </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">payment</span><br><span class="line"><span class="keyword">where</span> payment_date <span class="keyword">BETWEEN</span> <span class="string">'2005-06-17 09:19:45'</span> <span class="keyword">and</span> <span class="string">'2005-08-02 18:55:15'</span></span><br></pre></td></tr></table></figure><p>注意 between是左闭右开的</p><h3 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h3><h4 id="Like-匹配"><a href="#Like-匹配" class="headerlink" title="Like 匹配"></a>Like 匹配</h4><p>1.%：表示任意0个或多个字符。可匹配任意类型和长度的字符，有些情况下若是中文，请使用两个百分号（%%）表示<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title <span class="keyword">LIKE</span> <span class="string">'%W%'</span></span><br></pre></td></tr></table></figure></p><p>若是要搜索包含某两个字的<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title <span class="keyword">LIKE</span> <span class="string">'%W%'</span> <span class="keyword">and</span> title <span class="keyword">LIKE</span> <span class="string">'%O%'</span></span><br></pre></td></tr></table></figure></p><p>2._： 表示任意单个字符。匹配单个任意字符<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title <span class="keyword">LIKE</span> <span class="string">'_O%'</span></span><br></pre></td></tr></table></figure></p><h4 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h4><p>^ 匹配字符开始的部分<br>查询以W开头的<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title REGEXP <span class="string">'^W'</span></span><br></pre></td></tr></table></figure></p><p>$ 匹配字符结束的部分<br>查询以S为结尾的部分<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title REGEXP <span class="string">'S$'</span></span><br></pre></td></tr></table></figure></p><p>. 匹配字符串中的任意一个字符，包括回车和换行<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title REGEXP <span class="string">'^W................S$'</span></span><br></pre></td></tr></table></figure></p><p>[字符集合]匹配字符集合中的任意字符<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title REGEXP <span class="string">'^W[OE]'</span></span><br></pre></td></tr></table></figure></p><p>[^字符集合]匹配除了字符集合外的任意字符<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title REGEXP <span class="string">'^W[^B-Z]'</span></span><br></pre></td></tr></table></figure></p><p>s1|s2|s3 匹配s1s2s3中的任意一个<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title REGEXP  <span class="string">'^WA|^WE|^WH'</span></span><br></pre></td></tr></table></figure></p><p>*代表多个该字符前的字符，包括0个或1个<br>+代表多个该字符前的字符，包括1个<br>字符串{N} 字符串出现N次<br>字符串{M，N}字符串最少出现M次，最多出现N次<br>若是查找的就是转义字符本身，最后要加上ESCAPE</p><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>使用GROUP BY 进行分组<br>将查询的结果按某一列或多列的值分组，值相等的<br>为一组<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">rating,<span class="keyword">COUNT</span>(rating)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> rating</span><br></pre></td></tr></table></figure></p><p>使用GROUP BY子句后，SELECT子句的列名列表中只能出现分组属性和集函数<br>若要想要对分完的组做条件筛选，则需要用Having而不是where<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">rating,<span class="keyword">COUNT</span>(rating)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> rating</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(rating)&gt;<span class="number">195</span><span class="string">`sql</span></span><br></pre></td></tr></table></figure></p><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>可以基于关系运算的连接来理解连接查询</p><ul><li><p>广义笛卡尔积（交叉连接）<br>又称非限制连接，它将两个表不加任何约束地组合在一起，也就是将第一个表中的所有记录分别与第二个表的所有记录组成新的记录。（进行广义笛卡尔乘积）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="string">`language`</span>.*,staff.*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line"><span class="string">`language`</span>,staff</span><br></pre></td></tr></table></figure></li><li><p>等值连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  student.Sno,Sname,sex,Cno,Grade</span><br><span class="line"><span class="keyword">FROM</span>     student,sc</span><br><span class="line"><span class="keyword">WHERE</span>  student.sno = sc.sno</span><br></pre></td></tr></table></figure></li></ul><p>任何子句中引用表1和表2中同名属性时，都必须加表名前缀。引用唯一属性名时可以加也可以省略表名前缀<br>也可以用内连接表示等值连接<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">student.Sno,</span><br><span class="line">Sname,</span><br><span class="line">sex,</span><br><span class="line">Cno,</span><br><span class="line">Grade</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> sc <span class="keyword">ON</span> student.sno = sc.sno</span><br></pre></td></tr></table></figure></p><ul><li><p>自然连接<br>是一种特殊的等值链接，在等值连接的基础上，去掉相同的属性</p></li><li><p>自然连接<br>自表的某个属性进行对比<br>例：查一门课的先修课</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  FIRST.Cno，SECOND.Cpno</span><br><span class="line"><span class="keyword">FROM</span>  Course  <span class="keyword">FIRST</span>，Course  <span class="keyword">SECOND</span></span><br><span class="line"><span class="keyword">WHERE</span> FIRST.Cpno = SECOND.Cno；</span><br></pre></td></tr></table></figure></li></ul><p><img src="/upload/pasted-424.png" alt="upload successful"></p><ul><li><p>外连接<br>外连接就是一种不等值连接，相比于等值连接只输出相等部分的连接情况，这种方式会输出所有的情况两边的所有情况，没有的值则用空替代<br>MySQL并不支持</p></li><li><p>左外连接<br>以左边的为基础，除了相等的部分，还会输出左边不符合条件的，空的地方用null装</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">student.Sno,</span><br><span class="line">Sname,</span><br><span class="line">sex,</span><br><span class="line">Cno,</span><br><span class="line">Grade</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student</span><br><span class="line"><span class="keyword">LEFT</span>  <span class="keyword">JOIN</span> sc <span class="keyword">ON</span> student.sno=sc.sno</span><br></pre></td></tr></table></figure></li></ul><p><img src="/upload/pasted-425.png" alt="upload successful"></p><ul><li>右外连接<br>则是以右边的为基础<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">student.Sno,</span><br><span class="line">Sname,</span><br><span class="line">sex,</span><br><span class="line">Cno,</span><br><span class="line">Grade</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student</span><br><span class="line"><span class="keyword">RIGHT</span>  <span class="keyword">JOIN</span> sc <span class="keyword">ON</span> student.sno=sc.sno</span><br></pre></td></tr></table></figure></li></ul><p><img src="/upload/pasted-426.png" alt="upload successful"></p><h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><p>嵌套查询就是把一些“出处”变成查询结果<br>对于MySQL，嵌套的查询结果要有别名<br>例如 查询与刘晨在一个系学习的学生<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sno,</span><br><span class="line">sname,</span><br><span class="line">sdept</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">s</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sdept <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sdept</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">s</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sname = <span class="string">'刘晨'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">s1.sno,</span><br><span class="line">s1.sname,</span><br><span class="line">s1.sdept</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">s s1,</span><br><span class="line">s s2</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">s1.sdept = s2.sdept</span><br><span class="line"><span class="keyword">AND</span> s2.sname = <span class="string">' 刘晨 '</span></span><br></pre></td></tr></table></figure><p>ANY和ALL<br>any是某一个值，all是所有值，可以大于小于不等于<br>例选择编号01同学的成绩中大于04同学所有科目的成绩的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">sname,</span><br><span class="line">cno,</span><br><span class="line">grade</span><br><span class="line">FROM</span><br><span class="line">(</span><br><span class="line">SELECT</span><br><span class="line">student.Sno,</span><br><span class="line">Sname,</span><br><span class="line">sex,</span><br><span class="line">Cno,</span><br><span class="line">Grade</span><br><span class="line">FROM</span><br><span class="line">student</span><br><span class="line">INNER JOIN sc ON student.sno = sc.sno</span><br><span class="line">) AS a</span><br><span class="line">WHERE</span><br><span class="line">grade &gt; ALL (</span><br><span class="line">SELECT</span><br><span class="line">grade</span><br><span class="line">FROM</span><br><span class="line">sc</span><br><span class="line">WHERE</span><br><span class="line">sno = &apos;01&apos;</span><br><span class="line">) </span><br><span class="line">AND sno = &apos;04&apos;</span><br></pre></td></tr></table></figure></p><p>EXISTS<br>首先要理解这个关键词的运行机制<br>例子：选出选了课程1001的人<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student <span class="keyword">as</span> a</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">EXISTS</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">sc</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sno = a.sno</span><br><span class="line"><span class="keyword">AND</span> cno = <span class="string">'1001'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>使用exist，会对where前面的主查询语句进行逐一校验，对于前面的某一条记录，如果能使exist后的查询语句有返回值（不是空），那么此时exist判定就是true，对于主查询，当前这一条就会作为结果，如果不符合，就不会被作为结果</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/upload/pasted-427.png&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库SQL部分复习（1）【关系模型，关系运算】</title>
    <link href="https://www.junglezero.top/2019/07/16/%E5%BA%93SQL%E9%83%A8%E5%88%86%E5%A4%8D%E4%B9%A0/"/>
    <id>https://www.junglezero.top/2019/07/16/库SQL部分复习/</id>
    <published>2019-07-16T01:47:14.000Z</published>
    <updated>2019-07-17T13:56:27.284Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/upload/pasted-429.png" width="70%"></p><a id="more"></a><hr><h1 id="实体联系模型（E-R）"><a href="#实体联系模型（E-R）" class="headerlink" title="实体联系模型（E-R）"></a>实体联系模型（E-R）</h1><p>实体型之间的联系：一对一联系（１：１）、一对多联系（１：N）、   多对多联系（Ｍ：Ｎ）<br>  例： 假设一个学生可选多门课程，而一门课程又有多个学生选修，每个学生每选一门课只有一个成绩， 一个教师只能讲一门课程，一门课程也可有多个教师讲授，一门课使用多本参考书。画出E－R图。</p><p><img src="/upload/pasted-393.png" alt="upload successful"></p><h1 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h1><p>在用户观点下，关系模型中数据的逻辑结构是一张二维表，它由行和列组成。</p><p><img src="/upload/pasted-392.png" alt="upload successful"><br>关系数据模型的数据结构</p><ul><li>关系（Relation）<br>通常指的是一张表</li><li>元组（Tuple）<br>表中的一行即为一个元组</li><li>属性(attribute)<br>一列即为一个属性</li><li>主码（key）<br>表中的某一个属性组，可以唯一确定一个元组</li><li>域（Domain）<br>属性的取值范围</li><li>分量<br>元组中的一个属性值<h1 id="数据库的三级模式结构"><a href="#数据库的三级模式结构" class="headerlink" title="数据库的三级模式结构"></a>数据库的三级模式结构</h1><h2 id="模式（Schema）"><a href="#模式（Schema）" class="headerlink" title="模式（Schema）"></a>模式（Schema）</h2></li></ul><p><img src="/upload/pasted-394.png" alt="upload successful"><br>模式（也称逻辑模式）<br>数据库中全体数据的逻辑结构和特征的描述<br>所有用户的公共数据视图，综合了所有用户的需求<br>一个数据库只有一个模式<br>模式的地位：是数据库系统模式结构的中间层<br>与数据的物理存储细节和硬件环境无关<br>与具体的应用程序、开发工具及高级程序设计语言无关<br>模式的定义：<br>数据的逻辑结构（数据项的名字、类型、取值范围等）<br>数据之间的联系<br>数据有关的安全性、完整性要求</p><h3 id="外模式-External-Schema"><a href="#外模式-External-Schema" class="headerlink" title="外模式(External Schema)"></a>外模式(External Schema)</h3><p>外模式（也称子模式或用户模式）<br>数据库用户（包括应用程序员和最终用户）使用的局部数据的逻辑结构和特征的描述<br>数据库用户的数据视图，是与某一应用有关的数据的逻辑表示<br>模式与外模式的关系：一对多<br>通常是模式的子集；一个数据库可以有多个外模式<br>外模式与应用的关系：一对多<br>同一外模式可以为某一用户的多个应用系统所使用，<br>但一个应用程序只能使用一个外模式<br>外模式是保证数据库安全性的一个有力措施<br>每个用户只能看见和访问所对应的外模式中的数据</p><h3 id="内模式（Internal-Schema）"><a href="#内模式（Internal-Schema）" class="headerlink" title="内模式（Internal Schema）"></a>内模式（Internal Schema）</h3><p>是数据物理结构和存储方式的描述<br>是数据在数据库内部的表示方式<br>记录的存储方式（顺序存储，按照B树结构存储，按hash方法存储）/ 索引的组织方式 / 数据是否压缩存储 / 数据是否加密 / 数据存储记录结构的规定<br>一个数据库只有一个内模式</p><h1 id="关系模型和关系"><a href="#关系模型和关系" class="headerlink" title="关系模型和关系"></a>关系模型和关系</h1><p>关系模型的数据结构非常简单，只包含单一的数据结构—-关系。在关系模型中，实体和实体间的各种联系都用关系表示。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>域（Domain）<br>一组具有相同数据类型的值的集合</li><li>笛卡尔积（Cartesian Product）<br><img src="/upload/pasted-395.png" alt="upload successful"></li></ul><p><img src="/upload/pasted-396.png" alt="upload successful"><br>笛卡尔积的每一个结果(d1,d2,d3,d4)被称为元组（Tuple）;<br>笛卡尔积的每一个结果中的具体的值di叫做一个分量（Component）<br>笛卡尔积做出的结果的元组数是基数（Cardinal number）</p><ul><li>关系<br><img src="/upload/pasted-397.png" alt="upload successful"></li><li>属性<br>每列的名字</li><li>码<ul><li>候选码（Candidate key）<br>若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选码<br>在最简单的情况下，候选码只包含一个属性。<br>在最极端的情况下，关系模式的所有属性组是这个关系模式的候选码，称为全码（All-key）</li><li>主码<br>若一个关系有多个候选码，则选定其中一个为主码（Primary key）<br>侯选码的诸属性称为主属性（Prime attribute）。<br>不包含在任何侯选码中的属性称为非码属性（Non-key attribute） </li></ul></li></ul><h2 id="三类关系"><a href="#三类关系" class="headerlink" title="三类关系"></a>三类关系</h2><p><img src="/upload/pasted-398.png" alt="upload successful"></p><h2 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h2><p><img src="/upload/pasted-399.png" alt="upload successful"></p><p><img src="/upload/pasted-400.png" alt="upload successful"></p><h2 id="关系的基本运算"><a href="#关系的基本运算" class="headerlink" title="关系的基本运算"></a>关系的基本运算</h2><p>设两个关系R,S：有相同的目n，相应的属性取自同一个域</p><ul><li>选择</li></ul><p><img src="/upload/pasted-406.png" alt="upload successful"></p><p><img src="/upload/pasted-407.png" alt="upload successful"></p><ul><li>投影</li></ul><p><img src="/upload/pasted-408.png" alt="upload successful"></p><ul><li>并<br>R∪S = { t|t Î R∨t ÎS }</li></ul><p><img src="/upload/pasted-402.png" alt="upload successful"></p><ul><li>差<br>R -S = { t|tÎR∧tÏS }<br><img src="/upload/pasted-403.png" alt="upload successful"></li><li>笛卡尔积</li></ul><p><img src="/upload/pasted-404.png" alt="upload successful"></p><p><img src="/upload/pasted-405.png" alt="upload successful"></p><ul><li>交<br>R∩S = { t|t Î R∧t ÎS }<br>R∩S = R –(R-S）</li><li>连接<br><img src="/upload/pasted-409.png" alt="upload successful"><br><img src="/upload/pasted-410.png" alt="upload successful"><br>有两类连接，包括等值连接和自然连接<br>等值连接<br><img src="/upload/pasted-411.png" alt="upload successful"><br>自然连接<br><img src="/upload/pasted-412.png" alt="upload successful"><br>相当于是一种合并<br><img src="/upload/pasted-413.png" alt="upload successful"></li></ul><h2 id="实体完整性（Entity-Integrity）"><a href="#实体完整性（Entity-Integrity）" class="headerlink" title="实体完整性（Entity Integrity）"></a>实体完整性（Entity Integrity）</h2><p>若属性A是基本关系R的主属性，则属性A不能取空值</p><h2 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h2><p>设F是基本关系R的一个或一组属性，但不是关系R的码。如果F与基本关系S的主码Ks相对应，则称F是基本关系R的外码，基本关系R称为参照关系（Referencing Relation）<br>基本关系S称为被参照关系（Reference Relation）或目标关系（Target  Relation）<br>若属性（或属性组）F是基本关系R的外码<br>它与基本关系S的主码Ks相对应（基本关<br>系R和S不一定是不同的关系），则对<br>于R中每个元组在F上的值必须为：<br>· 或者取空值（F的每个属性值均为空值）<br>· 或者等于S中某个元组的主码值。</p><p><img src="/upload/pasted-401.png" alt="upload successful"><br>用人话来说，就是外键不能是自己造出来的</p><h2 id="关系代数运算题目实例"><a href="#关系代数运算题目实例" class="headerlink" title="关系代数运算题目实例"></a>关系代数运算题目实例</h2><p>设教学数据库有3个关系<br>学生关系 S（Sno，Sname，age，sex）<br>成绩关系 SC（Sno，Cno，grade）<br>课程关系 C（Cno，Cname，teacher）</p><ol><li>LIU老师所教授课程的课程号，课程名<br>∏CNO,CNAME(σTNAME=‘LIU’ （C））</li><li>检索年龄大于23岁的男学生的学号和姓名<br>∏SNO,SNAME（ σ AGE&gt;23 ∧ SEX=‘M’（S））</li><li>检索学号为S3学生所学课程的课程名与任课老师名<br> ∏CNAME,TNAME（ σ SNO=‘S3’（SC）∞(C)）</li><li>检索至少选修LIU老师所教授课程中一门课的女学生姓名<br>  ∏SNAME(σSEX=‘F’(S)∞SC∞σTNAME=‘LIU’(C))</li><li>检索wang同学不学课程的课程号<br> ∏CNO(C)-∏CNO(σSNAME=‘WANG’(S)∞SC)</li><li>检索至少选修两门课的学生学号<br>∏1(σ1=4 ∧ 2!=5(SC × SC))</li><li>检索全部学生都选修的课程的课程号和课程名<br> ∏CNO,CNAME,SNO(C ∞SC) ÷ ∏SNO(S)</li><li>检索选修课程包含LIU老师所教授课程的学生学号<br>∏CNO,SNO(SC) ÷ ∏CNO(σTNAME=‘LIU’(C))</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/upload/pasted-429.png&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java多线程学习8（线程池，阻塞队列（BlockingQueue）FutureTask,Callable）</title>
    <link href="https://www.junglezero.top/2019/07/12/va-mitple-thread8/"/>
    <id>https://www.junglezero.top/2019/07/12/va-mitple-thread8/</id>
    <published>2019-07-12T12:21:40.000Z</published>
    <updated>2019-07-17T13:54:47.374Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/upload/pasted-428.png" width="70%"></p><a id="more"></a><hr><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2><h3 id="框架简介"><a href="#框架简介" class="headerlink" title="框架简介"></a>框架简介</h3><p><img src="/upload/pasted-367.png" alt="upload successful"><br>而具体说来，Executor是一个接口，对于这个接口，API文档是这样描述的。</p><blockquote><p>An object that executes submitted Runnable tasks. This interface provides a way of decoupling task submission from the mechanics of how each task will be run, including details of thread use, scheduling, etc. An Executor is normally used instead of explicitly creating threads.</p></blockquote><p>第一句话强调了这个的用法就是提交任务，并通过Executor来运行，可以用Executor来替代显示的调用Thread，把实现任务的细节封装。<br>对于该接口，可以直接在调用线程运行任务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirectExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    r.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一般则是另起线程运行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以构造一个组件化的Executor,把任务的执行序列化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前类继承一个Executor</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Queue&lt;Runnable&gt; tasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</span><br><span class="line">   <span class="keyword">final</span> Executor executor;</span><br><span class="line">   Runnable active;</span><br><span class="line"></span><br><span class="line">   SerialExecutor(Executor executor) &#123;</span><br><span class="line">     <span class="keyword">this</span>.executor = executor;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</span><br><span class="line">     tasks.offer(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">           r.run();</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           scheduleNext();</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="keyword">if</span> (active == <span class="keyword">null</span>) &#123;</span><br><span class="line">       scheduleNext();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> ((active = tasks.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">       executor.execute(active);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>说来说去，Executor不过是提供了一个接口，一种线程服务的思路，具体的线程复杂操作还是要看他的各个实现类<br>和继承接口</p><p><img src="/upload/pasted-368.png" alt="upload successful"><br>这才是整个Executor的体系框架</p><h2 id="BlockingQueue（阻塞队列）"><a href="#BlockingQueue（阻塞队列）" class="headerlink" title="BlockingQueue（阻塞队列）"></a>BlockingQueue（阻塞队列）</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>所谓阻塞队列，就是比一般队列多了两个操作的队列</p><p><img src="/upload/pasted-370.png" alt="upload successful"></p><p><img src="/upload/pasted-371.png" alt="upload successful"></p><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><h3 id="七个属性"><a href="#七个属性" class="headerlink" title="七个属性"></a>七个属性</h3><p> 结合自已以前实现的一个<a href="https://www.junglezero.top/2019/04/02/%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/">线程池</a>，对于其大概的属性已经有了初步了解。<br> 从ThreadPoolExecutor的构造函数开始看起，有四个重载的构造函数，找到其中参数最多的那个</p><p><img src="/upload/pasted-369.png" alt="upload successful"><br>和以前自己的实现的思路基本差不多：<br>核心线程数量、最大线程数量、多余线程存活时间（相比于核心线程多出来的线程在空闲时的存活时间）、时间单位、任务队列(阻塞队列)、线程工厂方法、拒绝策略</p><p>可以用以下的测试理解这几个属性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> TestMain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor= (ThreadPoolExecutor) buildThreadPool();</span><br><span class="line">        <span class="keyword">int</span> activeCount=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> queueSize=-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//线程池执行一个任务（Runable）</span></span><br><span class="line">        threadPoolExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                DoingJobs(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程池执行两个任务（Runable）</span></span><br><span class="line">        threadPoolExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                DoingJobs(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//。。。</span></span><br><span class="line">        <span class="comment">//当活跃线程数量发生改变时输出</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (activeCount!=threadPoolExecutor.getActiveCount()||queueSize!=threadPoolExecutor.getQueue().size())&#123;</span><br><span class="line">                System.out.println(<span class="string">"线程池中活跃线程数量："</span>+threadPoolExecutor.getActiveCount());</span><br><span class="line">                System.out.println(<span class="string">"核心线程数量（固定的）："</span>+threadPoolExecutor.getCorePoolSize());</span><br><span class="line">                System.out.println(<span class="string">"任务队列中等待执行的任务数量："</span>+threadPoolExecutor.getQueue().size());</span><br><span class="line">                activeCount=threadPoolExecutor.getActiveCount();</span><br><span class="line">                queueSize=threadPoolExecutor.getQueue().size();</span><br><span class="line">                System.out.println(<span class="string">"================================"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">buildThreadPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//核心线程数为1，最大线程池为2，存活时间为10s，阻塞队列（任务队列）的大小为1</span></span><br><span class="line">        ExecutorService executorService=<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                Thread t=<span class="keyword">new</span> Thread(r);</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">        System.out.println(<span class="string">"线程池创建成功！"</span>);</span><br><span class="line">        <span class="keyword">return</span> executorService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用Sleep来模拟线程运行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoingJobs</span><span class="params">(<span class="keyword">long</span> seconds)</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"正在执行任务"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(seconds);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当任务为1个时</p><p><img src="/upload/pasted-373.png" alt="upload successful"></p><p>当任务为2时</p><p><img src="/upload/pasted-372.png" alt="upload successful"><br>可以发现，当任务为2时，线程池并没有创建新的线程，因为任务可以在队列中等待</p><p>当任务为3时，此时把测试方法中的活跃线程数量改为线程池大小（线程中线程的数量）</p><p><img src="/upload/pasted-374.png" alt="upload successful"><br>可以发现，当任务队列慢的时候，再有新的任务加入，线程池就会根据最大线程数量创建新的线程共同执行任务，当任务队列中没有任务时，过了存回时间，多创建出的线程就会被销毁。</p><p>当任务有4个时</p><p><img src="/upload/pasted-375.png" alt="upload successful"><br>此时多出一个任务，无法进入阻塞队列，也无法执行，拒绝策略生效。</p><h2 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h2><p>线程池的关闭涉及到三个方法</p><p><img src="/upload/pasted-376.png" alt="upload successful"></p><p><img src="/upload/pasted-377.png" alt="upload successful"></p><p><img src="/upload/pasted-378.png" alt="upload successful"><br>通过测试可以发现<br>shutdown方法：平滑的关闭ExecutorService，当此方法被调用时，ExecutorService停止接收新的任务并且等待已经提交的任务（包含提交正在执行和提交未执行）执行完成。<br>当所有已提交任务执行完毕，线程池即被关闭。<br>awaitTermination方法：接收timeout和unit两个参数，用于设定超时时间及单位。当等待超过设定时间时，会监测ExecutorService是否已经关闭，<br>若关闭则返回true，否则返回false。一般情况下会和shutdown方法组合使用。<br>shutdown调用后，不可以再submit新的task，已经submit的将继续执行。<br>shutdownNow试图停止当前正执行的task，并返回尚未执行的task的list</p><p>因此最好的关闭线程池的方式是shutdown+awaitTermination</p><h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><p>Executors是一个工厂类<br>其中包括了许多关于线程池及Executors框架相关的创建方法<br>毕竟拿七个参数创建一个线程池太复杂了<br><img src="/upload/pasted-379.png" alt="upload successful"></p><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><blockquote><p>Creates a thread pool that creates new threads as needed, but will reuse previously constructed threads when they are available. These pools will typically improve the performance of programs that execute many short-lived asynchronous tasks. Calls to execute will reuse previously constructed threads if available. If no existing thread is available, a new thread will be created and added to the pool. Threads that have not been used for sixty seconds are terminated and removed from the cache. Thus, a pool that remains idle for long enough will not consume any resources. Note that pools with similar properties but different details (for example, timeout parameters) may be created using ThreadPoolExecutor constructors.</p></blockquote><p>这种线程池的特点就是按照需求创建线程以处理更多的耗时短的异步任务<br>看其具体实现就可以知道<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，这个线程池一开始核心线程就是0，最大线程数量却相当于没有限制，存活时间为1分钟，这就很好的印证了按需分配创建线程的思路。而关键还是在这个阻塞队列上<br>SynchronousQueue是一种很特殊的阻塞队列，其中每个 put 必须等待一个 take，否则会进入wait状态反之亦然。同步队列没有任何内部容量，甚至连一个队列的容量都没有。<br>使用完成后不需要显示的调用shotdown<br>注意：仅适合周期短的多任务，因为创建线程的数量是没用限制的</p><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顾名思义，这是一种固定线程数量的线程池，不会额外去创建，阻塞队列采用LinkedBlockingQueue,是以链表为内核实现的阻塞队列，默认大小为Integar.Max<br>使用完成后需要shutdown</p><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">    (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                            <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br></pre></td></tr></table></figure><p>这个实际上就是newFixedThreadPool线程数量设置为1的时候</p><h3 id="newWorkStealingPool"><a href="#newWorkStealingPool" class="headerlink" title="newWorkStealingPool"></a>newWorkStealingPool</h3><p>这是在1.8新出的一种线程池服务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">        (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种服务是根据cpu个数创建的ForkJoinPool,根据前面讲的，ForkJoinPool中执行的是ForkJoinTask，Runable是不行的<br>看源码可以知道，传入Runable以后，会执行一个内部的转换</p><p>这种线程数量的确定和创建时是根据电脑根据cpu个数创建的（等于）<br>工作窃取概念：所谓工作窃取，指的是闲置的线程去处理本不属于它的任务。<br>每个处理器核，都有一个队列存储着需要完成的任务。对于多核的机器来说，当一个核对应的任务处理完毕后，就可以去帮助其他的核处理任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    ForkJoinTask&lt;?&gt; job;</span><br><span class="line">    <span class="keyword">if</span> (task <span class="keyword">instanceof</span> ForkJoinTask&lt;?&gt;) <span class="comment">// avoid re-wrap</span></span><br><span class="line">        job = (ForkJoinTask&lt;?&gt;) task;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        job = <span class="keyword">new</span> ForkJoinTask.RunnableExecuteAction(task);</span><br><span class="line">    externalSubmit(job);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在用Callable来执行（线程的第三种实现方法）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorsTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService =Executors.newWorkStealingPool();</span><br><span class="line">        System.out.println(executorService.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">         <span class="comment">//这里可以先把Callable当成是有返回值的Runable</span></span><br><span class="line">        List&lt;Callable&lt;String&gt;&gt; callables=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> ( ;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">            Callable&lt;String&gt; callable=<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="comment">//call方法就相当于Run方法</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                    sleep(<span class="number">2</span>);</span><br><span class="line">                    <span class="comment">//可以有返回值</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"任务被"</span>+Thread.currentThread().getName();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">             callables.add(callable);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//批量运行，且将返回运行结果Future</span></span><br><span class="line">            List&lt;Future&lt;String&gt;&gt; futures=executorService.invokeAll(callables);</span><br><span class="line">            <span class="comment">//若是没有执行完，这里会是堵塞的</span></span><br><span class="line">            <span class="keyword">for</span> (Future f:futures)&#123;</span><br><span class="line">                System.out.println(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> seconds)</span></span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           TimeUnit.SECONDS.sleep(seconds);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><p><img src="/upload/pasted-381.png" alt="upload successful"><br>可以发现，这种线程池服务也是自动退出的</p><h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor。它主要用来在给定的延迟之后运行任务，或者定期执行任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolExecutorDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个实现了Runable的时间任务类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String id;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TimerTask</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        ScheduledExecutorService ses = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//调用scheduleAtFixedRate来进行周期执行，拿第一个来说，开始时延是200ms，周期为1000ms</span></span><br><span class="line">        ScheduledFuture sfa = ses.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask(<span class="string">"a"</span>), <span class="number">200</span>,</span><br><span class="line">                                                    <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        ScheduledFuture sfb = ses.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask(<span class="string">"b"</span>), <span class="number">400</span>, </span><br><span class="line">                                                    <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        ScheduledFuture sfc = ses.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask(<span class="string">"c"</span>), <span class="number">600</span>,</span><br><span class="line">                                                    <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        ScheduledFuture sfd = ses.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask(<span class="string">"d"</span>), <span class="number">800</span>, </span><br><span class="line">                                                    <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        sfa.cancel(<span class="keyword">true</span>);</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        ses.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程运行时发生错误的处理"><a href="#线程运行时发生错误的处理" class="headerlink" title="线程运行时发生错误的处理"></a>线程运行时发生错误的处理</h2><p>一般情况下，可以<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread t=<span class="keyword">new</span> Thread();</span><br><span class="line">t.setUncaughtExceptionHandler(<span class="keyword">new</span> Thread.UncaughtExceptionHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(t.getName()+<span class="string">"运行时发生错误~！"</span>);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>如果线程的实现不是自己定义的<br>如果是=自己定义的，则可以定义内部方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Error</span><span class="params">(Throwable e)</span></span>&#123;</span><br><span class="line">     System.out.println(<span class="string">"当前线程发生错误"</span>);</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="拒绝策略细节"><a href="#拒绝策略细节" class="headerlink" title="拒绝策略细节"></a>拒绝策略细节</h2><h3 id="ThreadPoolExecutor-AbortPolicy"><a href="#ThreadPoolExecutor-AbortPolicy" class="headerlink" title="ThreadPoolExecutor.AbortPolicy()"></a>ThreadPoolExecutor.AbortPolicy()</h3><p>这个策略中，不能执行且不能进入阻塞队列的任务会直接被抛出异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p><img src="/upload/pasted-382.png" alt="upload successful"></p><h3 id="new-ThreadPoolExecutor-DiscardPolicy"><a href="#new-ThreadPoolExecutor-DiscardPolicy" class="headerlink" title="new ThreadPoolExecutor.DiscardPolicy()"></a>new ThreadPoolExecutor.DiscardPolicy()</h3><p>这个拒绝策略则不会做出任何事</p><h3 id="ThreadPoolExecutor-CallerRunsPolicy"><a href="#ThreadPoolExecutor-CallerRunsPolicy" class="headerlink" title="ThreadPoolExecutor.CallerRunsPolicy()"></a>ThreadPoolExecutor.CallerRunsPolicy()</h3><p>这个策略会在execute 方法的调用线程中运行被拒绝的任务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line"></span><br><span class="line">               r.run();</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><p><img src="/upload/pasted-383.png" alt="upload successful"></p><h3 id="ThreadPoolExecutor-DiscardOldestPolicy"><a href="#ThreadPoolExecutor-DiscardOldestPolicy" class="headerlink" title="ThreadPoolExecutor.DiscardOldestPolicy()"></a>ThreadPoolExecutor.DiscardOldestPolicy()</h3><p>这个方法会把阻塞队列的队尾元素去除，然后执行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line"></span><br><span class="line">        e.getQueue().poll();</span><br><span class="line"></span><br><span class="line">        e.execute(r);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="ExecutorService-几个其他方法"><a href="#ExecutorService-几个其他方法" class="headerlink" title="ExecutorService 几个其他方法"></a>ExecutorService 几个其他方法</h2><h3 id="invokeAny"><a href="#invokeAny" class="headerlink" title="invokeAny"></a>invokeAny</h3><p>测试方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">testInvokeAny</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ExecutorService executorService= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    List&lt;Callable&lt;Integer&gt;&gt; callables=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//创建5个Callable</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        Callable&lt;Integer&gt; callable= <span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">//先进入随机的sleep</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>));</span><br><span class="line">                <span class="comment">//输出语句</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//放入集合中</span></span><br><span class="line">        callables.add(callable);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//输出invokeany的结果</span></span><br><span class="line">        System.out.println(executorService.invokeAny(callables));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><p><img src="/upload/pasted-384.png" alt="upload successful"><br>也就是说，运行invokeany，当运行的那一个任务运行完毕后，会取消掉其他正在运行的任务<br>注意：这个方法是一个阻塞方法，也就是说只有选定的某个任务执行完成，才会有返回值，否则会一直陷入阻塞状态<br>另外，该方法的重载方法还可以添加TimeOut,超过TimeOut时间，其他任务取消运行。抛出Timeout异常。</p><h3 id="invokeAll"><a href="#invokeAll" class="headerlink" title="invokeAll"></a>invokeAll</h3><p><img src="/upload/pasted-385.png" alt="upload successful"><br>这个方法也是一个阻塞方法</p><h3 id="submit-Runable"><a href="#submit-Runable" class="headerlink" title="submit(Runable)"></a>submit(Runable)</h3><p><img src="/upload/pasted-386.png" alt="upload successful"><br>这个方法可以返回一个结果值，但是由于Runable没有返回值所以可以手动传入一个值作为返回值（Future）</p><h1 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h1><p>Future是一个接口</p><blockquote><p>A Future represents the result of an asynchronous computation. Methods are provided to check if the computation is complete, to wait for its completion, and to retrieve the result of the computation. The result can only be retrieved using method get when the computation has completed, blocking if necessary until it is ready. Cancellation is performed by the cancel method. Additional methods are provided to determine if the task completed normally or was cancelled. Once a computation has completed, the computation cannot be cancelled. If you would like to use a Future for the sake of cancellability but not provide a usable result, you can declare types of the form Future&lt;?&gt; and return null as a result of the underlying task. </p></blockquote><p>future可以理解为一个票据，表示一个某个任务的结果，我们不是非要等到这个任务执行完毕才能进行别的任务，我们，我们可以在这个任务执行时，先去执行别的任务，等到这个任务执行完毕，再通过future获得任务的结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        Callable&lt;String&gt; longTimeJob=<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"长时工作完成"</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Callable&lt;String&gt; shotTimeJob=<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"短时工作完成"</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Future&lt;String&gt; res1=executorService.submit(longTimeJob);</span><br><span class="line">        Future&lt;String&gt; res2=executorService.submit(shotTimeJob);</span><br><span class="line">        System.out.println(res1);</span><br><span class="line">        System.out.println(res2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Future的方法"><a href="#Future的方法" class="headerlink" title="Future的方法"></a>Future的方法</h2><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p>Waits if necessary for the computation to complete, and then retrieves its result.<br>也就是说，通过票据Future获得线程的运行结果（Callable），会使线程陷入阻塞（会使调用get方法的线程进入阻塞,和线程池执行任务的线程无关）<br>比如(res1是长时任务的结果)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"主线程！！！！"</span>);</span><br><span class="line">    System.out.println(res1.get());</span><br><span class="line">    System.out.println(<span class="string">"&gt;?&gt;&gt;?&gt;&gt;&gt;?&gt;"</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果输出:</p><p><img src="/upload/pasted-387.png" alt="upload successful"><br>重载方法中，有一个TimeOut的参数，若调用get超时，则调用get方法的线程会抛timeout异常，但是未完成的任务仍然会继续进行。</p><h3 id="isDone"><a href="#isDone" class="headerlink" title="isDone"></a>isDone</h3><p><img src="/upload/pasted-389.png" alt="upload successful"><br>任务完成了，返回true；任务没完成，出现了异常，任务不能再继续做了，返回true，任务在做了，返回false</p><h3 id="cancle"><a href="#cancle" class="headerlink" title="cancle"></a>cancle</h3><p><img src="/upload/pasted-390.png" alt="upload successful"><br>如果取消任务成功则返回true，如果取消任务失败则返回false。参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。</p><h1 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h1><p>FutureTask是Runable和Future的实现类（是Future的唯一实现）<br>所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    ExecutorService executorService= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    Thread doingLong=<span class="keyword">null</span>;</span><br><span class="line">    FutureTask&lt;String&gt; futureTask=<span class="keyword">new</span> FutureTask&lt;String&gt;(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"任务任务任务"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    executorService.submit(futureTask);</span><br><span class="line">    System.out.println(futureTask.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h1><p>铺垫了这么多，Callable也就很好理解了，</p><p><img src="/upload/pasted-391.png" alt="upload successful"><br>Callable和Runable类似，但是它却可以有返回值</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/upload/pasted-428.png&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java多线程学习7（Exchanger,StampedLock,Fork/join,Phaser）</title>
    <link href="https://www.junglezero.top/2019/07/09/java-mutiple-threading-7/"/>
    <id>https://www.junglezero.top/2019/07/09/java-mutiple-threading-7/</id>
    <published>2019-07-09T03:36:52.000Z</published>
    <updated>2019-07-12T04:37:33.974Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/upload/pasted-356.png" width="70%"></p><a id="more"></a><hr><h1 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>A synchronization point at which threads can pair and swap elements within pairs. Each thread presents some object on entry to the exchange method, matches with a partner thread, and receives its partner’s object on return. An Exchanger may be viewed as a bidirectional form of a SynchronousQueue. Exchangers may be useful in applications such as genetic algorithms and pipeline designs. </p></blockquote><p>主要内容：提供一个同步点，使一对线程交换数据，可以使用在遗传算法和管道设计上</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><img src="/upload/pasted-351.png" alt="upload successful"><br>简要来说就是调用该方法的线程会进入等待状态，等待其他线程调用，若有其他线程调用，则交换两者数据（把参数中的object传过去，返回传回来的object），注意一个及时性，即使调用该方法后休眠，也不会影响交换，若非特殊情况下的阻断，则调用该方法会一直等下去，<br>若有超过两个线程都调用exchange方法，则先到交换点（先调用方法）的两个线程会交换数据，若第三个线程调用，则会等待第四个线程调用来交换数据</p><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Exchanger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置交换器</span></span><br><span class="line">        <span class="keyword">final</span> Exchanger&lt;String&gt; exchanger=<span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"开始运行。"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//模拟为该线程有的数据</span></span><br><span class="line">                    String myData=<span class="string">"123456789"</span>;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"交换之前的数据:"</span>+myData);</span><br><span class="line">                    <span class="comment">//调用交换器的exchange方法，并返回交换的结果（进入交换点等待另一个线程调用该方法）</span></span><br><span class="line">                    String exchangeResult=exchanger.exchange(myData);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"交换之后的数据:"</span>+exchangeResult);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"结束。"</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"开始运行。"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String myData=<span class="string">"987654321"</span>;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"交换之前的数据:"</span>+myData);</span><br><span class="line">                    String exchangeResult=exchanger.exchange(myData);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"交换之后的数据:"</span>+exchangeResult);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"结束。"</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="/upload/pasted-352.png" alt="upload successful"></p><h1 id="StamperdLock"><a href="#StamperdLock" class="headerlink" title="StamperdLock"></a>StamperdLock</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>这是java1.8新增加的锁（在JUC中），是对ReentrantReadWriteLock锁的一种改进:基于读的乐观锁<br>在Optimistic reading中，即使读线程获取到了读锁，写线程尝试获取写锁也不会阻塞，这相当于对读模式的优化，但是可能会导致数据不一致的问题。所以，当使用Optimistic reading获取到读锁时，必须对获取结果进行校验。<br>注意：StampededLock不支持重入</p><p><img src="/upload/pasted-353.png" alt="upload successful"></p><p>这里有一篇<a href="https://blog.overops.com/java-8-stampedlocks-vs-readwritelocks-and-synchronized/" target="_blank" rel="noopener">文章</a>,在这片文章中，作者讨论了synchronized,StampedLocks,和RWlock的效率对比，可以发现当读线程远多于写线程时，乐观锁的效率是最高的。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>可以使用StampededLock直接替代reentrantreadwritelock<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.StampedLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLockTest</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> StampedLock lock=<span class="keyword">new</span> StampedLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> List&lt;Long&gt; DATA=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ExecutorService executorService= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        Runnable readTask=<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (;;)</span><br><span class="line">                    read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable writeTask =<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (;;)</span><br><span class="line">                    write();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(writeTask);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//悲观式读取</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamped=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamped=lock.readLock();</span><br><span class="line">            <span class="comment">//模拟读取数据</span></span><br><span class="line">            System.out.println(DATA.toString());</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlockRead(stamped);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamp=lock.writeLock();</span><br><span class="line">            DATA.add(System.currentTimeMillis());</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而这个锁的改进就是对读加上乐观锁<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> stamped = lock.tryOptimisticRead();</span><br><span class="line">    <span class="keyword">if</span> (lock.validate(stamped)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamped = lock.readLock();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Fork-join"><a href="#Fork-join" class="headerlink" title="Fork/join"></a>Fork/join</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>Fork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。<br>Fork就是把一个大任务切分为若干子任务并行的执行，Join就是合并这些子任务的执行结果，最后得到这个大任务的结果<br>ForkJoinTask是轻量级的线程形式<br><img src="/upload/pasted-354.png" alt="upload successful"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>一般是使用ForkJoinTask 的继承类RecursiveAction（无返回值）和RecursiveTask（有返回值），并且依附在ForkJoinPool上进行使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分割任务的最大阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_THRSHOLD=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ForkJoinPool forkJoinPool=<span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        <span class="comment">//把ForkJoinTask提交ForkJoinPool进行运行</span></span><br><span class="line">        <span class="comment">//计算范围为0到10</span></span><br><span class="line">        ForkJoinTask&lt;Integer&gt; future=forkJoinPool.submit(<span class="keyword">new</span> ComputeRecursiveTask(<span class="number">0</span>,<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer result=<span class="number">0</span>;</span><br><span class="line">            result=future.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算的Fork/join线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputeRecursiveTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算的起始和终点</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> start;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">ComputeRecursiveTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//当发现起始和终点的相差的小于阈值时</span></span><br><span class="line">            <span class="keyword">if</span> (end-start&lt;=MAX_THRSHOLD)&#123;</span><br><span class="line">                <span class="comment">//直接计算返回结果，这里模拟的的是累加</span></span><br><span class="line">                <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">                    result+=i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//将起始到终点二分，分成两个子部分</span></span><br><span class="line">                <span class="keyword">int</span> middle=(start-end);</span><br><span class="line">                ComputeRecursiveTask leftRecursiveTask=<span class="keyword">new</span> ComputeRecursiveTask(start,middle);</span><br><span class="line">                ComputeRecursiveTask rightRecursiveTask=<span class="keyword">new</span> ComputeRecursiveTask(middle,end);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//调用fork进行执行</span></span><br><span class="line">                leftRecursiveTask.fork();</span><br><span class="line">                rightRecursiveTask.fork();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//最终的结果就是两个join</span></span><br><span class="line">                <span class="keyword">return</span> leftRecursiveTask.join()+rightRecursiveTask.join();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>文档讲到，这是一个可复用的同步器栅栏，可以理解为时CyclicBarrier和CountDownLatch的一个升级版<br>Phaser类机制是在每一步结束的位置对线程进行同步，当所有的线程都完成了这一步，才能进行下一步。<br>用来解决控制多个线程分阶段共同完成任务的情景问题。<br>当有并发任务并且需要分解成几步执行的时候，这种机制就非常适合。<br>CyclicBarrier CountDownLatch 只能在构造时指定参与量，而phaser可以动态的增减参与量<br>且Phaser支持父子结构，可以用在fork/join框架中</p><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><p><img src="/upload/pasted-358.png" alt="upload successful"></p><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>API中给到的几个使用例子<br>可以替代CountDownLatch来执行只需运行一次的线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runTasks</span><span class="params">(List&lt;Runnable&gt; tasks)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Phaser phaser = <span class="keyword">new</span> Phaser(<span class="number">1</span>); <span class="comment">// 参数为1，表示phaser计数为1</span></span><br><span class="line">   <span class="comment">// 创建并开始线程</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">final</span> Runnable task : tasks) &#123;</span><br><span class="line">   <span class="comment">//phaser添加一个新的运行部分</span></span><br><span class="line">     phaser.register();</span><br><span class="line">     <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         phaser.arriveAndAwaitAdvance(); <span class="comment">// await all creation</span></span><br><span class="line">         task.run();</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;.start();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//允许线程开始执行并在运行结束后注销（一次执行），不等着其他线程</span></span><br><span class="line">   phaser.arriveAndDeregister();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>重复执行一系列线程：重写onAdvance方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startTasks</span><span class="params">(List&lt;Runnable&gt; tasks, <span class="keyword">final</span> <span class="keyword">int</span> iterations)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Phaser phaser = <span class="keyword">new</span> Phaser() &#123;</span><br><span class="line">   <span class="comment">//重写该方法，来确定phaser的终止条件（返回true 表示终止）</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> phase &gt;= iterations || registeredParties == <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   phaser.register();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">final</span> Runnable task : tasks) &#123;</span><br><span class="line">     phaser.register();</span><br><span class="line">     <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">do</span> &#123;</span><br><span class="line">           task.run();</span><br><span class="line">           phaser.arriveAndAwaitAdvance();</span><br><span class="line">         &#125; <span class="keyword">while</span> (!phaser.isTerminated());</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;.start();</span><br><span class="line">   &#125;</span><br><span class="line">   phaser.arriveAndDeregister(); <span class="comment">// deregister self, don't wait</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>自己写的例子：模仿CyclicBarrier<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Phaser;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhaserTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Phaser phaser=<span class="keyword">new</span> Phaser();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            Task a=<span class="keyword">new</span> Task(phaser);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将主线程运行块加入phaser</span></span><br><span class="line">        phaser.register();</span><br><span class="line">        phaser.arriveAndAwaitAdvance();</span><br><span class="line">        System.out.println(<span class="string">"全部线程全部完成"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Phaser taskPhaser;</span><br><span class="line">        Task(Phaser phaser)&#123;</span><br><span class="line">            taskPhaser=phaser;</span><br><span class="line">            <span class="comment">//新添加一个运行块</span></span><br><span class="line">            phaser.register();</span><br><span class="line">            <span class="comment">//直接运行</span></span><br><span class="line">            start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"正在工作中》》》》》"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//线程到达并等待运行</span></span><br><span class="line">            taskPhaser.arriveAndAwaitAdvance();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><img src="/upload/pasted-359.png" alt="upload successful"></p><p>多个线程分阶段共同完成任务:完成铁人三项<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Phaser;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhaserTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Phaser phaser=<span class="keyword">new</span> Phaser(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Athletes(i,phaser).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Athletes</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Phaser phaser;</span><br><span class="line"></span><br><span class="line">        Athletes(<span class="keyword">int</span> num,Phaser phaser)&#123;</span><br><span class="line">            <span class="keyword">this</span>.num=num;</span><br><span class="line">            <span class="keyword">this</span>.phaser=phaser;</span><br><span class="line">            <span class="comment">//phaser.register();</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"No."</span>+num+<span class="string">"开始跑了"</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>));</span><br><span class="line">                System.out.println(<span class="string">"No."</span>+num+<span class="string">"跑到头了"</span>);</span><br><span class="line"></span><br><span class="line">                phaser.arriveAndAwaitAdvance();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"No."</span>+num+<span class="string">"开始游泳了"</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>));</span><br><span class="line">                System.out.println(<span class="string">"No."</span>+num+<span class="string">"游泳到头了"</span>);</span><br><span class="line"></span><br><span class="line">                phaser.arriveAndAwaitAdvance();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"No."</span>+num+<span class="string">"开始骑自行车了"</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>));</span><br><span class="line">                System.out.println(<span class="string">"No."</span>+num+<span class="string">"骑自行车到头了"</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><img src="/upload/pasted-360.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/upload/pasted-356.png&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java语言基础知识和其他应该知道的东西</title>
    <link href="https://www.junglezero.top/2019/07/06/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://www.junglezero.top/2019/07/06/Java语言基础知识/</id>
    <published>2019-07-06T02:53:05.000Z</published>
    <updated>2019-07-14T01:19:13.048Z</updated>
    
    <content type="html"><![CDATA[<p># </p><h2 id="ArrayList和Linkedlist区别"><a href="#ArrayList和Linkedlist区别" class="headerlink" title="ArrayList和Linkedlist区别"></a>ArrayList和Linkedlist区别</h2><p>1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。<br>2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。<br>3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。<br>4．对ArrayList和LinkedList而言，在列表末尾增加一个元素所花的开销都是固定的。对ArrayList而言，主要是在内部数组中增加一项，指向所添加的元素，偶尔可能会导致对数组重新进行分配；而对LinkedList而言，这个开销是统一的，分配一个内部Entry对象。<br>5．在ArrayList的中间插入或删除一个元素意味着这个列表中剩余的元素都会被移动；而在LinkedList的中间插入或删除一个元素的开销是固定的。<br>6．LinkedList不支持高效的随机元素访问。<br>7．ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间 </p><h2 id="java方法“值传递”的理解"><a href="#java方法“值传递”的理解" class="headerlink" title="java方法“值传递”的理解"></a>java方法“值传递”的理解</h2><p>java中的数据类型有基本类型和引用类型，他们都是值传递方式。基本类型传递的是它的值，因此方法中的改变参数的值，不会影响方法外。引用类型传递的是一个地址，因为引用类型在生成对象实例时，里面的值是一个地址，指向了对象实例。在传值的时候实际上传的是一个地址，他们指向了同一块地址，所以在方法内的改变会影响方法外的参数。 这里比较乱人心的是包装类型，因为包装类型也是引用类型，这里应该就是和包装类型的实现有关了，在包装类型中，比如Integer a=1，有一个自动装箱的操作。其实a=1，如果现在令a=2，不会令2覆盖1（即1本身是不会变的），真正改变的是a被赋给了一个新地址，这个地址指向了2。因此方法内的改变包装类型的值就相当于改变了形参里面的地址，相当于重新new了一遍。而方法外面的实参仍旧指向含1的那个地址，一次方法内的改变不会影响方法外的实参。 </p><p><img src="/upload/pasted-320.png" alt="upload successful"></p><h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><p>Volatile：与锁相比，Volatile 变量是一种非常简单但同时又非常脆弱的同步机制，它在某些情况下将提供优于锁的性能和伸缩性。如果严格遵循 volatile 的使用条件 —— 即变量真正独立于其他变量和自己以前的值 —— 在某些情况下可以使用 volatile 代替 synchronized 来简化代码。然而，使用 volatile 的代码往往比使用锁的代码更加容易出错。<br>只能在有限的一些情形下使用 volatile 变量替代锁。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：</p><ul><li>（1）对变量的写操作不依赖于当前值。</li><li>（2）该变量没有包含在具有其他变量的不变式中。<br>实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。<br>第一个条件的限制使 volatile 变量不能用作线程安全计数器。虽然增量操作（x++）看上去类似一个单独操作，实际上它是一个由读取－修改－写入操作序列组成的组合操作，必须以原子方式执行，而 volatile 不能提供必须的原子特性。实现正确的操作需要使 x 的值在操作期间保持不变，而 volatile 变量无法实现这点。 </li></ul><h2 id="数组复制"><a href="#数组复制" class="headerlink" title="数组复制"></a>数组复制</h2><p>1.for循环<br>2.System.arraycopy<br>3.Arrays.copyOf<br>4.clone</p><h2 id="类的加载顺序"><a href="#类的加载顺序" class="headerlink" title="类的加载顺序"></a>类的加载顺序</h2><p>(1) 父类静态代码块(包括静态初始化块，静态属性，但不包括静态方法)<br>(2) 子类静态代码块(包括静态初始化块，静态属性，但不包括静态方法 )<br>(3) 父类非静态代码块( 包括非静态初始化块，非静态属性 )<br>(4) 父类构造函数<br>(5) 子类非静态代码块 ( 包括非静态初始化块，非静态属性 )<br>(6) 子类构造函数</p><h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p>1、不管有没有出现异常，finally块中代码都会执行；<br>2、当try和catch中有return时，finally仍然会执行；<br>3、finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，不管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值），所以函数返回值是在finally执行前确定的；<br>4、finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。</p><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="registerNatives"><a href="#registerNatives" class="headerlink" title="registerNatives()"></a>registerNatives()</h3><p>向JVM注册native方法<br>在类初始化的时候，会依次从父类到本类的类变量及类初始化块中的类变量及方法按照定义顺序放到 &lt; clinit&gt;方法中，这样可以保证父类的类变量及方法的初始化一定先于子类。所以当子类调用相应 native方法，比如计算 hashCode时，一定可以保证能够调用到 JVM的 native方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">       registerNatives();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h3 id="getClass"><a href="#getClass" class="headerlink" title="getClass()"></a>getClass()</h3><p>类加载的第一阶段类的加载就是将 .class文件加载到内存，并生成一个 java.lang.Class对象的过程。 getClass()方法就是获取这个对象，这是当前类的对象在运行时类的所有信息的集合。这个方法是反射三种方式之一。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure></p><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><p>这个方法返回一个int类型的hash值<br>在 Java应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改；<br>如果两个对象 x.equals(y) 方法返回 true，则 x、 y这两个对象的 hashCode必须相等。<br>如果两个对象 x.equals(y) 方法返回 false，则 x、 y这两个对象的 hashCode可以相等也可以不等。但是，为不相等的对象生成不同整数结果可以提高哈希表的性能。<br>默认的 hashCode是将内存地址转换为的 hash值，重写过后就是自定义的计算方式；也可以通过 System.identityHashCode(Object)来返回原本的 hashCode。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>计算 hashCode使用了31作为基础乘数，为什么使用31呢？result *31=(result&lt;&lt;5)-result。 JVM底层可以自动做优化为位运算，效率很高；还有因为 31计算的 hashCode冲突较少，利于 hash桶位的分布。</p><h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><p>用于比较当前对象与目标对象是否相等，默认是比较引用是否指向同一对象。为 public方法，子类可重写。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>重写equals的意义：<br>因为如果不重写equals方法，当将自定义对象放到 map或者 set中时；如果这时两个对象的 hashCode相同，就会调用 equals方法进行比较，这个时候会调用 Object中默认的 equals方法，而默认的 equals方法只是比较了两个对象的引用是否指向了同一个对象，显然大多数时候都不会指向，这样就会将重复对象存入 map或者 set中。这就破坏了 map与 set不能存储重复对象的特性，会造成内存溢出。</p><h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><p>这是一个 protected方法，提供给子类重写。但需要实现 Cloneable接口，这是一个标记接口，如果没有实现，当调用 object.clone()方法，会抛出 CloneNotSupportedException<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure></p><p>两个概念——<br>浅拷贝：创建一个新对象，然后将当前对象的非静态字段复制到该对象，如果字段类型是值类型（基本类型）的，那么对该字段进行复制；如果字段是引用类型的，则只复制该字段的引用而不复制引用指向的对象。此时新对象里面的引用类型字段相当于是原始对象里面引用类型字段的一个副本，原始对象与新对象里面的引用字段指向的是同一个对象。<br>说白了就是clone一个对象，将会创建一个新的对象，而对于其内部属性，比如一个String的引用类型，克隆对象和被克隆对象指向的是一个引用。换言之，如果克隆对象的属性发生了改变，则原对象也会发生改变<br>而深拷贝则是一个完全不同的拷贝的方式<br>深拷贝通过序列化(Serializable)实现</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="wait-相关方法"><a href="#wait-相关方法" class="headerlink" title="wait()相关方法"></a>wait()相关方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        timeout++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多线程情况下使用作用是阻塞进程</p><ul><li>此方法只能在当前线程获取到对象的锁监视器之后才能调用，否则会抛出 IllegalMonitorStateException异常。</li><li>调用 wait方法，线程会将锁监视器进行释放；而 Thread.sleep，Thread.yield()并不会释放锁。</li><li>wait方法会一直阻塞，直到其他线程调用当前对象的 notify()/notifyAll()方法将其唤醒；而 wait(long)是等待给定超时时间内（单位毫秒），如果还没有调用 notify()/nofiyAll()会自动唤醒； wait(long,int)如果第二个参数大于 0并且小于 999999，则第一个参数 +1作为超时时间；</li></ul><h3 id="notify-notifyAll"><a href="#notify-notifyAll" class="headerlink" title="notify()/notifyAll()"></a>notify()/notifyAll()</h3><p>如果当前线程获得了当前对象锁，调用 wait方法，将锁释放并阻塞；这时另一个线程获取到了此对象锁，并调用此对象的 notify()/notifyAll()方法将之前的线程唤醒。这些方法都是 publicfinal的，不可被重写。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>要点：<br>调用 notify()后，阻塞线程被唤醒，可以参与锁的竞争，但可能调用 notify()方法的线程还要继续做其他事，锁并未释放，所以我们看到的结果是，无论 notify()是在方法一开始调用，还是最后调用，阻塞线程都要等待当前线程结束才能开始。</p><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h3><p>jvm垃圾回收时进行调用</p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p><img src="/upload/pasted-321.png" alt="upload successful"></p><p><img src="/upload/pasted-380.png" alt="upload successful"></p><h2 id="和equals"><a href="#和equals" class="headerlink" title="==和equals"></a>==和equals</h2><p>==用来判断两个变量是否相等时，如果两个变量是基本类型变量，且都是数值类型(不要求数据类型严格相同)，则只要两个变量的值相等，就返回true；对于两个引用类型变量，必须指向同一个对象，==才会返回true。<br>equals方法用于比较两个独立对象的内容是否相同</p><h2 id="实例变量，局部变量，类变量，final变量"><a href="#实例变量，局部变量，类变量，final变量" class="headerlink" title="实例变量，局部变量，类变量，final变量"></a>实例变量，局部变量，类变量，final变量</h2><ul><li>实例变量：是定义在是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。分配了内存空间后会给所有的成员变量一次初始化，没有赋值的会给成员变量对应类型的值，数据类型不同则默认值不同。</li><li>局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。用的时候是直接入栈的，如果没有赋值，这个变量就没有初始值，也就无法操作，所以局部变量要初始化。</li><li>类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。</li><li>final变量，final 修饰的变量。如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li></ul><h2 id="Integer的赋值问题"><a href="#Integer的赋值问题" class="headerlink" title="Integer的赋值问题"></a>Integer的赋值问题</h2><p>在为Integer赋值的时候，java编译器会将其翻译成调用valueOf()方法。比如Integer i=127翻译为Integer i=Integer.valueOf(127)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//high为127</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= -<span class="number">128</span> &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + <span class="number">128</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，对于-128到127之间的数，Java会对其进行缓存。而超出这个范围则新建一个对象。</p><h2 id="throws和throw"><a href="#throws和throw" class="headerlink" title="throws和throw"></a>throws和throw</h2><p>1、throws出现在方法头，throw出现在方法体 2、throws表示出现异常的一种可能性，并不一定会发生异常；throw则是抛出了异常，执行throw则一定抛出了某种异常。 3、两者都是消极的异常处理方式，只是抛出或者可能抛出异常，是不会由函数处理，真正的处理异常由它的上层调用处理</p><h2 id="接口（Interface）"><a href="#接口（Interface）" class="headerlink" title="接口（Interface）"></a>接口（Interface）</h2><p>接口，比抽象类还要抽象的类。</p><ul><li>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract （只能是 public abstract，其他修饰符都会报错）。</li><li>接口中可以含有变量，但是接口中的变量会被隐式的指定为  public static final   变量（并且只能是 public，用 private 修饰会报编译错误。）</li><li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。 </li></ul><p>注：<br>接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。<br>接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字。<br>接口中的方法都是公有的。public</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>Reflection（反射）是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的內部信息，并能直接操作任意对象的内部属性及方法。</p><p>Java反射机制主要提供了以下功能：</p><ul><li>在运行时构造任意一个类的对象</li><li>在运行时获取任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的方法（属性）</li><li>生成动态代理</li></ul><ol><li><p>Class: 是一个类; 一个描述类的类.<br>　　封装了描述方法的 Method,描述字段的 Filed,描述构造器的 Constructor 等属性.</p><ol start="2"><li><p>如何得到 Class 对象:<br>　　2.1 Person.class<br>　　2.2 person.getClass()<br>　　2.3 Class.forName(“com.atguigu.javase.Person”)</p></li><li><p>关于 Method:<br>　　3.1 如何获取 Method:<br>　　　　1). getDeclaredMethods: 得到 Method 的数组.<br>　　　　2). getDeclaredMethod(String methondName, Class … parameterTypes)</p></li></ol><p>　　3.2 如何调用 Method<br>　　　　1). 如果方法时 private 修饰的, 需要先调用 Method 的　setAccessible(true), 使其变为可访问<br>　　　　2). method.invoke(obj, Object … args);</p><ol start="4"><li><p>关于 Field:<br>　　4.1 如何获取 Field: getField(String fieldName)<br>　　4.2 如何获取 Field 的值:<br>　　　　1). setAccessible(true)<br>　　　　2). field.get(Object obj)<br>　　4.3 如何设置 Field 的值:<br>　　　　field.set(Obejct obj, Object val)</p></li><li><p>了解 Constructor 和 Annotation </p></li><li><p>反射和泛型.<br>　　6.1 getGenericSuperClass: 获取带泛型参数的父类, 返回值为: BaseDao&lt;Employee, String&gt;<br>　　6.2 Type 的子接口: ParameterizedType<br>　　6.3 可以调用 ParameterizedType 的 Type[] getActualTypeArguments() 获取泛型参数的数组.<br><a href="https://www.cnblogs.com/tech-bird/p/3525336.html" target="_blank" rel="noopener">https://www.cnblogs.com/tech-bird/p/3525336.html</a></p></li></ol></li></ol><h2 id="AQS和CAS"><a href="#AQS和CAS" class="headerlink" title="AQS和CAS"></a>AQS和CAS</h2><p>抽象队列同步器AQS ( AbstractQueuedSychronizer ) , 如果说java.util.concurrent的基础是CAS的话,那么AQS就是整个Java并发包的核心了, ReentrantLock、CountDownLatch、Semaphore等都用到了它。AQS实际上以双向队列的形式连接所有的Entry ,比方说ReentrantLock ,所有等待的线程都被放在一个Entry中并连成双向队列,前面一个线程使用 ReentrantLock好了, 则双向队列实际上的第一个Entry开始运行。 AQS定 义了对双向队列所有的操作,而只开放了tryLock和tryRelease方法给开发者使用,开发者可以根据自己的实现重写tryLock和tryRelease方法,以实现自己的并发功能。</p><p>比较并替换CAS(Compare and Swap) ,假设有三个操作数:内存值V、旧的预期值A、要修改的值B ,当且仅当预期值A和内存值V相同时,才桧将内存值修改为B并返回true ,否则什么都不做并返回false ,整个比较并替换的操作是一个原子操作。CAS一定要volatile变量配合,这样才能保证每次拿到的变量是主内中最新的相应值,否则旧的预期值A对某条线程来说,永远是一个不会变的值A,只要某次CAS操作失败，下面永远都不可能成功。</p><p>CAS虽然比较高效的解决了原子操作问题,但仍存在三大问题。</p><ul><li>循环时间开销大</li><li>只能保证一个共享变量的原子操作</li><li>ABA问题</li></ul><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p> Condition是在java 1.5中才出现的，它用来替代传统的Object的wait()、notify()实现线程间的协作，相比使用Object的wait()、notify()，使用Condition1的await()、signal()这种方式实现线程间协作更加安全和高效。因此通常来说比较推荐使用Condition，在阻塞队列那一篇博文中就讲述到了，阻塞队列实际上是使用了Condition来模拟线程间协作。</p><ul><li>Condition是个接口，基本的方法就是await()和signal()方法；</li><li>Condition依赖于Lock接口，生成一个Condition的基本代码是lock.newCondition()</li><li>调用Condition的await()和signal()方法，都必须在lock保护之内，就是说必须在lock.lock()和lock.unlock之间才可以使用Conditon中的await()对应Object的wait()； Condition中的signal()对应Object的notify()； Condition中的signalAll()对应Object的notifyAll() </li></ul><h2 id="Spring-mvc执行流程"><a href="#Spring-mvc执行流程" class="headerlink" title="Spring mvc执行流程"></a>Spring mvc执行流程</h2><p><img src="/upload/pasted-323.png" alt="upload successful"><br><a href="https://www.cnblogs.com/jay36/p/7527039.html" target="_blank" rel="noopener">https://www.cnblogs.com/jay36/p/7527039.html</a></p><h2 id="AOP-IOC"><a href="#AOP-IOC" class="headerlink" title="AOP IOC"></a>AOP IOC</h2><p>AOP和IOC是Spring精华部分, AOP可以看做是对OOP的补充,对代码进行横向的扩展,通过代理模式实现,代理模式有静态代理,动态代理, Spring利用的是动态代理,在程序运行过程中将增强代码织入原代码中。IOC是 控制反转,将对象的控制权交给Spring框架,用户需要使用对象无需创建,直接使用即呵。AOP和IOC最可贵的是它们的思想。</p><h2 id="Hibernate-POJO"><a href="#Hibernate-POJO" class="headerlink" title="Hibernate POJO"></a>Hibernate POJO</h2><p>Hibernate Pojo的三态分别为transient（瞬时态）,persistent（持久态）,detached（游离态）</p><p>1、官方给出的三态与Session的关系如下：</p><p>transient: never persistent, not associated with any Session<br>persistent: associated with a unique Session<br>detached: previously persistent, not associated with any Session</p><p>2、三种状态间相互转换关系，及他们在数据库、session中的状态如下：<br>a.当我们new一个pojo时，它处于瞬时态，此时与session、数据库均无任何关联。<br>b.此后，我们获得session并开启hibernate事务，调用save(),persist(),saveOrUpdate()方法，将pojo转变为持久态，此时session中存有这个pojo，但直到transaction.commit()被调用时，sql语句才会执行，此后数据库中也才有此条数据。<br>c.但当commit()并且session.close()执行过后，pojo就变为了游离态，也就是说，数据库中有该记录，但session中不再有。<br>d.持久化状态的实例，也可以重新变成瞬时态，那就是调用delete()方法。<br>e.通过get()或load()方法得到的pojo是持久态的。<br>f.游离态的pojo可以通过update(),saveOrUpdate(),lock()和replicate()方法重新成为持久态。<br>g.调用merge()方法后，pojo维持原态，但内容会被更新到数据库</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>Java通过Executors提供四个静态方法创建四种线程池，分别为：</p><p>newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p><p>newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p><p>newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</p><p>newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</p><p>作用：<br>限定线程的个数，不会导致由于线程过多导致系统运行缓慢或崩溃</p><p>线程池不需要每次都去创建或销毁，节约了资源、</p><p>线程池不需要每次都去创建，响应时间更快。</p><h2 id="javaWeb"><a href="#javaWeb" class="headerlink" title="javaWeb"></a>javaWeb</h2><h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p><img src="/upload/pasted-324.png" alt="upload successful"><br>servlet是运行在服务器端的小应用程序，是接收网络服务的请求和产生响应的一种方式。<br>servlet的功能：接受http请求，产生动态http响应。<br>HttpServlet是GenericServlet的子类。<br>GenericServlet是个抽象类，必须给出子类才能实例化。它给 出了设计servlet的一些骨架，定义了servlet生命周期，还有一些得到名字、配置、初始化参数的方法，其设计的是和应用层协议无关的，也就是说 你有可能用非http协议实现它。<br>HttpServlet是子类，当然就具有GenericServlet的一切特性，还添加了doGet, doPost, doDelete, doPut, doTrace等方法对应处理http协议里的命令的请求响应过程。</p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>servlet有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。这个生存期由javax.servlet.Servlet接口的init,service和destroy方法表达。<br>加载Servlet的class—-&gt;实例化Servlet—–&gt;调用Servlet的init完成初始化—-&gt;响应请求（Servlet的service方法）—–&gt;Servlet容器关闭时(Servlet的destory方法)<br>Servlet启动时，开始加载servlet生命周期开始。Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候(服务器关闭)调用其destroy方法。</p><h4 id="forward-与redirect-的区别"><a href="#forward-与redirect-的区别" class="headerlink" title="forward() 与redirect()的区别"></a>forward() 与redirect()的区别</h4><p>forward是服务器端的转向而redirect是客户端的跳转。</p><p>使用forward浏览器的地址不会发生改变。而redirect会发生改变。</p><p>Forward是一次请求中完成。而redirect是重新发起请求。</p><p>Forward是在服务器端完成，而不用客户端重新发起请求，效率较高<br>一般没有特殊需要，自己写的Servlet都扩展HttpServlet 。</p><h4 id="JSP和Servlet有哪些相同点和不同点"><a href="#JSP和Servlet有哪些相同点和不同点" class="headerlink" title="JSP和Servlet有哪些相同点和不同点"></a>JSP和Servlet有哪些相同点和不同点</h4><p>JSP是Servlet技术的扩展，所有的jsp文件都会被翻译为一个继承HttpServlet的类。也就是jsp最终也是一个Servlet.这个Servlet对外提供服务。</p><p><img src="/upload/pasted-347.png" alt="upload successful"><br>Servlet和JSP最主要的不同点在于JSP侧重于视图，Servlet主要用于控制逻辑。<br>Servlet如果要实现html的功能，必须使用Writer输出对应的html,比较麻烦。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件,做界面展示比较方便而嵌入逻辑比较复杂</p><h4 id="jsp内置对象"><a href="#jsp内置对象" class="headerlink" title="jsp内置对象"></a>jsp内置对象</h4><p>request 用户端请求，此请求会包含来自GET/POST请求的参数</p><p>response 网页传回用户端的回应</p><p>pageContext 网页的属性是在这里管理</p><p>session 与请求有关的会话期</p><p>application servlet正在执行的内容</p><p>out 用来传送回应的输出</p><p>config servlet的构架部件</p><p>page JSP网页本身</p><p>exception 针对错误网页，未捕捉的例外</p><p>四大作用域：pageContext request session application 可以通过jstl从四大作用域中取值.</p><p>Jsp传递值request session application cookie也能传值</p><h3 id="http-get和post请求的区别"><a href="#http-get和post请求的区别" class="headerlink" title="http get和post请求的区别"></a>http get和post请求的区别</h3><p>GET和POST请求都是http的请求方式，用户通过不同的http的请求方式完成对资源（url）的不同操作。GET，POST，PUT，DELETE就对应着对这个资源的查 ，改 ，增 ，删 4个操作,具体点来讲GET一般用于获取/查询资源信息，而POST一般用于更新资源信息<br>1、Get请求提交的数据会在地址栏显示出来，而post请求不会再地址栏显示出来.</p><p>GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&amp;连接；POST提交：把提交的数据放置在是HTTP包的包体中。因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变</p><p>2、传输数据的大小</p><p>http Get请求由于浏览器对地址长度的限制而导致传输的数据有限制。而POST请求不会因为地址长度限制而导致传输数据限制。</p><p>3、安全性,POST的安全性要比GET的安全性高。由于数据是会在地址中呈现，所以可以通过历史记录找到密码等关键信息。</p><h3 id="Session-和-Cookie"><a href="#Session-和-Cookie" class="headerlink" title="Session 和 Cookie"></a>Session 和 Cookie</h3><p>Session和cookie都是会话(Seesion)跟踪技术。Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。但是Session的实现依赖于Cookie,sessionId(session的唯一标识需要存放在客户端).</p><p>cookie 和session 的区别：</p><p>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</p><p>2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗</p><p>   考虑到安全应当使用session。</p><p>3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用COOKIE。</p><p>4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p><p>5、所以个人建议：</p><p>   将登陆信息等重要信息存放为SESSION</p><p>   其他信息如果需要保留，可以放在COOKIE中，比如购物车</p><p>购物车最好使用cookie，但是cookie是可以在客户端禁用的，这时候我们要使用cookie+数据库的方式实现，当从cookie中不能取出数据时，就从数据库获取。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;# &lt;/p&gt;
&lt;h2 id=&quot;ArrayList和Linkedlist区别&quot;&gt;&lt;a href=&quot;#ArrayList和Linkedlist区别&quot; class=&quot;headerlink&quot; title=&quot;ArrayList和Linkedlist区别&quot;&gt;&lt;/a&gt;ArrayList和
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>结束是另一个开始</title>
    <link href="https://www.junglezero.top/2019/07/05/mething-Ends-Something-Begins-translate-cn/"/>
    <id>https://www.junglezero.top/2019/07/05/mething-Ends-Something-Begins-translate-cn/</id>
    <published>2019-07-05T15:05:25.000Z</published>
    <updated>2019-07-19T00:56:51.306Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/upload/pasted-357.png"><br>《猎魔人》原著作者送给其朋友的结婚礼物，和正传发生的故事有些矛盾，但问题不大<br>高甜预警！！！<br><a id="more"></a></p><hr><p>翻译自外国的某个热心粉丝Something Ends, Something Begins <a href="https://witcher.fandom.com/wiki/Something_Ends,_Something_Begins_(unofficial_translation)" target="_blank" rel="noopener">https://witcher.fandom.com/wiki/Something_Ends,_Something_Begins_(unofficial_translation)</a><br>意思跑偏太正常了，这哥们把波兰语翻译成英语要跑偏一部分，我再把英语翻译成汉语又会跑偏一部分。对于这里面出现的一些人物，已经在第一次出现的地方链接到了猎魔人的wiki,有兴趣的朋友可以看一看。</p><hr><h1 id="I"><a href="#I" class="headerlink" title="I"></a>I</h1><p>   太阳炽热的触须透过百叶窗的缝隙伸展开来，倾斜的阳光把房间横断开来，飞悬的尘埃在光线中跃动着，落在地板的熊皮上，在叶妮芙皮带扣炫目的闪光中渐渐消散。叶妮芙的腰带挂在高跟鞋上，高跟鞋在白色蕾丝内衣上，而内衣在黑色的裙子上。一只黑色长筒袜挂在雕刻成烟囱状的扶手椅上，另一只袜子和另一只高跟鞋却四处不见，杰洛特叹了口气。叶妮芙喜欢利索优雅的脱掉衣服，他必须开始习惯起来，他没别的选择。<br>他站起身来，打开窗子向外看去，湖面光滑如镜，迷迷蒙蒙中，岸边的桦树和赤杨的叶子上闪着露珠，远处的草地上覆盖着厚重的雾，沉默的压下来，犹如蛛网一般悬在草地之上</p><p>   叶妮芙在毯子下嘟囔着什么，含糊不清。杰洛特叹了口气<br>   “今天天气真好，叶。”<br>   “嗯？你说什么？”<br>   “今天天气很好，尤为的好”<br>   她还是让他吃了一惊，女术士并没有像往常一样讽刺挖苦，也没有把头压在枕头下，而是坐起身来。用手梳理着头发，然后在床上找睡衣，杰洛特知道睡衣就在床头下面，就在她昨晚脱掉的地方，但是他一句话也没说，因为他知道，叶妮芙讨厌这种话。<br>   女术士突然咒骂起来，她踢了踢毯子，举起手咬住手指，睡袍就从床前飞来，摆动着荷叶边，犹如一个可怕的幽灵，然后落在她的手上。杰洛特叹了口气。叶妮芙站起身来走到他跟前，抱住了他，咬了他的胳膊，杰洛特叹了口气，他不得不习惯的事似乎多的数不清。<br>   “你没什么想说的吗？”，女术士眯着眼睛，问道<br>   “并没有。”<br>   “很好，今天的确很好，干的不错。”<br>   “什么意思？”<br>   叶妮芙还没来得及回答，就听见远处传来一声又高又长的叫喊声和喘息声。湖边，希瑞骑着一匹黑色的母马溅起一阵水花，这是一匹纯种马，长得很漂亮。杰洛特还记得它的上一个主人是个半精灵，这个半精灵轻率的凭第一印象错误的判断了这个白发的猎魔女，最终犯下大错。希瑞将这匹母马命名为“卡尔比”，在史凯利杰岛民的口中，这个意思是一种可怕的，胆大妄为的海的神灵，有时也会化身为马。这名字非常适合这匹母马。不久之前，有个半身人就因为某种艰难的方式了解到了，当他尝试偷走这匹马时，被这匹马猛地给了一脚，正中脸上，这半身人以前叫桑迪·弗洛莫顿，但自此以后人们就叫他“花椰菜”了。<br>   “总有一天她会摔断脖子的”，叶妮芙叫喊道，看着希瑞在溅起的水花中飞奔，弯腰，牢牢的踩着马镫。“总有一天你这疯女儿会摔断脖子的。”<br>   杰洛特转过头来，也不说话，就这么静静的看着女术士那双紫罗兰色的眼眸。<br>   “好吧好吧，”叶妮芙目不转睛的微笑着，“对不起，我们的女儿。”<br>   她又抱住他，紧紧地靠在他身上，又咬了下他的胳膊，然后亲吻她，接着又咬了下，杰洛特嘴唇触碰着她的头发，小心翼翼的把睡袍来到她的肩上。<br>   然后最终他们还是又上了床，散乱的毯子，尚有余温，仍旧沉浸在梦中。他们开始互相寻找彼此，寻找的时间很长，也很耐心，他们都深知最终会找到彼此，充满欢喜的彼此，他们所做的一切都是欢愉的，尽管他们之间尚有很大的差异，他们也和往常一样想着，这种差异并不是将他们分割开来，而是紧紧的绑在一起的差异，就犹如房梁和屋脊，那才是房屋的诞生所在。这也犹如第一次，当他被她赤裸而强烈的欲望所迷住，而她被他的巧妙和感性所迷住，就像她第一次本想告诉他，但是他却只用了一个吻和一个安抚让她安宁下来，消除了其他的所有感觉，后来，当他想要告诉她时，他却一点声音也发不出来，再后来，欢愉被一块巨石压倒，他们的眼中只有那一刻的闪光，听到的只是无声的呼喊，世界犹如静止一般，结束了，开始了，然后是沉默，宁静的沉默【本段见小说第一本《白狼崛起》的“最后的愿望”】<br>   还有无限的魅力。<br>   世界又重新回到它的轨道上，这里还是一张充满梦幻和光亮的床，然后是一天，那样的一天……<br>   “叶…”<br>   “嗯？”<br>   “当你说今天天气不错时，还说了句‘干得不错’，该不是……”<br>   “是的”她承认道，伸展着双臂握紧毯子的边，使她的胸部在那一刻以这种方式展现出来，这使得猎魔人的下半身一阵颤动<br>   “看啊，杰洛特，是我们打造出这样的天气，昨晚，我，<a href="http://witcher.huijiwiki.com/wiki/%E5%8D%97%E5%B0%BC%E5%85%8B" target="_blank" rel="noopener">南尼克</a>,特莉丝和<a href="http://witcher.huijiwiki.com/wiki/%E5%A4%9A%E7%91%9E%E5%8A%A0%E9%9B%B7" target="_blank" rel="noopener">多瑞加雷</a>,我不能冒险，今天必须是美好的一天……”<br>她一声不吭的用膝盖猛击了杰洛特一下。<br>   “为什么？因为这是你生命中最重要的一天，傻东西。”【叶妮芙设定上会读心术，专读杰洛特的】</p><hr><h1 id="II"><a href="#II" class="headerlink" title="II"></a>II</h1><p>   洛史洛格城堡矗立在湖中凸起的地带，亟需进行全面的修缮工作，绝对不仅仅是现在。说的好听一点，洛史洛格就是一片废墟，一个不规整的石头堆，铺满了常青藤，野葡萄，地衣和苔藓，说来说去也不过是这片烂沼泽地中的一个遗迹，四处满是蛤蟆，蝾螈和乌龟，当年这片土地给赫维格国王时，这已经就是一片废墟了，这个城堡以及周边的沼泽，更像是一份毕生的礼物，一份送给赫维格告别礼物。赫维格于12年前退位，以支持他的侄子“友善者”布伦南，杰洛特曾通过丹德里恩结识了这位前国王，因为赫维格国王为人和蔼，也喜好招待宾客，所以这位吟游诗人经常出入城堡。<br>   当女术士排除了猎魔人所提供的所有地点参考时，丹德里恩就把赫维格国王的洛史洛格城堡提了上来，诡异的是，女术士马上就同意了这个提议，甚至连鼻子也没抽一下。<br>于是，杰洛特和叶妮芙的婚礼将在洛史洛格城堡举行</p><hr><h1 id="III"><a href="#III" class="headerlink" title="III"></a>III</h1><p>   一开始，这场婚礼设定上是小型的，不那么引人注目的婚礼，可是因为各种原因，这是不可能实现的，所以很有必要找一个擅长组织的人。自然，叶妮芙是拒绝的，她不想张罗她自己的婚礼，杰洛特和希瑞，还有丹德里恩，那就不用说了，他们就没组织这个概念，于是他们向艾尔兰德的梅里泰莉神庙的大祭司南尼克求助，南尼克二话不说就来了，带着两个年轻的女祭司小爱若拉和尤妮德。<br>   于是各种问题开始接踵而至。</p><hr><h1 id="IV"><a href="#IV" class="headerlink" title="IV"></a>IV</h1><p>   “这可不行，杰洛特，”南尼克怒吼道，跺了跺脚，“婚礼和宴会要是出了什么岔子我可不负责。那片废墟，有些傻瓜竟然称之为一座城堡，那可是一点用也没有，那里的厨房都要塌了，舞厅也就能用来做个马厩，那个礼拜堂……那就不是个礼拜堂，至少你能告诉我那个瘸子赫维格信奉哪位神灵吗？”<br>“据我所知，他谁也不信奉，他还声称宗教不过是大众的精神毒品”<br>“哼，我就知道，”女祭司说道，丝毫没有掩饰自己的轻蔑，“那个礼拜堂里没有一座雕像，除了老鼠粪以外，就没有别的东西了，最重要的是，那个地方不过是一摊死水，杰洛特，你怎么不想在一个文明的国家举行婚礼呢，比如温格堡？”<br>   “你知道的，叶是一个混血儿，你们的那些文明国家可不准许这种混合的婚姻”<br>“梅里泰莉女神在上！不过是四分之一的精灵血统，有什么问题吗？谁都或多或少的带点上古民族的血统，这只是个愚蠢的偏见！”<br>   “那也不是我编出来的。”</p><hr><h1 id="V"><a href="#V" class="headerlink" title="V"></a>V</h1><p>   邀请的客人名单实际上并不长，夫妇两人把名单汇总交给了丹德里恩，让他去发放邀请函，结果是这个吟游诗人还没来得及读完就给弄丢了，因为他羞于承认，于是他就耍了些花招：尽可能的邀请他所能邀请的任何人，当然，他对叶妮芙和杰洛特都很了解，所以没有落下任何一个重要的人，但是要是没有趁机邀请到更多的乱七八糟的形形色色的人的话，那他也就不是丹德里恩了。<br>   于是，杰洛特的导师，来自凯尔莫罕的老维瑟米尔和杰洛特的童年伙伴，猎魔人艾斯卡尔就过来了<br>   德鲁伊<a href="http://witcher.huijiwiki.com/wiki/%E8%8E%AB%E6%96%AF%E8%90%A8%E5%85%8B" target="_blank" rel="noopener">莫斯萨克</a>带着一个名叫芙蕾雅的金发女郎来了，芙蕾雅比他高一头，但是可比他年轻上百岁。来的还有<a href="http://witcher.huijiwiki.com/wiki/%E5%85%8B%E6%8B%89%E8%8C%A8%C2%B7%E5%AE%89%C2%B7%E5%85%8B%E8%8E%B1%E7%89%B9" target="_blank" rel="noopener">克拉茨·安·克莱特</a>,史凯利杰群岛的伯爵，带着他的两个儿子拉格纳和洛基，拉格纳骑马时，脚都快碰到地了，而洛基则像个精灵，也难怪他们兄弟两个，但是他们有着不同的母亲<br>   来自布拉维坎的里夫·凯尔迪米恩和他女儿阿妮卡到了【出自《白狼崛起》的“勿以恶小”，布拉维坎屠夫的称号就是从这个地方得来的】，阿妮卡很有魅力但生性害羞。矮人<a href="http://witcher.huijiwiki.com/wiki/%E4%BA%9A%E5%B0%94%E6%BD%98%C2%B7%E9%BD%90%E6%A0%BC%E6%9E%97" target="_blank" rel="noopener">亚尔潘·齐格林</a>出现了，没有带着其他人，这很有意思，他一般都是带着他的长胡子同伙的。他是在半路上碰上了精灵<a href="http://witcher.huijiwiki.com/wiki/%E5%87%AF%E7%91%9E%E5%B0%94%E4%B8%B9" target="_blank" rel="noopener">凯瑞尔丹</a>一起来的，可见凯瑞尔丹在精灵中还是有些地位的，身边有几个默默无闻的精灵，无人知晓。<br>又来了一队吵吵嚷嚷的半身人，这群人里杰洛特只认识<a href="http://witcher.huijiwiki.com/wiki/%E4%B8%B9%E8%BF%AA%C2%B7%E6%AF%94%E4%BC%AF%E5%A8%81%E7%89%B9" target="_blank" rel="noopener">丹迪·比伯威特</a>，蓼草牧场的商人和牧马人,还有只是有所耳闻的，因好斗而出名的老婆加德尼娅·比伯威特，领头的还有一个不是半身人的半身人——著名的商人特里科·朗格瑞文克·勒托特，一个异形怪，伪装成名为“<a href="http://witcher.huijiwiki.com/wiki/%E5%98%9F%E5%98%9F" target="_blank" rel="noopener">嘟嘟</a>”的半身人。【见《宿命之剑》的“永恒之火”】<br>   来自布洛克莱昂的<a href="http://witcher.huijiwiki.com/wiki/%E8%8F%B2%E6%96%AF%E5%A5%88%E7%89%B9" target="_blank" rel="noopener">菲斯奈特</a>男爵到了，带着他的妻子，高贵的树精布蕾恩，以及他们的五个女儿莫丽恩、希瑞菈、莫娜、艾思娜和卡什卡，莫丽恩15岁的样子，而卡什卡看上去只有五岁。她们都是一头红发，尽管菲斯奈特是黑发，布蕾恩是金发、布蕾恩明显怀有身孕。他的一群红发树精女儿彼此咯咯的笑着，菲斯奈特信誓旦旦的说，这次一定是个儿子【小说中说树精X非树精=女树精】而布蕾恩则笑着补充道，这个“儿子”就叫梅丽莎。【这两个人的故事见《宿命之剑》的“宿命之剑”】<br>   独臂的<a href="http://witcher.huijiwiki.com/wiki/%E9%9B%85%E5%B0%94" target="_blank" rel="noopener">雅尔</a>也来了，这是一位年轻的牧师，编年史家，来自艾尔兰德，是南尼克的一个学徒，他来这里主要是因为他暗恋的希瑞，心疼的南尼克觉得，希瑞对于这个残疾青年的隐晦的调情似乎太过冷淡。<br>   打头的不速之客是布利姆巫德的<a href="http://witcher.huijiwiki.com/wiki/%E8%89%BE%E6%A0%BC%E7%BD%97%E7%93%A6%E5%B0%94" target="_blank" rel="noopener">艾格罗瓦尔</a>王子，他的到来被视作为一个奇迹，因为他和杰洛特曾经毫不留情的公开鄙视对方，更奇怪的是，他是和他的妻子美人鱼<a href="http://witcher.huijiwiki.com/wiki/%E5%B8%8C%E6%81%A9%E5%A8%9C%E5%85%B9" target="_blank" rel="noopener">希恩娜兹</a>一起来的，尽管她为了一双异常漂亮的腿牺牲了自己的鱼尾，但人们都知道她从未离开过海岸，因为她对陆地充满恐惧【这段故事见《宿命之剑》的“一点牺牲”】<br>   没人料到还会有其他的国王会对于此事比较上心——说来说去也没人邀请他们。尽管如此，还是有很多国王派发贺信，礼物，使者——或者以上的一并送出。他们应该是事先商量好了，因为他们的使者是组团来的，彼此都相互认识了。伊夫骑士代表埃塞因国王，领主苏力沃伊代表文斯拉夫国王，玛索尔姆爵士代表西吉斯蒙德国王，德弗卢爵士代表<a href="http://witcher.huijiwiki.com/wiki/%E9%9B%85%E5%A6%B2" target="_blank" rel="noopener">雅坦</a>王后，他们这几个人的旅行一定很愉快，因为伊夫的嘴唇被割破了，苏力沃伊的胳膊绑在板子上，玛索尔姆一瘸一拐的，而德弗卢醉的很厉害，几乎要从马上摔下来了。<br>   没人能邀请金龙<a href="http://witcher.huijiwiki.com/wiki/%E5%8D%9A%E5%B0%94%E5%A5%87" target="_blank" rel="noopener">维纶特瑞坦梅斯</a>,因为没人知道怎么邀请他以及他到底在哪，令众人吃惊的是，他还是来了，自然是隐藏了真实的形态，是以骑士博尔奇“三只寒鸦”的身份来的，当然，有丹德里恩在的地方，就没有什么隐私可言，但是当吟游诗人指着这位卷发骑士声称他其实是一条金龙时，还是没什么人相信。<br>   没人会料到还有一群各式各样的流浪人的到来，当然，也没人邀请他们。他们被登记为“丹德里恩的朋友和熟人”，主要是诗人，歌手和剧场演员，还有杂耍演员，职业骰子手，鳄鱼训练师以及四个浓妆艳抹的女人，其中三个毫无疑问就是妓女，而第四个虽然看上去不像，但毫无疑问也是，有两个算命的，其中一个还是个骗子，还有一个雕塑家，一个金发女郎，和一个醉酒的灵媒师，还有个麻子脸的侏儒，自称是舒滕巴赫<br>   在一艘外形犹如一只天鹅背着一个巨大的枕头的魔法船上，术士团到了，他们比邀请的要少上4倍，但是比预期来的要多上三倍，正如传言所说的那样，叶妮芙的同行并不认同她会嫁给一个外人，还是个猎魔人，他们中的一部分人直接无视邀请，另一部分人则以没时间为由，说是要去参见一年一度的世界修道院集会，因此，在那艘被丹德里恩唤做“枕头鸟”的船上只有沃尔的多瑞加雷，牛堡的<a href="http://witcher.huijiwiki.com/wiki/%E8%8E%B1%E5%BE%B7%E5%85%8B%E9%87%8C%E5%A4%AB" target="_blank" rel="noopener">莱德克里夫</a>,以及一头栗色头发的特莉丝·梅利葛德</p><hr><h1 id="VI"><a href="#VI" class="headerlink" title="VI"></a>VI</h1><p>   “是你邀请的特莉丝·梅利葛德？”<br>   “没有的事，”猎魔人急忙摇了摇头，暗自庆幸自己的血液循环系统不会让自己脸红。“不是我，估计是丹德里恩，尽管他们都说他们是通过水晶占卜知道的。”<br>   “我不希望特莉丝·梅利葛德出现在我的婚礼上！”<br>   “为什么呀，她可是你的朋友。”<br>   “不要把我当傻子，猎魔人！是个人就知道你跟她有一腿。”<br>   “扯淡！”<br>   叶妮芙的紫罗兰色眼睛危险的眯着。<br>   “是真的”<br>   “真不是”<br>   “就是真的”<br>   “够了，”他生气的把头扭向一边，“就是真的了，你想怎么样？”<br>   女术士沉默了，摆弄着脖子上的黑曜石星星。<br>   “也没什么，”女术士最终开了口，“我就是想让你承认罢了，不要冲我撒谎，杰洛特，永远也不要”</p><hr><h1 id="VII"><a href="#VII" class="headerlink" title="VII"></a>VII</h1><p>   城堡的石墙散发出一股潮湿的气息，外加一股子药草的酸味。阳光照在褐色的泥水上，竟然拽出了沼泽地里某种植物的暖绿色和海狸百合闪闪发光的黄色<br>城堡也慢慢苏醒过来，渐渐有了生机。城堡西翼，有人打开百叶窗，放声大笑。有人用一种微弱的声音请求来一些泡菜卤水，丹德里恩的一位同事，一个盲诗人，一边刮着胡子，一边放声唱到：</p><p>干草仓后的栅栏上，<br>有只公鸡高声唱，<br>姑娘我会赶到你身旁，<br>来上一炮也无妨……</p><p>   门吱扭一声开了，丹德里恩来到院子中，他伸了伸懒腰，揉了揉眼睛<br>   “你好啊，新郎官，”他疲惫的说道。“如果你想要溜走，就只有现在了。”<br>   “丹德里恩，你竟然成了早起的鸟儿。”<br>   “我压根就没上床”，诗人嘟囔着，坐在猎魔人旁的石凳上，靠着长满藤蔓的石墙。“神啊，多么每美妙的夜晚，但不管怎么说，可不是每天都有好朋友要结婚，自然是要好好的庆祝一下。”<br>   “婚礼的宴会是在今天，”杰洛特提醒道，“你能撑得过去吗？”<br>   “你瞧不起我吗？”</p><p>   艳阳高照，鸟儿在灌木丛中啾啾的叫着，湖上传来溅水声和咯咯的笑声，那是菲斯奈特的红发树精女儿们莫丽恩、希瑞菈、莫娜、艾思娜和卡什卡正和往常一样光着身子在湖中玩耍，特莉丝·梅利葛德和莫斯萨克的朋友芙蕾雅正看着她们。而城垛上，皇家的使者们，伊夫骑士，苏力沃伊领主，玛索尔姆爵士和德弗卢爵士却为了争抢一个望远镜而大打出手。</p><p>   “玩得还好吗，丹德里恩？”<br>   “别提了。”<br>   “又出什么乱子了？”<br>   “可是有那么几个。”</p><p>   正如诗人所说，第一个争端是关于种族的。宴会开到一半时，特里科·朗格瑞文克·勒托特突然发作，说他已经忍受够了半身人的伪装，勒托特指着在坐的树精，精灵，半身人，美人鱼，人类和一个声称自己是舒滕巴赫的侏儒，说他们每个人都能做他们自己而只有他，特里科必须得伪装成别人的样子，这就是种歧视，然后他突然变回了自己自然模样，看到这一幕，加德尼娅·比伯威特当场晕了过去，艾格罗瓦尔王子差点被龙虾给噎着，而里夫·卡尔迪米恩的女儿阿妮卡则歇斯底里的叫了起来，这混乱场面最终还是靠着金龙维纶特瑞坦梅斯得以拯救，当然，是以骑士博尔奇“三只寒鸦”的形态。他淡淡的向勒托特解释道，说异形是一种天赐的恩惠，然而这种恩惠也要求他保持一种社会能够接受的形态，而且也是出于对东道主的礼仪。<br>   可是勒托特指责维纶特瑞坦梅斯，说他的这番话完全就是种族主义，沙文主义以及站着说话不腰疼。因此受辱的维纶特瑞坦梅斯猛地变成了龙形，毁坏了几件家具，引得众人一阵恐慌，待局势稍微缓和下来时，一场激烈的争端就开始了，人类和非人种族在互相指责对方的不宽容，对方的种族歧视，这场争论意想不到的转折来自脸上长着雀斑的媚儿，就是那个不像妓女的妓女，她说这场争辩就是扯淡，对于“专业人士”来说，是不是人根本就没有关系，还说愿意当场证明（当然，钱要到位。）甚至包括处在自然形态下的维纶特瑞坦梅斯，在那片刻间的寂静中，众人听到那个灵媒师说她也愿意做同样的事，而且不收钱。维纶特瑞坦梅斯赶忙转换话题，开始讨论一些相对安全的话题，比如经济，政治，狩猎，钓鱼以及冒险。<br>   其他的事情可能相对来说不那么暴力。莫斯萨克，莱德克里夫和多瑞加雷比他们谁能用意念控制更多的东西浮空。最终是多瑞加雷赢了，他成功的将两把椅子，一个水果盘，一碗汤，一个地球仪，一只猫，两只狗以及菲斯奈特和布蕾恩的女儿卡什卡悬在空中。<br>   然后是菲斯奈特和布蕾恩的两个女儿，希瑞拉和莫娜扭打在一起，于是她们被要求返回自己的房间，不一会拉格纳和玛索尔姆爵士为菲斯奈特的大女儿莫林又打了起来。生气的菲斯奈特赶忙把自己的红发女儿们都关在了屋子里，然后自己兴冲冲的跑去参加由莫斯萨克的女友芙蕾雅组织的斗酒。很快，丹德里恩的朋友们，那些诗人和歌手，纷纷喝倒在桌子下，很明显芙蕾雅对于酒精有难以想象的抑制能力，近乎于免疫。但是菲斯奈特，克拉茨·安·克莱特，里夫·卡尔迪米恩仍然勇敢的战斗着，然后他们也败下阵来。术士莱德克里夫此时却还坚定的举着酒杯，直到人们发现他带着一个独角兽的角，拿掉之后，他一下子就不行了。有那么一段时间，桌子上都没人，然后就来了一个穿着老式服装的卡夫坦人，他脸色苍白，没人认识他。他和芙蕾雅喝了几个来回，过了一会，站了起来，晕晕乎乎的，礼貌的鞠了一躬，穿过一堵墙，就好像一阵雾，通过对大厅中的挂画的彻底搜查，人们认定他可能是几百年前在黑暗时代被谋杀的罗兹罗格的继承人“魔鬼”威廉姆。<br>   这座古堡藏着各种各样的秘密，早些年，它以它的阴森可怕而闻名，但是人们都比较怀疑，毕竟并没有发生什么超自然的事。午夜时分，一只吸血鬼从开着的窗子飞来进来，一进来，就被矮人亚尔潘·齐格林扔了头大蒜，然后被他追着打。整个晚上，总能听见货真价实的鬼哭狼嚎，但没人在意，人们都觉得是丹德里恩和他的朋友在搞鬼。然而，楼梯上大量的外质表明，这的确就是货真价实的鬼魂，还有几个人滑到在上面。</p><p>   有个影子跨过门槛，他眨着火一般的眼睛，淘气的捏了希恩娜兹的屁股一把，看来要想解决这些误会可能要有些难度了，因为希恩娜兹认定就是丹德里恩干的，这个鬼影立刻借着这个误会，四处捣乱，直到他被南尼克抓住并用驱魔术驱逐出去。<br>   几个人声称自己看见了苍白夫人，传说中，她被活埋在洛史洛格城堡的地下墓穴中。而别的人则觉得这个不是苍白夫人，而是那个女灵媒师在画廊中走动着找酒喝<br>   然后就开始有人失踪了，最开始失踪的是伊夫骑士和鳄鱼杀手，不一会人，人们发现拉格纳和年轻的女祭司尤妮德也没了。然后是加德尼娅·比伯威特，但后来才知道她去睡觉了。接着是独臂的雅尔和第二个年轻女祭司小爱若拉。虽然希瑞对雅尔没什么感情可言，但还是有些担心，但很显然，这个年轻人不小心摔在了阴沟里，在里面睡着了。而小爱若拉则是在楼梯口被发现了，旁边还有精灵凯瑞尔丹。特莉丝·梅利葛德和来自凯尔莫罕的猎魔人艾斯卡尔被发现了消失在花园的凉亭附近。早上，有人声称看见了在凉亭那里看见了变形怪特里科，人们就在议论纷纷，琢磨着这个异形怪到底变成了谁的模样，甚至有人觉得这里有两个异形怪。他们想向金龙维纶特瑞坦梅斯征求下意见，毕竟他也是个变形专家，结果这条龙也不见了，妓女媚儿和他在一起。<br>   第二个妓女也没了，同时消失的还有一个算命的，剩下的一个算命的说他才是真的那个，但是没人能证明。同时，那个自称是舒滕巴赫的侏儒也不见了。</p><p>   “你大概已经后悔了，”吟游诗人打了个大大的哈欠，“你不在真的是太遗憾了，那可是相当的精彩。”<br>   “我的确挺后悔的，”猎魔人感叹道，“但是你懂得……我不能,因为叶妮芙……总之你应该是最了解的。”<br>   “那是肯定的，”丹德里恩赞成到，“所以我才不会傻到去结婚。”</p><hr><h1 id="VIII"><a href="#VIII" class="headerlink" title="VIII"></a>VIII</h1><p>   城堡的厨房中传来了平底锅的叮当声，快乐的笑声以及哼哼的小调声。要为这么多客人提供盛宴是个问题，因为赫维格国王平日几乎就没什么客人。术士的到来并没有解决任何问题，出于对于食品安全的考量，食物都得是自然的东西，不掺杂一点魔法，所以南尼克到处助抓人打下手。一开始并不简单，因为被拉过来的人一点厨房的常识也没有，而那些会做饭的早就跑掉了。然而还是加德尼娅·比伯威特带着一群半身人过来帮忙。令人吃惊的是，丹德里恩招来的那四个妓女都是出乎意料的厨房能手。<br>   供给方面也没有问题菲斯奈特和艾格罗瓦尔组织了一场狩猎，打来了不少鹿肉，布蕾恩和他的女儿们只用了两个小时就打来了足够多的野味，众所周知树精大多箭术惊人，就连小女儿卡什卡弯弓搭箭也很流畅。热衷钓鱼的老国王赫维格一早就到湖上打鱼去了。带回了梭子鱼，狭鳕鱼还有好大只的贝斯鱼。ke的小儿子洛基跟他一同去的，岛民出身的他驾船打鱼样样精通，并且他也是早上为数不多能派上用场的，因为他和赫维格国王一样不沾酒。<br>   在变形怪特里科的驱使下，丹迪·比伯威特和他的亲戚们开始打扫大厅和各个房间，他们又赶着两个算命的，鳄鱼杀手，雕塑家还有喝的烂醉的灵媒师一同打扫清理。<br>   看管地下室的酒水的工作一开始交给了丹德里恩和他的朋友们，后来被证明这是一个灾难性的决定，于是这些诗人们就被赶了出去，钥匙交到莫斯萨克的女朋友芙蕾雅手中。但是丹德里恩和他的朋友们还赖着不走了，试图用抒情诗打动芙蕾雅，可这位岛民却像抵制酒精那样抵制他们的诗歌。<br>   杰洛特猛地抬起头来，他被从石子路上传来的马蹄声惊醒了，卡尔比从墙边的灌木丛中冲出，是希瑞来了，她穿着她的黑色皮革护甲，背上背着把剑，正是名剑格维尔，是她从科洛奇沙漠的地下墓穴中得到的。<br>   有那么一会他们就要彼此对视，也不说话。女孩驾着马向前，卡尔比向着杰洛特咬了过去，却被希瑞猛地拉了回来。<br>   “就是今天了，”猎魔女说道，“是今天，杰洛特。”<br>   “是今天，”猎魔人背靠着墙，确认到。<br>   “我很高兴”，她的声音中有种不确定，“我想……我不太肯定你们两个会不会幸福，但我还是很高兴。”<br>   “希瑞，下马，我们得谈谈。”<br>   女孩甩了下头，把头发甩到了后面。杰洛特看见了一道又宽又丑的伤疤——这是一段不堪回首的往事，希瑞就是为了遮住伤疤才将头发蓄长，但是她总是忘了挡住伤疤。<br>   “我要走了，杰洛特”她告诉猎魔人，“宴会之后，立马上路。”<br>   “下马，希瑞。”<br>   猎魔女跳下马来，坐在他身旁，杰洛特抱住了她，希瑞靠在他的肩上。<br>   “我要离开了，”她又说了一遍。<br>   他什么也没说，话到嘴边，但是他觉得不合适，或者说不必要。他什么也没说。<br>   “我知道你在想什么，”她慢慢的说道，“你觉得我是要逃跑，的确是这样。”<br>   他还是沉默着，他确实明白。<br>   “毕竟，在经历了这么多风风雨雨，你终于和叶结婚了，你理应幸福，理应有一个安定的家，但是这一切却令我感到害怕，杰洛特，所以……我要逃离这一切。”<br>   他还是沉默着，他想起了自己的逃跑。<br>   “宴会结束马上就走，”希瑞又说了一遍。“我想……我想要再次感受策马急行的风，我想眺望地平线上的星星，我想要晚上吹丹德里恩歌谣的调调，我渴求战斗，渴求用剑一决胜负，渴求冒险，渴求胜利带给我的喜悦，并且我渴求孤孤单单的一个人，你能明白我的意思吗？”<br>   “明白，”杰洛特悲伤的笑了笑，“我当然明白，你是我的宿命，你是个猎魔人，你要去做你必须要做的，但我必须要告诉你一件事，你不能一走了之，尽管你在不停的尝试。”<br>   “我知道，”她回应到，紧紧的抱住他，“我也希望有一天，如果我不停的等待，如果我有足够的耐心，我大概也有像你这样的一天……如此好的一天……即使……”<br>   “即使什么，希瑞？”<br>   “我很丑，而且还有那样一道难看的伤疤……”<br>   “希瑞！”他打断她，“你是世上最漂亮的女孩……当然只是在叶之后。”<br>   “杰洛特……”<br>   “你不信的话，去问丹德里恩。”<br>   “杰洛特，我……”<br>   “说起来，他死哪里去了……”<br>   “我要去南方，”她打断了他，不敢直视他。“战后仍然不安定，那里的人们需要保护，我会派上用场的，还要去科洛奇……还有尼弗迦德，我和格威尔在那里还有未了结的事。”<br>   她突然沉默了，脸变得冷漠起来。绿色的眼睛眯了起来，嘴角挂满了仇恨。我记得，杰洛特，我还记得，就像现在一样。上一次他们并肩在吕思勋城堡作战。楼梯上已经血流成河，他们就站在血泊当中。狼和猫，两个冷血的杀人机器，非人的速度和非人的冷漠，围上来的尼弗迦德人慢慢的后退。一只出奇冷静的狼和一只出奇疯狂的猫，闪烁的刀锋，哭喊声，四处迸溅的鲜血，以及遍地凋零的生命……就像那样，就像上一次那样。<br>   希瑞将头发向后甩去，灰白的头发在太阳穴处一阵震荡。<br>   “我还用未竟之事，”她冷冷的说道，“为了<a href="http://witcher.huijiwiki.com/wiki/%E7%B1%B3%E5%B8%8C%E5%B0%94" target="_blank" rel="noopener">米希尔</a>,为了我的米希尔，我已经为她报了仇，但是只杀一个人是不够的。”<br>   <a href="http://witcher.huijiwiki.com/wiki/%E7%B1%B3%E5%B8%8C%E5%B0%94" target="_blank" rel="noopener">雷欧·邦纳特</a>，她杀了他，为她报了仇。希瑞啊希瑞，你现在已经处在深渊边缘，女儿，即使杀了上千人也换不回你的米希尔，要提防仇恨啊，那种堪比癌症的情感。<br>   “你要当心你自己啊。”他低沉的说。<br>   “我宁愿让别人当心，”她讽刺的笑了笑，“这样回报更多，也更加有意义。”<br>   我再也见不到她了，他想，如果她走了，我不会再见到她了。<br>   “还会再见的，”她出乎意料的回答道，脸上挂着一个女术士而非猎魔人的微笑。“还会再见的，杰洛特。”<br>   她如一个男孩般跑开了，敏捷的跳上马鞍。<br>   “架，卡尔比！！”<br>【以上对话涉及的人的确是后面小说中的人物，但是故事的发展稍微不太一样】<br>马蹄铁踏在路上，迸溅出火花。丹德里恩不知从哪里冒出来了，他把鲁特琴挂在肩上，腾出手来，一手拿着一大罐啤酒。</p><p>   “来，喝一杯”他说着，坐在他身边，“这对你有好处。”<br>   “我不太确定，叶妮芙警告我，如果他在我身上闻到酒味”<br>   “嚼些欧芹就行了，喝吧，你这妻管严。”</p><p>   他们静静的坐了好长时间，慢悠悠的喝着啤酒，丹德里恩叹了口气。<br>   “希瑞要走了，是吗？”<br>   “嗯。”<br>   “我觉得也是，杰洛特，听我说两句……”<br>   “丹德里恩，你还是闭嘴吧。”<br>   “哦。好吧。”<br>   他们又沉默了。厨房传来了一股烤鹿肉的香味，刺柏的味道很浓。<br>   “……结束了（Something ends），”杰洛特艰难的说，“都结束了。”<br>   “可不是这样，”诗人严肃的反驳道，“是开始了（Something begins）”</p><hr><h1 id="IX"><a href="#IX" class="headerlink" title="IX"></a>IX</h1><p>   下午是在一片哭声中度过的，一切都是从美之灵药开始的，这种灵药，更准确的说是一种软膏，在古老的习俗中，也被称作“格拉玛耶”，据说可以使女性变得更加漂亮，更加引人注目。在各个主妇的要求下，te准备了大量的药膏。于是在场的女士们开始按照习俗涂抹。但是，在锁死的门后传来了希瑞菈、莫娜、艾思娜和卡什卡的哭声，她们不允许使用格拉玛耶，只有大女儿莫丽恩才能享受这一殊荣。哭的最响的是卡什卡，在她的上一层，莉莉正在哇哇的哭，她是dan的女儿，因为她发现和大多数魔法物品一样，格拉玛耶对半身人不起作用，在花园中瞎逛的灵媒师只是嗅了嗅，可她不知道的是嗅上一口就提神醒脑的后果，酒醒之后她陷入了无尽的忧郁当中。城堡的西翼，里夫·卡尔迪米恩的女儿阿妮卡也哭了起来，她不知道格拉玛耶是要涂在眼睛下面的，却吃了那药膏，现在正在腹泻。希瑞也拿了她那一份，涂在了卡尔比的眼下。<br>   女祭司小爱若拉和尤妮德也哭了，因为叶妮芙拒绝穿她们为她精心制作的白色婚纱，甚至南尼克在一旁劝也没用，叶妮芙骂骂咧咧，还把盘子给摔了，大声喊着她穿上这玩意就像一个他妈的白衣处女，南尼克也生气了，大声骂着她的行为比三个该死处女还糟糕。叶妮芙也没有回骂回去，直接放了一道闪电，打穿了塔楼的屋顶。这一举措还是有好的一面的，突如其来的巨响让卡尔迪米恩的女儿一惊，竟然吓好了她的腹泻。<br>   又有人看见特莉丝和猎魔人艾斯卡尔溜进了花园的小亭子，两人还手牵着手，毫无疑问，这次两人都是本人，因为变形怪特里科正在和丹迪·比伯威特和金龙维纶特瑞坦梅斯喝酒。<br>   人们又仔仔细细的找了一遍，还是没找到那个自称是舒滕巴赫的侏儒。</p><hr><h1 id="X"><a href="#X" class="headerlink" title="X"></a>X</h1><p>   “叶……”<br>   她看上去心情激动，金色的宝冠下，她那黑色的波浪般的卷发，垂在肩头，乌黑亮丽。立起的衣领是白色棉织，而袖口却镶着黑色条纹，两者通过紫罗兰色的紧身上衣连在一起。<br>   “花，别忘了花”，特莉丝在一旁提醒道，她一身深蓝色的装扮，递给新娘一束白玫瑰，“哦，叶。我太开心了……”<br>   “特莉丝，亲爱的……”叶妮芙突然抽泣起来，两个女术士紧紧地拥抱在一起，轻吻着彼此的钻石耳环。<br>   “意思意思就行了”南尼克在一旁不耐烦的提醒道，抚平洁白的祭祀服上的褶皱。“走，我们去教堂，爱若拉，尤妮德，托着她的裙摆，否则她会在楼梯口摔死自己的。”<br>   叶妮芙走向杰洛特伸出，伸出戴着白色蕾丝手套的手，整理了杰洛特嵌着银边的黑色斗篷的衣领，杰洛特伸出胳膊挽住她。<br>   “杰洛特，”他在她耳边轻轻的说道，“我还是不敢相信。”<br>   “叶，”杰洛特低声的回答道，“我爱你。”<br>   “我知道。”叶妮芙喃喃道。</p><hr><h1 id="XI"><a href="#XI" class="headerlink" title="XI"></a>XI</h1><p>   “赫维格死哪里去了？”<br>   “不知道，”丹德里恩一边轻抚着他那身时髦上衣的扣子，一边回答道。<br>   “说起来，希瑞去哪了？”<br>   “不知道。”叶妮芙皱起眉头，吸了吸鼻子。“你那股欧芹味的道不错啊，丹德里恩，你改吃素了吗？”<br>   宾客们开始陆续入场，小小的礼拜堂变得拥挤起来，一身黑礼服的艾格罗瓦尔坐在闪着白光的美人鱼希恩娜兹身边。他们的身边是一群穿着米黄色，棕色衣服的半身人，亚尔潘和金龙维纶特瑞坦梅斯则浑身上下金光闪闪，菲斯奈特和多瑞格雷则是一身紫色装扮，皇家使团的各位使者则和他们各自的纹章保持着一致的色调，精灵和树精是一身绿色。而丹德里恩和他的朋友们则穿的花里胡哨，五颜六色的的衣服。<br>   “有人看见洛基了吗？”莫斯萨克问道。<br>   “洛基？”艾斯卡尔走了过来，顺着装饰着野鸡毛的帽子看向德鲁伊。“洛基和赫维格一起湖上捕鱼去了，我看见他们的船还在湖上，希瑞则是去叫他们回来。”<br>   “这是什么时候的事?”<br>   “有一会了”。<br>   “诅咒你们得瘟疫，这群该死的渔夫，”克拉茨·安·克莱特咒骂道，“他们这是钓鱼钓上头了，把正事给忘了，雷格纳，去吧他们叫回来。”<br>   “等一下，”布蕾恩一把推开想要吃她豆腐的丹德里恩，“我们需要跑的快的人，莫娜，卡什卡， Raenn’ess aen laeke, va!”<br>   “早就说了，”南尼克气得不行，“赫维格根本就不靠谱，不敬畏神灵的白痴还要让他负责？谁还赞成他继续做主婚人？”<br>   “他好歹是个国王，”杰洛特不确定的说道，“可能叫前国王更确切，但好歹是个国王”<br>   “万岁……”一个算命的听到国王两个字后职业本能的开始唱起歌来，幸好，旁边的鳄鱼杀手及时放倒了他。半身人们开始骚动起来，有人骂骂咧咧，还有人被别人锤了鼻子，变形怪特里科踩到了加德尼娅·比伯威特的裙子，她开始尖叫起来，灵媒师则无缘无故的抽泣了起来<br>   “要是在这么等下去，”叶妮芙紧紧地抓住花束，努力保持着微笑，“再等一会我就要吐血了，马上给我开始。”<br>   “不要乱动，叶，”特莉丝悄声说道，“紧身衣要裂开了。”<br>   “那个侏儒舒滕巴赫跑到哪里去了，”一个歌手叫喊道。<br>   “我们也不知道啊。”四个妓女异口同声的喊道。<br>   “狗娘养的，马上派个人去找他，”丹德里恩大喊到，“他是负责带花过来的，现在可怎么办，舒滕巴赫和花都不在这，这婚礼可怎么继续？”<br>   被派去寻找国王的树精姐妹尖叫着冲进婚礼大厅，洛基则紧随其后，身上又脏又湿，前额上破了一个大口子。<br>   “洛基，”克拉奇喊了起来，“什么情况？”<br>   “妈妈！！！！！！”卡什卡哭喊道。<br>   “Que’ss aen!，”布蕾恩抓住她的两个女儿，抚慰她们，用精灵语问道，”Que’ss aen que suecc’ss feal, caer me?”<br>   “我们的船翻了……”洛基上气不接下气的说道，“就在岸边，来了只大怪物！，我用船桨揍他，但是他就直接吞了…….吞了我的船桨！”<br>   “谁？什么东西？”<br>   “杰洛特，”布蕾恩喊道，“杰洛特，莫娜说那是一只cinarea”<br>   “一只巨水蝽!”猎魔人惊叫道，“艾斯卡尔，快把我的剑拿来！”<br>   【怪物出自《精灵之血》，按照时间上来看，这是后来作者才安排的。】<br>   “我的法杖呢，”多瑞格雷也喊了一声，“雷德克里夫，我的法杖在哪？”<br>   “希瑞！”洛基喊了一声，擦了擦额头的鲜血，“希瑞正在和那怪兽战斗！”<br>   “操蛋了，希瑞根本打不过一只巨水蝽！艾斯卡尔，把我的马也牵来”<br>   “等一下，”叶妮芙甩掉头上的宝冠，“我们用传送门，那样更快，多瑞格雷，特莉丝，雷德克里夫，把你们的手给我……”<br>   一阵沉默过后，又响起了尖叫声，赫维格国王出现在门口，浑身又湿又脏，但是全身完好。他身边则站着一个光头的年轻人，身上穿着一套闪闪发光奇怪的盔甲。希瑞则紧随他们之后，手上提着格维尔，浑身泥泞，衣服滴着水，头发蓬乱，一道恐怖的伤疤横在脸上，从太阳穴直到下巴，袖口下的衣服被撕烂了，鲜血直流。<br>   “希瑞！！”<br>   “我杀了它，”猎魔人女孩弱弱的说道，“我劈开了它的头。”<br>   希瑞几乎要倒下了，杰洛特，艾斯卡尔和丹德里恩簇拥上前把住她，但就是这样她也没放开她的剑。<br>   “又受伤了……”吟游诗人悲叹到，“又是伤到了脸，为什么她的命运就这么不堪……”<br>   叶妮芙高声尖叫，一把推开雅尔，这个独臂的年轻人正好站在叶妮芙和希瑞之间，希瑞身上的泥巴和鲜血弄脏了女术士的婚纱，但是她一点也不在意。叶妮芙用手指按住猎魔人女孩的脸，吟诵了了一个魔法咒语，在杰洛特看来，整个城堡都因为这个法术晃了一下，甚至太阳也暗淡了一秒。叶妮芙缓慢的把手指从希瑞脸上移开，众人惊叹起来，巨大，丑陋的伤口变成一条细细的红线，只有几滴血而已，希瑞倒在杰洛特怀中。<br>   “厉害！”多瑞格雷感叹道，“这可是大师的手笔。”<br>   “干得好，叶，”特莉丝静静的说道，而一旁的南尼克则哭了起来。<br>   叶妮芙笑了笑，眼睛向上一翻，晕了过去，杰洛特还是在她如丝带般倒下之前抱住了她。</p><hr><h1 id="XII"><a href="#XII" class="headerlink" title="XII"></a>XII</h1><p>   “杰洛特，冷静，”南尼克说，“别太激动，过一会就好了，她只是用力过猛，别那么紧张了……你知道她有多爱希瑞。”<br>   “我知道。”杰洛特抬起头，看着门口站着的那个穿着一身闪闪发光的奇怪盔甲的年轻人。<br>   “听着，孩子，现在回到礼堂，这里没你事了，只是告诉我，你是谁？”<br>   “我，我是加拉哈德。”年轻的骑士回答道，“我想……我想问下那位美丽勇敢的少女怎么样了？”<br>   “哪一个？”猎魔人笑道，“这里有两个，两个都是漂亮，勇敢的少女，尽管其中一个只是偶然才是的，你说的是哪一个？”<br>   年轻人的脸，明显红了，“年轻的那一位……”他回答道，“就是那个义无反顾跑去帮助渔王的那位。”<br>   “谁？”<br>   “他说的是赫维格，”南尼克插嘴道，“巨水蝽在赫维格和洛基捕鱼时攻击了他们的船，希瑞则冲向了巨水蝽，而这个小伙子正好在近旁，过去帮了希瑞。”<br>   “你帮了希瑞，”猎魔人满怀感激的看着这个年轻的骑士，“你叫什么来着……”<br>   “加拉哈德，请问这里是阿瓦隆，渔王的城堡吗？”<br>   【阿瓦隆：亚瑟王传说中的极乐世界】<br>   门开了，叶妮芙在特莉丝的搀扶下出现在门口，她的脸色苍白。<br>   “叶！”<br>   “我们去礼堂。”女术士平静的要求到。“客人们都等着呢。”<br>   “叶……我们不急，可以再迟些。”<br>   “即使是恶魔要带走我，我也要嫁给你，而且是现在！”<br>   “希瑞怎么样了？”<br>   “哪个希瑞？”，猎魔人女孩从叶妮芙身后冒出，她正在往脸上涂抹着格拉玛耶。<br>   “一切都好，杰洛特，不过是一道擦伤，我都没什么感觉。”<br>   加拉哈德单膝跪地，铠甲发出金属碰撞的咯吱声。<br>   “女神……”<br>   希瑞漂亮的绿眼睛睁圆了。<br>   “希瑞，请允许我……”猎魔人说道，“这个骑士，嗯，加拉哈德，你们应当彼此见过了，他当时帮了你一把。”<br>   希瑞脸红了，格拉玛耶开始生效了，细小的伤疤在红润的脸蛋上几乎看不见了。<br>   “女神，”加拉哈德喃喃的说道，“您是如此亲切，如此美丽，请允许我留下,我想……”<br>   “毫无疑问，他想成为你的骑士，希瑞，”特莉丝说道。<br>   希瑞优雅的欠身行礼，但始终一句话也没说。<br>   “客人还等着呢，”叶妮芙打断他们。“加拉哈德，我在我看来，你不仅是个勇敢的战士，而且还是有礼貌的小伙子，你和我的……我的女儿并肩作战，所以，在婚礼上你可以挽住她，希瑞，快去换一身裙子，杰洛特，整理整理的你的头发，把你的内衬塞回袖子里去，都出来了，十分钟之内我要在礼堂看见你们。”</p><hr><h1 id="XIII"><a href="#XIII" class="headerlink" title="XIII"></a>XIII</h1><p>  婚礼仪式无比的辉煌，夫人和女孩们感动的哭成一片，赫维格——是前国王，但仍然是个国王——主持的婚礼，来自凯尔莫罕的维瑟米尔和南尼克作为这对新婚夫妻的父母方，特莉丝和艾斯卡尔是证婚人，加拉哈德陪着希瑞，后者脸红的像一枝娇艳的牡丹。<br>  佩剑的人们把剑搭在了一起，支起一个架子。丹德里恩和他的朋友们则演奏者鲁特琴，唱着特意为这个时刻谱写的曲子，在菲斯奈特的红发女儿们和美人鱼希恩娜兹的优美的歌声的伴奏下，丹德里恩开始即兴的祝愿这对新婚夫妻幸福，好运，以及一个成功的新婚之夜，听到这话，叶妮芙娇嗔的给了他一脚。【这里和原著有冲突，美人鱼献祭了尾巴换了腿以后，就失去了声音】<br>  人们聚集在王座大厅，各就各位，叶妮芙和杰洛特坐在主席上，手上绑着婚礼纱带，他们微笑着回应各位嘉宾的祝福和祝酒词。<br>  昨晚还乱搞一气的客人们，今晚则彻底变了样，都在以一种文明的方式尽情享乐，在相当长的一段时间里竟然没有人喝醉，当然只有一个人例外，那就是可怜的独臂小伙子雅尔，他无法忍受在加拉哈德甜甜的注视下满脸通红的希瑞，不停的喝闷酒 。今晚也没人意外失踪，除了卡什卡，不久之后，在桌子底下看见了她，她趴在一直狗身上，睡得正香呢。<br>  吸取了前一晚的教训，洛史洛格的鬼魂们也没有再来捣乱，只有一个例外，那就是只剩下骨架和裹尸布的马洪，突然出现在艾格罗瓦尔,莫斯萨克和菲斯奈特身后，然而王子，男爵和德鲁伊正非常专注的讨论政治，甚至都没有注意到他，由于没有一个人鸟他，这个骨架非常的沮丧。他在桌子旁四处走动，冷不丁的用他的牙齿咬了特莉丝一口，而女术士正温柔的依偎在艾斯卡尔的手臂上，她优雅的举起了手，掰断了他的手指头，狗处理了掰断的指骨。<br>  “愿伟大的梅里特利女神保佑你们夫妻俩，”南尼克亲吻了叶妮芙，和杰洛特碰了碰杯。“但是你们可没少走弯路，不过可算是结了婚。我真的很高兴，希望希瑞也能跟你们一样，找到命中注定的那个人后，能痛快的定下终生。”<br>  “我觉得，”杰洛特看向被猎魔人女孩迷住的加拉哈德，“她已经找到一个了。”<br>  “你说的是那个不知从哪里来的怪人？”女祭司惊讶道，“他们之间是没有结果的，你有没有仔细观察过那个人？没有？那你现在看看他在干嘛，他现在正在向希瑞求爱，但是手却不停的摸索着桌子上的酒杯，这可不太正常，我实在想不明白希瑞看他就像看一张照片那样仔细，雅尔，他可不一样，这孩子有理性，懂礼貌……”<br>  “您那有理性，懂礼貌的加尔已经摔到桌子下面去了，”叶妮芙打断了女祭司，“南尼克，别说了，希瑞过来了。”<br>  灰发的猎魔人女孩坐在赫维格让出的椅子上，搂住女术士。<br>  “我要离开了。”她平静地说。<br>  “我知道，孩子。”<br>  “加拉哈德……加拉哈德打算跟着我，也不知道为什么，我大概不能阻止他吧，对吗？”<br>  “当然阻止不了，杰洛特！”叶妮芙的眼睛，在温暖的紫罗兰色调中闪闪发光，看着她的丈夫，“到桌边去，陪客人们说说话，你也可以稍微喝上一小杯，但是只能是一小杯，我想和我的女儿谈谈，这是女人之间的谈话。”<br>  杰洛特叹了口气。<br>  聚会的氛围上来了。丹德里恩的朋友们唱的小黄歌让卡尔迪米恩的女儿安尼卡满脸通红。醉醺醺的龙v紧紧的抱着喝的更醉的变形怪特里科，试图说服他，变成a王子然后和美人鱼上床可不是个太友好的行为。<br>  菲斯奈特的红发女儿们则为了取悦那些皇家的使者们尽情的展现她们美妙的身姿，而皇家的使者们也在尽他们的全力打动树精们，看他们表演，总有种在游乐场的错觉。亚尔潘齐格林，用带有浓重鼻音的嗓子向精灵凯瑞尔丹说他打小就想当个精灵。莫斯萨克大喊着政府药丸，而艾格罗瓦尔则极力反对，当然也没人知道他们说的是哪个政府，赫维格国王则对加德尼娅说他用马鬃绳钓上了条大鲤鱼，半身人只是梦游般的点了点头，并且时不时的拍打下旁边的丈夫叫他不要喝的太多。<br>  画廊里，两个算命的和鳄鱼杀手则在四处走动，想找到那个名字叫舒滕巴赫的侏儒，但是仍旧找不到【未见侏儒——我们仍未找到那天前来赴宴的那个名字叫做舒滕巴赫的侏儒】，芙蕾雅显然讨厌酒量不行的男人，于是就在这和那个女灵媒师喝赫尔特·斯凯尔特，两人都保持着一种高尚和严肃的静默，因为这是一场无声的战斗。<br>  杰洛特绕着桌子走了一圈，挨个和客人们碰了杯，客人们也拍着他的背，祝他幸福。最后他来到了加拉哈德和丹德里恩附近，加拉哈德盯着诗人的酒杯，嘟嘟囔囔的说着什么，而吟游诗人则眯着眼睛仔细听着。杰洛特打算一探究竟。<br>  “……于是我就上了船，”加拉哈德说，“船驶向那片薄雾，我得向您承认，丹德里恩大师，我那时候怕的不行……我承认我有时候会失去希望，就像这次，我觉得我的末日到了，我会死在那片无法穿透的薄雾中，然后太阳就出来了…..在湖面上闪烁，就好像…金子一般。然后在我前方就是…阿瓦隆，这里是阿瓦隆，对吗？”<br>  “不是，”丹德里恩一边给两人满上，一边回答道，“这是Schwemmland，可以翻译成沼泽地……先喝一杯吧，加拉哈德。”<br>  “这个城堡……一定是蒙萨尔瓦特，不是吗？”<br>  “可不是，这个城堡叫洛史洛格，我就从来没听说过什么蒙萨尔瓦特，孩子，如果我都没听说过的话，那就是没有的事了，年轻人，为新婚夫妇干一杯吧。”<br>  “干杯，丹德里恩大师，但是那位国王，他不是渔王吗？”<br>  “赫维格？哦，他是挺喜欢钓鱼的，这倒是真的，他以前喜欢打猎，但是在奥斯战役中伤了腿，然后就再也不能骑马了，但你也不能叫人家渔王，首先，这个名字太蠢了，其次，你这样会冒犯到赫维格的。”<br>  加拉哈德半晌没说话，只是晃动着杯子中剩下一半的酒，然后他深深地叹了口气，环顾四周。<br>  “他们是对的，”他低声说道，“这只是个传说，一个童话，一段幻象，简而言之，这就是个谎言，这就是一片普通的沼泽地而不是阿瓦隆，没有希望了。”【阿瓦隆跟这个地方外表差不多】<br>  “喂，喂，”诗人用手戳了戳他，“不要伤心，孩子，你忧郁个什么劲？你正在参加一场婚礼派对，所以要做到就是高兴点，喝喝酒，唱唱歌。你还年轻，还有大把时光。还有一辈子的路要走。”<br>  “一辈子？”骑士若有所思的重复道，“那又如何，丹德里恩大师，有什么开始了，还是说有什么结束了？”<br>  丹德里恩好奇的看了他一眼。<br>  “不，我可不知道，如果连我都不知道的话，那就没人知道了，所以结论就是吗，没什么要结束，也没什么要开始。”<br>  “我不明白。”<br>  “你明白也没什么用。”</p><p>  加拉哈德想了想，皱起眉。<br>  “那圣杯呢？”他最后问道，“圣杯到哪里去了？”<br>  “圣杯又是什么东西？”<br>  “是我们追寻的东西，”他解释道，悲伤的看着吟游诗人，“那是最重要的，没有它，我们的生命就没什么意义，没有它，我们的生命永远不完整。”<br>  吟游诗人紧闭双唇，以他那著名的神色看向骑士，眼神中充满睿智和诚恳。<br>  “你个傻蛋，”他回答道，“你一整晚都坐在你的‘圣杯’旁边。”<br>  【这段亚瑟王的圆桌骑士异世界穿越是真的秀】</p><hr><h1 id="XIV"><a href="#XIV" class="headerlink" title="XIV"></a>XIV</h1><p>  午夜时分的，当客人已经玩的上头时，杰洛特和叶妮芙从宴会中脱离出来，他们终于可以平和的看看对方。突然，门开了，强盗维辛来了，人们都称他作“抢劫柏”，维辛身长两米开外，留着及腰长的大胡子，鼻子的颜色和形状都像萝卜，一直肩膀上扛着他那根著名的大棍子“牙签”，另一只肩膀上则扛着个大袋子。<br>  杰洛特和叶妮芙都认识这位“抢劫柏”。他俩谁也没想着要邀请他来。毫无疑问，这又是丹德里恩干的好事。<br>  “维辛，欢迎你，”女术士微笑道，“能记住我们真的是太好了，来，请坐”<br>  强盗倚着牙签，恭敬的鞠了一躬<br>  “祝你们快快乐乐，早生贵子”，他大声说道，“祝你们夫妻俩百年好合……我在说什么？两百年，该死的，应该是两百年。啊，我很高兴，杰洛特，还有叶妮芙夫人，我就知道你们会结婚的，尽管你们总是像,像狗一样打来打去。他妈的，我在说什么鸟话……”<br>  “欢迎，欢迎，维辛。”猎魔人说着，向着他能找到的最大的杯子倒酒，“为我们的健康干杯，你是打哪来的？有谣言说你进了监狱。”<br>  “他们把我给放了。”“抢劫柏”喝了一大口，叹了口气，“你们怎么说的，他妈的，保释？然后我就到这里来了，亲爱的，我给你们带了礼物，打开看看。”<br>  “这什么玩意，”女术士高声叫道，看着那个大口袋，里面的东西还在不停的动。<br>  “我是在路上看见的，”，抢劫柏回答道，“我是在花坛那里找见的，那有个光着屁股的石头女人，你知道的，就是有鸽子在上面……”<br>  “这袋子里到底是什么？”<br>  “哦，是一个，嗯，怎么说呢，一个小恶魔。这就当做新婚礼物了。你们这有放养动物的地方吗，没有？好吧，你们可以把他做成标本，然后挂着走廊上，人们看见了会惊叹的。但是我得告诉你，这他妈的是个骗子，他一直说自己叫舒滕巴赫。”</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/upload/pasted-357.png&quot;&gt;&lt;br&gt;《猎魔人》原著作者送给其朋友的结婚礼物，和正传发生的故事有些矛盾，但问题不大&lt;br&gt;高甜预警！！！&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java多线程学习6（CAS，原子类，CountDownLatch，CyclicBarrier，Semaphore）</title>
    <link href="https://www.junglezero.top/2019/07/02/ithreading-6/"/>
    <id>https://www.junglezero.top/2019/07/02/ithreading-6/</id>
    <published>2019-07-02T01:08:13.000Z</published>
    <updated>2019-07-12T04:40:25.746Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/upload/pasted-361.png" width="70%"></p><a id="more"></a><h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CAS通常是指（Compare And Swap或 Compare And Set）是硬件操作系统级别提供的具有原子性的原语指令，利用它可以在多线程中取得和同步一样的效果。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>基于<a href="https://www.junglezero.top/2019/04/23/%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81-1/#more">乐观锁</a>。以i++为例子举例，一般情况下是三步操作，分别是取值，+操作，存值，但是如果是多线程操作，就会存在线程安全的问题，对于CAS，首先获取旧的预期值，在准备保存时，和当前内存中的值进行对比（compare）,如果两个值相等，说明这个值没有发生改变，此时就存入新值（swap），如果发生改变，说明这个值已经被别的线程修改，此时当前线程不会进行操作，或者循环几个周期</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>因为加锁花销太大了（悲观锁）<br>结合上一个多线程的学习（AQS）,包括下面的原子类型，就可以发现实际上CAS是java并发包主要应用的一个方法</p><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>既然是基于乐观锁，那么势必会有ABA问题，所谓ABA问题，就是在当前线程准备存储过程中，如果这个值从A变成了B又变回了A，则对于当前线程，值是没有发生改变的，虽然从结果来看没什么影响，但是这实际上是个潜在的问题，解决的方法在上面的那个链接已经说明，就是添加一个版本号，或者时间戳</p><h3 id="自旋式循环"><a href="#自旋式循环" class="headerlink" title="自旋式循环"></a>自旋式循环</h3><p>当存值失败时，就有可能进入循环状态（自旋），如果多次失败，就会有效率上的问题</p><h1 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h1><p>java并发包下提供了java.util.concurrent.atomic包，包中包含了16个类（java8）</p><p><img src="/upload/pasted-339.png" alt="upload successful"></p><h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>摘录自API文档</p><blockquote><p>A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.</p></blockquote><blockquote><p>A CountDownLatch is initialized with a given count. The await methods block until the current count reaches zero due to invocations of the countDown() method, after which all waiting threads are released and any subsequent invocations of await return immediately. This is a one-shot phenomenon – the count cannot be reset. If you need a version that resets the count, consider using a CyclicBarrier.</p><p>A CountDownLatch is a versatile synchronization tool and can be used for a number of purposes. A CountDownLatch initialized with a count of one serves as a simple on/off latch, or gate: all threads invoking await wait at the gate until it is opened by a thread invoking countDown(). A CountDownLatch initialized to N can be used to make one thread wait until N threads have completed some action, or some action has been completed N times.</p><p>A useful property of a CountDownLatch is that it doesn’t require that threads calling countDown wait for the count to reach zero before proceeding, it simply prevents any thread from proceeding past an await until all threads could pass. </p></blockquote><p>从上面的描述中，得知几个事情</p><ul><li>这是一个计数器，用来使一个或者多个线程等待其他线程完成其操作</li><li>使用一个数值初始化，调用await使【当前线程】进入等待状态，当被等待的线程完成其任务时调用countDown()使计数–，直到减到0时【当前线程】不再等待</li><li>可以把countDownLatch理解为一个开关或者，只有【被等待线程】调用countDown()，await的线程才能“从大门进去”</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>文档中给到了一个Driver-Worker的实例<br>使用两个CountDownLatch，第一个在driver准备就绪之前，阻止worker执行，第二个使driver等待直到worker执行完<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123; <span class="comment">// ...</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     CountDownLatch startSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">     CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="comment">// create and start threads</span></span><br><span class="line">       <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(startSignal, doneSignal)).start();</span><br><span class="line"></span><br><span class="line">     doSomethingElse();            <span class="comment">// driver先执行</span></span><br><span class="line">     startSignal.countDown();      <span class="comment">// 调用countDown使startSignal归0</span></span><br><span class="line">     doSomethingElse();</span><br><span class="line">     doneSignal.await();           <span class="comment">// 使driver等着worker的线程执行完（等待doneSignal归0）</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startSignal;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line">   Worker(CountDownLatch startSignal, CountDownLatch doneSignal) &#123;</span><br><span class="line">     <span class="keyword">this</span>.startSignal = startSignal;</span><br><span class="line">     <span class="keyword">this</span>.doneSignal = doneSignal;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//等待startSignal归0</span></span><br><span class="line">       startSignal.await();</span><br><span class="line">       doWork();</span><br><span class="line">       <span class="comment">//worker线程每执行完，调用countdown，是doneSignal减1</span></span><br><span class="line">       doneSignal.countDown();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;&#125; <span class="comment">// return;</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>文档中还给到了一个另一个实例：<br>将一个问题分成多个部分，然后每个线程运行一部分<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver2</span> </span>&#123; <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N);</span><br><span class="line">    Executor e = ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="comment">// create and start threads</span></span><br><span class="line">      e.execute(<span class="keyword">new</span> WorkerRunnable(doneSignal, i));</span><br><span class="line"></span><br><span class="line">    doneSignal.await();           <span class="comment">// wait for all to finish</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkerRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> i;</span><br><span class="line">  WorkerRunnable(CountDownLatch doneSignal, <span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">this</span>.doneSignal = doneSignal;</span><br><span class="line">    <span class="keyword">this</span>.i = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      doWork(i);</span><br><span class="line">      doneSignal.countDown();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;&#125; <span class="comment">// return;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>和上面的CountDownLatch类似，但还是有区别的</p><blockquote><p>A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point. CyclicBarriers are useful in programs involving a fixed sized party of threads that must occasionally wait for each other. The barrier is called cyclic because it can be re-used after the waiting threads are released.</p><p>A CyclicBarrier supports an optional Runnable command that is run once per barrier point, after the last thread in the party arrives, but before any threads are released. This barrier action is useful for updating shared-state before any of the parties continue.</p></blockquote><p>这个强调的是“使一套线程等待彼此，直到所有的线程都到达了检查点（barrier point）”，相比于上面的CountDownLatch，它不需要执行线程去调用变化（countdown）</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>有两个构造方法<br><img src="/upload/pasted-340.png" alt="upload successful"><br>第一个方法的参数是这一组需要互相等待的线程的数量<br>当输入的数量大于需要运行的线程的数量时，由于到达检查点的线程（运行await）的数量小于预定的，所以会一直等待<br>当输入的参数小于需要进行互相等待的数量时，先到者优先，没有抢到的只能顺序运行<br>第二个方法还多一个Runnable对象，包括上面也说到了，这个线程的参数是指当所有的线程到达检查点时，并不会立刻运行，会先跑传入的参数的这个线程，这个线程完了，其他到检查点的线程才会解除等待状态</p><p><img src="/upload/pasted-341.png" alt="upload successful"><br>调用await时，有几个情况会使等待线程不再等待：</p><ul><li>最后一个线程到达检查点</li><li>超时</li><li>别的线程打断当前线程</li><li>别的线程打断别的等待线程（到达检查点的线程）</li><li>别的线程超时</li><li>对于当前的检查点，别的线程调用了它的reset方法</li></ul><p>CylicBarrier比countDownLatch优越在reset上，因为可以重复使用</p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>假设有一个使用场景，需要计算四个地方的值，然后进行汇总，计算部分的值单开一个线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建线程数量为4的检查点，四个线程到达检查点后，运行this的run</span></span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier c=<span class="keyword">new</span> CyclicBarrier(<span class="number">4</span>,<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//假设有4个需要计算的表，启动四个线程</span></span><br><span class="line">    <span class="keyword">private</span> Executor executor= Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">//保存结果</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;String,Integer&gt; results=<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//假设计算结果为1</span></span><br><span class="line">                    results.put(Thread.currentThread().getName(),<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//计算完毕后，在检查点等着</span></span><br><span class="line">                        c.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">"结果计算完毕，"</span>+Thread.currentThread().getName()+<span class="string">"溜了"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String,Integer&gt; sheet:results.entrySet())&#123;</span><br><span class="line">            result+=sheet.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"输出计算结果："</span>+result);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrierTest c=<span class="keyword">new</span> CyclicBarrierTest();</span><br><span class="line">        c.count();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：</p><p><img src="/upload/pasted-342.png" alt="upload successful"></p><h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><h2 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h2><p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。</p><blockquote><p>A counting semaphore. Conceptually, a semaphore maintains a set of permits. Each acquire() blocks if necessary until a permit is available, and then takes it. Each release() adds a permit, potentially releasing a blocking acquirer. However, no actual permit objects are used; the Semaphore just keeps a count of the number available and acts accordingly.</p></blockquote><p>关键点：Semaphore维持一个“许可证”（permit）来控制线程访问数量。通过acquire()获取许可，通过release()释放<br>要想理解其方法的实现，一定要知道一个重要的事情，这个工具是基于AQS实现的，通过观察源码可以发现不管是公平不公平的acquire还是release，都是基于内部自己继承<a href="https://www.junglezero.top/2019/06/28/va%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%88Lock%EF%BC%8CAQS-ReentrantLock%EF%BC%89/">AQS</a>的一个内部类Sync实现的</p><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><p>构造方法：<br><img src="/upload/pasted-343.png" alt="upload successful"><br>两个参数，一个是许可证的数量，再一个是允不允许公平（AQS那一套），默认不公平的</p><p><img src="/upload/pasted-344.png" alt="upload successful"><br>如果还有许可证就马上返回，许可证数量减1，如果没有许可证则进入阻塞序列直到有其他线程调用release或者被打断</p><h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><p>文档中给到了一个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_AVAILABLE = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Semaphore available = <span class="keyword">new</span> Semaphore(MAX_AVAILABLE, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getItem</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    available.acquire();</span><br><span class="line">    <span class="keyword">return</span> getNextAvailableItem();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putItem</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (markAsUnused(x))</span><br><span class="line">      available.release();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not a particularly efficient data structure; just for demo</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> Object[] items = ... whatever kinds of items being managed</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[MAX_AVAILABLE];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Object <span class="title">getNextAvailableItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">         used[i] = <span class="keyword">true</span>;</span><br><span class="line">         <span class="keyword">return</span> items[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// not reached</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">markAsUnused</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (item == items[i]) &#123;</span><br><span class="line">         <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">           used[i] = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个例子实际上并没有很显示的应用在多线程中，但还是有一点要说的，要是看的仔细，就会发现acquire，release方法并没有外面上锁，这是因为Semaphore，内部维持着一个实现AQS的内部类</p><p>当许可证的数量设置为1时，这时Semaphore就成为了一个互斥锁，但是和一般的锁不同的是这个Semaphore可以被其他线程调用（因为Semaphore没有拥有者的概念），这个特性可以用在解决死锁上（文档中说的）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SemaphoreLock lock=<span class="keyword">new</span> SemaphoreLock();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.lock();</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">"抢到了锁"</span>);</span><br><span class="line">                            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"释放了锁"</span>);</span><br><span class="line">                        lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreLock</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Semaphore semaphore=<span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> semaphore.tryAcquire();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/upload/pasted-361.png&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>字符串专题</title>
    <link href="https://www.junglezero.top/2019/06/30/StringProblemsCollection/"/>
    <id>https://www.junglezero.top/2019/06/30/StringProblemsCollection/</id>
    <published>2019-06-30T12:48:01.000Z</published>
    <updated>2019-07-10T13:30:52.320Z</updated>
    
    <content type="html"><![CDATA[<h1 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>题目描述：输入一个矩阵，按照从外向里以顺时针打印出每一个数字，例如：输入如下矩阵，则依次打印出的数字为：1、2、3、4、8、12、16、15、14、13、9、5、6、7、11、10.<br><img src="/upload/pasted-336.png" alt="upload successful"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Problem20</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] array=&#123;</span><br><span class="line">                &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,&#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;,&#123;<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>&#125;&#125;;</span><br><span class="line">        Problem20 testCircle=<span class="keyword">new</span> Problem20();</span><br><span class="line">        testCircle.printMatixClockwisely(array);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMatixClockwisely</span><span class="params">(<span class="keyword">int</span>[][] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(array[<span class="number">0</span>].length&gt;start*<span class="number">2</span>&amp;&amp;array.length&gt;start*<span class="number">2</span>)&#123;</span><br><span class="line">            printOneCircle(array,start);</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printOneCircle</span><span class="params">(<span class="keyword">int</span>[][] array, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;array[<span class="number">0</span>].length-start;i++)&#123;</span><br><span class="line">            System.out.print(array[start][i]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(array.length-<span class="number">1</span>-start&gt;start)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=start+<span class="number">1</span>;i&lt;array.length-start-<span class="number">1</span>;i++)&#123;</span><br><span class="line">                System.out.print(array[i][array[<span class="number">0</span>].length-<span class="number">1</span>-start]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(array[<span class="number">0</span>].length-start-<span class="number">1</span>&gt;start &amp;&amp;</span><br><span class="line">                array.length-start-<span class="number">1</span>&gt;start)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=array.length-start-<span class="number">1</span>;i&gt;start;i--)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(array[array.length-start-<span class="number">1</span>][i]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(array.length-<span class="number">1</span>-start&gt;start &amp;&amp;</span><br><span class="line">                array[<span class="number">0</span>].length-<span class="number">1</span>-start&gt;start)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=array.length-start-<span class="number">1</span>;i&gt;start;i--)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(array[i][start]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h1><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>主要的思路就是定住一个排后面的,对于定住这个问题，用到了递归的思想<br><img src="/upload/pasted-355.png" alt="upload successful"><br>这里存在的问题就是如果后面有重复的字母，就不在进行交换</p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串的排列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">permutation</span><span class="params">(String a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] chars=a.toCharArray();</span><br><span class="line">    permutationHelper(chars,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">permutationHelper</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> current)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (current==chars.length-<span class="number">1</span>)</span><br><span class="line">        System.out.println(chars.toString());</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=current;i&lt;chars.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isExisted(chars,current,i))&#123;</span><br><span class="line">                swap(chars,current,i);</span><br><span class="line">                permutationHelper(chars,current+<span class="number">1</span>);</span><br><span class="line">                swap(chars,i,current);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> current, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp=chars[i];</span><br><span class="line">    chars[i]=chars[current];</span><br><span class="line">    chars[current]=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isExisted</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> current, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=current;k&lt;i;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (chars[k]==chars[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串的组合"><a href="#字符串的组合" class="headerlink" title="字符串的组合"></a>字符串的组合</h1><h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><p>{a,b,c}要求输出{a,b,c,ab,ac,bc,abc}。</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>可以将题目分成小问题来理解，1个字符的组合+2个字符的组合+3个字符的组合，因此我们只要找到一般的方法，即从n个字符中找m个字符的组合就可以了。<br>我们可以把n个字符分成两部分，第一个字符和其他所有字符。如果组合里包含第一个字符，则下一步在剩余的字符里选取m-1个字符；如果组合里不包含第一个字符，则下一步在剩余的n-1个字符里选取m个字符，从中可以看出又是个递归的过程。</p><h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">char</span>[] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= array.length ; i ++ )</span><br><span class="line">            combination(array,<span class="number">0</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">combination</span><span class="params">(<span class="keyword">char</span>[] strArr, <span class="keyword">int</span> begin, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(stack);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (begin &gt;= strArr.length) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//把第一个字符放入组合中,在剩余的字符中选取num-1个字符</span></span><br><span class="line">            stack.push(strArr[begin]);</span><br><span class="line">            combination(strArr, begin + <span class="number">1</span>, num - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//组合里不包含第一个字符,则下一步在剩余的字符中选取num个字符</span></span><br><span class="line">            stack.pop();</span><br><span class="line">            combination(strArr, begin + <span class="number">1</span>, num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>因为组合问题，比如3个元素的组合就有2^3-1种，所以不妨给他们进行编号，就像上面的问题，从a——abc一次编号为 001——111。1就代表该位置出现字符。例如：001-&gt;c,010-&gt;b,101-&gt;ac……，所以原题就是要求输出”001”-“111”这2^n-1个组合对应的字符串。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">　　String s = <span class="string">"abc"</span>;</span><br><span class="line">　　ArrayList&lt;String&gt; result = combineString(s);</span><br><span class="line">　　<span class="keyword">for</span>(String r : result)&#123;</span><br><span class="line">　　　　System.out.println(r);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title">combineString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">　　<span class="keyword">int</span> len = s.length();</span><br><span class="line">　　ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(); </span><br><span class="line">　　<span class="keyword">int</span> count = (<span class="keyword">int</span>) (Math.pow(<span class="number">2</span>, len));</span><br><span class="line">　　<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; ++i)&#123;</span><br><span class="line">　　　　String temp = <span class="string">""</span>;</span><br><span class="line">　　　　String str = Integer.toBinaryString(i);</span><br><span class="line">　　　　<span class="keyword">while</span>(str.length() &lt; len)&#123;</span><br><span class="line">　　　　　　str = <span class="string">"0"</span> + str;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; str.length(); ++j)&#123;</span><br><span class="line">　　　　　　<span class="keyword">if</span>(str.charAt(j) == <span class="string">'1'</span>)&#123;</span><br><span class="line">　　　　　　　　temp += s.charAt(j);</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　list.add(temp);</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;顺时针打印矩阵&quot;&gt;&lt;a href=&quot;#顺时针打印矩阵&quot; class=&quot;headerlink&quot; title=&quot;顺时针打印矩阵&quot;&gt;&lt;/a&gt;顺时针打印矩阵&lt;/h1&gt;&lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>树（二叉树）专题</title>
    <link href="https://www.junglezero.top/2019/06/30/%E9%A2%98/"/>
    <id>https://www.junglezero.top/2019/06/30/题/</id>
    <published>2019-06-30T12:42:06.000Z</published>
    <updated>2019-07-08T10:49:04.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本结构（实现）"><a href="#基本结构（实现）" class="headerlink" title="基本结构（实现）"></a>基本结构（实现）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h1><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p>是一种先访问根结点，再访问左子节点，再访问右子结点的访问方式，用递归方式很容易实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preorderTraverse</span><span class="params">(TreeNode t)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(t!=<span class="keyword">null</span>)&#123;</span><br><span class="line">         System.out.println(t.val+<span class="string">""</span>);</span><br><span class="line">         preorderTraverse(t.left);</span><br><span class="line">         preorderTraverse(t.right);</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环的方法实现：<br>对于当前结点，首先访问，然后访问其左子结点，若其左子结点为空（即“访问到头了”）就要访问其右子结点，这个时候，就需要栈来记录其没有访问右子结点的父结点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderTraverse2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    TreeNode pNode = root;</span><br><span class="line">    <span class="comment">//栈不为空表示还有没有访问右结点的父结点存在</span></span><br><span class="line">    <span class="keyword">while</span> (pNode != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//若结点不为空，直接访问，下一步循环其左结点，并将该结点入栈，以便访问其右结点</span></span><br><span class="line">        <span class="keyword">if</span> (pNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(pNode.val+<span class="string">"  "</span>);</span><br><span class="line">            stack.push(pNode);</span><br><span class="line">            pNode = pNode.left;</span><br><span class="line">            <span class="comment">//左节点为空，即“到头”了，此时要从栈中找出没有访问右结点的父结点，出栈，访问其右结点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//pNode == null &amp;&amp; !stack.isEmpty()</span></span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            pNode = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>先访问左子结点，再访问父结点，再访问右子结点<br>递归方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderTraverse1</span><span class="params">(TreeNode node)</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;  </span><br><span class="line">           inOrderTraverse1(root.left);  </span><br><span class="line">           System.out.print(root.val+<span class="string">"  "</span>);  </span><br><span class="line">           inOrderTraverse1(root.right);  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>非递归方式：和之前差不多，只不过这次是在某个结点出栈的时候进行访问<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderTraverse2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    TreeNode pNode = root;</span><br><span class="line">    <span class="keyword">while</span> (pNode != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(pNode);</span><br><span class="line">            pNode = pNode.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//pNode == null &amp;&amp; !stack.isEmpty()</span></span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            System.out.print(node.val + <span class="string">"  "</span>);</span><br><span class="line">            pNode = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p>先访问左结点，再放问右结点，最后访问根结点<br>递归方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrderTraverse1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        postOrderTraverse1(root.left);</span><br><span class="line">        postOrderTraverse1(root.right);</span><br><span class="line">        System.out.print(root.val+<span class="string">"  "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>非递归方法：<br>初始根结点入栈，对于栈顶结点，如果其有左子结点或者右子结点且没有被访问，则按照右子结点，左子结点的顺序入栈，如果是叶子节点名，则出栈，直接访问，并用标记<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="常见题目"><a href="#常见题目" class="headerlink" title="常见题目"></a>常见题目</h1><h2 id="根据前序和中序遍历构造二叉树（假设不包含重复数字）"><a href="#根据前序和中序遍历构造二叉树（假设不包含重复数字）" class="headerlink" title="根据前序和中序遍历构造二叉树（假设不包含重复数字）"></a>根据前序和中序遍历构造二叉树（假设不包含重复数字）</h2><p>重点：</p><p><img src="/upload/pasted-317.png" alt="upload successful"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in)</span> </span>&#123;</span><br><span class="line">TreeNode root = reConstructBinaryTree(pre, <span class="number">0</span>, pre.length - <span class="number">1</span>, in, <span class="number">0</span>, in.length - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序遍历&#123;1,2,4,7,3,5,6,8&#125;和中序遍历序列&#123;4,7,2,1,5,3,8,6&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span> startPre, <span class="keyword">int</span> endPre, <span class="keyword">int</span>[] in, <span class="keyword">int</span> startIn, <span class="keyword">int</span> endIn)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (startPre &gt; endPre || startIn &gt; endIn) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode root = <span class="keyword">new</span> TreeNode(pre[startPre]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = startIn; i &lt;= endIn; i++)</span><br><span class="line"><span class="keyword">if</span> (in[i] == pre[startPre]) &#123;</span><br><span class="line">root.left = reConstructBinaryTree(pre, startPre + <span class="number">1</span>, startPre + i - startIn, in, startIn, i - <span class="number">1</span>);</span><br><span class="line">root.right = reConstructBinaryTree(pre, i - startIn + startPre + <span class="number">1</span>, endPre, in, i + <span class="number">1</span>, endIn);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先在树1中找到树2的根结点，然后在比较左子树和右子树</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树的子结构</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasSubTree</span><span class="params">(TreeNode t1,TreeNode t2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result=<span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1!=<span class="keyword">null</span>&amp;&amp;t2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1==t2)</span><br><span class="line">            result=checkSubTree(t1,t2);</span><br><span class="line">        <span class="keyword">if</span> (!result)</span><br><span class="line">            hasSubTree(t1.left,t2);</span><br><span class="line">        <span class="keyword">if</span> (!result)</span><br><span class="line">            hasSubTree(t1.right,t2);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkSubTree</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t2==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1.val!=t2.val)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> checkSubTree(t1.left,t2.left)&amp;&amp;checkSubTree(t1.right,t2.right);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="镜像二叉树"><a href="#镜像二叉树" class="headerlink" title="镜像二叉树"></a>镜像二叉树</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>输入一个二叉树，输出它的镜像</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p><img src="/upload/pasted-335.png" alt="upload successful"><br>通过示例图可以看出，输出镜像结点的方法就是从根结点开始，交换左右孩子…不断递归知道到达叶子结点<br>需要注意的是递归</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span> <span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    TreeNode temp = root.left;</span><br><span class="line">    root.left=root.right;</span><br><span class="line">    root.right=temp;</span><br><span class="line"></span><br><span class="line">    mirrorTree(root.left);</span><br><span class="line">    mirrorTree(root.right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>输入一个树，判断是不是对称的，即这棵树是不是和他的镜像树相同</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>注意找到递归的突破口</p><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对称二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode t1)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isSymmetrical(t1,t1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t1==<span class="keyword">null</span>&amp;&amp;t2==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1==<span class="keyword">null</span>||t2==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1.val!=t2.val)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (t1.left.val==t2.right.val)&amp;&amp;(t1.right.val==t2.left.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归方法，用栈实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root.left);</span><br><span class="line">    stack.push(root.right);</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">        TreeNode n1 = stack.pop(), n2 = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (n1 == <span class="keyword">null</span> &amp;&amp; n2 == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (n1 == <span class="keyword">null</span> || n2 == <span class="keyword">null</span> || n1.val != n2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        stack.push(n1.left);</span><br><span class="line">        stack.push(n2.right);</span><br><span class="line">        stack.push(n1.right);</span><br><span class="line">        stack.push(n2.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="从上到下打印二叉树"><a href="#从上到下打印二叉树" class="headerlink" title="从上到下打印二叉树"></a>从上到下打印二叉树</h1><h2 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h2><p>从上到下打印一棵二叉树，同一层的结点按照从左到右的顺序打印</p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>利用一个队列放下一系列需要打印的结点</p><h2 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从上到下打印二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTreeTopToBottom</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; q=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>||root.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        q.add(root.left);</span><br><span class="line">        q.add(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(root.val);</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span> (q.peek().left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            q.add(q.peek().left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q.peek().right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            q.add(q.peek().right);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(q.poll().val);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分行从上到下打印二叉树"><a href="#分行从上到下打印二叉树" class="headerlink" title="分行从上到下打印二叉树"></a>分行从上到下打印二叉树</h1><h2 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h2><p>上一道题的一种变式</p><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>添加两个变量，分别对当前行和下一行计数</p><h2 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTreeTopToBottomByLine</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; q=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.add(root);</span><br><span class="line">    <span class="keyword">int</span> currentLine=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> nextLine=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span> (q.peek().left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            q.add(q.peek().left);</span><br><span class="line">            nextLine++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q.peek().right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            q.add(q.peek().right);</span><br><span class="line">            nextLine++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(q.poll().val);</span><br><span class="line">        currentLine--;</span><br><span class="line">        <span class="keyword">if</span> (currentLine==<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println();</span><br><span class="line">            currentLine=nextLine;</span><br><span class="line">            nextLine=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="之字形打印二叉树"><a href="#之字形打印二叉树" class="headerlink" title="之字形打印二叉树"></a>之字形打印二叉树</h1><h2 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h2><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左往右的顺序，第二行从右往左，第三行从左往右依次类推</p><h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><p>有了上两道题的铺垫，我们对于这道题，首先可以看出这也需要逐行的分析，也就是偶数行需要从左往右打印，奇数行需要从右向左（从第0行开始），同样也用队列当做容器</p><h2 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h2><p>LeetCode第103题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">int</span> level=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> num=queue.size();</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(level%<span class="number">2</span>!=<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (queue.peek().left!=<span class="keyword">null</span>)queue.offer(queue.peek().left);</span><br><span class="line">                <span class="keyword">if</span> (queue.peek().right != <span class="keyword">null</span>) queue.offer(queue.peek().right);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (queue.peek().right != <span class="keyword">null</span>) queue.offer(queue.peek().right);</span><br><span class="line">                <span class="keyword">if</span> (queue.peek().left!=<span class="keyword">null</span>)queue.offer(queue.peek().left);</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(queue.poll().val);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(list);</span><br><span class="line">        level++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="二叉搜索树的后续遍历序列"><a href="#二叉搜索树的后续遍历序列" class="headerlink" title="二叉搜索树的后续遍历序列"></a>二叉搜索树的后续遍历序列</h1><h2 id="描述-6"><a href="#描述-6" class="headerlink" title="描述"></a>描述</h2><p>输入一个整数数组，判断该数组是不是某二叉搜素树后续遍历的结果，假设输入的数都各不相同</p><h2 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h2><p>应当抓住<a href="https://www.junglezero.top/2018/02/14/%EF%BC%882%EF%BC%89/">二叉搜索树</a>的特点,即对于根结点，左子树的结点数值都比根结点小，右子树的结点数值都比根结点大，然后递归的方式寻找</p><h2 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的后续遍历序列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence, <span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sequence==<span class="keyword">null</span>||sequence.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> root=sequence[sequence.length-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i=start;</span><br><span class="line">    <span class="comment">//确定左子树边界</span></span><br><span class="line">    <span class="keyword">for</span> (;i&lt;end;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (sequence[i]&gt;root)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j=i;</span><br><span class="line">    <span class="comment">//在右子树中，如果存在小于根结点的值，则说明这个序列不是个搜索树的后续遍历</span></span><br><span class="line">    <span class="keyword">for</span> (;j&lt;end;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (sequence[j]&lt;root)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归判断左子树</span></span><br><span class="line">    <span class="keyword">boolean</span> left=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        left=isSquenceOfBST(sequence,<span class="number">0</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归判断右子树</span></span><br><span class="line">    <span class="keyword">boolean</span> right=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;end)&#123;</span><br><span class="line">        right=isSquenceOfBST(sequence,i,end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left&amp;&amp;right;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h1><h2 id="描述-7"><a href="#描述-7" class="headerlink" title="描述"></a>描述</h2><p>输入一个二叉树和一个整数，打印二叉树中结点的值的和为输入整数的所有路径，从根结点一直到尾结点为一个路径</p><h2 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h2><p>这个题很明显想到用回溯法，用一个栈来存放结点</p><h2 id="实现-8"><a href="#实现-8" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树中和为某一值的路径</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findPath</span><span class="params">(TreeNode root,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root==<span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       <span class="keyword">int</span> curentNum=<span class="number">0</span>;</span><br><span class="line">       findPath(root,num,stack,curentNum);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findPath</span><span class="params">(TreeNode root, <span class="keyword">int</span> num, Stack&lt;Integer&gt; stack, <span class="keyword">int</span> curentNum)</span> </span>&#123;</span><br><span class="line">       curentNum+=root.val;</span><br><span class="line">       stack.push(root.val);</span><br><span class="line">       <span class="keyword">if</span> (root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span> (curentNum==num)&#123;</span><br><span class="line">               System.out.println(<span class="string">"找到一条路径："</span>);</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> n:stack)&#123;</span><br><span class="line">                   System.out.print(n+<span class="string">" "</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (root.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           findPath(root.left,num,stack,curentNum);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (root.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           findPath(root.right,num,stack,curentNum);</span><br><span class="line">       &#125;</span><br><span class="line">       stack.pop();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="二叉搜素树和双向链表"><a href="#二叉搜素树和双向链表" class="headerlink" title="二叉搜素树和双向链表"></a>二叉搜素树和双向链表</h1><h2 id="描述-8"><a href="#描述-8" class="headerlink" title="描述"></a>描述</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求<br>不能创建任何新的结点，只能调整树中结点指针的指向</p><h2 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h2><p>还是要抓住二叉搜素树的特点<br><img src="/upload/pasted-349.png" alt="upload successful"><br>中序遍历恰好可以使一棵二叉搜索树按顺序输出<br><img src="/upload/pasted-350.png" alt="upload successful"><br>按照中序遍历的顺序，当我们遍历到根结点时，它的左子树已经转换成一个排序的好的双向链表了，并且处在链表中最后一个的结点是当前值最大的结点。我们把值为8的结点和根结点链接起来，10就成了最后一个结点，接着我们就去遍历右子树，并把根结点和右子树中最小的结点链接起来。</p><h2 id="实现-9"><a href="#实现-9" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRootOfTree == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(pRootOfTree.left == <span class="keyword">null</span> &amp;&amp; pRootOfTree.right == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">    </span><br><span class="line">    TreeNode leftNode = Convert(pRootOfTree.left);</span><br><span class="line">    TreeNode curNode = leftNode;</span><br><span class="line">    <span class="comment">//找到左子树最右边的叶子节点</span></span><br><span class="line">    <span class="keyword">while</span>(curNode != <span class="keyword">null</span> &amp;&amp; curNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        curNode = curNode.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接根节点与左子树的最右叶子节点</span></span><br><span class="line">    <span class="keyword">if</span>(leftNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        pRootOfTree.left = curNode;</span><br><span class="line">        curNode.right = pRootOfTree;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//右子树的最左叶子节点</span></span><br><span class="line">    TreeNode rightNode = Convert(pRootOfTree.right);</span><br><span class="line">    <span class="comment">//连接根节点与右子树的最左叶子节点</span></span><br><span class="line">    <span class="keyword">if</span>(rightNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        pRootOfTree.right = rightNode;</span><br><span class="line">        rightNode.left = pRootOfTree;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//考虑没有左子树的情况</span></span><br><span class="line">    <span class="keyword">return</span> leftNode==<span class="keyword">null</span>?pRootOfTree:leftNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h1><h2 id="描述-9"><a href="#描述-9" class="headerlink" title="描述"></a>描述</h2><p>请实现两个函数，分别用来序列化和反序列化二叉树</p><h2 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h2><p>二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（$）</p><p>二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p><h2 id="实现-10"><a href="#实现-10" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">Serialize</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    StringBuilder b=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    circleSerialize(root,b);</span><br><span class="line">    <span class="keyword">return</span> b.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">circleSerialize</span><span class="params">(TreeNode root, StringBuilder b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>)</span><br><span class="line">        b.append(<span class="string">"$,"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    b.append(root.val+<span class="string">","</span>);</span><br><span class="line">    circleSerialize(root.left,b);</span><br><span class="line">    circleSerialize(root.right,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反序列化（根据前序遍历结果）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">DeSeriablize</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">   String[] s= str.split(<span class="string">","</span>);</span><br><span class="line">   <span class="keyword">int</span> index=-<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">return</span> DeSeriablizeCore(str,index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">DeSeriablizeCore</span><span class="params">(String str, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    String[]s=str.split(<span class="string">","</span>);</span><br><span class="line">    TreeNode node=<span class="keyword">null</span>;</span><br><span class="line">    index++;</span><br><span class="line">    <span class="keyword">if</span> (!s[index].equals(<span class="string">"$"</span>)) &#123;</span><br><span class="line">        node = <span class="keyword">new</span> TreeNode(Integer.parseInt(s[index]));</span><br><span class="line">        node.left=DeSeriablizeCore(str,index);</span><br><span class="line">        node.right=DeSeriablizeCore(str,index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本结构（实现）&quot;&gt;&lt;a href=&quot;#基本结构（实现）&quot; class=&quot;headerlink&quot; title=&quot;基本结构（实现）&quot;&gt;&lt;/a&gt;基本结构（实现）&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
      <category term="[object Object]" scheme="https://www.junglezero.top/categories/object-Object/"/>
    
    
      <category term="数据结构" scheme="https://www.junglezero.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="https://www.junglezero.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程学习5（Lock，AQS，ReentrantLock，ReentrantReadWriteLock，Condition）</title>
    <link href="https://www.junglezero.top/2019/06/28/va%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%88Lock%EF%BC%8CAQS-ReentrantLock%EF%BC%89/"/>
    <id>https://www.junglezero.top/2019/06/28/va多线程学习（Lock，AQS-ReentrantLock）/</id>
    <published>2019-06-28T08:09:00.000Z</published>
    <updated>2019-07-12T04:41:43.925Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/upload/pasted-362.png" width="70%"></p><a id="more"></a><h1 id="Lock-接口"><a href="#Lock-接口" class="headerlink" title="Lock 接口"></a>Lock 接口</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Java程序是靠synchronized关键字实现锁功能的，而Java SE 5之后，并发包中新增<br>了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized关键字类似的同步功<br>能，只是在使用时需要显式地获取和释放锁。虽然它缺少了（通过synchronized块或者方法所提<br>供的）隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以<br>及超时获取锁等多种synchronized关键字所不具备的同步特性</p><p>相比于Synchronized，Lock具有以下几个特性</p><p><img src="/upload/pasted-331.png" alt="upload successful"></p><h2 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h2><h3 id="void-lock-void-unlock"><a href="#void-lock-void-unlock" class="headerlink" title="void lock(),void unlock()"></a>void lock(),void unlock()</h3><p>这两个方法一个是上锁，一个是解锁<br>基本相当于synchronized关键字，具体使用方法如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="void-lockInterruptibly-throws-InterruptedException"><a href="#void-lockInterruptibly-throws-InterruptedException" class="headerlink" title="void lockInterruptibly() throws InterruptedException;"></a>void lockInterruptibly() throws InterruptedException;</h3><p>这个方法可以中断的获取锁，这就是和synchronized（lock()）很大的一个不同，即在抢锁的过程中可以中断该线程</p><p>演示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">validLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"Thread-"</span>+Thread.currentThread().getName()+<span class="string">"takes the synlock"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">        e.printStackTrace();;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>   <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String arg[])</span></span>&#123;</span><br><span class="line">    Thread t1=<span class="keyword">new</span> Thread()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            validLock();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Thread t2 =<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            validLock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t2.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个例子中，线程2是不会响应中断的</p><p>然而<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">validLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"Thread-"</span>+Thread.currentThread().getName()+<span class="string">"takes the synlock"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">        e.printStackTrace();;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>   <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String arg[])</span></span>&#123;</span><br><span class="line">    Thread t1=<span class="keyword">new</span> Thread()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                validLock();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Thread t2 =<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                validLock();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t2.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个实例中。t2会响应中断</p><h3 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock()"></a>tryLock()</h3><p>通过这个方式可以非阻塞的获取锁，即，即使抢不到锁，该线程也不会进入block状态，tryLock()的返回值是boolean,获取锁成功返回true，没获取锁返回false</p><p>具体用法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">TestTryLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lock.tryLock())&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"抢不到锁，溜了溜了（反正绝对不堵着）"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="boolean-tryLock-long-time-TimeUnit-unit-throws-InterruptedException"><a href="#boolean-tryLock-long-time-TimeUnit-unit-throws-InterruptedException" class="headerlink" title="boolean tryLock(long time, TimeUnit unit) throws InterruptedException;"></a>boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</h3><p>这个就是超时获取锁的体现，如果在指定时间内没有获取锁，就退出，在这个指定的时间内，也可以中断</p><h3 id="Condition-newCondition"><a href="#Condition-newCondition" class="headerlink" title="Condition newCondition();"></a>Condition newCondition();</h3><p>用来创建一个基于当前同步器的Condition对象，下文会介绍Condition</p><h1 id="AQS-AbstractQueuedSynchronizer"><a href="#AQS-AbstractQueuedSynchronizer" class="headerlink" title="AQS(AbstractQueuedSynchronizer)"></a>AQS(AbstractQueuedSynchronizer)</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>队列同步器AbstractQueuedSynchronizer（以下简称同步器），是用来构建锁或者其他同步组<br>件的基础框架，它使用了一个int成员变量（一个atomic int value）表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作，所以说AQS是JUC锁的灵魂所在</p><h2 id="各种概念"><a href="#各种概念" class="headerlink" title="各种概念"></a>各种概念</h2><h3 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h3><p>同步器依赖内部的同步队列（一个FIFO双向队列）来完成同步状态的管理，当前线程获取<br>同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node）并将其<br>加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再<br>次尝试获取同步状态。</p><p>同步器包含了两个节点类型的引用，一个指向头节点，而另一个指向尾节点。<br>试想一下，当一个线程成功地获取了同步状态（或者锁），其他线程将无法获取到同步状态，转<br>而被构造成为节点并加入到同步队列中，而这个加入队列的过程必须要保证线程安全，因此同步器提供了一个基于CAS的设置尾节点的方法：compareAndSetTail(Node expect,Node<br>update)，它需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式<br>与之前的尾节点建立关联</p><p><img src="/upload/pasted-332.png" alt="upload successful"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="独占锁的的实现"><a href="#独占锁的的实现" class="headerlink" title="独占锁的的实现"></a>独占锁的的实现</h3><h4 id="我们要做的"><a href="#我们要做的" class="headerlink" title="我们要做的"></a>我们要做的</h4><p>在API文档中，提到这么一句</p><blockquote><p>Subclasses should be defined as non-public internal helper classes that are used to implement the synchronization properties of their enclosing class. </p></blockquote><p>也就是说在使用上，要把AQS的继承类写在阻塞队列的内部，作为一个内部类出现<br>官方文档中还提到：<br>要想实现一个自定义同步器，就要实现以下几种方法，并且对于线程的状态，运用 getState(), setState(int) and/or compareAndSetState(int, int): </p><ul><li>tryAcquire(int)</li><li>tryRelease(int)</li><li>tryAcquireShared(int)</li><li>tryReleaseShared(int)</li><li>isHeldExclusively(</li></ul><p>API文档中也给了一个非重入式互斥独占锁的实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要自定义的锁</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 上文提到的内部类</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">     <span class="comment">// Reports whether in locked state</span></span><br><span class="line">     <span class="comment">//返回是否独占当前锁（0表示为占用锁，1表示锁已经被占用）</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Acquires the lock if state is zero</span></span><br><span class="line">     <span class="comment">//状态为0时尝试获取锁</span></span><br><span class="line">     <span class="comment">//重点要实现的方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//意思是传入的accauires的值必须要是1，要是不是1就退出了</span></span><br><span class="line">       <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">       <span class="comment">//这是一个原子操作</span></span><br><span class="line">       <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">         <span class="comment">//如果成功将状态从0变成了1，说明抢到锁，并且排他的（Exclusive）占用这把锁（独占）</span></span><br><span class="line">         <span class="comment">//并不用考虑这两个动作会不会发生同步问题，因为该方法是accquire调用的，其内部已经实现了某种竞争机制</span></span><br><span class="line">         setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Releases the lock by setting state to zero</span></span><br><span class="line">     <span class="comment">//将状态设为0来释放锁</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">       <span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">       <span class="comment">//将独占锁的线程设置为空</span></span><br><span class="line">       setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">       <span class="comment">//将状态设置为0</span></span><br><span class="line">       setState(<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Provides a Condition</span></span><br><span class="line">     <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject(); &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Deserializes properly</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">       s.defaultReadObject();</span><br><span class="line">       setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//上面就是几个重要方法的实现，具体使用如下</span></span><br><span class="line">   <span class="comment">// The sync object does all the hard work. We just forward to it.</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//调用Accquire</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>                </span>&#123; sync.acquire(<span class="number">1</span>); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>          </span>&#123; <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>              </span>&#123; sync.release(<span class="number">1</span>); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> sync.newCondition(); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span>         </span>&#123; <span class="keyword">return</span> sync.isHeldExclusively(); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sync.hasQueuedThreads(); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h4 id="细节理解"><a href="#细节理解" class="headerlink" title="细节理解"></a>细节理解</h4><h5 id="acquire"><a href="#acquire" class="headerlink" title="acquire()"></a>acquire()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryAcquire(int arg):线程安全的获取同步状态<br>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)：构造同步节点（独占式<br>Node.EXCLUSIVE，同一时刻只能有一个线程成功获取同步状态）并通过addWaiter(Node node)<br>方法将该节点加入到同步队列的尾部，最后调用acquireQueued(Node node,int arg)方法，使得该<br>节点以“死循环”的方式获取同步状态<br>…<br>。。。<br>…<br>。。。</p><p><img src="/upload/pasted-333.png" alt="upload successful"></p><h3 id="共享锁的实现"><a href="#共享锁的实现" class="headerlink" title="共享锁的实现"></a>共享锁的实现</h3><p>一个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwinsLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//依然是内部类的方式实现</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//状态用“0,1,2”进行标记</span></span><br><span class="line">        Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count must large than zero."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//实现tryAcquireShared</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> reduceCount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();<span class="keyword">int</span> newCount = current - reduceCount;</span><br><span class="line">                <span class="keyword">if</span> (newCount &lt; <span class="number">0</span> || compareAndSetState(current,</span><br><span class="line">                        newCount)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> newCount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//实现tryReleaseShared</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> returnCount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="keyword">int</span> newCount = current + returnCount;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, newCount)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他接口方法略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是一个允许最多两个线程同时访问的共享锁，因而实现的方法是shared那些。同步器会先计算出获取后的同步状态，然后通过CAS确保状态的正确设置，当tryAcquireShared(int reduceCount)方法返回值大于等于0时，当前线程才获取同步状态，对于上层的TwinsLock而言，则表示当前线程获得了锁</p><h1 id="ReentrantLock（重入锁）"><a href="#ReentrantLock（重入锁）" class="headerlink" title="ReentrantLock（重入锁）"></a>ReentrantLock（重入锁）</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>根据其名字，可以知道，这个锁是可“重复使用”的（synchronized也是支持重入的），一般情况下（如上文实现的互斥独占锁），如果让一个已经上锁的线程尝试再次上锁，那么它就会被自己所阻塞，最终进入阻塞状态它实际上，是Lock的一种实现，另外，还涉及到一个公平的问题</p><h2 id="细节分析"><a href="#细节分析" class="headerlink" title="细节分析"></a>细节分析</h2><h3 id="重进入的实现"><a href="#重进入的实现" class="headerlink" title="重进入的实现"></a>重进入的实现</h3><p>锁的获取：<br>识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理重进入的过程</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>锁的释放：<br>重复获取锁n次，就需要重复释放锁n次（有一个计数器）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//每次释放，都要做减法，只有状态值为0才能释放出去，允许其他线程抢</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="公平和不公平"><a href="#公平和不公平" class="headerlink" title="公平和不公平"></a>公平和不公平</h3><p>所谓公平和不公平，是指能不按照运行的绝对时间获取锁，即FIFO<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">    <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">    <span class="comment">// thread is first in queue.</span></span><br><span class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过观察我们可以返现相比于上文的nofair方法，这个方法多了一个hasQueuedPredecessors()，上面也附上了这个方法的实现，可以了解到“公平”就是通过同步器队列实现的，查看当前线程是否有前置结点，如果没有前置结点，则获得锁。<br>有一点要记住：默认的ReentrantLock中的require是非公平的方法，因为其效率更高</p><h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>读写锁在之前已经自己实现过一次了<br><a href="https://www.junglezero.top/2019/04/16/%E7%BA%BF%E7%A8%8B%E8%AF%BB%E5%86%99%E9%94%81%E5%88%86%E7%A6%BB/">自己实现的读写锁</a><br>根据以前的总结，读写锁需要注意的是：读进程和读进程可以同时进行，但是读进程和写进程是互斥的</p><p>API文档介绍了这个类的几个特性：</p><ul><li>支持公平不公平的抢锁（默认是不公平的）</li><li>可重入</li><li>可以从写锁降级至读锁，但不能从读锁升级为写锁</li><li>获取过程可以被打断</li><li>支持Condition</li></ul><h3 id="细节分析-1"><a href="#细节分析-1" class="headerlink" title="细节分析"></a>细节分析</h3><h4 id="读写状态的确定"><a href="#读写状态的确定" class="headerlink" title="读写状态的确定"></a>读写状态的确定</h4><p>实现时，采用了一个整型变量进行维护读写两种状态</p><p><img src="/upload/pasted-334.png" alt="upload successful"><br>当前同步状态值为S，写状态等于S&amp;0x0000FFFF（将高16位全部抹去），读状态等于S&gt;&gt;&gt;16（无符号补0右移<br>16位）。当写状态增加1时，等于S+1，当读状态增加1时，等于S+(1&lt;&lt;16)，也就是<br>S+0x00010000。<br>S不等于0时，当写状态（S&amp;0x0000FFFF）等于0时，则读状态（S&gt;&gt;&gt;16）大于0，即读锁已被获取。</p><h4 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 存在读锁或者当前获取线程不是已经获取写锁的线程</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读写锁要确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞</p><h4 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">int</span> nextc = c + (<span class="number">1</span> &lt;&lt; <span class="number">16</span>);</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; c)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp; owner != Thread.currentThread())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。</p><h4 id="写锁降级"><a href="#写锁降级" class="headerlink" title="写锁降级"></a>写锁降级</h4><p>API文档中给到了一个降级锁的实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CachedData</span> </span>&#123;</span><br><span class="line">  Object data;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">boolean</span> cacheValid;</span><br><span class="line">  <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">processCachedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rwl.readLock().lock();</span><br><span class="line">    <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">      <span class="comment">// Must release read lock before acquiring write lock</span></span><br><span class="line">      rwl.readLock().unlock();</span><br><span class="line">      rwl.writeLock().lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Recheck state because another thread might have</span></span><br><span class="line">        <span class="comment">// acquired write lock and changed state before we did.</span></span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">          data = ...</span><br><span class="line">          cacheValid = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Downgrade by acquiring read lock before releasing write lock</span></span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        rwl.writeLock().unlock(); <span class="comment">// Unlock write, still hold read</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      use(data);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      rwl.readLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>API文档已经说明了适合使用在数据量较大的容器，读操作比写操作更多的情况下，也给到了一个实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RWDictionary</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Data&gt; m = <span class="keyword">new</span> TreeMap&lt;String, Data&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Lock r = rwl.readLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Lock w = rwl.writeLock();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Data <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    r.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.get(key); &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; r.unlock(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String[] allKeys() &#123;</span><br><span class="line">    r.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.keySet().toArray(); &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; r.unlock(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Data <span class="title">put</span><span class="params">(String key, Data value)</span> </span>&#123;</span><br><span class="line">    w.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.put(key, value); &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; w.unlock(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    w.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123; m.clear(); &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; w.unlock(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意，读锁和写锁都有最大值的限制：65535</p><h2 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><p>用官方文档的话来说，Condition的作用就是用来替代object监视器的wait，notify，notifyAll方法，并且，A Condition instance is intrinsically bound to a lock.要想生成一种condition，调用lock方法的new condition创建。<br>下面用一个官方API文档中写的例子讲解用法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">final</span> Condition notFull  = lock.newCondition(); </span><br><span class="line">  <span class="keyword">final</span> Condition notEmpty = lock.newCondition(); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">  <span class="keyword">int</span> putptr, takeptr, count;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (count == items.length)</span><br><span class="line">        notFull.await();</span><br><span class="line">      items[putptr] = x;</span><br><span class="line">      <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">      ++count;</span><br><span class="line">      notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">        notEmpty.await();</span><br><span class="line">      Object x = items[takeptr];</span><br><span class="line">      <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;</span><br><span class="line">      --count;</span><br><span class="line">      notFull.signal();</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个例子实现的是一个有界缓存，类似于<a href="https://www.junglezero.top/2019/03/29/a%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%883%EF%BC%89/">生产者/消费者</a>，当缓存不为空时，消费者就可以拿取数据，当缓存不满时，生产者就可以放入数据，唯一不同的是这里的锁不是synchronized，而监视器用的也不是object</p><h3 id="细节分析-2"><a href="#细节分析-2" class="headerlink" title="细节分析"></a>细节分析</h3><p>一个Condition包含一个FIFO等待队列，队列中的结点都包含一个线程的引用，如果一个线程调用了Condition.await()方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态，对于一个Lock（同步器），其包含一个阻塞队列和多个等待队列（一个Condition对应一个）</p><h4 id="等待await"><a href="#等待await" class="headerlink" title="等待await"></a>等待await</h4><p><img src="/upload/pasted-337.png" alt="upload successful"><br>该方法的线程成功获取了锁的线程，也就是同步队列中的首节点，该方法会将当前线程构造成节点并加入等待队列中，然后释放同步状态，唤醒同步队列中的后继节点，然后当前线程会进入等待状态。<br>等待队列中的节点被唤醒，则唤醒节点的线程开始尝试获取同步状态。如果不是通过其他线程调用Condition.signal()方法唤醒，而是对等待线程进行中断，则会抛出InterruptedException。</p><h4 id="通知signal"><a href="#通知signal" class="headerlink" title="通知signal"></a>通知signal</h4><p><img src="/upload/pasted-338.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/upload/pasted-362.png&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="https://www.junglezero.top/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>链表专题</title>
    <link href="https://www.junglezero.top/2019/06/24/%E4%B8%93%E9%A2%98/"/>
    <id>https://www.junglezero.top/2019/06/24/专题/</id>
    <published>2019-06-24T08:15:00.000Z</published>
    <updated>2019-07-07T02:48:13.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在O-1-删除链表中的结点"><a href="#在O-1-删除链表中的结点" class="headerlink" title="在O(1)删除链表中的结点"></a>在O(1)删除链表中的结点</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定单链表的头指针和一个节点指针，定义一个函数在O(1)时间删除该节点</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一般的链表删除结点都是从头结点遍历，找到要删除的结点然后进行删除，但是这个题目由于给了要删除结点的位置，就可以采取一些别的措施<br><img src="/upload/pasted-325.png" alt="upload successful"><br>这里的一个思路就是看重了结点的值：把要删除结点的下一个结点的值赋给要删除的结点，此时在删除要删除结点的下一个结点（如c）<br>但是还要注意特殊情况：</p><ul><li>要删除的结点是尾结点：此时只能从头结点顺序遍历，然后找到尾结点的前一个结点，然后再删除</li><li>要删除的链表只有一个结点，直接将头结点设为空</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除链表中的结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(ListNode first,ListNode deleteNode)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        first=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (deleteNode.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode l=first;</span><br><span class="line">        <span class="keyword">while</span> (l.next!=deleteNode)&#123;</span><br><span class="line">            l=l.next;</span><br><span class="line">        &#125;</span><br><span class="line">        l.next=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    deleteNode.val=deleteNode.next.val;</span><br><span class="line">    deleteNode.next=deleteNode.next.next;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链表中倒数第K个结点"><a href="#链表中倒数第K个结点" class="headerlink" title="链表中倒数第K个结点"></a>链表中倒数第K个结点</h1><h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><p>输入一个链表，输出该链表中倒数第k个结点。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>一般思路：向后找n-k+1个结点，需要两次遍历，第一次遍历找到n<br>更好的想法：两个指针，第一个指针首先移动k-1然后第二指针开始从头移动，此时两个指针同时移动，当第一个指针到达尾结点时，第二个指针所指就是要找到点<br>但是仍然要注意一些特殊的情况：</p><ul><li>输入的头结点为空：结果返回null</li><li>链表数小于k:无意义，结果返回null</li><li>k为0:无意义，结果返回null</li></ul><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">findKthNodeInLinkedList</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (head==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode Ahead=head;</span><br><span class="line">    ListNode Behind=head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (Ahead.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            Ahead=Ahead.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (Ahead!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        Ahead=Ahead.next;</span><br><span class="line">        Behind=Behind.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Behind;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链表中环的入口结点"><a href="#链表中环的入口结点" class="headerlink" title="链表中环的入口结点"></a>链表中环的入口结点</h1><h2 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h2><p>输入一个链表如果有环，返回其入口结点</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>第一步：确定链表有环：用两个指针，一个一次移动一步，另一个一次移动两步，若两个指针在移动中相等，则证明有环<br>第二步，找到环的长度：从两个指针相遇的地方开始，再次回到这个点的计数就是环的长度<br>第三步，找到入口，在知道了环的长度以后，就和上面的题一样了</p><h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//链表中环的入口结点</span></span><br><span class="line">    <span class="function">ListNode <span class="title">findEntryInCircle</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode slow=head;</span><br><span class="line">        ListNode fast=head;</span><br><span class="line">        ListNode meetingNode=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用快慢指针判断是否有环</span></span><br><span class="line">        <span class="keyword">while</span> (slow!=<span class="keyword">null</span>&amp;&amp;fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">            <span class="comment">//记录相遇结点</span></span><br><span class="line">            <span class="keyword">if</span> (slow==fast)</span><br><span class="line">                meetingNode=slow;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//fast到了null时，一定无环</span></span><br><span class="line">        <span class="keyword">if</span> (fast==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> circleLen=<span class="number">1</span>;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">        <span class="comment">//从相遇结点出发，再次回到相遇结点，计数，找出环的长度</span></span><br><span class="line">        <span class="keyword">while</span> (slow!=meetingNode)&#123;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            circleLen++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//两个指针，一个先走n（环的长度），当两个指针相遇时，就是环的入口</span></span><br><span class="line">        ListNode Ahead=head;</span><br><span class="line">        ListNode Behind=head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;circleLen;i++)&#123;</span><br><span class="line">            Ahead=Ahead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (Ahead!=Behind)&#123;</span><br><span class="line">            Ahead=Ahead.next;</span><br><span class="line">            Behind=Behind.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Ahead;</span><br><span class="line">.</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><h2 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h2><p>输入一个链表，反转链表后，输出新链表的表头。</p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>设置三个指针，head为当前节点，pre为当前节点的前一个节点，next为当前节点的下一个节点，需要pre和next的目的是让当前节点从pre-&gt;head-&gt;next1-&gt;next2变成pre<-head next1->next2的过程中，用pre让节点反转所指方向，next节点保存next1节点防止链表断开<br>仍然要注意特殊输入</-head></p><h2 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反转链表</span></span><br><span class="line"> <span class="function">ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">     ListNode ReverseHead=<span class="keyword">null</span>;</span><br><span class="line">     ListNode node=head;</span><br><span class="line">     ListNode pre=<span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">while</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="comment">//先获取当前结点的下一个结点</span></span><br><span class="line">         ListNode Next=node.next;</span><br><span class="line">         <span class="comment">//若下一个结点为空，则证明到头了</span></span><br><span class="line">         <span class="keyword">if</span> (Next==<span class="keyword">null</span>)</span><br><span class="line">             ReverseHead=node;</span><br><span class="line">         <span class="comment">//修改当前结点的下一个结点</span></span><br><span class="line">         node.next=pre;</span><br><span class="line">         <span class="comment">//当前结点成为新的pre</span></span><br><span class="line">         pre=node;</span><br><span class="line">         <span class="comment">//下一个结点成为新的当前结点</span></span><br><span class="line">         node=Next;</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ReverseHead;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h1><h2 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h2><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>注意处理两个链表为空的情况</p><h2 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//合并两个排序链表</span></span><br><span class="line"><span class="function">ListNode <span class="title">Merge</span><span class="params">(ListNode l1,ListNode l2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    ListNode node1=l1;</span><br><span class="line">    ListNode node2=l2;</span><br><span class="line">    ListNode MergeList =<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (l1.val&gt;l2.val)&#123;</span><br><span class="line">        MergeList=l1;</span><br><span class="line">        MergeList.next=Merge(l1.next,l2);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        MergeList=l2;</span><br><span class="line">        MergeList.next=Merge(l1,l2.next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MergeList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h1><h2 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h2><p>实现函数复制一个复杂链表。在复杂链表中，每个结点除了有一个 next，指针指向下一个结点外，还有一个指向链表中任意结点或 null。</p><h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><p>照猫画虎法，<br>先在每个结点后生成其复制结点，下一步是最关键的复杂指针的复制，就是照猫画虎，不管指针有多么的复杂，都会有A1.random=A.random.next，B1.random=B.random.next，C1.random=C.random.next，这样就解决了这个题的难点，最后把链表拆分。</p><h2 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复杂链表的复制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ComplicatedLinkedListNode <span class="title">copyComplicatiedLinkedList</span><span class="params">(ComplicatedLinkedListNode firstNode)</span></span>&#123;</span><br><span class="line">    <span class="comment">//第一步，在每个结点后面复制其自身的结点</span></span><br><span class="line">    ComplicatedLinkedListNode node=firstNode;</span><br><span class="line">    <span class="keyword">while</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        ComplicatedLinkedListNode newNode=<span class="keyword">new</span> ComplicatedLinkedListNode(node.val);</span><br><span class="line">        newNode.next=node.next;</span><br><span class="line">        node.next=newNode;</span><br><span class="line">        node=newNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二步，复制复杂指针，依照A1.random=A.random.next</span></span><br><span class="line">    ComplicatedLinkedListNode node2=firstNode;</span><br><span class="line">    node=firstNode.next;</span><br><span class="line">    <span class="keyword">while</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        node.random=node2.random.next;</span><br><span class="line">        node=node.next.next;</span><br><span class="line">        node2=node2.next.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三步。拆分出目标链表</span></span><br><span class="line">    node=firstNode.next;</span><br><span class="line">    node2=node.next;</span><br><span class="line">    <span class="keyword">while</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        node.next=node2.next;</span><br><span class="line">        node2=node.next.next;</span><br><span class="line">        node=node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ComplicatedLinkedListNode ans=firstNode.next;</span><br><span class="line">    firstNode.next=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;在O-1-删除链表中的结点&quot;&gt;&lt;a href=&quot;#在O-1-删除链表中的结点&quot; class=&quot;headerlink&quot; title=&quot;在O(1)删除链表中的结点&quot;&gt;&lt;/a&gt;在O(1)删除链表中的结点&lt;/h1&gt;&lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; cla
      
    
    </summary>
    
      <category term="刷算法题" scheme="https://www.junglezero.top/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="数据结构" scheme="https://www.junglezero.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="链表" scheme="https://www.junglezero.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数值/数组算法题整理</title>
    <link href="https://www.junglezero.top/2019/06/24/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <id>https://www.junglezero.top/2019/06/24/算法题/</id>
    <published>2019-06-24T01:07:00.000Z</published>
    <updated>2019-07-14T12:29:04.902Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>分清各种情况：</p><ul><li>指数为负：需要将底数求倒数然后再将指数取正</li><li>指数为最小的负数（Integer.MIN_VALUE），此时不能直接取正，直接二分递归再取正</li><li>底数为0，指数为负：会出现对0求倒数情况，要特殊处理</li><li>指数为0：无论底数，结果为1</li><li>可以用二分的思想减少运算</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"底数为0无意义"</span>);</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        x=<span class="number">1</span>/x;</span><br><span class="line">        n=-n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == Integer.MIN_VALUE)</span><br><span class="line">        <span class="keyword">return</span> myPow(x*x, -(n/<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n%<span class="number">2</span>==<span class="number">0</span>?myPow(x*x,n/<span class="number">2</span>):x*myPow(x*x,n/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="打印从1到最大的n位数"><a href="#打印从1到最大的n位数" class="headerlink" title="打印从1到最大的n位数"></a>打印从1到最大的n位数</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>输入数字n,按顺序打印出从1到最大的n位十进制数，比如输入3,则打印出1,2,3一直到最大的3位数即999</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这个题看似白给，实际容易被白给，因为当n特别特别大时，要是想直接输出数，是不可能的，因此要想到大数模拟，而大数从1到999…999递增的输出，用String模拟就又是一个问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//打印从1到最大的N位数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintOneToMaxNthDigits</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">char</span>[]num=<span class="keyword">new</span> <span class="keyword">char</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//从第一位开始初始化</span></span><br><span class="line">    num[<span class="number">0</span>]=<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        num[<span class="number">0</span>]=(<span class="keyword">char</span>) (i+<span class="string">'0'</span>);</span><br><span class="line">        <span class="comment">//进入递归方法</span></span><br><span class="line">        print1ToMaxOfNDigitsRecursely(num,n,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print1ToMaxOfNDigitsRecursely</span><span class="params">(<span class="keyword">char</span>[] num, <span class="keyword">int</span> n, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//递归终止条件 ：已经填充到了最后一位</span></span><br><span class="line">    <span class="keyword">if</span> (index==n)&#123;</span><br><span class="line">        printNum(num);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前位从0-9依次填充</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        num[index+<span class="number">1</span>]=(<span class="keyword">char</span>)(i+<span class="string">'0'</span>);</span><br><span class="line">        <span class="comment">//递归到下一位</span></span><br><span class="line">        print1ToMaxOfNDigitsRecursely(num,n,index+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印从num中第一个非0位到第0位</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNum</span><span class="params">(<span class="keyword">char</span>[] num)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=num.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span> (num[i]!=<span class="string">'0'</span>)&#123;</span><br><span class="line">            start=i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=start;j++)</span><br><span class="line">        System.out.print(num[j]);</span><br><span class="line"></span><br><span class="line">    System.out.print(<span class="string">"    "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="数组中出现次数超过一半的数"><a href="#数组中出现次数超过一半的数" class="headerlink" title="数组中出现次数超过一半的数"></a>数组中出现次数超过一半的数</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>题目：输入 n 个整数，找出其中最小的 k 个数。例如输入 4,5,1， 6,2,7,3,8 这<br>8 个数字，则最少的 4 个数字是 1,2,3,4.</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>如果某个数在数组中出现的次数超过数组长度的一半，则如果这是个有序数组，这个数肯定是中位数<br>可以利用快排中差分的思想<br>另外，也可以按照数组的特点，遍历数组，然后计数，遇见相同的就+1，遇见不同的就-1，若为0就替换，遍历完数组肯定是</p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组中超过一半的数</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">moreThanHalfNum</span><span class="params">(<span class="keyword">int</span> []data)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (checkInvalidArray(data))</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> middle=data.length/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> end=data.length-<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> index=Partition(data,data.length,start,end);</span><br><span class="line">      <span class="keyword">while</span> (index!=middle)&#123;</span><br><span class="line">          <span class="keyword">if</span> (index&gt;middle)&#123;</span><br><span class="line">              end=index-<span class="number">1</span>;</span><br><span class="line">              index=Partition(data,data.length,start,end);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              start=index+<span class="number">1</span>;</span><br><span class="line">              index=Partition(data,data.length,start,end);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> result=data[middle];</span><br><span class="line">      <span class="keyword">if</span> (checkMoreThanHalf(result,data))</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkMoreThanHalf</span><span class="params">(<span class="keyword">int</span> result, <span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (i&lt;data.length)&#123;</span><br><span class="line">          <span class="keyword">if</span> (data[i]==result)</span><br><span class="line">              count++;</span><br><span class="line">          i++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (count&gt;data.length/<span class="number">2</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkInvalidArray</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (data.length==<span class="number">0</span>||data==<span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> [ ]data,<span class="keyword">int</span> length,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (data==<span class="keyword">null</span>||length&lt;=<span class="number">0</span>||start&lt;<span class="number">0</span>||end&gt;=length)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      Random r=<span class="keyword">new</span> Random();</span><br><span class="line">      <span class="keyword">int</span> index= r.nextInt(end-start+<span class="number">1</span>)+start;</span><br><span class="line">      swap(data,index,end);</span><br><span class="line">      <span class="keyword">int</span> small=start-<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (index=start;index&lt;end;end++)&#123;</span><br><span class="line">          <span class="keyword">if</span> (data[index]&lt;data[end])&#123;</span><br><span class="line">              small++;</span><br><span class="line">              <span class="keyword">if</span> (small!=index)</span><br><span class="line">                  swap(data,index,small);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      small++;</span><br><span class="line">      swap(data,small,end);</span><br><span class="line">      <span class="keyword">return</span> small;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> [] data,<span class="keyword">int</span> index,<span class="keyword">int</span> index2)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> temp=data[index];</span><br><span class="line">       data[index]=data[index2];</span><br><span class="line">       data[index2]=temp;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组中出现次数超过一半的数字</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span>  <span class="title">MoreThanHalfNum</span><span class="params">(<span class="keyword">int</span> [] data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (checkInvalidArray(data))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result=data[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> times=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;data.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (data[i]==result)</span><br><span class="line">            times++;</span><br><span class="line">        <span class="keyword">else</span> times--;</span><br><span class="line">        <span class="keyword">if</span> (times==<span class="number">0</span>) &#123;</span><br><span class="line">            result = data[i];</span><br><span class="line">            times = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!checkMoreThanHalf(result,data))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数组中前K个小的数"><a href="#数组中前K个小的数" class="headerlink" title="数组中前K个小的数"></a>数组中前K个小的数</h1><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>除了排序以外，可以使用最大堆来存放K个数，遇见比堆顶小的数时，删去堆顶元素，新元素进堆</p><h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最小的k个数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">getLeastKNumber</span><span class="params">(<span class="keyword">int</span> [] data,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">      ArrayList&lt;Integer&gt; ans=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">int</span> len=data.length;</span><br><span class="line">      <span class="keyword">if</span> (k&gt;len||k&lt;<span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//使用优先队列创建最大堆（优先队列就是靠堆实现的）</span></span><br><span class="line">      PriorityQueue&lt;Integer&gt; maxHeap=<span class="keyword">new</span> PriorityQueue(k, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">          <span class="keyword">if</span> (maxHeap.size()!=k)&#123;</span><br><span class="line">              maxHeap.add(data[i]);</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span> (maxHeap.peek()&gt;data[i])&#123;</span><br><span class="line">              maxHeap.poll();</span><br><span class="line">              maxHeap.offer(data[i]);</span><br><span class="line">              </span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (Integer i:maxHeap)&#123;</span><br><span class="line">          ans.add(i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="数据流的中位数"><a href="#数据流的中位数" class="headerlink" title="数据流的中位数"></a>数据流的中位数</h1><h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><p>得到一个数据流的中位数，若这个数据流的个数为奇数个，则是中间那个数，若是偶数个数，则是中间两个数的平均数</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>如果把数组分为两个部分，前半部分的最大值和后半部分的最小值要是知道了，就可以确定中位数了，而不用排序的方式，就想到了最大堆和最小堆</p><h2 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据流的中位数</span></span><br><span class="line"> <span class="comment">//使用最大堆和最小堆实现</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMiduemNum</span><span class="params">(<span class="keyword">int</span> [] nums)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">     <span class="comment">//最大堆</span></span><br><span class="line">     PriorityQueue&lt;Integer&gt; maxHeap=<span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="comment">//最小堆</span></span><br><span class="line">     PriorityQueue&lt;Integer&gt; minHeap=<span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="comment">//当i为偶数时，把数字加入到最大堆（从0开始）</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> n:nums)&#123;</span><br><span class="line">         <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">             maxHeap.add(n);</span><br><span class="line">         &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//加入最小堆时，若当前数比最大堆的最大数要小（要是这个时候把这个数加入最小堆就不满足要求了），则把这个数加入最大堆，然后把最大堆的最大数加入最小堆</span></span><br><span class="line">             <span class="keyword">if</span> (n&lt;maxHeap.peek()) &#123;</span><br><span class="line">                 maxHeap.add(n);</span><br><span class="line">                 minHeap.add(maxHeap.poll());</span><br><span class="line">             &#125;<span class="keyword">else</span> minHeap.add(n);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (nums.length%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> (maxHeap.peek()+minHeap.peek())/<span class="number">2</span>;</span><br><span class="line">     &#125;<span class="keyword">else</span> <span class="keyword">return</span> maxHeap.peek();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数值的整数次方&quot;&gt;&lt;a href=&quot;#数值的整数次方&quot; class=&quot;headerlink&quot; title=&quot;数值的整数次方&quot;&gt;&lt;/a&gt;数值的整数次方&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题
      
    
    </summary>
    
      <category term="刷算法题" scheme="https://www.junglezero.top/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="数据结构" scheme="https://www.junglezero.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>编程常识（各种杂七杂八的东西）</title>
    <link href="https://www.junglezero.top/2019/06/20/%E5%B8%B8%E8%AF%86%EF%BC%88%E5%90%84%E7%A7%8D%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E4%B8%9C%E8%A5%BF%EF%BC%89/"/>
    <id>https://www.junglezero.top/2019/06/20/常识（各种杂七杂八的东西）/</id>
    <published>2019-06-20T12:33:33.000Z</published>
    <updated>2019-06-20T12:36:08.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="各种编码"><a href="#各种编码" class="headerlink" title="各种编码"></a>各种编码</h1><p> 很多人都把Unicode编码挂在嘴边，其实咱们现实生活中遇到的编码基本都是Unicode的</p><p>因为Unicode兼容了大多数老版本的编码规范例如 ASCII</p><p>Unicode编码定义了这个世界上几乎所有字符（就是你眼睛看到的长那个样子的符号）的数字表示</p><p>也就是说Unicode为每个字符发了一张身份证，这张身份证上有一串唯一的数字ID确定了这个字符</p><p>在这个纷乱世界上存在的唯一性。Unicode给这串数字ID起了个名字叫［码点］（Code Point）</p><p>而很多人说的编码其实是想表达［Unicode转换格式］（即UTF，Unicode Transformation Formats）</p><p>有没有觉得眼前一亮豁然开朗？没错 这就是我们看到的UTF-8/UTF-16/UTF-32的前缀来源</p><p>这个［Unicode转换格式］的存在是为了解决［码点］在计算机中的二进制表现形式而设计的</p><p>毕竟我们的机内表示涉及存储位宽，兼容古老编码格式，码点是数值过大的罕见字符等问题</p><p>［码点］经过映射后得到的二进制串的转换格式单位称之为［码元］（Code Unit）。也就是说如果有一种UTF的码点二进制表示有n字节，其码元为8位（1个byte），那么其拥有码元n个。每种UTF的码元都不同，其宽度被作为区分写在了UTF的后缀——这就是UTF-8/UTF-16/UTF-32的由来。UTF-8的码元是8位的，UTF-16的码元是16位的。大部分的编程语言采用16位的码元作为机内表示。这就是我们在各种语言中调用获取一个字符串中character的数量时会出现这么多混乱的原因。事实上我们调用这些方法时取得的不是字符个数，而是码元个数！一旦我们的字符串中包含了位于基本平面之外的码点，那么就会需要更多的码元来表示，这个时候就会出现测试时常见的困惑——为何return的字符数比实际字符数要多？所以实际写代码时要特别注意这个问题。</p><p>采取不同的映射方式可以得到不同格式的二进制串，但是他们背后所表示的［码点］永远是一致的就好像你换身份证但是身份证号不变一样。由于平时人们误把［转换格式］也称为［编码］，所以造成今天Unicode／UTF傻傻分不清楚且遣词造句运用混乱的悲桑局面。</p><p>Unicode 编码 发展到今天 扩展到了 21 位（从 U+0000 到 U+10FFFF ）。这一点很重要： Unicode 不是 16 位的编码， 它是 21 位的。这 21 位提供了 1,114,112 个码点，其中，只有大概 10% 正在使用，所以还有相当大的扩充空间。</p><p>编码空间被分成 17 个平面（plane），每个平面有 65,536 个字符（正好填充2个字节，16位）。0 号平面叫做「基本多文种平面」（ BMP, Basic Multilingual Plane ），涵盖了几乎所有你能遇到的字符，除了 emoji（emoji位于1号平面 - -）。其它平面叫做补充平面，大多是空的。</p><p>总结一下各种编码格式的特质：</p><p>UTF-32</p><p>最清楚明了的一个 UTF 就是 UTF-32 ：它在每个码点上使用整 32 位。32 大于 21，因此每一个 UTF-32 值都可以直接表示对应的码点。尽管简单，UTF-32却几乎从来不在实际中使用，因为每个字符占用 4 字节太浪费空间了。</p><p>UTF-16 以及「代理对」（ Surrogate Pairs ）的概念</p><p>UTF-16要常见得多，它是根据有 16 位固定长度的码元（ code units ）定义的。UTF-16 本身是一种长度可变的编码。基本多文种平面（BMP）中的每一个码点都直接与一个码元相映射。鉴于 BMP 几乎囊括了所有常见字符，UTF-16 一般只需要 UTF-32 一半的空间。其它平面里很少使用的码点都是用两个 16 位的码元来编码的，这两个合起来表示一个码点的码元就叫做代理对（ surrogate pair ）。</p><p>UTF-8</p><p>UTF-8 使用一到四个字节来编码一个码点。从 0 到 127 的这些码点直接映射成 1 个字节（对于只包含这个范围字符的文本来说，这一点使得 UTF-8 和 ASCII 完全相同）。接下来的 1,920 个码点映射成 2 个字节，在 BMP 里所有剩下的码点需要 3 个字节。Unicode 的其他平面里的码点则需要 4 个字节。UTF-8 是基于 8 位的码元的，因此它并不需要关心字节顺序（不过仍有一些程序会在 UTF-8 文件里加上多余的 BOM）。</p><p>有效率的空间使用（仅就西方语言来讲），以及不需要操心字节顺序问题使得 UTF-8 成为存储和交流 Unicode 文本方面的最佳编码。它也已经是文件格式、网络协议以及 Web API 领域里事实上的标准了。</p><p>我们的JVM中保存码点是UTF16的转换格式，从char的位宽为16位也可以看得出来。由于绝大部分编码的码点位于基本平面，所以使用16位可以几乎表示所有常用字符。这就是许多语言编译器或运行时都使用UTF16的原因。英文在使用UTF16时也是2字节表示的。当我们想要使用其他平面的字符时，码元超过2个字节，就需要使用代理对在语言中的特定表示方式，譬如‘\U112233’之类的。</p><p>使用UTF8时，常用的Alphabet和Numeric都在前127字节，被有效率地用一个字节表示。而我们的中文由于排在1920个码点之后，所以使用3个字节表示，这方面就比UTF16转换格式耗费更多空间。</p><p>最后，不论使用哪种UTF转换格式，都是程序员自己可以选择的一种表达方式而已。我们可以通过Java方便的API进行自如转换。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;各种编码&quot;&gt;&lt;a href=&quot;#各种编码&quot; class=&quot;headerlink&quot; title=&quot;各种编码&quot;&gt;&lt;/a&gt;各种编码&lt;/h1&gt;&lt;p&gt; 很多人都把Unicode编码挂在嘴边，其实咱们现实生活中遇到的编码基本都是Unicode的&lt;/p&gt;
&lt;p&gt;因为Unicod
      
    
    </summary>
    
    
  </entry>
  
</feed>
