<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>淋中之虹</title>
  
  <subtitle>向来不知道该说些什么</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.junglezero.top/"/>
  <updated>2019-04-16T03:10:58.195Z</updated>
  <id>https://www.junglezero.top/</id>
  
  <author>
    <name>JungleZero</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GOT第八季第一集观感（就是剧透,就是剧透，大量图片剧透）</title>
    <link href="https://www.junglezero.top/2019/04/15/OT%E7%AC%AC%E5%85%AB%E5%AD%A3%E7%AC%AC%E4%B8%80%E9%9B%86%E8%A7%82%E6%84%9F%EF%BC%88%E5%B0%B1%E6%98%AF%E5%89%A7%E9%80%8F%EF%BC%89/"/>
    <id>https://www.junglezero.top/2019/04/15/OT第八季第一集观感（就是剧透）/</id>
    <published>2019-04-15T13:01:00.000Z</published>
    <updated>2019-04-16T03:10:58.195Z</updated>
    
    <content type="html"><![CDATA[<p>第一集，作为最终季的1/6，我觉得反映的第一个主题就是重逢,顺便回应第一季的第一集</p><p>开头兄弟二人</p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/ptiGwe803RxWS2H1*r6W*GRpUbAnuNkxo1WjhrQytlw!/b/dMEAAAAAAAAA&amp;bo=gAc4BAAAAAADd.k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/rz*nwe0m6GKh2Vtx5NPEHg0szboq2Y0zT.syXTXAg6k!/b/dLYAAAAAAAAA&amp;bo=gAc4BAAAAAADd.k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>第一季第一集开头的回忆杀（为背景板的狼大默哀一分钟）<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/APCXgdffANyQFEb*VljTnRWmCF.j2otHOnbwk0ZT1z4!/b/dLYAAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>北境权利最高层的兄妹二人重逢<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/ET3m1JtaTn.OSp46PTlkW6boB6OeE.l7C1FJvPHqcBA!/b/dLYAAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>当年被夫妻的二人重逢，两人经历了自打乔大帝的婚礼分离后，各自遇上了各种风浪，都已经成长起来<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/zGBfl7FoGE9VExlYnsO0nUsG0SK9R2Pa.qnhrS95Dxo!/b/dL8AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>兄妹二人重逢,兄妹二人的剑代表了他们的成长<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/VGKFxoQGapXZt6Ce.G607r*K.nfKKu7S62DQPR*WXvc!/b/dL8AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/XXe*ky97I3GuGHM0G3KdvDX8MSMZYbXhC0K5jMmFkY0!/b/dD4BAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/hcEk3S580XFudW6HQvOYFrhBXdvfP4HLo5YUnNfO16o!/b/dL4AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>铁民家族兄妹二人，大姐表示你特么救驾来迟了<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/kqlHXDrVq5.AzKLPfojEPgYP7jK8OxRp4WOsrou5ovM!/b/dLYAAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/glAJCz7lqTlraE4fx2iJBdB*d4V1PgHv2bSOpAcWYsk!/b/dL8AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>不太冷的杀手和小姑娘重逢，两人心情都很复杂，毕竟小姑娘觉得自己杀掉了猎犬<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/dFhUuGHhrxaflO7o6R1ogq46jzu8d4I1VylozH9bDU8!/b/dFQBAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>当年的逃亡路上的小伙伴重逢<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/8HySdarX0LpjeoFUbSjasEPHjIwGZfPm8zlFcILs29E!/b/dFQBAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>当年的守夜人好基友重逢<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/Tx2xPhG0iNDuzsB9TE59ncVo9IL.*UgndSNNN9doQAk!/b/dDQBAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>以及在本集末尾弑君者和布兰（还是改叫三眼乌鸦）的重逢，不得不说弑君者是真的帅，两人的心情估计也十分微妙<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/h70VN*XQuWnsOlscEL1i7c*T0BlTwmjkkOpArzma6Yw!/b/dMAAAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/ARjoFO*RUfnb67xyU747GJAbzQaXJeLttpfyqxq.gXg!/b/dDQBAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"><br>想想当年<br>（第一季第一集的结尾）<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/uKbEY2*mcdnHUzTrWVa5PycwWfSbWKWjDCeXTtQa8JM!/b/dL8AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/8uCU.xccrjdexEfYiXc49dZB7CmR.2opr049czppBxM!/b/dL8AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>最终季开篇，肯定要交代背景</p><ul><li>联盟的形成，以及众人不同的看法，此处以傲娇小女王为代表</li></ul><p><img src="/upload/pasted-308.png" alt="upload successful"></p><ul><li>据说很牛逼还有大象的黄金团来袭</li></ul><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/IGyi1wYLKaaqvdyKPZvR6VgOgFZa9ULoDNGYpD9gD2s!/b/dEkBAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/tPTrgCyZAO7Bw4XWHoIVxfZSaoxptbCJ8t9HB7iNNHc!/b/dFMBAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/R5y0wqbsAeo4lmcciqc*inNTlM7t3jY6vjjqPQlRa18!/b/dL8AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><ul><li>一无所知的雪诺终于知道自己到底是个什么神仙</li></ul><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/hmgQhC05JRiiBQJQiROweKfa*uZ36v5Ot3ZYweVJJDQ!/b/dLkAAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><ul><li>夜王又一次用人体行为艺术下了战书</li></ul><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/qKRTpOQzJ83OEmgXV9BDuKn04YP1e5Dip874UurgkxU!/b/dL8AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><ul><li>弑君者代表铁王座率军赶赴抗妖前线的北地</li></ul><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/b9B0JzaHWcsK*DYUyLVssnMGInn6XxjYC0uYuw8sn1k!/b/dDABAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>然后，作为最终季开篇，表明主要登场人物及其立场自然是必不可少的（纯属个人根据情况推测的）<br>一无所知琼恩雪诺：王位什么的不重要，大敌当前，我们要团结———&gt;我特么本是一无所知的二逼小青年，现在全知道了，感觉好复杂<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/7yRourdnruYwAOewG.yLXOTA0i.t16NP4jghvxzkfrE!/b/dLgAAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/XsffEnGX2gUjILAHEts46qJTGGottTJgNkvJcbtyS8I!/b/dEkBAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/NhUt6YMPcq*po3ADxsgDZTIAvFmDBfqQBSTADC1HApc!/b/dL8AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>……(省略一堆头衔)的龙妈：君之所向便是光，并表示好歹我也是有这么多头衔的女王，要是小姑子不给面子……<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/iau195BHlQmZUmo5jVbEuYNzvJxqYwFvQmVMAJ7M1bU!/b/dLkAAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/qT2CVgaTPDZ5rbsep7xt1.XU*aGFvP0dO6ukSUR9V64!/b/dL8AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>临冬女爵三傻：不行不行先把谁当老大这个事搞明白（你个外来的小妮子敢在这里撒泼）<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/Ghl.OR.NZqo.*f.7*YjUju.rG*TR4kP8BetdKxsYXbw!/b/dL4AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>传奇刺客艾莉雅：咱（我们？）这一家子整整齐齐的就好<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/kJT.wblPug3YZZatP8YoEfRzcEmSbDCntJ*KRVlVhFw!/b/dL8AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>同盟的三个顶级谋士<br>小恶魔：先别说别的了，先把那群妖怪干趴再说吧，现在关键是团结人心，毕竟欧尼桑不是个省油的灯……<br>洋葱骑士：最后搞个联合政府也还是不错的，那两位很般配<br>八爪蜘蛛：Nothing lasts（原话）</p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/WG6vhSZyH6qHiaUtFf62BLII.1.U2d4PZ06pXzqfu3M!/b/dDEBAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>“臭佬”（并不）席恩：我还是和我史塔克家的难兄难弟们在一起吧<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/Ap6Gm.2QLfFcHVjdsohhXFQj3Zd4ZicSGmnC80ZM91Y!/b/dL4AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>作者本体：兄弟我挺你，你比那贱货正统的多，况且那贱货还杀了我的爸爸和哥哥<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/5aWkJpntUDKwZsI*eJubgI2u*wqp7GnUJ4eAXccNoiw!/b/dLYAAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>给钱办事的波隆爵士：他妈的兄弟对不住了……(给弩这个细节也表示都知道弑君者是近战高手，尽管你手黑，尽管他废了个胳膊，但估计近战刚也是打不过)</p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/ExkAWSDL5r46vfJ4wb1yW.WSHTCyvJZtFwOP5OycOI0!/b/dDQBAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>想当年这位仁兄拼了老命在龙焰之下拉了兄弟一把，现在却受命要做掉他<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/OK.Q8thY1WOL6Z3ycxxWbJ37*tdSE7UjNsNFjKeQZjc!/b/dL8AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>舰队司令：我就是个用屌思考的人，我一切的动机就是日您，女王陛下（我觉得这个人是真心有点意思，他在这集里面所有的对话基本离不开日女王）<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/C53FZAZg*MdDSmhv8y0hpfxufjusNB87NhIlGGM0aOM!/b/dLYAAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>坐在铁王座上的色后：都是好事，都是好事啊</p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/qqqeDnHt.DIGPCvzk.u38C3XSiSxP6To.edupw7xTlY!/b/dL4AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>三眼乌鸦：……就这么要凉了吗？！</p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/AFt1o2WZTzvlvTwq3xJIG8K0KTcZrEqJgbO6yKh1HNc!/b/dL8AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"><br>要是仔细看的话，就会发现，整集他多处出现，坐在轮椅上四处观望着这群人，看来这位才是手里有剧本的人</p><p>毕竟是最终季的开始，好戏马上就要上演了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第一集，作为最终季的1/6，我觉得反映的第一个主题就是重逢,顺便回应第一季的第一集&lt;/p&gt;
&lt;p&gt;开头兄弟二人&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/ptiGwe803RxWS2H1*r6W*GRpUbA
      
    
    </summary>
    
    
      <category term="个人杂谈" scheme="https://www.junglezero.top/tags/%E4%B8%AA%E4%BA%BA%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>单线程执行设计模式（Single Thread Execution）</title>
    <link href="https://www.junglezero.top/2019/04/15/%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.junglezero.top/2019/04/15/线程执行设计模式/</id>
    <published>2019-04-15T09:00:00.000Z</published>
    <updated>2019-04-15T12:55:27.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>在多线程的状况下，对于某些共享资源，我们需要在使用的时候确保安全性，因此这种模式下，同一时刻只能有一个线程去访问共享资源，就像独木桥一次通过一个人一样</p><h1 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SharedResource 指代多线程下的共享资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"Nobody"</span>;</span><br><span class="line">    <span class="keyword">private</span> String address = <span class="string">"Nowhere"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 临界值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> address</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">pass</span><span class="params">(String name, String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.counter++;</span><br><span class="line">        <span class="comment">/*race*/</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        verify();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置验证规则：当name和address的首字母不相同时，输出打断</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">verify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.name.charAt(<span class="number">0</span>) != <span class="keyword">this</span>.address.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"*******BROKEN********"</span> + toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"No."</span> + counter + <span class="string">":"</span> + name + <span class="string">","</span> + address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指代操作临界资源的线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String myName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String myAddress;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Gate gate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String myName, String myAddress, Gate gate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myName = myName;</span><br><span class="line">        <span class="keyword">this</span>.myAddress = myAddress;</span><br><span class="line">        <span class="keyword">this</span>.gate = gate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(myName + <span class="string">" BEGIN"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.gate.pass(myName, myAddress);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Gate gate = <span class="keyword">new</span> Gate();</span><br><span class="line">        User bj = <span class="keyword">new</span> User(<span class="string">"Baobao"</span>, <span class="string">"Beijing"</span>, gate);</span><br><span class="line">        User sh = <span class="keyword">new</span> User(<span class="string">"ShangLao"</span>, <span class="string">"ShangHai"</span>, gate);</span><br><span class="line">        User gz = <span class="keyword">new</span> User(<span class="string">"GuangLao"</span>, <span class="string">"GuangZhou"</span>, gate);</span><br><span class="line"></span><br><span class="line">        bj.start();</span><br><span class="line">        sh.start();</span><br><span class="line">        gz.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*******BROKEN********No.111356925:GuangLao,GuangZhou</span><br><span class="line">*******BROKEN********No.111357328:Baobao,Beijing</span><br><span class="line">*******BROKEN********No.111357709:GuangLao,GuangZhou</span><br><span class="line">*******BROKEN********No.111362695:Baobao,Beijing</span><br></pre></td></tr></table></figure></p><p>可以看到，其中有的输出结果name和address不同，尽管初始化线程传入的参数时是相同的。有的是满足验证规则但还是输出打断<br>解释：比如A线程传入参数Beyco和Beijing，当向pass方法传入Beyco时，A线程被B线程打断，B线程传入Shenzhen，此时verify自然就broke；另一种情况是，继前面一种情况之后，此时参数已经是Beyco和Shenzhen，在准备toString时，B线程又将address传入实参Beijing，所以就出现了首字母相同还是broke的情况。<br>解决：对于共享资源，在多线程状态下使用，最好的办法自然是上锁，将pass方法和toString方法加上同步锁即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>   <span class="keyword">void</span> <span class="title">pass</span><span class="params">(String name, String address)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.counter++;</span><br><span class="line">    <span class="comment">/*race*/</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.address = address;</span><br><span class="line">    verify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>   String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"No."</span> + counter + <span class="string">":"</span> + name + <span class="string">","</span> + address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;在多线程的状况下，对于某些共享资源，我们需要在使用的时候确保安全性，因此这种模式下，同一时刻只能有一个线程去访问共享资源，就
      
    
    </summary>
    
      <category term="java多线程学习" scheme="https://www.junglezero.top/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="java多线程" scheme="https://www.junglezero.top/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>观察者模式和线程监控</title>
    <link href="https://www.junglezero.top/2019/04/15/%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9B%91%E6%8E%A7/"/>
    <id>https://www.junglezero.top/2019/04/15/者模式和线程监控/</id>
    <published>2019-04-15T07:28:00.000Z</published>
    <updated>2019-04-15T08:38:53.957Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本理解"><a href="#基本理解" class="headerlink" title="基本理解"></a>基本理解</h1><p><img src="/upload/pasted-278.png" alt="upload successful"><br>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有的观察者对象，使它们能够自动更新自己。</p><p>四个角色</p><ul><li>抽象被观察者角色：也就是一个抽象主题，它把所有对观察者对象的引用保存在一个集合中，每个主题都可以有任意数量的观察者。抽象主题提供一个接口，可以增加和删除观察者角色。一般用一个抽象类和接口来实现。</li><li>抽象观察者角色：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。</li><li>具体被观察者角色：也就是一个具体的主题，在集体主题的内部状态改变时，所有登记过的观察者发出通知。</li><li>具体观察者角色：实现抽象观察者角色所需要的更新接口，一边使本身的状态与制图的状态相协调。</li></ul><h1 id="java实现例子"><a href="#java实现例子" class="headerlink" title="java实现例子"></a>java实现例子</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 抽象被观察者接口</span></span><br><span class="line"><span class="comment"> * 声明了添加、删除、通知观察者方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observerable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 抽象观察者</span></span><br><span class="line"><span class="comment"> * 定义了一个update()方法，当被观察者调用notifyObservers()方法时，观察者的update()方法会被回调。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jstao</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被观察者，也就是微信公众号服务</span></span><br><span class="line"><span class="comment"> * 实现了Observerable接口，对Observerable接口的三个方法进行了具体实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WechatServer</span> <span class="keyword">implements</span> <span class="title">Observerable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意到这个List集合的泛型参数为Observer接口，设计原则：面向接口编程而不是面向实现编程</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; list;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WechatServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        list.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!list.isEmpty())</span><br><span class="line">            list.remove(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            Observer oserver = list.get(i);</span><br><span class="line">            oserver.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfomation</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = s;</span><br><span class="line">        System.out.println(<span class="string">"微信服务更新消息： "</span> + s);</span><br><span class="line">        <span class="comment">//消息更新，通知所有观察者</span></span><br><span class="line">        notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察者</span></span><br><span class="line"><span class="comment"> * 实现了update方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jstao</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        read();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">" 收到推送消息： "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：<br>首先注册了三个用户，ZhangSan、LiSi、WangWu。公众号发布了一条消息”PHP是世界上最好用的语言！”，三个用户都收到了消息。</p><p>用户ZhangSan看到消息后颇为震惊，果断取消订阅，这时公众号又推送了一条消息，此时用户ZhangSan已经收不到消息，其他用户</p><p>还是正常能收到推送消息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WechatServer server = <span class="keyword">new</span> WechatServer();</span><br><span class="line">        </span><br><span class="line">        Observer userZhang = <span class="keyword">new</span> User(<span class="string">"ZhangSan"</span>);</span><br><span class="line">        Observer userLi = <span class="keyword">new</span> User(<span class="string">"LiSi"</span>);</span><br><span class="line">        Observer userWang = <span class="keyword">new</span> User(<span class="string">"WangWu"</span>);</span><br><span class="line">        </span><br><span class="line">        server.registerObserver(userZhang);</span><br><span class="line">        server.registerObserver(userLi);</span><br><span class="line">        server.registerObserver(userWang);</span><br><span class="line">        server.setInfomation(<span class="string">"PHP是世界上最好用的语言！"</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"----------------------------------------------"</span>);</span><br><span class="line">        server.removeObserver(userZhang);</span><br><span class="line">        server.setInfomation(<span class="string">"JAVA是世界上最好用的语言！"</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="利用观察者模式监控线程状态"><a href="#利用观察者模式监控线程状态" class="headerlink" title="利用观察者模式监控线程状态"></a>利用观察者模式监控线程状态</h1><p>观察者抽象类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LifeCycleObserver</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当被观察者（这个例子中是“可被观察线程”）发生改变时，调用该方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(ObservableRunnable.RunnableEvent event)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>被观察者类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单一的被观察者</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">protected</span> LifeCycleObserver observer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableRunnable</span><span class="params">(<span class="keyword">final</span> LifeCycleObserver listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.observer = listener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发生线程事件时，调用该方法提醒观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">notifyChange</span><span class="params">(<span class="keyword">final</span> RunnableEvent event)</span> </span>&#123;</span><br><span class="line">        observer.onEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程状态枚举</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> RunnableState &#123;</span><br><span class="line">        RUNNING, ERROR, DONE</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义状态改变的类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableEvent</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> RunnableState state;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Thread thread;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Throwable cause;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RunnableEvent</span><span class="params">(RunnableState state, Thread thread, Throwable cause)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.state = state;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">            <span class="keyword">this</span>.cause = cause;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> RunnableState <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> state;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">getThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> thread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Throwable <span class="title">getCause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cause;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体观察者的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLifeCycleObserver</span> <span class="keyword">implements</span> <span class="title">LifeCycleObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//多线程加锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object LOCK = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该观察者有一个根据id查询线程的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">concurrentQuery</span><span class="params">(List&lt;String&gt; ids)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ids == <span class="keyword">null</span> || ids.isEmpty())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        ids.stream().forEach(id -&gt; <span class="keyword">new</span> Thread(<span class="keyword">new</span> ObservableRunnable(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//被观察线程是运行态，传Running参数</span></span><br><span class="line">                    notifyChange(<span class="keyword">new</span> RunnableEvent(RunnableState.RUNNING, Thread.currentThread(), <span class="keyword">null</span>));</span><br><span class="line">                    System.out.println(<span class="string">"query for the id "</span> + id);</span><br><span class="line">                    Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">                    <span class="comment">//传递Done参数</span></span><br><span class="line">                    notifyChange(<span class="keyword">new</span> RunnableEvent(RunnableState.DONE, Thread.currentThread(), <span class="keyword">null</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">//发生异常，传递error</span></span><br><span class="line">                    notifyChange(<span class="keyword">new</span> RunnableEvent(RunnableState.ERROR, Thread.currentThread(), e));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, id).start());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 观察者的"反应方法"</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(ObservableRunnable.RunnableEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//多线程加锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            System.out.println(<span class="string">"The runnable ["</span> + event.getThread().getName() + <span class="string">"] data changed and state is ["</span> + event.getState() + <span class="string">"]"</span>);</span><br><span class="line">            <span class="keyword">if</span> (event.getCause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"The runnable ["</span> + event.getThread().getName() + <span class="string">"] process failed."</span>);</span><br><span class="line">                event.getCause().printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLifeCycleClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ThreadLifeCycleObserver().concurrentQuery(Arrays.asList(<span class="string">"1"</span>, <span class="string">"2"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The runnable [1] data changed and state is [RUNNING]</span><br><span class="line">The runnable [2] data changed and state is [RUNNING]</span><br><span class="line">query for the id 2</span><br><span class="line">query for the id 1</span><br><span class="line">The runnable [1] data changed and state is [DONE]</span><br><span class="line">The runnable [2] data changed and state is [DONE]</span><br></pre></td></tr></table></figure></p><p>当运行中有异常时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">The runnable [1] data changed and state is [RUNNING]</span><br><span class="line">The runnable [2] data changed and state is [RUNNING]</span><br><span class="line">query for the id 2</span><br><span class="line">query for the id 1</span><br><span class="line">The runnable [2] data changed and state is [DONE]</span><br><span class="line">The runnable [1] data changed and state is [DONE]</span><br><span class="line">The runnable [1] data changed and state is [ERROR]</span><br><span class="line">The runnable [1] process failed.</span><br><span class="line">java.lang.ArithmeticException: / by zero</span><br><span class="line">at aConcurenty.concurrent2.chapter4.ThreadLifeCycleObserver$1.run(ThreadLifeCycleObserver.java:35)</span><br><span class="line">at java.base/java.lang.Thread.run(Thread.java:844)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本理解&quot;&gt;&lt;a href=&quot;#基本理解&quot; class=&quot;headerlink&quot; title=&quot;基本理解&quot;&gt;&lt;/a&gt;基本理解&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/upload/pasted-278.png&quot; alt=&quot;upload successful&quot;&gt;&lt;br&gt;
      
    
    </summary>
    
      <category term="java多线程学习" scheme="https://www.junglezero.top/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="设计模式" scheme="https://www.junglezero.top/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java多线程" scheme="https://www.junglezero.top/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="https://www.junglezero.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>HashMap和ConcurrentHashMap</title>
    <link href="https://www.junglezero.top/2019/04/11/oncurrentHashMap/"/>
    <id>https://www.junglezero.top/2019/04/11/oncurrentHashMap/</id>
    <published>2019-04-11T01:35:00.000Z</published>
    <updated>2019-04-13T06:04:56.557Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.importnew.com/28263.html" target="_blank" rel="noopener">http://www.importnew.com/28263.html</a></p><h1 id="Hashmap"><a href="#Hashmap" class="headerlink" title="Hashmap"></a>Hashmap</h1><h2 id="1-7"><a href="#1-7" class="headerlink" title="1.7"></a>1.7</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。<br>HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。<br>HashMap 的实现不是同步的，这意味着它<strong>不是线程安全</strong>的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。</p><p>HashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。容量 是哈希表中桶的数量，初始容量 只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。<br>通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>在详细介绍HashMap的代码之前，我们需要了解：HashMap就是一个散列表，它是通过“拉链法”解决哈希冲突的。<br>见<a href="散列表">https://www.junglezero.top/2018/02/17/%EF%BC%88%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%89/</a><br>还需要再补充说明的一点是影响HashMap性能的有两个参数：初始容量(initialCapacity) 和加载因子(loadFactor)。容量 是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。</p><p><img src="/upload/pasted-271.png" alt="upload successful"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认的初始容量是16，必须是2的幂。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认加载因子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储数据的Entry数组，长度是2的幂。</span></span><br><span class="line">    <span class="comment">// HashMap是采用拉链法实现的，每一个Entry本质上是一个单向链表</span></span><br><span class="line">    <span class="keyword">transient</span> Entry[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HashMap的大小，它是HashMap保存的键值对的数量</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HashMap的阈值，用于判断是否需要调整HashMap的容量（threshold = 容量*加载因子）</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载因子实际大小</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HashMap被改变的次数</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定“容量大小”和“加载因子”的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="comment">// HashMap的最大容量只能是MAXIMUM_CAPACITY</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找出“大于initialCapacity”的最小的2的幂</span></span><br><span class="line">        <span class="keyword">int</span> capacity = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (capacity &lt; initialCapacity)</span><br><span class="line">            capacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置“加载因子”</span></span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="comment">// 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。</span></span><br><span class="line">        threshold = (<span class="keyword">int</span>)(capacity * loadFactor);</span><br><span class="line">        <span class="comment">// 创建Entry数组，用来保存数据</span></span><br><span class="line">        table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认构造函数。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置“加载因子”</span></span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">        <span class="comment">// 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。</span></span><br><span class="line">        threshold = (<span class="keyword">int</span>)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);</span><br><span class="line">        <span class="comment">// 创建Entry数组，用来保存数据</span></span><br><span class="line">        table = <span class="keyword">new</span> Entry[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 包含“子Map”的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Math.max((<span class="keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>,</span><br><span class="line">                      DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</span><br><span class="line">        <span class="comment">// 将m中的全部元素逐个添加到HashMap中</span></span><br><span class="line">        putAllForCreate(m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">        <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回索引值</span></span><br><span class="line">    <span class="comment">// h &amp; (length-1)保证返回值的小于length</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取key对应的value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> getForNullKey();</span><br><span class="line">        <span class="comment">// 获取key的hash值</span></span><br><span class="line">        <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">        <span class="comment">// 在“该hash值对应的链表”上查找“键值等于key”的元素</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">             e != <span class="keyword">null</span>;</span><br><span class="line">             e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取“key为null”的元素的值</span></span><br><span class="line">    <span class="comment">// HashMap将“key为null”的元素存储在table[0]位置！</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> V <span class="title">getForNullKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.key == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HashMap是否包含key</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getEntry(key) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回“键为key”的键值对</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取哈希值</span></span><br><span class="line">        <span class="comment">// HashMap将“key为null”的元素存储在table[0]位置，“key不为null”的则调用hash()计算哈希值</span></span><br><span class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key.hashCode());</span><br><span class="line">        <span class="comment">// 在“该hash值对应的链表”上查找“键值等于key”的元素</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">             e != <span class="keyword">null</span>;</span><br><span class="line">             e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将“key-value”添加到HashMap中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若“key为null”，则将该键值对添加到table[0]中。</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">        <span class="comment">// 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。</span></span><br><span class="line">        <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="comment">// 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若“该key”对应的键值对不存在，则将“key-value”添加到table中</span></span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// putForNullKey()的作用是将“key为null”键值对添加到table[0]位置</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里的完全不会被执行到!</span></span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建HashMap对应的“添加方法”，</span></span><br><span class="line">    <span class="comment">// 它和put()不同。putForCreate()是内部方法，它被构造函数等调用，用来创建HashMap</span></span><br><span class="line">    <span class="comment">// 而put()是对外提供的往HashMap中添加元素的方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putForCreate</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若该HashMap表中存在“键值等于key”的元素，则替换该元素的value值</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                e.value = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若该HashMap表中不存在“键值等于key”的元素，则将该key-value添加到HashMap中</span></span><br><span class="line">        createEntry(hash, key, value, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将“m”中的全部元素都添加到HashMap中。</span></span><br><span class="line">    <span class="comment">// 该方法被内部的构造HashMap的方法所调用。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putAllForCreate</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 利用迭代器将元素逐个添加到HashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; i = m.entrySet().iterator(); i.hasNext(); ) &#123;</span><br><span class="line">            Map.Entry&lt;? extends K, ? extends V&gt; e = i.next();</span><br><span class="line">            putForCreate(e.getKey(), e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新调整HashMap的大小，newCapacity是调整后的单位</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">        Entry[] oldTable = table;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建一个HashMap，将“旧HashMap”的全部元素添加到“新HashMap”中，</span></span><br><span class="line">        <span class="comment">// 然后，将“新HashMap”赋值给“旧HashMap”。</span></span><br><span class="line">        Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">        transfer(newTable);</span><br><span class="line">        table = newTable;</span><br><span class="line">        threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将HashMap中的全部元素都添加到newTable中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">        Entry[] src = table;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                src[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                    <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">                    e.next = newTable[i];</span><br><span class="line">                    newTable[i] = e;</span><br><span class="line">                    e = next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将"m"的全部元素都添加到HashMap中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 有效性判断</span></span><br><span class="line">        <span class="keyword">int</span> numKeysToBeAdded = m.size();</span><br><span class="line">        <span class="keyword">if</span> (numKeysToBeAdded == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算容量是否足够，</span></span><br><span class="line">        <span class="comment">// 若“当前实际容量 &lt; 需要的容量”，则将容量x2。</span></span><br><span class="line">        <span class="keyword">if</span> (numKeysToBeAdded &gt; threshold) &#123;</span><br><span class="line">            <span class="keyword">int</span> targetCapacity = (<span class="keyword">int</span>)(numKeysToBeAdded / loadFactor + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (targetCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">                targetCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">            <span class="keyword">int</span> newCapacity = table.length;</span><br><span class="line">            <span class="keyword">while</span> (newCapacity &lt; targetCapacity)</span><br><span class="line">                newCapacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (newCapacity &gt; table.length)</span><br><span class="line">                resize(newCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过迭代器，将“m”中的元素逐个添加到HashMap中。</span></span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; i = m.entrySet().iterator(); i.hasNext(); ) &#123;</span><br><span class="line">            Map.Entry&lt;? extends K, ? extends V&gt; e = i.next();</span><br><span class="line">            put(e.getKey(), e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除“键为key”元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = removeEntryForKey(key);</span><br><span class="line">        <span class="keyword">return</span> (e == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除“键为key”的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取哈希值。若key为null，则哈希值为0；否则调用hash()进行计算</span></span><br><span class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">        Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">        Entry&lt;K,V&gt; e = prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除链表中“键为key”的元素</span></span><br><span class="line">        <span class="comment">// 本质是“删除单向链表中的节点”</span></span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                modCount++;</span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">if</span> (prev == e)</span><br><span class="line">                    table[i] = next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    prev.next = next;</span><br><span class="line">                e.recordRemoval(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除“键值对”</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeMapping</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o;</span><br><span class="line">        Object key = entry.getKey();</span><br><span class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">        Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">        Entry&lt;K,V&gt; e = prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除链表中的“键值对e”</span></span><br><span class="line">        <span class="comment">// 本质是“删除单向链表中的节点”</span></span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; e.equals(entry)) &#123;</span><br><span class="line">                modCount++;</span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">if</span> (prev == e)</span><br><span class="line">                    table[i] = next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    prev.next = next;</span><br><span class="line">                e.recordRemoval(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空HashMap，将所有的元素设为null</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; i++)</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否包含“值为value”的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若“value为null”，则调用containsNullValue()查找</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> containsNullValue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若“value不为null”，则查找HashMap中是否有值为value的节点。</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length ; i++)</span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i] ; e != <span class="keyword">null</span> ; e = e.next)</span><br><span class="line">                <span class="keyword">if</span> (value.equals(e.value))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否包含null值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">containsNullValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length ; i++)</span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i] ; e != <span class="keyword">null</span> ; e = e.next)</span><br><span class="line">                <span class="keyword">if</span> (e.value == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 克隆一个HashMap，并返回Object对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashMap&lt;K,V&gt; result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = (HashMap&lt;K,V&gt;)<span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="comment">// assert false;</span></span><br><span class="line">        &#125;</span><br><span class="line">        result.table = <span class="keyword">new</span> Entry[table.length];</span><br><span class="line">        result.entrySet = <span class="keyword">null</span>;</span><br><span class="line">        result.modCount = <span class="number">0</span>;</span><br><span class="line">        result.size = <span class="number">0</span>;</span><br><span class="line">        result.init();</span><br><span class="line">        <span class="comment">// 调用putAllForCreate()将全部元素添加到HashMap中</span></span><br><span class="line">        result.putAllForCreate(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Entry是单向链表。</span></span><br><span class="line">    <span class="comment">// 它是 “HashMap链式存储法”对应的链表。</span></span><br><span class="line">    <span class="comment">// 它实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        <span class="comment">// 指向下一个节点</span></span><br><span class="line">        Entry&lt;K,V&gt; next;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造函数。</span></span><br><span class="line">        <span class="comment">// 输入参数包括"哈希值(h)", "键(k)", "值(v)", "下一节点(n)"</span></span><br><span class="line">        Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">            value = v;</span><br><span class="line">            next = n;</span><br><span class="line">            key = k;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断两个Entry是否相等</span></span><br><span class="line">        <span class="comment">// 若两个Entry的“key”和“value”都相等，则返回true。</span></span><br><span class="line">        <span class="comment">// 否则，返回false</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            Map.Entry e = (Map.Entry)o;</span><br><span class="line">            Object k1 = getKey();</span><br><span class="line">            Object k2 = e.getKey();</span><br><span class="line">            <span class="keyword">if</span> (k1 == k2 || (k1 != <span class="keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;</span><br><span class="line">                Object v1 = getValue();</span><br><span class="line">                Object v2 = e.getValue();</span><br><span class="line">                <span class="keyword">if</span> (v1 == v2 || (v1 != <span class="keyword">null</span> &amp;&amp; v1.equals(v2)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现hashCode()</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (key==<span class="keyword">null</span>   ? <span class="number">0</span> : key.hashCode()) ^</span><br><span class="line">                   (value==<span class="keyword">null</span> ? <span class="number">0</span> : value.hashCode());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getKey() + <span class="string">"="</span> + getValue();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当向HashMap中添加元素时，绘调用recordAccess()。</span></span><br><span class="line">        <span class="comment">// 这里不做任何处理</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当从HashMap中删除元素时，绘调用recordRemoval()。</span></span><br><span class="line">        <span class="comment">// 这里不做任何处理</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">recordRemoval</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保存“bucketIndex”位置的值到“e”中</span></span><br><span class="line">        Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">        <span class="comment">// 设置“bucketIndex”位置的元素为“新Entry”，</span></span><br><span class="line">        <span class="comment">// 设置“e”为“新Entry的下一个节点”</span></span><br><span class="line">        table[bucketIndex] = <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">        <span class="comment">// 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小</span></span><br><span class="line">        <span class="keyword">if</span> (size++ &gt;= threshold)</span><br><span class="line">            resize(<span class="number">2</span> * table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Entry。将“key-value”插入指定位置，bucketIndex是位置索引。</span></span><br><span class="line">    <span class="comment">// 它和addEntry的区别是：</span></span><br><span class="line">    <span class="comment">// (01) addEntry()一般用在 新增Entry可能导致“HashMap的实际容量”超过“阈值”的情况下。</span></span><br><span class="line">    <span class="comment">//   例如，我们新建一个HashMap，然后不断通过put()向HashMap中添加元素；</span></span><br><span class="line">    <span class="comment">// put()是通过addEntry()新增Entry的。</span></span><br><span class="line">    <span class="comment">//   在这种情况下，我们不知道何时“HashMap的实际容量”会超过“阈值”；</span></span><br><span class="line">    <span class="comment">//   因此，需要调用addEntry()</span></span><br><span class="line">    <span class="comment">// (02) createEntry() 一般用在 新增Entry不会导致“HashMap的实际容量”超过“阈值”的情况下。</span></span><br><span class="line">    <span class="comment">//   例如，我们调用HashMap“带有Map”的构造函数，它绘将Map的全部元素添加到HashMap中；</span></span><br><span class="line">    <span class="comment">// 但在添加之前，我们已经计算好“HashMap的容量和阈值”。也就是，可以确定“即使将Map中</span></span><br><span class="line">    <span class="comment">// 的全部元素添加到HashMap中，都不会超过HashMap的阈值”。</span></span><br><span class="line">    <span class="comment">//   此时，调用createEntry()即可。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保存“bucketIndex”位置的值到“e”中</span></span><br><span class="line">        Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">        <span class="comment">// 设置“bucketIndex”位置的元素为“新Entry”，</span></span><br><span class="line">        <span class="comment">// 设置“e”为“新Entry的下一个节点”</span></span><br><span class="line">        table[bucketIndex] = <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HashIterator是HashMap迭代器的抽象出来的父类，实现了公共了函数。</span></span><br><span class="line">    <span class="comment">// 它包含“key迭代器(KeyIterator)”、“Value迭代器(ValueIterator)”和“Entry迭代器(EntryIterator)”3个子类。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 下一个元素</span></span><br><span class="line">        Entry&lt;K,V&gt; next;</span><br><span class="line">        <span class="comment">// expectedModCount用于实现fast-fail机制。</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount;</span><br><span class="line">        <span class="comment">// 当前索引</span></span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        <span class="comment">// 当前元素</span></span><br><span class="line">        Entry&lt;K,V&gt; current;</span><br><span class="line"></span><br><span class="line">        HashIterator() &#123;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">                Entry[] t = table;</span><br><span class="line">                <span class="comment">// 将next指向table中第一个不为null的元素。</span></span><br><span class="line">                <span class="comment">// 这里利用了index的初始值为0，从0开始依次向后遍历，直到找到不为null的元素就退出循环。</span></span><br><span class="line">                <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>)</span><br><span class="line">                    ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取下一个元素</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">nextEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            Entry&lt;K,V&gt; e = next;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注意！！！</span></span><br><span class="line">            <span class="comment">// 一个Entry就是一个单向链表</span></span><br><span class="line">            <span class="comment">// 若该Entry的下一个节点不为空，就将next指向下一个节点;</span></span><br><span class="line">            <span class="comment">// 否则，将next指向下一个链表(也是下一个Entry)的不为null的节点。</span></span><br><span class="line">            <span class="keyword">if</span> ((next = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Entry[] t = table;</span><br><span class="line">                <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>)</span><br><span class="line">                    ;</span><br><span class="line">            &#125;</span><br><span class="line">            current = e;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除当前元素</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            Object k = current.key;</span><br><span class="line">            current = <span class="keyword">null</span>;</span><br><span class="line">            HashMap.<span class="keyword">this</span>.removeEntryForKey(k);</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// value的迭代器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nextEntry().value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// key的迭代器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> K <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nextEntry().getKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Entry的迭代器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nextEntry();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个“key迭代器”</span></span><br><span class="line">    <span class="function">Iterator&lt;K&gt; <span class="title">newKeyIterator</span><span class="params">()</span>   </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回一个“value迭代器”</span></span><br><span class="line">    <span class="function">Iterator&lt;V&gt; <span class="title">newValueIterator</span><span class="params">()</span>   </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ValueIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回一个“entry迭代器”</span></span><br><span class="line">    Iterator&lt;Map.Entry&lt;K,V&gt;&gt; newEntryIterator()   &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HashMap的Entry对应的集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回“key的集合”，实际上返回一个“KeySet对象”</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;K&gt; ks = keySet;</span><br><span class="line">        <span class="keyword">return</span> (ks != <span class="keyword">null</span> ? ks : (keySet = <span class="keyword">new</span> KeySet()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Key对应的集合</span></span><br><span class="line">    <span class="comment">// KeySet继承于AbstractSet，说明该集合中没有重复的Key。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> newKeyIterator();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> containsKey(o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> HashMap.<span class="keyword">this</span>.removeEntryForKey(o) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            HashMap.<span class="keyword">this</span>.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回“value集合”，实际上返回的是一个Values对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collection&lt;V&gt; vs = values;</span><br><span class="line">        <span class="keyword">return</span> (vs != <span class="keyword">null</span> ? vs : (values = <span class="keyword">new</span> Values()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// “value集合”</span></span><br><span class="line">    <span class="comment">// Values继承于AbstractCollection，不同于“KeySet继承于AbstractSet”，</span></span><br><span class="line">    <span class="comment">// Values中的元素能够重复。因为不同的key可以指向相同的value。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Values</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Iterator&lt;V&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> newValueIterator();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> containsValue(o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            HashMap.<span class="keyword">this</span>.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回“HashMap的Entry集合”</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">        <span class="keyword">return</span> entrySet0();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回“HashMap的Entry集合”，它实际是返回一个EntrySet对象</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet0() &#123;</span><br><span class="line">        Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet;</span><br><span class="line">        <span class="keyword">return</span> es != <span class="keyword">null</span> ? es : (entrySet = <span class="keyword">new</span> EntrySet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// EntrySet对应的集合</span></span><br><span class="line">    <span class="comment">// EntrySet继承于AbstractSet，说明该集合中没有重复的EntrySet。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">            <span class="keyword">return</span> newEntryIterator();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            Map.Entry&lt;K,V&gt; e = (Map.Entry&lt;K,V&gt;) o;</span><br><span class="line">            Entry&lt;K,V&gt; candidate = getEntry(e.getKey());</span><br><span class="line">            <span class="keyword">return</span> candidate != <span class="keyword">null</span> &amp;&amp; candidate.equals(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> removeMapping(o) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            HashMap.<span class="keyword">this</span>.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// java.io.Serializable的写入函数</span></span><br><span class="line">    <span class="comment">// 将HashMap的“总的容量，实际容量，所有的Entry”都写入到输出流中</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i =</span><br><span class="line">            (size &gt; <span class="number">0</span>) ? entrySet0().iterator() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out the threshold, loadfactor, and any hidden stuff</span></span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out number of buckets</span></span><br><span class="line">        s.writeInt(table.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out size (number of Mappings)</span></span><br><span class="line">        s.writeInt(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out keys and values (alternating)</span></span><br><span class="line">        <span class="keyword">if</span> (i != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            s.writeObject(e.getKey());</span><br><span class="line">            s.writeObject(e.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// java.io.Serializable的读取函数：根据写入方式读出</span></span><br><span class="line">    <span class="comment">// 将HashMap的“总的容量，实际容量，所有的Entry”依次读出</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> IOException, ClassNotFoundException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Read in the threshold, loadfactor, and any hidden stuff</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in number of buckets and allocate the bucket array;</span></span><br><span class="line">        <span class="keyword">int</span> numBuckets = s.readInt();</span><br><span class="line">        table = <span class="keyword">new</span> Entry[numBuckets];</span><br><span class="line"></span><br><span class="line">        init();  <span class="comment">// Give subclass a chance to do its thing.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in size (number of Mappings)</span></span><br><span class="line">        <span class="keyword">int</span> size = s.readInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            K key = (K) s.readObject();</span><br><span class="line">            V value = (V) s.readObject();</span><br><span class="line">            putForCreate(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回“HashMap总的容量”</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span>   <span class="title">capacity</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> table.length; &#125;</span><br><span class="line">    <span class="comment">// 返回“HashMap的加载因子”</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">loadFactor</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> loadFactor;   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重点方法"><a href="#重点方法" class="headerlink" title="重点方法"></a>重点方法</h3><h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当插入第一个元素的时候，需要先初始化数组大小</span></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 key 为 null，感兴趣的可以往里看，最终会将这个 entry 放到 table[0] 中</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="comment">// 1. 求 key 的 hash 值</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 2. 找到对应的数组下标</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 3. 遍历一下对应下标处的链表，看是否有重复的 key 已经存在，</span></span><br><span class="line">    <span class="comment">//    如果有，直接覆盖，put 方法返回旧值就结束了</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 4. 不存在重复的 key，将此 entry 添加到链表中，细节后面说</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><ul><li>数组初始化<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保证数组大小一定是 2 的 n 次方。</span></span><br><span class="line">    <span class="comment">// 比如这样初始化：new HashMap(20)，那么处理成初始数组大小是 32</span></span><br><span class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line">    <span class="comment">// 计算扩容阈值：capacity * loadFactor</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 算是初始化数组吧</span></span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">    initHashSeedAsNeeded(capacity); <span class="comment">//ignore</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在第一个元素插入 HashMap 的时候做一次数组的初始化，就是先确定初始的数组大小，并计算数组扩容的阈值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保证数组大小一定是 2 的 n 次方。</span></span><br><span class="line">    <span class="comment">// 比如这样初始化：new HashMap(20)，那么处理成初始数组大小是 32</span></span><br><span class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line">    <span class="comment">// 计算扩容阈值：capacity * loadFactor</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 算是初始化数组吧</span></span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">    initHashSeedAsNeeded(capacity); <span class="comment">//ignore</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里有一个将数组大小保持为 2 的 n 次方的做法，Java7 和 Java8 的 HashMap 和 ConcurrentHashMap 都有相应的要求，只不过实现的代码稍微有些不同，后面再看到的时候就知道了。</p><ul><li>计算具体数组位置</li></ul><p>这个简单，我们自己也能 YY 一个：使用 key 的 hash 值对数组长度进行取模就可以了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> hash, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";</span></span><br><span class="line">    <span class="keyword">return</span> hash &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法很简单，简单说就是取 hash 值的低 n 位。如在数组长度为 32 的时候，其实取的就是 key 的 hash 值的低 5 位，作为它在数组中的下标位置。</p><ul><li>添加节点到链表中</li></ul><p>找到数组下标后，会先进行 key 判重，如果没有重复，就准备将新值放入到链表的表头。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前 HashMap 大小已经达到了阈值，并且新值要插入的数组位置已经有元素了，那么要扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        <span class="comment">// 扩容，后面会介绍一下</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        <span class="comment">// 扩容以后，重新计算 hash 值</span></span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 重新计算扩容后的新的下标</span></span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 往下看</span></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个很简单，其实就是将新值放到链表的表头，然后 size++</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法的主要逻辑就是先判断是否需要扩容，需要的话先扩容，然后再将这个新的数据插入到扩容后的数组的相应位置处的链表的表头。</p><ul><li>数组扩容</li></ul><p>前面我们看到，在插入新值的时候，如果当前的 size 已经达到了阈值，并且要插入的数组位置上已经有元素，那么就会触发扩容，扩容后，数组大小为原来的 2 倍。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新的数组</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    <span class="comment">// 将原来数组中的值迁移到新的更大的数组中</span></span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>扩容就是用一个新的大数组替换原来的小数组，并将原来数组中的值迁移到新的数组中。</p><p>由于是双倍扩容，迁移过程中，会将原来 table[i] 中的链表的所有节点，分拆到新的数组的 newTable[i] 和 newTable[i + oldLength] 位置上。如原来数组长度是 16，那么扩容后，原来 table[0] 处的链表中的所有元素会被分配到新数组中 newTable[0] 和 newTable[16] 这两个位置。代码比较简单，这里就不展开了。</p><p>1.对Key求Hash值，然后再计算下标<br>2.如果没有碰撞，直接放入桶中（碰撞的意思是计算得到的Hash值相同，需要放到同一个bucket中）<br>3.如果碰撞了，以链表的方式链接到后面<br>4.如果链表长度超过阀值( TREEIFY THRESHOLD==8)，就把链表转成红黑树，链表长度低于6，就把红黑树转回链表<br>5.如果节点已经存在就替换旧值<br>6.如果桶满了(容量16*加载因子0.75)，就需要 resize（扩容2倍后重排）</p><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>当我们调用 get() 方法，HashMap 会使用键对象的 hashcode 找到 bucket 位置，找到 bucket 位置之后，会调用 keys.equals() 方法去找到链表中正确的节点，最终找到要找的值对象。</p><p><img src="/upload/pasted-273.png" alt="upload successful"></p><h2 id="1-8"><a href="#1-8" class="headerlink" title="1.8"></a>1.8</h2><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。</p><p>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。</p><p>为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。</p><p><img src="/upload/pasted-276.png" alt="upload successful"><br>Java7 中使用 Entry 来代表每个 HashMap 中的数据节点，Java8 中使用 Node，基本没有区别，都是 key，value，hash 和 next 这四个属性，不过，Node 只能用于链表的情况，红黑树的情况需要使用 TreeNode。</p><p>我们根据数组元素中，第一个节点数据类型是 Node 还是 TreeNode 来判断该位置下是链表还是红黑树的。</p><h3 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ublic V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 第三个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作</span></span><br><span class="line"><span class="comment">// 第四个参数 evict 我们这里不关心</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 第一次 put 值的时候，会触发下面的 resize()，类似 java7 的第一次 put 也要初始化数组长度</span></span><br><span class="line">    <span class="comment">// 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置就可以了</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 数组该位置有数据</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是"相等"，如果是，取出这个节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果该节点是代表红黑树的节点，调用红黑树的插值方法，本文不展开说红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 到这里，说明数组该位置上是一个链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 插入到链表的最后面(Java7 是插入到链表的最前面)</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 9 个</span></span><br><span class="line">                    <span class="comment">// 会触发下面的 treeifyBin，也就是将链表转换为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果在该链表中找到了"相等"的 key(== 或 equals)</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 此时 break，那么 e 为链表中[与要插入的新值的 key "相等"]的 node</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// e!=null 说明存在旧值的key与要插入的key"相等"</span></span><br><span class="line">        <span class="comment">// 对于我们分析的put操作，下面这个 if 其实就是进行 "值覆盖"，然后返回旧值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>和 Java7 稍微有点不一样的地方就是，Java7 是先扩容后插入新值的，Java8 先插值再扩容，不过这个不重要。</p><ul><li>数组扩容</li></ul><p>resize() 方法用于初始化数组或数组扩容，每次扩容后，容量为原来的 2 倍，并进行数据迁移。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123; <span class="comment">// 对应数组扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将数组大小扩大一倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 将阈值扩大一倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 对应使用 new HashMap() 初始化后，第一次 put 的时候</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 用新的数组大小初始化新的数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab; <span class="comment">// 如果是初始化数组，到这里就结束了，返回 newTab 即可</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 开始遍历原数组，进行数据迁移。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 如果该数组位置上只有单个元素，那就简单了，简单迁移这个元素就可以了</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果是红黑树，具体我们就不展开了</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; </span><br><span class="line">                    <span class="comment">// 这块是处理链表的情况，</span></span><br><span class="line">                    <span class="comment">// 需要将此链表拆成两个链表，放到新的数组中，并且保留原来的先后顺序</span></span><br><span class="line">                    <span class="comment">// loHead、loTail 对应一条链表，hiHead、hiTail 对应另一条链表，代码还是比较简单的</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 第一条链表</span></span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 第二条链表的新的位置是 j + oldCap，这个很好理解</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>其底层数据与HashMap的数据结构相同，数组+链表+红黑树，桶中的结构可能是链表，也可能是红黑树，红黑树是为了提高查找效率。</p><p><img src="/upload/pasted-274.png" alt="upload successful"></p><h2 id="1-7-1"><a href="#1-7-1" class="headerlink" title="1.7"></a>1.7</h2><p>HashMap的容量由负载因子决定，插入的元素超过了容量的范围就会触发扩容操作，就是rehash。<br>在多线程环境下，若同时存在其他元素进行put操作，如果hash值相同，可能出现在同一数组下用链表表示，出现闭环，导致在get的操作会出现死循环，所以hashmap是线程不安全的。<br>Hashtable是线程安全的，它在所有都涉及到多线程操作时都加了synchronized关键字来锁住整个table，意味着所有线程都在争用一把锁，在多线程的环境下，它是安全的，但效率低下。<br>ConcurrentHashMap采用锁分离技术，将锁的粒度降低，利用多个锁来控制多个小的table。<br>ConcurrentHashMap的数据结构是由一个Segment数组和多个HashEntry组成，如下图所示：</p><p><img src="/upload/pasted-275.png" alt="upload successful"><br>ConcurrentHashMap的初始化是会通过位与运算来初始化Segment的大小，用ssize来表示，如下所示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">    ++sshift;</span><br><span class="line">    ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上所示，因为ssize用位于运算来计算（ssize &lt;&lt;=1），所以Segment的大小取值都是以2的N次方，无关concurrencyLevel的取值，当然concurrencyLevel最大只能用16位的二进制来表示，即65536，换句话说，Segment的大小最多65536个，没有指定concurrencyLevel元素初始化，Segment的大小ssize默认为16。<br>每一个Segment元素下的HashEntry的初始化也是按照位于运算来计算，用cap来表示，如下所示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cap = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">    cap &lt;&lt;= <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><p>如上所示，HashEntry大小的计算也是2的N次方（cap &lt;&lt;=1）， cap的初始值为1，所以HashEntry最小的容量为2。</p><h3 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h3><p>对于ConcurrentHashMap的数据插入，这里要进行两次Hash去定位数据的存储位置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br></pre></td></tr></table></figure></p><p>从上Segment的继承体系可以看出，Segment实现了ReentrantLock,也就带有锁的功能，当执行put操作时，会进行第一次key的hash来定位Segment的位置，如果该Segment还没有初始化，即通过CAS操作进行赋值，然后进行第二次hash操作，找到相应的HashEntry的位置，这里会利用继承过来的锁的特性，在将数据插入指定的HashEntry位置时（链表的尾端），会通过继承ReentrantLock的tryLock（）方法尝试去获取锁，如果获取成功就直接插入相应的位置，如果已经有线程获取该Segment的锁，那当前线程会以自旋的方式去继续的调用tryLock（）方法去获取锁，超过指定次数就挂起，等待唤醒。</p><h3 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h3><p>ConcurrentHashMap的get操作跟HashMap类似，只是首先要判断volatile类型变量count是否不等于0，若不等于0则ConcurrentHashMap第一次需要经过一次hash定位到Segment的位置，然后再hash定位到指定的HashEntry，遍历该HashEntry下的链表进行对比，成功就返回，不成功就返回null。是弱一致性的。</p><p>   因为count是volatile，所以对count的写要happens-before于读操作。写线程 M 对链表做的结构性修改，在读线程 N 读取了同一个 volatile 变量后，对线程 N 也是可见的了。虽然线程 N 是在未加锁的情况下访问链表。Java 的内存模型可以保证：只要之前对链表做结构性修改操作的写线程 M 在退出写方法前写 volatile 型变量 count，读线程 N 在读取这个 volatile 型变量 count 后，就一定能“看到”这些修改。使得在 ConcurrentHashMap 中，读线程在读取散列表时，基本不需要加锁就能成功获得需要的值,不仅减少了请求同一个锁的频率（读操作一般不需要加锁就能够成功获得值），也减少了持有同一个锁的时间（只有读到 value 域的值为 null 时 , 读线程才需要加锁后重读）。</p><h3 id="size操作"><a href="#size操作" class="headerlink" title="size操作"></a>size操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">        &#125;</span><br><span class="line">        sum = <span class="number">0L</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        overflow = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">            Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">            <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123; sum += seg.modCount; <span class="keyword">int</span> c = seg.count; <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">               overflow = <span class="keyword">true</span>;</span><br><span class="line">            &#125; &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum == last) <span class="keyword">break</span>;</span><br><span class="line">        last = sum; &#125; &#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">            segmentAt(segments, j).unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一种方案他会使用不加锁的模式去尝试多次计算ConcurrentHashMap的size，最多三次，比较前后两次计算的结果，结果一致就认为当前没有元素加入，计算的结果是准确的；<br>第二种方案是如果第一种方案不符合，他就会给每个Segment加上锁，然后计算ConcurrentHashMap的size返回。</p><h2 id="1-8-1"><a href="#1-8-1" class="headerlink" title="1.8"></a>1.8</h2><p> JDK1.8的实现已经摒弃了Segment的概念，而是直接用Node数组+链表+红黑树的数据结构来实现，并发控制使用Synchronized和CAS来操作，整个看起来就像是优化过且线程安全的HashMap，虽然在JDK1.8中还能看到Segment的数据结构，但是已经简化了属性，只是为了兼容旧版本，序列化与反序列化的时候会发挥作用。</p><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>Node是ConcurrentHashMap存储结构的基本单元，继承于HashMap中的Entry，用于存储数据，源代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//链表的数据结构</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="comment">//val和next都会在扩容时发生变化，所以加上volatile来保持可见性和禁止重排序</span></span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>       </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> key.hashCode() ^ val.hashCode(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + val; &#125;</span><br><span class="line">    <span class="comment">//不允许更新value  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        Object k, v, u; Map.Entry&lt;?,?&gt; e;</span><br><span class="line">        <span class="keyword">return</span> ((o <span class="keyword">instanceof</span> Map.Entry) &amp;&amp;</span><br><span class="line">                (k = (e = (Map.Entry&lt;?,?&gt;)o).getKey()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (v = e.getValue()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (k == key || k.equals(key)) &amp;&amp;</span><br><span class="line">                (v == (u = val) || v.equals(u)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用于map中的get（）方法，子类重写</span></span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                K ek;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Node数据结构很简单，它与HashMap中的定义很相似，但是但是有一些差别它对value和next属性设置了volatile同步锁，它不允许调用setValue方法直接改变Node的value域，它增加了find方法辅助map.get()方法。</p><h3 id="TreeNode"><a href="#TreeNode" class="headerlink" title="TreeNode"></a>TreeNode</h3><p>TreeNode继承与Node，但是数据结构换成了二叉树结构，它是红黑树的数据的存储结构，用于红黑树中存储数据，当链表的节点数大于8时会转换成红黑树的结构，树节点类，另外一个核心的数据结构。当链表长度过长的时候，会转换为TreeNode。但是与HashMap不相同的是，它并不是直接转换为红黑树，而是把这些结点包装成TreeNode放在TreeBin对象中，由TreeBin完成对红黑树的包装。而且TreeNode在ConcurrentHashMap集成自Node类，而并非HashMap中的集成自LinkedHashMap.Entry&lt;K,V&gt;类，也就是说TreeNode带有next指针，这样做的目的是方便基于TreeBin的访问。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//树形结构的属性定义</span></span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red; <span class="comment">//标志红黑树的红节点</span></span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next,</span><br><span class="line">             TreeNode&lt;K,V&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> findTreeNode(h, k, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据key查找 从根节点开始找出相应的TreeNode，</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">findTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">do</span>  &#123;</span><br><span class="line">                <span class="keyword">int</span> ph, dir; K pk; TreeNode&lt;K,V&gt; q;</span><br><span class="line">                TreeNode&lt;K,V&gt; pl = p.left, pr = p.right;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (pk != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                          (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">                    p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.findTreeNode(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p = pl;</span><br><span class="line">            &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="TreeBin"><a href="#TreeBin" class="headerlink" title="TreeBin"></a>TreeBin</h3><p>TreeBin从字面含义中可以理解为存储树形结构的容器，而树形结构就是指TreeNode，所以TreeBin就是封装TreeNode的容器，它提供转换黑红树的一些条件和锁的控制。这个类并不负责包装用户的key、value信息，而是包装的很多TreeNode节点。它代替了TreeNode的根节点，也就是说在实际的ConcurrentHashMap“数组”中，存放的是TreeBin对象，而不是TreeNode对象，这是与HashMap的区别。另外这个类还带有了读写锁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//指向TreeNode列表和根节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; root;</span><br><span class="line">    <span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> lockState;</span><br><span class="line">    <span class="comment">// 读写锁状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITER = <span class="number">1</span>; <span class="comment">// 获取写锁的状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITER = <span class="number">2</span>; <span class="comment">// 等待写锁的状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER = <span class="number">4</span>; <span class="comment">// 增加数据时读锁的状态</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化红黑树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TreeBin(TreeNode&lt;K,V&gt; b) &#123;</span><br><span class="line">        <span class="keyword">super</span>(TREEBIN, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.first = b;</span><br><span class="line">        TreeNode&lt;K,V&gt; r = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = b, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">            next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">            x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">                x.parent = <span class="keyword">null</span>;</span><br><span class="line">                x.red = <span class="keyword">false</span>;</span><br><span class="line">                r = x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                K k = x.key;</span><br><span class="line">                <span class="keyword">int</span> h = x.hash;</span><br><span class="line">                Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = r;;) &#123;</span><br><span class="line">                    <span class="keyword">int</span> dir, ph;</span><br><span class="line">                    K pk = p.key;</span><br><span class="line">                    <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                        dir = -<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                        dir = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                              (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                             (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                        dir = tieBreakOrder(k, pk);</span><br><span class="line">                        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                    <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        x.parent = xp;</span><br><span class="line">                        <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                            xp.left = x;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            xp.right = x;</span><br><span class="line">                        r = balanceInsertion(r, x);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.root = r;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="ForwardingNode"><a href="#ForwardingNode" class="headerlink" title="ForwardingNode"></a>ForwardingNode</h3><p>一个用于连接两个table的节点类。它包含一个nextTable指针，用于指向下一张表。而且这个节点的key value next指针全部为null，它的hash值为-1. 这里面定义的find的方法是从nextTable里进行查询节点，而不是以自身为头节点进行查找<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">     * A node inserted at head of bins during transfer operations. </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;  </span><br><span class="line">        <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;  </span><br><span class="line">        ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;  </span><br><span class="line">            <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);  </span><br><span class="line">            <span class="keyword">this</span>.nextTable = tab;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;  </span><br><span class="line">            <span class="comment">// loop to avoid arbitrarily deep recursion on forwarding nodes  </span></span><br><span class="line">            outer: <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = nextTable;;) &#123;  </span><br><span class="line">                Node&lt;K,V&gt; e; <span class="keyword">int</span> n;  </span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span> || tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||  </span><br><span class="line">                    (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) == <span class="keyword">null</span>)  </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">                    <span class="keyword">int</span> eh; K ek;  </span><br><span class="line">                    <span class="keyword">if</span> ((eh = e.hash) == h &amp;&amp;  </span><br><span class="line">                        ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))  </span><br><span class="line">                        <span class="keyword">return</span> e;  </span><br><span class="line">                    <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">                        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ForwardingNode) &#123;  </span><br><span class="line">                            tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;  </span><br><span class="line">                            <span class="keyword">continue</span> outer;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        <span class="keyword">else</span>  </span><br><span class="line">                            <span class="keyword">return</span> e.find(h, k);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)  </span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.importnew.com/28263.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.importnew.com/28263.html&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Hashmap&quot;
      
    
    </summary>
    
      <category term="数据结构" scheme="https://www.junglezero.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="java相关" scheme="https://www.junglezero.top/tags/java%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>volatile关键字</title>
    <link href="https://www.junglezero.top/2019/04/09/atile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://www.junglezero.top/2019/04/09/atile关键字/</id>
    <published>2019-04-09T07:24:00.000Z</published>
    <updated>2019-04-10T07:22:10.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="准备概念"><a href="#准备概念" class="headerlink" title="准备概念"></a>准备概念</h1><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p>当一个变量被两个线程同时处理时，由于两个线程处在不同的CPU中（多核CPU），因此对于该变量存在缓存一致性的问题<br>在硬件层面上，有两种解决方式：总线加锁，通过缓存一致性协议</p><p><img src="/upload/pasted-270.png" alt="upload successful"></p><h2 id="并发编程的三个概念"><a href="#并发编程的三个概念" class="headerlink" title="并发编程的三个概念"></a>并发编程的三个概念</h2><ul><li>原子性：<br>即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。<br>Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</li><li>可见性：<br>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。<br>对于可见性，Java提供了volatile关键字来保证可见性。<br>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。<br>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</li><li>有序性：<br>即程序执行的顺序按照代码的先后顺序执行<br>一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。（重排序）<br>在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</li></ul><h2 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a>happens-before原则</h2><p>在java中，有一套“happens-before”原则，满足这个原则，则会顺序执行，不满足则会发生重排序</p><ul><li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li><li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作</li><li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li><li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li><li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</li><li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li><li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li><li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li></ul><h1 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>1.保证了修饰变量的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> INIT_VALUE = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_LIMIT = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> localValue = INIT_VALUE;</span><br><span class="line">            <span class="keyword">while</span> (localValue &lt; MAX_LIMIT) &#123;</span><br><span class="line">                <span class="keyword">if</span> (localValue != INIT_VALUE) &#123;</span><br><span class="line">                    System.out.printf(<span class="string">"The value updated to [%d]\n"</span>, INIT_VALUE);</span><br><span class="line">                    localValue = INIT_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"READER"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> localValue = INIT_VALUE;</span><br><span class="line">            <span class="keyword">while</span> (INIT_VALUE &lt; MAX_LIMIT) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"Update the value to [%d]\n"</span>, ++localValue);</span><br><span class="line">                INIT_VALUE = localValue;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"UPDATER"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Update the value to [1]</span><br><span class="line">The value updated to [1]</span><br><span class="line">Update the value to [2]</span><br><span class="line">The value updated to [2]</span><br><span class="line">Update the value to [3]</span><br><span class="line">The value updated to [3]</span><br><span class="line">Update the value to [4]</span><br><span class="line">The value updated to [4]</span><br><span class="line">Update the value to [5]</span><br><span class="line">The value updated to [5]</span><br></pre></td></tr></table></figure></p><p>当INIT_VALUE没有被volatile修饰时<br>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Update the value to [1]</span><br><span class="line">Update the value to [2]</span><br><span class="line">Update the value to [3]</span><br><span class="line">Update the value to [4]</span><br><span class="line">Update the value to [5]</span><br></pre></td></tr></table></figure></p><p>分析：在没有volatile修饰时，对于第一个读线程，此时判定是两个值是相等的，因此执行完毕后就退出了，而有了volatile修饰后，这个值就是可见的了，而且是立即可见，因此会不断的运行</p><p>2.volatile可以保证有序性<br>volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。<br>volatile关键字禁止指令重排序有两层意思：<br>1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；<br>2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。<br>举例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x、y为非volatile变量</span></span><br><span class="line"><span class="comment">//flag为volatile变量</span></span><br><span class="line"> </span><br><span class="line">x = <span class="number">2</span>;        <span class="comment">//语句1</span></span><br><span class="line">y = <span class="number">0</span>;        <span class="comment">//语句2</span></span><br><span class="line">flag = <span class="keyword">true</span>;  <span class="comment">//语句3</span></span><br><span class="line">x = <span class="number">4</span>;         <span class="comment">//语句4</span></span><br><span class="line">y = -<span class="number">1</span>;       <span class="comment">//语句5</span></span><br></pre></td></tr></table></figure></p><p>　由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。<br>并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</p><p>对于<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">context = loadContext();   <span class="comment">//语句1</span></span><br><span class="line">inited = <span class="keyword">true</span>;             <span class="comment">//语句2</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure></p><p>有可能语句2会在语句1之前执行，那么可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。<br>这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>　synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。<br> 通常来说，使用volatile必须具备以下2个条件：</p><p>　　1）对变量的写操作不依赖于当前值</p><p>　　2）该变量没有包含在具有其他变量的不变式中</p><p>1.状态标记量<br><figure class="highlight plain"><figcaption><span>boolean flag </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">while(!flag)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public void setFlag() &#123;</span><br><span class="line">    flag = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> inited = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//线程1:</span></span><br><span class="line">context = loadContext();  </span><br><span class="line">inited = <span class="keyword">true</span>;            </span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;</span><br><span class="line">sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure><p>2.单例模式中的doublecheck<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考自 <a href="https://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3920373.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;准备概念&quot;&gt;&lt;a href=&quot;#准备概念&quot; class=&quot;headerlink&quot; title=&quot;准备概念&quot;&gt;&lt;/a&gt;准备概念&lt;/h1&gt;&lt;h2 id=&quot;内存模型&quot;&gt;&lt;a href=&quot;#内存模型&quot; class=&quot;headerlink&quot; title=&quot;内存模型&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="java多线程学习" scheme="https://www.junglezero.top/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="java多线程" scheme="https://www.junglezero.top/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="关键字系列" scheme="https://www.junglezero.top/tags/%E5%85%B3%E9%94%AE%E5%AD%97%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>多线程下的单例设计模式</title>
    <link href="https://www.junglezero.top/2019/04/09/%E7%A8%8B%E4%B8%8B%E7%9A%84%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.junglezero.top/2019/04/09/程下的单例设计模式/</id>
    <published>2019-04-09T02:14:00.000Z</published>
    <updated>2019-04-15T02:01:42.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>1、单例类只能有一个实例。<br>2、单例类必须自己创建自己的唯一实例。<br>3、单例类必须给所有其他对象提供这一实例。<br>单例模式保证了全局对象的唯一性，比如系统启动读取配置文件就需要单例保证配置的一致性。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>饿汉式单例模式：类加载初始化时就创建好一个静态的对象供外部使用，除非系统重启，这个对象不会改变，所以本身就是线程安全的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObject1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无法进行懒加载：一旦类加载了，就会占用内存空间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonObject1 instance = <span class="keyword">new</span> SingletonObject1();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数私有</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonObject1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//empty</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonObject1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>懒汉式单例（延迟加载方式）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObject2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonObject2 instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonObject2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//empty</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//虽然实现了调用才构造（即懒加载），但是存在线程安全问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonObject2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance)</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonObject2();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> SingletonObject2.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>部分加锁的懒汉式单例，实际上最初的想法是在整个方法上加锁，但实际上虽然解决了多个实例对象问题，但是该方式运行效率却很低下，下一个线程想要获取对象，就必须等待上一个线程释放锁之后，才可以继续运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObject4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonObject4 instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonObject4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//---</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//double check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonObject4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">            <span class="comment">//在创建处加锁，防止多个线程的多次创建</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonObject4.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == instance)</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonObject4();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> SingletonObject4.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类的方法,这种方法巧用类的加载机制，而且也能保证线程安全，在未使用时，不会加载内部类，只有在使用实例时，才会加载内部类，从而初始化实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObject6</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonObject6</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> SingletonObject6 instance = <span class="keyword">new</span> SingletonObject6();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonObject6 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InstanceHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过内部枚举实现：枚举的构造函数只会调用一次<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObject7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonObject7</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> SingletonObject7 instance;</span><br><span class="line"></span><br><span class="line">        Singleton() &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonObject7();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> SingletonObject7 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonObject7 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程
      
    
    </summary>
    
      <category term="java多线程学习" scheme="https://www.junglezero.top/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="设计模式" scheme="https://www.junglezero.top/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java多线程" scheme="https://www.junglezero.top/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="https://www.junglezero.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>从爬楼梯问题所想到的</title>
    <link href="https://www.junglezero.top/2019/04/03/%E6%A5%BC%E6%A2%AF%E9%97%AE%E9%A2%98%E6%89%80%E6%83%B3%E5%88%B0%E7%9A%84/"/>
    <id>https://www.junglezero.top/2019/04/03/楼梯问题所想到的/</id>
    <published>2019-04-03T00:16:00.000Z</published>
    <updated>2019-04-09T07:25:49.090Z</updated>
    
    <content type="html"><![CDATA[<p>一道简单的爬楼梯问题</p><p>You are climbing a stair case. It takes n steps to reach to the top.</p><p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?<br><strong>Note:</strong> Given n will be a positive integer.</p><p><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step</span><br><span class="line">2. 2 steps</span><br></pre></td></tr></table></figure></p><p><strong>Example2</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: There are three ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step + 1 step</span><br><span class="line">2. 1 step + 2 steps</span><br><span class="line">3. 2 steps + 1 step</span><br></pre></td></tr></table></figure></p><p>这是一道DP入门级别的题目，按照自顶向下（TOP to BOTTOM）的思考方式,要向到第n级台阶的话，只需要第n-1阶走一级或者n-2阶走两级，这时问题就又变成了到n-1阶和n-2阶有多少种方法，因此可以得到dp式子：dp(n)=dp(n-1)+dp(n-2)</p><p>因此，自然而然就写出了以下实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d[n] &gt; <span class="number">0</span>) <span class="keyword">return</span> d[n];</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> climbStairs(n - <span class="number">1</span>) + climbStairs(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然而，提交以后就报TLE,细细一想，这种递归方式，虽然写起来简单，而且看上去也很好理解，但是这里有个严重的缺陷：有些计算会重复很多次，比如计算dp(6)，需要算dp(5)和dp(4)，算dp(5)需要算dp(4),dp(3),这个时候，dp(4)就算了两次，求的数越大，重复计算的次数也就愈多</p><p>于是我就想班里的搞竞赛的大佬讨教，大佬首先给出了“记录搜索”<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> d[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d[n] &gt; <span class="number">0</span>) <span class="keyword">return</span> d[n];</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> d[n] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> d[n] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d[n] = climbStairs(n - <span class="number">1</span>) + climbStairs(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所谓“记录搜索”，就是查表，所谓的表，就是把计算的结果存起来，刚才的问题不就是需要重复计算吗，这样一来就没有重复计算的问题</p><p>后来看讨论区，又有种方法就是自底向上，顺序递推的方式，时间复杂度为O(n)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d[n] &gt; <span class="number">0</span>) <span class="keyword">return</span> d[n];</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> N_1=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> N_2=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">        ans=N_1+N_2;</span><br><span class="line">        N_1=N_2;</span><br><span class="line">        N_2=ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然而，现在又有一个新的问题，假设需要算1e8的情况，那么即使是O(n),也会超时，这时候就需要一种更快的方式<br>这里就有一种新的处理方式：<strong>矩阵快速幂</strong>（感谢大佬特地跑过来给我讲，要不然都没地方去知道）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一道简单的爬楼梯问题&lt;/p&gt;
&lt;p&gt;You are climbing a stair case. It takes n steps to reach to the top.&lt;/p&gt;
&lt;p&gt;Each time you can either climb 1 or 2 steps
      
    
    </summary>
    
      <category term="刷算法题" scheme="https://www.junglezero.top/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="算法题目" scheme="https://www.junglezero.top/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>java多线程学习（4）</title>
    <link href="https://www.junglezero.top/2019/04/02/%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/"/>
    <id>https://www.junglezero.top/2019/04/02/笔记（4）/</id>
    <published>2019-04-02T01:48:00.000Z</published>
    <updated>2019-04-08T13:12:02.108Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程组（Thread-Group）"><a href="#线程组（Thread-Group）" class="headerlink" title="线程组（Thread Group）"></a>线程组（Thread Group）</h1><blockquote><p><strong>public class ThreadGroup</strong><br>extends Object<br>implements Thread.UncaughtExceptionHandler</p></blockquote><p>A thread group represents a set of threads. In addition, a thread group can also include other thread groups. The thread groups form a tree in which every thread group except the initial thread group has a parent.</p><blockquote></blockquote><p>A thread is allowed to access information about its own thread group, but not to access information about its thread group’s parent thread group or any other thread groups.</p><p>从上面的文档可以得知：<br>线程组也是一个树形<br>ThreadGroup中，也有一系列的生成和销毁方法</p><h1 id="线程池-（ThreadPool）"><a href="#线程池-（ThreadPool）" class="headerlink" title="线程池 （ThreadPool）"></a>线程池 （ThreadPool）</h1><h2 id="自己实现"><a href="#自己实现" class="headerlink" title="自己实现"></a>自己实现</h2><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li>任务队列：把等待执行的任务储存起来</li><li>拒绝策略：任务队列应该是有大小的，当有过多的任务申请提交时，应当有拒绝策略，方法有：抛出异常，直接丢弃，进入阻塞状态，放入临时队列</li><li>初始化值：初始时线程池大小（最小）</li><li>运行时：活跃任务多的时候的大小</li><li>最大值：最多任务数</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线程组（Thread-Group）&quot;&gt;&lt;a href=&quot;#线程组（Thread-Group）&quot; class=&quot;headerlink&quot; title=&quot;线程组（Thread Group）&quot;&gt;&lt;/a&gt;线程组（Thread Group）&lt;/h1&gt;&lt;blockquote&gt;

      
    
    </summary>
    
      <category term="java多线程学习笔记" scheme="https://www.junglezero.top/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java多线程" scheme="https://www.junglezero.top/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>最长回文串的几个解法</title>
    <link href="https://www.junglezero.top/2019/04/01/%E5%9B%9E%E6%96%87%E4%B8%B2%E7%9A%84%E5%87%A0%E4%B8%AA%E8%A7%A3%E6%B3%95-1/"/>
    <id>https://www.junglezero.top/2019/04/01/回文串的几个解法-1/</id>
    <published>2019-04-01T15:00:00.000Z</published>
    <updated>2019-04-09T07:26:15.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="解法一-动态规划"><a href="#解法一-动态规划" class="headerlink" title="解法一 动态规划"></a>解法一 动态规划</h1><p>应当发现，如果一个字符串是回文串，那么在其两端加上相同的字母也是回文串<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = s.length();</span><br><span class="line">  String res = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">      dp[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt; <span class="number">3</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">            </span><br><span class="line">      <span class="keyword">if</span> (dp[i][j] &amp;&amp; (res == <span class="keyword">null</span> || j - i + <span class="number">1</span> &gt; res.length())) &#123;</span><br><span class="line">        res = s.substring(i, j + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;解法一-动态规划&quot;&gt;&lt;a href=&quot;#解法一-动态规划&quot; class=&quot;headerlink&quot; title=&quot;解法一 动态规划&quot;&gt;&lt;/a&gt;解法一 动态规划&lt;/h1&gt;&lt;p&gt;应当发现，如果一个字符串是回文串，那么在其两端加上相同的字母也是回文串&lt;br&gt;&lt;figure
      
    
    </summary>
    
      <category term="刷算法题" scheme="https://www.junglezero.top/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="算法题目" scheme="https://www.junglezero.top/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>java多线程学习（3）</title>
    <link href="https://www.junglezero.top/2019/03/31/a%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%883%EF%BC%89/"/>
    <id>https://www.junglezero.top/2019/03/31/a多线程学习（3）/</id>
    <published>2019-03-31T07:50:00.000Z</published>
    <updated>2019-04-02T01:42:30.883Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java中线程间的死锁"><a href="#java中线程间的死锁" class="headerlink" title="java中线程间的死锁"></a>java中线程间的死锁</h1><p>实例：<br>服务1<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Service_2 service_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Service_1</span><span class="params">(Service_2 service_2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.service_2 = service_2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(<span class="string">"m1"</span>);</span><br><span class="line">            service_2.s1();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(<span class="string">"m2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>服务2：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service_2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Service_1 service_1;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">s1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(<span class="string">"s1=========="</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">s2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(<span class="string">"s2=========="</span>);</span><br><span class="line">            service_1.m2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setService_1</span><span class="params">(Service_1 service_1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.service_1 = service_1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试主函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Service_2 service_2 = <span class="keyword">new</span> Service_2();</span><br><span class="line">        Service_1 service_1 = <span class="keyword">new</span> Service_1(service_2);</span><br><span class="line">        service_2.setService_1(service_1);</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    service_1.m1();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">                    service_2.s2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果：<br><img src="/upload/pasted-269.png" alt="upload successful"></p><p>分析：两个线程已经陷入了死锁（互相等待互相结束）</p><h1 id="线程间的通信"><a href="#线程间的通信" class="headerlink" title="线程间的通信"></a>线程间的通信</h1><h2 id="Object-的两个方法"><a href="#Object-的两个方法" class="headerlink" title="Object 的两个方法"></a>Object 的两个方法</h2><h3 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h3><blockquote><p>public final void wait()<br>                throws InterruptedException</p></blockquote><p>Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object. In other words, this method behaves exactly as if it simply performs the call wait(0).</p><blockquote></blockquote><p>The current thread must own this object’s monitor. The thread releases ownership of this monitor and waits until another thread notifies threads waiting on this object’s monitor to wake up either through a call to the notify method or the notifyAll method. The thread then waits until it can re-obtain ownership of the monitor and resumes execution.</p><blockquote></blockquote><p>As in the one argument version, interrupts and spurious wakeups are possible, and this method should always be used in a loop:</p><pre><code>synchronized (obj) {    while (&lt;condition does not hold&gt;)        obj.wait();    ... // Perform action appropriate to condition}</code></pre><blockquote><p>This method should only be called by a thread that is the owner of this object’s monitor. See the notify method for a description of the ways in which a thread can become the owner of a monitor.</p></blockquote><p>从上面的文档可以得知<br>当线程执行wait()时，会把当前的锁释放，然后让出CPU，进入等待状态。<br>当执行notify/notifyAll方法时，会唤醒一个处于等待该 对象锁 的线程，然后继续往下执行，直到执行完退出对象锁锁住的区域（synchronized修饰的代码块）后再释放锁。<br>并且也提供了一种建议的使用方式</p><h4 id="notify-notifyAll"><a href="#notify-notifyAll" class="headerlink" title="notify/notifyAll"></a>notify/notifyAll</h4><blockquote><p>public final void notify()</p></blockquote><p>Wakes up a single thread that is waiting on this object’s monitor. If any threads are waiting on this object, one of them is chosen to be awakened. The choice is arbitrary and occurs at the discretion of the implementation. A thread waits on an object’s monitor by calling one of the wait methods.</p><blockquote></blockquote><p>The awakened thread will not be able to proceed until the current thread relinquishes the lock on this object. The awakened thread will compete in the usual manner with any other threads that might be actively competing to synchronize on this object; for example, the awakened thread enjoys no reliable privilege or disadvantage in being the next thread to lock this object.</p><blockquote></blockquote><p>This method should only be called by a thread that is the owner of this object’s monitor. A thread becomes the owner of the object’s monitor in one of three ways:</p><blockquote></blockquote><pre><code>- By executing a synchronized instance method of that object.- By executing the body of a synchronized statement that synchronizes on the object.- For objects of type Class, by executing a synchronized static method of that class. </code></pre><blockquote></blockquote><p>Only one thread at a time can own an object’s monitor.</p><p>意思很明确：唤醒某个在当前锁下wait的线程，对于notify和notifyAll的区别就是，假设有多个线程正在当前的的锁下wait，notify只会唤醒其中任意一个线程，而notifyAll则会唤醒所有正在wait的线程<br>唤醒之后，会继续接着wait执行（这就是为什么外层要用while循环而不是if）</p><h2 id="生产-消费实例"><a href="#生产-消费实例" class="headerlink" title="生产/消费实例"></a>生产/消费实例</h2><p>生产者消费者是典型的线程通信的例子，只要缓冲区未充满，生产者就会一直进行生产；只要缓冲区不为空，消费者就一直消费<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProduceConsumerVersion3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对产品进行编号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//当前缓冲池产品的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//监视器，同步锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> Object LOCK = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">//缓冲池的大小</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">int</span> fullsize=<span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            <span class="keyword">while</span> (number==fullsize) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    LOCK.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            i++;</span><br><span class="line">            System.out.println(<span class="string">"P-&gt;"</span> + i);</span><br><span class="line">            number++;</span><br><span class="line">            LOCK.notifyAll();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            <span class="keyword">while</span> (number==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    LOCK.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"C-&gt;"</span> +( i-number+<span class="number">1</span>));</span><br><span class="line">            number--;</span><br><span class="line">            LOCK.notifyAll();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProduceConsumerVersion3 pc = <span class="keyword">new</span> ProduceConsumerVersion3();</span><br><span class="line">        Stream.of(<span class="string">"P1"</span>, <span class="string">"P2"</span>, <span class="string">"P3"</span>).forEach(n -&gt;</span><br><span class="line">                <span class="keyword">new</span> Thread(n) &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                            pc.produce();</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;.start()</span><br><span class="line">        );</span><br><span class="line">        Stream.of(<span class="string">"C1"</span>, <span class="string">"C2"</span>, <span class="string">"C3"</span>, <span class="string">"C4"</span>).forEach(n -&gt;</span><br><span class="line">                <span class="keyword">new</span> Thread(n) &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                            pc.consume();</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;.start()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="涉及到限制当前运行线程数量的实例"><a href="#涉及到限制当前运行线程数量的实例" class="headerlink" title="涉及到限制当前运行线程数量的实例"></a>涉及到限制当前运行线程数量的实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaptureService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">private</span> LinkedList&lt;Control&gt; CONTROLS = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_WORKER = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Thread&gt; worker = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.asList(<span class="string">"M1"</span>, <span class="string">"M2"</span>, <span class="string">"M3"</span>, <span class="string">"M4"</span>, <span class="string">"M5"</span>, <span class="string">"M6"</span>, <span class="string">"M7"</span>, <span class="string">"M8"</span>, <span class="string">"M9"</span>, <span class="string">"M10"</span>).stream()</span><br><span class="line">                .map(CaptureService::createCaptureThread)</span><br><span class="line">                .forEach(t -&gt; &#123;</span><br><span class="line">                    t.start();</span><br><span class="line">                    worker.add(t);</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        worker.stream().forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Optional.of(<span class="string">"All of capture work finished"</span>).ifPresent(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Thread <span class="title">createCaptureThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            Optional.of(<span class="string">"The worker ["</span> + Thread.currentThread().getName() + <span class="string">"] BEGIN capture data."</span>)</span><br><span class="line">                    .ifPresent(System.out::println);</span><br><span class="line">            <span class="keyword">synchronized</span> (CONTROLS) &#123;</span><br><span class="line">                <span class="keyword">while</span> (CONTROLS.size() &gt; MAX_WORKER) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        CONTROLS.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                CONTROLS.addLast(<span class="keyword">new</span> Control());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Optional.of(<span class="string">"The worker ["</span> + Thread.currentThread().getName() + <span class="string">"] is working..."</span>)</span><br><span class="line">                    .ifPresent(System.out::println);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (CONTROLS) &#123;</span><br><span class="line">                Optional.of(<span class="string">"The worker ["</span> + Thread.currentThread().getName() + <span class="string">"] END capture data."</span>)</span><br><span class="line">                        .ifPresent(System.out::println);</span><br><span class="line">                CONTROLS.removeFirst();</span><br><span class="line">                CONTROLS.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Control</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设计思路是用一个linkedlist来作为锁，在线程的run方法中，有两个地方需要进行锁操作，一个是开始时判定线程数量需要判断是否进行wait（如果不需要，一个元素加入linkedlist），另一个是当前线程结束需要让出运行（linkedlist删除元素，并唤醒等待的线程）</p><h2 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h2><ul><li>sleep是Thread的方法，wait是Object的方法</li><li><p>sleep不会放锁，wait会放锁<br>解释：在一个synchronized方法块中，调用sleep的话，一个进程进入该方法的sleep这部分，其他线程是进不来的，而在锁中调用wait的话，其他进程是可以进来的</p></li><li><p>sleep不需要依附于锁，但是wait需要</p></li></ul><p>举例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      m2();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              System.out.println(<span class="string">"The Thread "</span> + Thread.currentThread().getName() + <span class="string">" enter."</span>);</span><br><span class="line">              LOCK.wait();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><p>会抛异常：java.lang.IllegalMonitorStateException</p><ul><li>sleep不需要唤醒操作，但是wait需要</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java中线程间的死锁&quot;&gt;&lt;a href=&quot;#java中线程间的死锁&quot; class=&quot;headerlink&quot; title=&quot;java中线程间的死锁&quot;&gt;&lt;/a&gt;java中线程间的死锁&lt;/h1&gt;&lt;p&gt;实例：&lt;br&gt;服务1&lt;br&gt;&lt;figure class=&quot;highl
      
    
    </summary>
    
      <category term="java多线程学习" scheme="https://www.junglezero.top/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="java多线程" scheme="https://www.junglezero.top/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java多线程学习（2）</title>
    <link href="https://www.junglezero.top/2019/03/29/ava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89/"/>
    <id>https://www.junglezero.top/2019/03/29/ava多线程学习（2）/</id>
    <published>2019-03-29T01:13:00.000Z</published>
    <updated>2019-03-31T05:50:05.539Z</updated>
    
    <content type="html"><![CDATA[<h1 id="java-Thread-中涉及的函数"><a href="#java-Thread-中涉及的函数" class="headerlink" title="java Thread 中涉及的函数"></a>java Thread 中涉及的函数</h1><h2 id="Daemon相关（受保护线程）"><a href="#Daemon相关（受保护线程）" class="headerlink" title="Daemon相关（受保护线程）"></a>Daemon相关（受保护线程）</h2><p>官方文档说明：</p><blockquote><p>public final void setDaemon(boolean on)</p><p>Marks this thread as either a daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.</p><p>This method must be invoked before the thread is started.</p></blockquote><p>文档中有两个需要注意的地方</p><ul><li>当jvm中只有保护线程在运行时，jvm退出</li><li>不能在一个线程已经启动后再把其标记为受保护线程</li></ul><h3 id="两种线程的说明"><a href="#两种线程的说明" class="headerlink" title="两种线程的说明"></a>两种线程的说明</h3><ul><li><p>用户线程: 用户线程可以简单的理解为用户定义的线程,当然包括main线程</p></li><li><p>daemon线程: daemon线程是为我们创建的用户线程提供服务的线程,比如说jvm的GC等等,这样的线程有一个非常明显的特征: 当用户线程运行结束的时候,daemon线程将会自动退出，由于daemon线程的终止条件是当前是否存在用户线程,所以我们不能指派daemon线程来进行一些业务操作,而只能服务用户线程，daemon线程创建的子线程任然是daemon线程.</p></li></ul><h3 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonThread2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            Thread innerThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"Do some thing for health check."</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">100_000</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            innerThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            innerThread.start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1_000</span>);</span><br><span class="line">                System.out.println(<span class="string">"T thread finish done."</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明： 首先创建线程对象t，其次在线程内部创建线程对象innerThread，并且在启动之前将其设置为受保护线程，可以发现，innerThread中是一个死循环，而t只是一个休眠一秒的线程</p><p>运行结果：</p><p><img src="/upload/pasted-263.png" alt="upload successful"><br>这也就说明了当用户线程(t)执行完毕后，它的子受保护线程也会停止</p><h2 id="线程ID"><a href="#线程ID" class="headerlink" title="线程ID"></a>线程ID</h2><p>官方文档说明：</p><blockquote><p><strong>public long getId()</strong></p><p>Returns the identifier of this Thread. The thread ID is a positive long number generated when this thread was created. The thread ID is unique and remains unchanged during its lifetime. When a thread is terminated, this thread ID may be reused.</p><p><strong>Returns</strong>:<br>    this thread’s ID.</p></blockquote><p>几点注意：</p><ul><li>ID是一个正的long形</li><li>ID独一无二且保持不变</li></ul><p>源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextThreadID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> ++threadSeqNumber;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>可见ID在实现过程也是逐步累加</p><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>记住一点，优先级高不一定优先，优先级低不一定落后执行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                Optional.of(Thread.currentThread().getName() + <span class="string">"-Index"</span> + i).ifPresent(System.out::println);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                Optional.of(Thread.currentThread().getName() + <span class="string">"-Index"</span> + i).ifPresent(System.out::println);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t2.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line"></span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                Optional.of(Thread.currentThread().getName() + <span class="string">"-Index"</span> + i).ifPresent(System.out::println);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t3.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><p><img src="/upload/pasted-265.png" alt="upload successful"></p><h2 id="joint-方法"><a href="#joint-方法" class="headerlink" title="joint 方法"></a>joint 方法</h2><p>官方文档说明：</p><blockquote><p><strong>void     join()</strong><br>Waits for this thread to die.<br><strong>void     join(long millis)</strong><br>Waits at most millis milliseconds for this thread to die.<br><strong>void     join(long millis, int nanos)</strong><br>Waits at most millis milliseconds plus nanos nanoseconds for this thread to die.</p></blockquote><p>理解：应当是让当前线程（父线程）等待此线程（子线程，调用join的线程）结束，当前线程才执行</p><p>实例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoin</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            IntStream.range(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">                    .forEach(i -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">"-&gt;"</span> + i));</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            IntStream.range(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">                    .forEach(i -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">"-&gt;"</span> + i));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        Optional.of(<span class="string">"All of tasks finish done."</span>).ifPresent(System.out::println);</span><br><span class="line">        IntStream.range(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">                .forEach(i -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">"-&gt;"</span> + i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果：</p><p><img src="/upload/pasted-267.png" alt="upload successful"></p><p>分析：<br>t1t2两个子线程，在start之后调用join，就使得当前线程（主线程）需要等待两个线程的结束后才能执行</p><p>问题：若当前线程调用join<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().join();</span><br></pre></td></tr></table></figure></p><p>会陷入无限等待状态</p><p>用途：利用join的特性：父线程需要等待子线程结束才可执行，就可以应用到一些有明确先后顺序的线程交互中去</p><h2 id="interrupt方法"><a href="#interrupt方法" class="headerlink" title="interrupt方法"></a>interrupt方法</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><blockquote><p><strong>void     interrupt()</strong><br>Interrupts this thread.<br><strong>static boolean     interrupted()</strong><br>Tests whether the current thread has been interrupted.</p></blockquote><blockquote><p><strong>public void interrupt()</strong></p><p>Interrupts this thread.</p></blockquote><p>Unless the current thread is interrupting itself, which is always permitted, the checkAccess method of this thread is invoked, which may cause a SecurityException to be thrown.</p><blockquote></blockquote><p>If this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException.</p><blockquote></blockquote><p>If this thread is blocked in an I/O operation upon an InterruptibleChannel then the channel will be closed, the thread’s interrupt status will be set, and the thread will receive a ClosedByInterruptException.</p><blockquote></blockquote><p>If this thread is blocked in a Selector then the thread’s interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as if the selector’s wakeup method were invoked.</p><blockquote></blockquote><p>If none of the previous conditions hold then this thread’s interrupt status will be set.</p><blockquote></blockquote><p>Interrupting a thread that is not alive need not have any effect.</p><blockquote></blockquote><p><strong>Throws:</strong><br>    SecurityException - if the current thread cannot modify this thread</p><p>通过文档的介绍知道几点</p><ul><li>运行的权限问题</li><li>对于运行了sleep，wait，join(让父线程进入堵塞状态)等陷入堵塞状态的方法，若调用interrupt，会把当前的“中断标记”清除，然后抛出InterruptedException.</li><li>对于io堵塞的线程，调用interrupt方法会将“中断标记”设为true，并且抛出ClosedByInterruptException</li><li>如果不是处于堵塞状态，调用interrupt会将“中断标记”设为true</li></ul><h3 id="终止某个线程"><a href="#终止某个线程" class="headerlink" title="终止某个线程"></a>终止某个线程</h3><h4 id="设置一个标志位"><a href="#设置一个标志位" class="headerlink" title="设置一个标志位"></a>设置一个标志位</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">ThreadClose</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置的标志位</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> start = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//在run中循环</span></span><br><span class="line">            <span class="keyword">while</span> (start) &#123;</span><br><span class="line">                <span class="comment">//业务逻辑</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line">        worker.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        worker.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用interrupt"><a href="#使用interrupt" class="headerlink" title="使用interrupt"></a>使用interrupt</h4><ul><li>用isInterrupt()进行判断</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadCloseGraceful2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!isInterrupted())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//业务逻辑</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//模拟线程因为wait，sleep，join而陷入休眠</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            System.out.println(<span class="string">"输出结果"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line">        worker.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        worker.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里存在一个问题，当把sleep移出while循环后，在进行interrupt，首先会抛异常，但是while循环不会终止，因为根据官方文档说明的，遇见这种堵塞状态，“终止标记”会被消除（重置为false），因此循环不会退出</p><h4 id="利用deamon线程的特性"><a href="#利用deamon线程的特性" class="headerlink" title="利用deamon线程的特性"></a>利用deamon线程的特性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Thread executeThread;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> finished = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        executeThread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//在执行线程中设置一个守护线程</span></span><br><span class="line">                Thread runner = <span class="keyword">new</span> Thread(task);</span><br><span class="line">                runner.setDaemon(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                runner.start();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    runner.join();</span><br><span class="line">                    <span class="comment">//当子线程（runner，守护线程执行完毕后）。将结束标记设置为true</span></span><br><span class="line">                    finished = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">//e.printStackTrace();</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        executeThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">long</span> mills)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span> (!finished) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((System.currentTimeMillis() - currentTime) &gt;= mills) &#123;</span><br><span class="line">                System.out.println(<span class="string">"任务超时，需要结束他!"</span>);</span><br><span class="line">                <span class="comment">//关闭执行线程，则守护线程的子线程就一定关闭了</span></span><br><span class="line">                executeThread.interrupt();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                executeThread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"执行线程被打断!"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        finished = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>在java中，每一个对象有且仅有一个同步锁。这也意味着，同步锁是依赖于对象而存在。<br>当我们调用某对象的synchronized方法时，就获取了该对象的同步锁。例如，synchronized(obj)就获取了“obj这个对象”的同步锁。<br>不同线程对同步锁的访问是互斥的。也就是说，某时间点，对象的同步锁只能被一个线程获取到！通过同步锁，我们就能在多线程中，实现对“对象/方法”的互斥访问。 例如，现在有两个线程A和线程B，它们都会访问“对象obj的同步锁”。假设，在某一时刻，线程A获取到“obj的同步锁”并在执行一些操作；而此时，线程B也企图获取“obj的同步锁” —— 线程B会获取失败，它必须等待，直到线程A释放了“该对象的同步锁”之后线程B才能获取到“obj的同步锁”从而才可以运行。<br>应当注意：同步锁应当尽量作用在数据出现线程不安全的地方，如果把它作用在run方法，实际上一个多线程的实现就会变成一个单线程</p><h3 id="几种使用方式"><a href="#几种使用方式" class="headerlink" title="几种使用方式"></a>几种使用方式</h3><ol><li><p>锁“this”对象的某部分代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//readonly shared data.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//this</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticket())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">ticket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &gt; MAX)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">" 的号码是:"</span> + (index++));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>锁一个obj对象</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//readonly shared data.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX = <span class="number">500</span>;</span><br><span class="line">    <span class="comment">//添加一个obj对象</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">final</span>  <span class="keyword">static</span>  Object OBJ=<span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//this</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticket())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">ticket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对obj进行上锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (OBJ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &gt; MAX)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">" 的号码是:"</span> + (index++));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  以上两种方式效果是一样的，都能够达成同步锁的要求</p><ol start="3"><li>对某个方法上锁<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//readonly shared data.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//this</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticket())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将其改为synchronized方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">ticket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (index &gt; MAX)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">" 的号码是:"</span> + (index++));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="同步锁的使用"><a href="#同步锁的使用" class="headerlink" title="同步锁的使用"></a>同步锁的使用</h3><ul><li>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。</li><li>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。</li><li>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。</li></ul><h4 id="演示1："><a href="#演示1：" class="headerlink" title="演示1："></a>演示1：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>); <span class="comment">// 休眠100ms</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" loop "</span> + i);  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Runnable demo = <span class="keyword">new</span> MyRunable();     <span class="comment">// 新建“Runnable对象”</span></span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(demo, <span class="string">"t1"</span>);  <span class="comment">// 新建“线程t1”, t1是基于demo这个Runnable对象</span></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(demo, <span class="string">"t2"</span>);  <span class="comment">// 新建“线程t2”, t2是基于demo这个Runnable对象</span></span><br><span class="line">        t1.start();                          <span class="comment">// 启动“线程t1”</span></span><br><span class="line">        t2.start();                          <span class="comment">// 启动“线程t2” </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">t1 loop 0</span><br><span class="line">t1 loop 1</span><br><span class="line">t1 loop 2</span><br><span class="line">t1 loop 3</span><br><span class="line">t1 loop 4</span><br><span class="line">t2 loop 0</span><br><span class="line">t2 loop 1</span><br><span class="line">t2 loop 2</span><br><span class="line">t2 loop 3</span><br><span class="line">t2 loop 4</span><br></pre></td></tr></table></figure></p><p>分析：<br>在run方法中设置了针对Runable对象的“同步锁”，一旦t1开始执行run方法，t2若要执行，就会进入阻塞状态，需要等到t1执行完毕才会执行</p><h4 id="演示2"><a href="#演示2" class="headerlink" title="演示2"></a>演示2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 含有synchronized同步块的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>); <span class="comment">// 休眠100ms</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" synMethod loop "</span> + i);  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非同步的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonSynMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" nonSynMethod loop "</span> + i);  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">final</span> Count count = <span class="keyword">new</span> Count();</span><br><span class="line">        <span class="comment">// 新建t1, t1会调用“count对象”的synMethod()方法</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(</span><br><span class="line">                <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        count.synMethod();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="string">"t1"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建t2, t2会调用“count对象”的nonSynMethod()方法</span></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(</span><br><span class="line">                <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        count.nonSynMethod();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="string">"t2"</span>);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        t1.start();  <span class="comment">// 启动t1</span></span><br><span class="line">        t2.start();  <span class="comment">// 启动t2</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">t1 synMethod loop 0</span><br><span class="line">t2 nonSynMethod loop 0</span><br><span class="line">t1 synMethod loop 1</span><br><span class="line">t2 nonSynMethod loop 1</span><br><span class="line">t1 synMethod loop 2</span><br><span class="line">t2 nonSynMethod loop 2</span><br><span class="line">t1 synMethod loop 3</span><br><span class="line">t2 nonSynMethod loop 3</span><br><span class="line">t1 synMethod loop 4</span><br><span class="line">t2 nonSynMethod loop 4</span><br></pre></td></tr></table></figure></p><p>结果分析：<br>主线程中新建了两个子线程t1和t2。t1会调用count对象的synMethod()方法，该方法内含有同步块；而t2则会调用count对象的nonSynMethod()方法，该方法不是同步方法。t1运行时，虽然调用synchronized(this)获取“count的同步锁”；但是并没有造成t2的阻塞，因为t2没有用到“count”同步锁。</p><h4 id="演示3"><a href="#演示3" class="headerlink" title="演示3"></a>演示3</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 含有synchronized同步块的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>); <span class="comment">// 休眠100ms</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" synMethod loop "</span> + i);  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也包含synchronized同步块的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonSynMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" nonSynMethod loop "</span> + i);  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">final</span> Count count = <span class="keyword">new</span> Count();</span><br><span class="line">        <span class="comment">// 新建t1, t1会调用“count对象”的synMethod()方法</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(</span><br><span class="line">                <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        count.synMethod();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="string">"t1"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建t2, t2会调用“count对象”的nonSynMethod()方法</span></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(</span><br><span class="line">                <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        count.nonSynMethod();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="string">"t2"</span>);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        t1.start();  <span class="comment">// 启动t1</span></span><br><span class="line">        t2.start();  <span class="comment">// 启动t2</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">t1 synMethod loop 0</span><br><span class="line">t1 synMethod loop 1</span><br><span class="line">t1 synMethod loop 2</span><br><span class="line">t1 synMethod loop 3</span><br><span class="line">t1 synMethod loop 4</span><br><span class="line">t2 nonSynMethod loop 0</span><br><span class="line">t2 nonSynMethod loop 1</span><br><span class="line">t2 nonSynMethod loop 2</span><br><span class="line">t2 nonSynMethod loop 3</span><br><span class="line">t2 nonSynMethod loop 4</span><br></pre></td></tr></table></figure></p><p>分析：<br>主线程中新建了两个子线程t1和t2。t1和t2运行时都调用synchronized(this)，这个this是Count对象(count)，而t1和t2共用count。因此，在t1运行时，t2会被阻塞，等待t1运行释放“count对象的同步锁”，t2才能运行。</p><h4 id="一个特例：static方法的锁"><a href="#一个特例：static方法的锁" class="headerlink" title="一个特例：static方法的锁"></a>一个特例：static方法的锁</h4><p>众所周知，static方法是基于一个类使用的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SychronizedStatic</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态且上锁方法m1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"进入加锁static方法的是 "</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1_000L</span>);</span><br><span class="line">                System.out.println(<span class="string">"静态方法m1暂停一秒"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上锁方法m2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"m2 "</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10_000L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SychronizedStaticTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"T1"</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                SychronizedStatic s1=<span class="keyword">new</span> SychronizedStatic();</span><br><span class="line">                s1.m1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"T2"</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                SychronizedStatic s2=<span class="keyword">new</span> SychronizedStatic();</span><br><span class="line">                s2.m1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"T3"</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                SychronizedStatic s3=<span class="keyword">new</span> SychronizedStatic();</span><br><span class="line">                s3.m2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>进入加锁static方法的是 T1<br>m2 T3<br>静态方法m1暂停一秒<br>静态方法m1暂停一秒<br>静态方法m1暂停一秒<br>静态方法m1暂停一秒<br>静态方法m1暂停一秒<br>进入加锁static方法的是 T2<br>静态方法m1暂停一秒<br>静态方法m1暂停一秒<br>静态方法m1暂停一秒<br>静态方法m1暂停一秒<br>静态方法m1暂停一秒</p></blockquote><p>结果分析：<br>t1,t2和t3的比较说明，对于t1,t2来说，他们的方法锁的是“类”（SychronizedStatic.class），而t3的方法锁的是实例“s3”;因此并没有锁在一起可以同时运行；对于t1,t2，虽然调用m1时，用的是不同的实例，但是m1是static方法，且锁的是“类”,故T1调用时，t2会发生堵塞</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;java-Thread-中涉及的函数&quot;&gt;&lt;a href=&quot;#java-Thread-中涉及的函数&quot; class=&quot;headerlink&quot; title=&quot;java Thread 中涉及的函数&quot;&gt;&lt;/a&gt;java Thread 中涉及的函数&lt;/h1&gt;&lt;h2 id=&quot;D
      
    
    </summary>
    
      <category term="java多线程学习笔记" scheme="https://www.junglezero.top/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java多线程" scheme="https://www.junglezero.top/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>java多线程学习（1）</title>
    <link href="https://www.junglezero.top/2019/03/27/va%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89/"/>
    <id>https://www.junglezero.top/2019/03/27/va多线程学习（1）/</id>
    <published>2019-03-27T10:42:00.000Z</published>
    <updated>2019-03-31T13:09:48.155Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线程相关概念复习（操作系统）"><a href="#线程相关概念复习（操作系统）" class="headerlink" title="线程相关概念复习（操作系统）"></a>线程相关概念复习（操作系统）</h1><h2 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h2><p>并行：两个或多个事件，在同一时刻发生<br>并发：两个或者多个事件在同一时间间隔发生<br>比如在一个单处理机系统中，每一时刻只能有一个程序运行，在一秒的时间内，0~15ms运行A,15~30ms运行B.30~45ms运行C,45~60ms运行D，就可以说ABCD是并发的</p><h2 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h2><p>为了多个程序能并发执行，以提高资源利用率和系统吞吐量，操作系统引入了进程的概念<br>进程，是指系统中能独立运行并作为资源分配的基本单位，是由一组机器指令，数据和堆栈组成，是一个能独立运行的实体</p><h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><p><img src="/upload/pasted-259.png" alt="upload successful"></p><h2 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h2><p>为了减少程序在并发执行时所付出的时空开销，使os具有更好的并发性，引入了线程的概念<br>在引入线程的os中，已经把线程作为调度和分派的基本单位，因而线程是能独立运行的基本单位；不仅进程可以并发执行，一个进程中的多个线程也可以并发执行，不同进程中的线程也能并发执行，线程并不拥有系统资源，而是仅维持一点自身必须的资源</p><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p><img src="/upload/pasted-260.png" alt="upload successful"></p><ol><li><strong>新建状态(New)</strong>         : 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。</li><li><strong>就绪状态(Runnable)</strong>: 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。</li><li><strong>运行状态(Running)</strong> : 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。</li><li><strong>阻塞状态(Blocked)</strong>  : 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：<ul><li>等待阻塞 – 通过调用线程的wait()方法，让线程等待某工作的完成。</li><li>同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。</li><li>其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</li></ul></li><li><strong>死亡状态(Dead)</strong>    : 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</li></ol><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><img src="/upload/pasted-268.png" alt="upload successful"><br>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程</p><h1 id="java线程"><a href="#java线程" class="headerlink" title="java线程"></a>java线程</h1><h2 id="简单认识java线程"><a href="#简单认识java线程" class="headerlink" title="简单认识java线程"></a>简单认识java线程</h2><p>java官方文档中，一段对于Thread api的描述</p><blockquote><p>A thread is a thread of execution in a program. The Java Virtual Machine allows an application to have multiple threads of execution running concurrently.</p><p>Every thread has a priority. Threads with higher priority are executed in preference to threads with lower priority. Each thread may or may not also be marked as a daemon. When code running in some thread creates a new Thread object, the new thread has its priority initially set equal to the priority of the creating thread, and is a daemon thread if and only if the creating thread is a daemon.</p><p>When a Java Virtual Machine starts up, there is usually a single non-daemon thread (which typically calls the method named main of some designated class). </p></blockquote><p>从上面的概念中可以知道，java支持多线程，且线程有优先级的概念，以及受保护线程和main线程的概念<br>一段简单的入门程序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryConcurrency</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t=<span class="keyword">new</span> Thread(<span class="string">"READ-Thread"</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                println(Thread.currentThread().getName());<span class="comment">//main</span></span><br><span class="line">                readFromDataBase();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">     <span class="comment">//内部匿名类</span></span><br><span class="line">     <span class="keyword">new</span> Thread(<span class="string">"WRITE-Thread"</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                writeDataToFile();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFromDataBase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//read data from database and handle it.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            println(<span class="string">"Begin read data from db."</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span> * <span class="number">30L</span>);</span><br><span class="line">            println(<span class="string">"Read data done and start handle it."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"The data handle finish and successfully."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeDataToFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            println(<span class="string">"Begin write data to file."</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span> * <span class="number">20L</span>);</span><br><span class="line">            println(<span class="string">"Write data done and start handle it."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"The data handle finish and successfully."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从这个例子中，可以学习几点</p><ul><li>java可以通过继承Thread并重写run方法来支持线程的运行</li><li>创建线程对象后，需要运行（start()）才能使线程跑起来</li></ul><h2 id="start-方法"><a href="#start-方法" class="headerlink" title="start()方法"></a>start()方法</h2><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>来自官方文档的说明</p><blockquote><p>Causes this thread to begin execution; the Java Virtual Machine calls the run method of this thread.</p><p>The result is that two threads are running concurrently: the current thread (which returns from the call to the start method) and the other thread (which executes its run method).</p><p>It is never legal to start a thread more than once. In particular, a thread may not be restarted once it has completed execution.</p></blockquote><p>从这段说明中，可以获得以下信息</p><ul><li>start()方法的作用是使当前线程开始执行，此时jvm会调用该线程下的run()方法</li><li>执行之后，会有两个线程进入并发的执行状态：调用start()方法的线程（当前线程），执行下属run()方法的线程（新线程）</li><li>一个线程要是start（）两次是会抛异常的</li></ul><p>关于当前线程和新线程的问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t=<span class="keyword">new</span> Thread(<span class="string">"READ-Thread"</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//获取当前线程的名字</span></span><br><span class="line">                println(Thread.currentThread().getName());</span><br><span class="line">                readFromDataBase();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        t.start();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>这个结果输出的是“READ-Thread”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t=<span class="keyword">new</span> Thread(<span class="string">"READ-Thread"</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//获取当前线程的名字</span></span><br><span class="line">                println(Thread.currentThread().getName());</span><br><span class="line">                readFromDataBase();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//与上一个例子的不同之处</span></span><br><span class="line">        t.run();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个输出的是main</p><p>由此可以得出结论：创建一个新线程后，只有执行start()方法，才算是执行了这个新线程</p><h3 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * This method is not invoked for the main method thread or "system"</span></span><br><span class="line"><span class="comment">         * group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment">         * to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * A zero status value corresponds to state "NEW".</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">         * so that it can be added to the group's list of threads</span></span><br><span class="line"><span class="comment">         * and the group's unstarted count can be decremented. */</span></span><br><span class="line">        group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            start0();</span><br><span class="line">            started = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                    group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">                <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">                  it will be passed up the call stack */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If this thread was constructed using a separate</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;Runnable&lt;/code&gt; run object, then that</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;Runnable&lt;/code&gt; object's &lt;code&gt;run&lt;/code&gt; method is called;</span></span><br><span class="line"><span class="comment">     * otherwise, this method does nothing and returns.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Subclasses of &lt;code&gt;Thread&lt;/code&gt; should override this method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     #start()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     #stop()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     #Thread(ThreadGroup, Runnable, String)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从源码可以看出，start()方法内部首先验证当前调用的线程是否已经执行，如果已经执行，则抛出异常，然后就去执行本地方法start0()，在start0()中，会调用run()方法</p><h3 id="启发"><a href="#启发" class="headerlink" title="启发"></a>启发</h3><p>对于start()和run()方法的这种设计，我们学习到一种“模板”的思想，即start()方法实际上就是已经定好的模板，而对于我们自己使用的情况下，我们覆盖run()方法实现自己的业务逻辑</p><h2 id="java线程实现的两种方式"><a href="#java线程实现的两种方式" class="headerlink" title="java线程实现的两种方式"></a>java线程实现的两种方式</h2><p>众所周知的两种方式：<br>实现Runable 接口<br>继承Thread 类</p><p>下面模拟一个银行叫号系统进行说明</p><h3 id="继承Thread"><a href="#继承Thread" class="headerlink" title="继承Thread"></a>继承Thread</h3><p>首先写一个窗口的线程实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketWindow</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TicketWindow</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (index &lt;= MAX) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"柜台："</span> + name + <span class="string">"当前的号码是:"</span> + (index++));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>主函数，在主函数中，开辟三个线程进行叫号的模拟<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        TicketWindow ticketWindow1 = <span class="keyword">new</span> TicketWindow(<span class="string">"一号柜台"</span>);</span><br><span class="line">        ticketWindow1.start();</span><br><span class="line"></span><br><span class="line">        TicketWindow ticketWindow2 = <span class="keyword">new</span> TicketWindow(<span class="string">"二号柜台"</span>);</span><br><span class="line">        ticketWindow2.start();</span><br><span class="line"></span><br><span class="line">        TicketWindow ticketWindow3 = <span class="keyword">new</span> TicketWindow(<span class="string">"三号柜台"</span>);</span><br><span class="line">        ticketWindow3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：</p><p><img src="/upload/pasted-261.png" alt="upload successful"></p><p>一些思考 </p><ol><li><p>多个线程共享一个变量、<br>从这里可以看出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> index = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>关键是在static关键字上，使用static关键字定义的变量。static可以修饰变量和方法，也有static静态代码块。被static修饰的成员变量和成员方法独立于该类的任何对象。也就是说，它<strong>不依赖类特定的实例</strong>，被类的所有实例共享。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它的类的对象时，不生成static变量的副本，而是类的所有实例共享同一个static变量。<br>假设没有static，那么作为一个普通的成员变量，伴随着每次新的实例的产生，会在堆上分配空间，即此时这个变量是和对象实例绑定的</p></li><li><p>输出是乱序的</p></li><li><p>用static设置静态变量有一个问题，该变量会伴随着jvm的整个过程，生命周期过长</p></li></ol><h3 id="实现Runable接口"><a href="#实现Runable接口" class="headerlink" title="实现Runable接口"></a>实现Runable接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketWindowRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (index &lt;= MAX) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">" 的号码是:"</span> + (index++));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankVersion2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只需一个业务实例对象</span></span><br><span class="line">    <span class="keyword">final</span> TicketWindowRunnable ticketWindow = <span class="keyword">new</span> TicketWindowRunnable();</span><br><span class="line"></span><br><span class="line">        Thread windowThread1 = <span class="keyword">new</span> Thread(ticketWindow, <span class="string">"一号窗口"</span>);</span><br><span class="line">        Thread windowThread2 = <span class="keyword">new</span> Thread(ticketWindow, <span class="string">"二号窗口"</span>);</span><br><span class="line">        Thread windowThread3 = <span class="keyword">new</span> Thread(ticketWindow, <span class="string">"三号窗口"</span>);</span><br><span class="line">        windowThread1.start();</span><br><span class="line">        windowThread2.start();</span><br><span class="line">        windowThread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果</p><p><img src="/upload/pasted-262.png" alt="upload successful"></p><p>利用这种实现方式，可以将线程的逻辑执行单元从控制中抽离出来（应用了策略模式）<br>然而这里存在一个线程安全的问题</p><h2 id="Thread的构造方法"><a href="#Thread的构造方法" class="headerlink" title="Thread的构造方法"></a>Thread的构造方法</h2><h3 id="Thread构造方法及其重载方法的参数"><a href="#Thread构造方法及其重载方法的参数" class="headerlink" title="Thread构造方法及其重载方法的参数"></a>Thread构造方法及其重载方法的参数</h3><p>源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allocates a new &#123;<span class="doctag">@code</span> Thread&#125; object. This constructor has the same</span></span><br><span class="line"><span class="comment"> * effect as &#123;<span class="doctag">@linkplain</span> #Thread(ThreadGroup,Runnable,String) Thread&#125;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> (null, null, gname)&#125;, where &#123;<span class="doctag">@code</span> gname&#125; is a newly generated</span></span><br><span class="line"><span class="comment"> * name. Automatically generated names are of the form</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> "Thread-"+&#125;&lt;i&gt;n&lt;/i&gt;, where &lt;i&gt;n&lt;/i&gt; is an integer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* For autonumbering anonymous threads. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> threadInitNumber;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">nextThreadNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> threadInitNumber++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes a Thread with the current AccessControlContext.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #init(ThreadGroup,Runnable,String,long,AccessControlContext,boolean)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">long</span> stackSize)</span> </span>&#123;</span><br><span class="line">    init(g, target, name, stackSize, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes a Thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> g the Thread group</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target the object whose run() method gets called</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name the name of the new Thread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> stackSize the desired stack size for the new thread, or</span></span><br><span class="line"><span class="comment"> *        zero to indicate that this parameter is to be ignored.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> acc the AccessControlContext to inherit, or</span></span><br><span class="line"><span class="comment"> *            AccessController.getContext() if null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inheritThreadLocals if &#123;<span class="doctag">@code</span> true&#125;, inherit initial values for</span></span><br><span class="line"><span class="comment"> *            inheritable thread-locals from the constructing thread</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    Thread parent = currentThread();</span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">/* Determine if it's an applet or not */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If there is a security manager, ask the security manager</span></span><br><span class="line"><span class="comment">           what to do. */</span></span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = security.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the security doesn't have a strong opinion of the matter</span></span><br><span class="line"><span class="comment">           use the parent thread group. */</span></span><br><span class="line">        <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = parent.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* checkAccess regardless of whether or not threadgroup is</span></span><br><span class="line"><span class="comment">       explicitly passed in. */</span></span><br><span class="line">    g.checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Do we have the required permissions?</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g.addUnstarted();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.group = g;</span><br><span class="line">    <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">    <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">    <span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">    <span class="keyword">this</span>.inheritedAccessControlContext =</span><br><span class="line">            acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    setPriority(priority);</span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    <span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line">    <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set thread ID */</span></span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可传递的参数：</p><ul><li>name：线程名称，若没有传递参数，关于线程对象自动生成名称，以Thread-开头，从0 开始计数（静态变量threadInitNumber）</li><li>Runable实例：可以参照上面的实现部分理解（如果在构造Thread时没有传递Runable或者没有重写run方法。该Thread将不会执行任何东西（一个Thread若没传入Runable参数，则会设置为null），如果传递了Runable实例（如上面的例子所示）或者重写了run方法，则执行对应的新逻辑单元）</li><li><p>线程组 ThreadGroup(通过看源码可以得出，若传入ThreadGroup为空，就会为新键进程附上parent的线程组，而parent指的就是“当前线程”,当前进程和新线程的理解，另外，可以通过线程组获取当前的线程运行数量）</p></li><li><p>int stacksize：即为线程开辟的 虚拟机栈（JVM概念） 的大小（构造Thread时传入的该值定义着虚拟机栈的大小，如果未指定，则默认为0，0表示会忽略该参数，由jvm自己去设定）（假设调用的是一个没有结束的递归函数，则会不断在虚拟机栈中压入栈帧，最终导致stackoverflow）</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;线程相关概念复习（操作系统）&quot;&gt;&lt;a href=&quot;#线程相关概念复习（操作系统）&quot; class=&quot;headerlink&quot; title=&quot;线程相关概念复习（操作系统）&quot;&gt;&lt;/a&gt;线程相关概念复习（操作系统）&lt;/h1&gt;&lt;h2 id=&quot;并发和并行的区别&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="Java多线程学习笔记" scheme="https://www.junglezero.top/categories/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="java多线程" scheme="https://www.junglezero.top/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>jvm学习（类的加载机制）</title>
    <link href="https://www.junglezero.top/2019/03/26/m%E5%AD%A6%E4%B9%A0%EF%BC%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%89/"/>
    <id>https://www.junglezero.top/2019/03/26/m学习（类的加载机制）/</id>
    <published>2019-03-26T05:32:00.000Z</published>
    <updated>2019-03-27T04:00:18.819Z</updated>
    
    <content type="html"><![CDATA[<h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><h2 id="一般概念"><a href="#一般概念" class="headerlink" title="一般概念"></a>一般概念</h2><p>虚拟机把描述类的数据从文件加载到内存，并对数据进行解析，校验和初始化，最终形成可以被虚拟机使用的java类型，这就是虚拟机类的加载的一般过程</p><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p><img src="/upload/pasted-253.png" alt="upload successful"></p><h3 id="加载（Loading）"><a href="#加载（Loading）" class="headerlink" title="加载（Loading）"></a>加载（Loading）</h3><p>类加载阶段就是由类加载器负责根据一个类的全限定名来读取此类的二进制字节流到JVM内部，并存储在运行时内存区的方法区，然后将其转换为一个与目标类型对应的java.lang.Class对象实例,这个Class对象在日后就会作为方法区中该类的各种数据的访问入口。<br>加载的方式非常广泛，只要有满足二进制字节流，都可以执行类加载</p><p>多种加载源：</p><ul><li>文件<ul><li>class文件</li><li>jar文件</li></ul></li><li>网络传输</li><li>计算生成一个二进制流  <ul><li>$proxy</li></ul></li><li>数据库</li></ul><p><img src="/upload/pasted-254.png" alt="upload successful"></p><h3 id="连接（Linking）"><a href="#连接（Linking）" class="headerlink" title="连接（Linking）"></a>连接（Linking）</h3><p>1.验证过程<br>这一阶段的目的是确保.class文文件的字节流中包含的信息符合虚拟机规范且不会影响虚拟机的自身安全<br><img src="/upload/pasted-255.png" alt="upload successful"></p><p>2.准备过程<br>为类中的所有静态变量(static)分配内存空间，并为其设置一个初始值（默认值）（由于还没有产生对象，实例变量不在此操作范围内）<br>被final修饰的静态变量，会直接赋予原值；类字段的字段属性表中存在ConstantValue属性，则在准备阶段，其值就是ConstantValue的值</p><p>3.解析过程<br>解析过程是虚拟机将常量池内的符号引用替换为直接引用的过程</p><ul><li><p>符号引用（Symbolic References）：<br>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。例如，在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现。符号引用与虚拟机的内存布局无关，引用的目标并不一定加载到内存中。在Java中，一个java类将会编译成一个class文件。在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language（假设是这个，当然实际中是由类似于CONSTANT_Class_info的常量来表示的）来表示Language类的地址。各种虚拟机实现的内存布局可能有所不同，但是它们能接受的符号引用都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。</p></li><li><p>直接引用：<br>直接引用可以是<br>（1）直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）<br>（2）相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）<br>（3）一个能间接定位到目标的句柄<br>直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了。</p></li><li><p>解析内容</p><ul><li>类和接口的解析</li><li>字段的解析</li><li>类方法的解析</li><li>接口方法的解析</li></ul></li></ul><h3 id="初始化（Initialzation）"><a href="#初始化（Initialzation）" class="headerlink" title="初始化（Initialzation）"></a>初始化（Initialzation）</h3><p>即执行类构造器”clinit”()方法的过程。类加载过程最后一步，前面的过程完全由虚拟机主导和控制（除了通过自定义加载器参与外），初始化阶段才真正开始执行类中定义的Java代码（或者说是字节码）</p><h4 id="类构造器”clinit”-方法"><a href="#类构造器”clinit”-方法" class="headerlink" title="类构造器”clinit”()方法"></a>类构造器”clinit”()方法</h4><ul><li>“clinit”()方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块（Static｛｝块）中的的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在静态语句块可以赋值，但是不能访问。</li></ul><p>例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span>&#123;</span><br><span class="line">     i=<span class="number">0</span>;</span><br><span class="line">     System.out.println(i); </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个例子中，“i=0”处不会报错，而输出语句地方会报错</p><ul><li>“clinit”()方法对于类和接口不是必需的，如果没有static修饰的方法、代码块、变量。编译器可以不为其生成”clinit”方法</li><li>无需显式的调用父类构造器，虚拟机会保证在子类”clinit”()方法执行前，父类的”clinit”方法已经执行完， 虚拟机中第一个执行”clinit”()方法的肯定是java.lang.Object，父类中定义的静态语句块先于子类的变量赋值操作<br>例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Partent</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        a=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> b=a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        System.out.println(Sub.b);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>输出结果为2</p><ul><li>如果多个线程同时初始化一个类，只有一个线程执行这个类的“cinit”方法，其他线程需要等待其执行完毕，如果方法执行时间过长，就会造成线程堵塞</li></ul><p>例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span>  <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"init"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        ExecutorService threadPool= Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"start。。。。。。"</span>);</span><br><span class="line">                    Hello h=<span class="keyword">new</span> Hello();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"end。。。。。。"</span>);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行以后，会发现会输出“start。。。。。。”,当一个完成“init”后，才会进行初始化</p><h4 id="初始化的条件"><a href="#初始化的条件" class="headerlink" title="初始化的条件"></a>初始化的条件</h4><ul><li>在执行下列需要引用类或接口的 Java 虚拟机指令时： new， getstatic， putstatic或 invokestatic。这些指令通过字段或方法引用来直接或间接地引用其它类。执行上面所述的 new 指令，在类或接口没有被初始化过时就初始化它。执行上面的 getstatic，putstatic 或 invokestatic 指令时，那些解析好的字段或方法中的类或接口如果还没有被初始化那就初始化它。</li><li><p>在初次调用 java.lang.invoke.MethodHandle 实例时，它的执行结果为通过 Java虚拟机解析出类型是 2（REF_getStatic）、 4（REF_putStatic）或者 6（REF_invokeStatic）的方法句柄。</p></li><li><p>在调用 JDK 核心类库中的反射方法时，例如， Class 类或 java.lang.reflect 包。</p></li><li>在对于类的某个子类的初始化时。</li><li>在它被选定为 Java 虚拟机启动时的初始类时<h4 id="不初始化的几个例子"><a href="#不初始化的几个例子" class="headerlink" title="不初始化的几个例子"></a>不初始化的几个例子</h4></li><li>通过子类引用父类的静态字段</li><li>通过数组定义来引用类</li><li>调用类的常量</li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>根据一个类的全限定名来读取此类二进制字节流到jvm内部，然后转换为一个与目标类对应的java.lang.Class对象实例.<br>Java 虚拟机支持两种类加载器： Java 虚拟机提供的引导类加载器（Bootstrap Class Loader）和用户自定义类加载器（User-Defined Class Loader）。每个用户自定义的类加载器应该是抽象类 ClassLoader 的某个子类的实例。应用程序使用用户自定义类加载器是为了便于扩展 Java 虚拟机的功能，支持动态加载并创建类。当然，它也可以从用户自定义的数据来源来获取类的二进制表示并创建类。例如，用户自定义类加载器可以通过网络下载、动态产生或是从一个加密文件中提取类的信息</p><ul><li><p>启动类加载器（Bootstrap ClassLoader）：由C++语言实现（针对HotSpot）,负责将存放在&lt;JAVA_HOME&gt;\lib目录或-Xbootclasspath参数指定的路径中的类库加载到内存中。</p></li><li><p>其他类加载器：由Java语言实现，继承自抽象类ClassLoader。<br>如：<br>扩展类加载器（Extension ClassLoader）：负责加载&lt;JAVA_HOME&gt;\lib\ext目录或java.ext.dirs系统变量指定的路径中的所有类库。<br>应用程序类加载器（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</p></li></ul><p>一个自定义类的加载器的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        ClassLoader mycl=<span class="keyword">new</span> ClassLoader() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                <span class="comment">//获取类的简单名称</span></span><br><span class="line">                String className=name.substring(name.lastIndexOf(<span class="string">"."</span>)+<span class="number">1</span>)+<span class="string">".class"</span>;</span><br><span class="line">                <span class="comment">//获取类的流</span></span><br><span class="line">                InputStream ins=getClass().getResourceAsStream(className);</span><br><span class="line">                <span class="keyword">if</span>(ins==<span class="keyword">null</span>)&#123;<span class="comment">//如果当前包下没有，则由父类进行加载</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] buff=<span class="keyword">new</span> <span class="keyword">byte</span>[ins.available()];</span><br><span class="line">                    ins.read();</span><br><span class="line">                    <span class="comment">//实例化与当前类对应的class对象</span></span><br><span class="line">                    <span class="keyword">return</span> defineClass(name,buff,<span class="number">0</span>,buff.length);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                   <span class="keyword">throw</span>  <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p><img src="/upload/pasted-257.png" alt="upload successful"></p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。</p><p>双亲委派模型的工作过程是：</p><ul><li><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成。</p></li><li><p>每一个层次的类加载器都是如此。因此，所有的加载请求最终都应该传送到顶层的启动类加载器中。</p></li><li><p>只有当父加载器反馈自己无法完成这个加载请求时（搜索范围中没有找到所需的类），子加载器才会尝试自己去加载。</p></li></ul><h4 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h4><p>在JVM中，判断一个对象是否是某个类型时，如果该对象的实际类型与待比较的类型的类加载器不同，那么会返回false。<br>比如<br>  ClassLoader1、ClassLoader2都加载java.lang.String类，对应Class1、Class2对象。那么Class1对象不属于ClassLoad2对象加载的java.lang.String类型。</p><p><strong>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在虚拟机中的唯一性</strong>，每一个类加载器，都拥有一个独立的类名称空间。因此，使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处：类随着它的类加载器一起具备了一种带有优先级的层次关系。</p><p>例如类java.lang.Object，它由启动类加载器加载。双亲委派模型保证任何类加载器收到的对java.lang.Object的加载请求，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。</p><p>相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并用自定义的类加载器加载，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。</p><h4 id="自定义类加载器的完整-实现"><a href="#自定义类加载器的完整-实现" class="headerlink" title="自定义类加载器的完整 实现"></a>自定义类加载器的完整 实现</h4><p>关于自定义类加载器的几个函数</p><p>1.loadClass()<br>默认实现:<br>根据全限定名创建该类的class对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>loadClass(String name, boolean resolve)<br>基本过程</p><ul><li>1.首先，检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载，直接返回。</li><li><p>2.如果此类没有加载过，那么，再判断一下是否有父加载器；如果有父加载器，则由父加载器加载（即调用parent.loadClass(name, false);）.或者是调用bootstrap类加载器来加载。</p></li><li><p>3.如果父加载器及bootstrap类加载器都没有找到指定的类，那么调用当前类加载器的findClass方法来完成类加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>2 findClass()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，抽象类ClassLoader的findClass函数默认是抛出异常的。而前面我们知道，loadClass在父加载器无法加载类的时候，就会调用我们自定义的类加载器中的findeClass函数，因此我们必须要在loadClass这个函数里面实现将一个指定类名称转换为Class对象.</p><p>如果是是读取一个指定的名称的类为字节数组的话，这很好办。但是如何将字节数组转为Class对象呢？很简单，Java提供了defineClass方法，通过这个方法，就可以把一个字节数组转为Class对象</p><p>3 defineClass()<br>将一个字节数组转为Class对象，这个字节数组是class文件读取后最终的字节数组。如，假设class文件是加密过的，则需要解密后作为形参传入defineClass函数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span><br><span class="line">        <span class="keyword">throws</span> ClassFormatError  &#123;</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, b, off, len, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>完整函数调用过程</p><p><img src="/upload/pasted-258.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;类加载机制&quot;&gt;&lt;a href=&quot;#类加载机制&quot; class=&quot;headerlink&quot; title=&quot;类加载机制&quot;&gt;&lt;/a&gt;类加载机制&lt;/h1&gt;&lt;h2 id=&quot;一般概念&quot;&gt;&lt;a href=&quot;#一般概念&quot; class=&quot;headerlink&quot; title=&quot;一般概念&quot;
      
    
    </summary>
    
      <category term="jvm学习笔记" scheme="https://www.junglezero.top/categories/jvm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="jvm类的加载机制" scheme="https://www.junglezero.top/tags/jvm%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>jvm学习笔记（字节码文件）</title>
    <link href="https://www.junglezero.top/2019/03/24/jvm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%EF%BC%89/"/>
    <id>https://www.junglezero.top/2019/03/24/jvm学习笔记（字节码文件）/</id>
    <published>2019-03-24T00:55:00.000Z</published>
    <updated>2019-03-26T03:28:37.307Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字节码文件（ByteCode）"><a href="#字节码文件（ByteCode）" class="headerlink" title="字节码文件（ByteCode）"></a>字节码文件（ByteCode）</h1><h2 id="基本理解"><a href="#基本理解" class="headerlink" title="基本理解"></a>基本理解</h2><p>字节码文件（.class）实际上就是java源码文件（.java）经过编译而形成的 ，可以被虚拟机所理解的文件。字节码文件结构比较特殊，内部不包含任何的分段符，字节顺序和数量都是严格规定的，所有16位，32位，64位长度的数据都将构成2个，4个，8个8字节单位来表示，多字节数据项按照big-endian顺序（高位字节的地址在低位，低位字节的地址在最高位）</p><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p><img src="/upload/pasted-243.png" alt="upload successful"><br>在该结构体中，只有两种数据结构，分别是无符号数和表，其中无符号数属于字节码的基本类型，u1,u2分别表说一个字节和两个字节无符号类型，表是由多个无符号是或者其他表作为数据项的复合数据结构，所有表都是用“_info”进行结尾</p><h3 id="magic"><a href="#magic" class="headerlink" title="magic"></a>magic</h3><p>用来标识文件为一个字节码文件，是固定的，为“0xCAFEBABE”，并不是采用文件后缀名标识字节码文件，因为文件后缀可以手动修改</p><h3 id="minor-version-和-major-version"><a href="#minor-version-和-major-version" class="headerlink" title="minor_version 和 major_version"></a>minor_version 和 major_version</h3><p>紧接着魔数的四个字节是class文件的此版本号和主版本号。一般来说，高版本可以向下兼容低版本，而当低版本jvm处理高版本的字节码文件时，就会抛出“java.lang.UnsupportedClassVersionError”异常</p><h3 id="constant-pool-count-常量池计数器-和constant-pool-常量池"><a href="#constant-pool-count-常量池计数器-和constant-pool-常量池" class="headerlink" title="constant_pool_count(常量池计数器)和constant_pool(常量池)"></a>constant_pool_count(常量池计数器)和constant_pool(常量池)</h3><p>常量池是字节码文件中非常重要的，也是字节码文件中与其他项关联的最多和占用字节码空间最大的数据项，常量池中主要存放字面量（Literal），包含文字字符串，final常量值，和符号引用（Symbolic）包含类和接口的全限定名（Full Qualified Name）,字段的名称和描述符（Descriptor）以及方法的名称和描述符，访问是通过索引进行访问<br>常量池计数器是记录常量池中到底有多少数据常量，从1开始计数，但是0也是使用的，为了满足后续其他项在不引用常量池中的任何常量项时，默认可以把常量池中的访问索引设为0</p><p><img src="/upload/pasted-244.png" alt="upload successful"></p><p><img src="/upload/pasted-245.png" alt="upload successful"></p><p><img src="/upload/pasted-246.png" alt="upload successful"><br>可以通过命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -verbose xxx.class</span><br></pre></td></tr></table></figure></p><p>查看常量池中的信息</p><h3 id="access-flags-访问标志"><a href="#access-flags-访问标志" class="headerlink" title="access_flags(访问标志)"></a>access_flags(访问标志)</h3><p><img src="/upload/pasted-247.png" alt="upload successful"><br>这一位一般是表中一个或者几个的组合</p><h3 id="this-class-类索引-和super-class-超类索引"><a href="#this-class-类索引-和super-class-超类索引" class="headerlink" title="this_class(类索引)和super_class(超类索引)"></a>this_class(类索引)和super_class(超类索引)</h3><p> 分别保存了类和超类的全限定名</p><p><img src="/upload/pasted-248.png" alt="upload successful"><br>如果一个类并没有显式的继承其他类，则它的直接超类就是Object，此时父类的索引值就是0，这时就没有引用常量池中的常量</p><h3 id="interfaces-count-接口计数器-和interfaces（接口表）"><a href="#interfaces-count-接口计数器-和interfaces（接口表）" class="headerlink" title="interfaces_count(接口计数器)和interfaces（接口表）"></a>interfaces_count(接口计数器)和interfaces（接口表）</h3><p>interfaces_count 指的是当前类实现的接口数目<br>interfaces[] 是包含interfaces_count个接口的全局限定名的索引的数组</p><h3 id="fields-count（字段计数器）-和fields（字段表）"><a href="#fields-count（字段计数器）-和fields（字段表）" class="headerlink" title="fields_count（字段计数器） 和fields（字段表）"></a>fields_count（字段计数器） 和fields（字段表）</h3><p>字段表计数器用来表示一个字节码文件中field_info的个数，是一个类中类变量和实例变量的总和，字段表是一个数组集合，字段表中的每一个成员必须是field_info数据项，用来表示一个字段的完整信息，包括字段的标识符，访问修饰符（public private protected），类变量还是实例变量（static），是否为常量（final），字段表中，只含有当前类的字段，并不含有超类的字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">field_info &#123;</span><br><span class="line">   u2 access_flags;</span><br><span class="line">   u2 name_index;</span><br><span class="line">   u2 descriptor_index;</span><br><span class="line">   u2 attributes_count;</span><br><span class="line">   attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="methods-count-方法计数器-和methods-方法表"><a href="#methods-count-方法计数器-和methods-方法表" class="headerlink" title="methods_count(方法计数器)和methods(方法表)"></a>methods_count(方法计数器)和methods(方法表)</h3><p>methods_count是该类或者接口显示定义的方法的数量。<br>method[]是包含方法信息的一个详细列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">method_info &#123;</span><br><span class="line">   u2 access_flags;</span><br><span class="line">   u2 name_index;</span><br><span class="line">   u2 descriptor_index;</span><br><span class="line">   u2 attributes_count;</span><br><span class="line">   attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="attrubutes-count和attributes"><a href="#attrubutes-count和attributes" class="headerlink" title="attrubutes_count和attributes"></a>attrubutes_count和attributes</h3><p>class文件的最后一部分是属性，它描述了该类或者接口所定义的一些属性信息。attributes_count指的是attributes列表中包含的attribute_info的数量。<br>属性可以出现在class文件的很多地方，而不只是出现在attributes列表里。如果是attributes表里的属性，那么它就是对整个class文件所对应的类或者接口的描述；如果出现在fileds的某一项里，那么它就是对该字段额外信息的描述；如果出现在methods的某一项里，那么它就是对该方法额外信息的描述。</p><p><img src="/upload/pasted-251.png" alt="upload successful"><br>必须要被虚拟机所识别的三个属性<br>Code：<br>Code 属性是一个变长属性，位于 method_info结构的属性表。一个 Code 属性<br>只为唯一一个方法、实例类初始化方法或类初始化方法保存 Java 虚拟机指令及相关辅<br>助信息。 所有 Java 虚拟机实现都必须能够识别 Code 属性。如果方法被声明为 native 或者<br>abstract 类型，那么对应的 method_info 结构不能有明确的 Code 属性，其它情况下，<br>method_info 有必须有明确的 Code 属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Code_attribute &#123;</span><br><span class="line">   u2 attribute_name_index;//必须是对常量池的有效索引， 常量池在该索引处的项</span><br><span class="line">必须是 CONSTANT_Utf8_info结构，表示字符串“Code”。</span><br><span class="line">   u4 attribute_length;//表示当前属性的长度，不包括开始的 6 个字节</span><br><span class="line">   u2 max_stack;//给出了当前方法的操作数栈在运行执行的任何时间点的最大深度</span><br><span class="line">   u2 max_locals;//给出了分配在当前方法引用的局部变量表中的局部变量个数，包括</span><br><span class="line">调用此方法时用于传递参数的局部变量</span><br><span class="line">   u4 code_length;//给出了当前方法的 code[]数组的字节数①， code_length 的值必须</span><br><span class="line">大于 0，即 code[]数组不能为空。</span><br><span class="line">   u1 code[code_length]; //code[]数组给出了实现当前方法的 Java 虚拟机字节码。</span><br><span class="line">code[]数组以按字节寻址的方式读入机器内存，如果 code[]数组的第一个字节是按以</span><br><span class="line">4 字节边界对齐的话，那么 tableswitch 和 lookupswitch 指令中所有涉及到的 32</span><br><span class="line">位偏移量也都是按 4 字节长度对齐的（关于 code[]数组边界对齐对字节码的影响， 请参</span><br><span class="line">考相关的指令描述）。</span><br><span class="line">   u2 exception_table_length;//给出了 exception_table[]数组的成员个数量。</span><br><span class="line">  &#123;    u2 start_pc;</span><br><span class="line">       u2 end_pc;</span><br><span class="line">       u2 handler_pc;</span><br><span class="line">       u2 catch_type;</span><br><span class="line">  &#125; exception_table[exception_table_length];//数组的每个成员表示 code[]数组中的一个异常处理器</span><br><span class="line">（Exception Handler）。 exception_table[]数组中， 异常处理器顺序是有意义的</span><br><span class="line">  u2 attributes_count;</span><br><span class="line">  attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ConstantValue<br>Execptions</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;字节码文件（ByteCode）&quot;&gt;&lt;a href=&quot;#字节码文件（ByteCode）&quot; class=&quot;headerlink&quot; title=&quot;字节码文件（ByteCode）&quot;&gt;&lt;/a&gt;字节码文件（ByteCode）&lt;/h1&gt;&lt;h2 id=&quot;基本理解&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="jvm学习笔记" scheme="https://www.junglezero.top/categories/jvm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="jvm内存相关" scheme="https://www.junglezero.top/tags/jvm%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>jvm学习笔记（垃圾回收）</title>
    <link href="https://www.junglezero.top/2019/03/21/m%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%89/"/>
    <id>https://www.junglezero.top/2019/03/21/m学习笔记（垃圾回收）/</id>
    <published>2019-03-21T03:22:00.000Z</published>
    <updated>2019-03-24T08:37:22.554Z</updated>
    
    <content type="html"><![CDATA[<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="GC的评估"><a href="#GC的评估" class="headerlink" title="GC的评估"></a>GC的评估</h2><ul><li>吞吐量：程序的运行时间/（程序的运行时间+内存的回收时间）</li><li>垃圾回收开销：吞吐量的补数，垃圾收集时间和总时间的比例</li><li>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间</li><li>收集频率：相对于应用程序的执行，收集操作的发生频率</li><li>堆空间：java堆区所占的内存大小</li><li>快速：一个对象从诞生到被回收所经历的时间</li></ul><h2 id="如何判定垃圾对象"><a href="#如何判定垃圾对象" class="headerlink" title="如何判定垃圾对象"></a>如何判定垃圾对象</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>在对象中添加一个引用计数器，当有地方引用这个对象时，引用计数器的数值+1，引用失效时，计数器的值-1<br>虽然效率很高，但是存在较大弊端，如果有两个潜在垃圾相互引用，那么他们的计数器不为1，不会被标记为垃圾 </p><h3 id="可达分析法（根搜索法）"><a href="#可达分析法（根搜索法）" class="headerlink" title="可达分析法（根搜索法）"></a>可达分析法（根搜索法）</h3><p><img src="/upload/pasted-215.png" alt="upload successful"><br>以根对象集合为起始点，按照从上到下的方式搜索被根对象集合所连接的目标对象是否可达（根搜索后，内存中存活的对象都会和根对象集合直接或者间接的连接着），若不可达，则意味着目标对象已经死亡，会被标记为垃圾对象<br>跟对象集合中包括：</p><ul><li>Java栈中对象的引用</li><li>本地方法栈中的对象引用</li><li>运行常量池中的对象引用</li><li>方法区中类静态属性的对象引用</li><li>与一个类对象的唯一数据类型的Class对象</li></ul><h2 id="回收方式"><a href="#回收方式" class="headerlink" title="回收方式"></a>回收方式</h2><h3 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h3><h4 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h4><p>是基础的垃圾收集算法，过程正如名字所说的两个过程，但是其效率低下，而且会产生不连续的内存块</p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><h5 id="堆的具体分区"><a href="#堆的具体分区" class="headerlink" title="堆的具体分区"></a>堆的具体分区</h5><p><img src="/upload/pasted-218.png" alt="upload successful"></p><h5 id="复制算法过程"><a href="#复制算法过程" class="headerlink" title="复制算法过程"></a>复制算法过程</h5><p>当执行一次Minor GC（新生代的垃圾回收），Eden中存活的对象会被复制到To空间，并且之前已经经历过一次Minor GC并在Form空间中存活下来的对象如果还存活的话会被复制到To空间中<br><img src="/upload/pasted-216.png" alt="upload successful"><br>Minor GC执行完毕后Eden空间和From空间会被清空，存活下来的对象已经全部复制到了To中,接下来From空间和To空间会交换位置，复制算法的本质就是保证From和To有一块空间是空的<br><img src="/upload/pasted-217.png" alt="upload successful"><br>Minor GC却不适用于老年代的垃圾回收，因为老年代的对象生命周期都很长</p><h4 id="标记整理算法（标记-压缩算存法）"><a href="#标记整理算法（标记-压缩算存法）" class="headerlink" title="标记整理算法（标记-压缩算存法）"></a>标记整理算法（标记-压缩算存法）</h4><p>当成功标记出内存的垃圾对象后，该算法会将所有活对象移动到一个规整且连续的空间中去，然后执行Full GC（老年代回收算法，Major GC）回收无用对象所占的内存，当成功执行压缩后，已用的内存和未用的内存会各占一边，彼此维护着一个标记指针，当新对象分配空间时，则可以通过指针碰撞方式（Bump the Pointer）</p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>根据分代的概念，依照每个代的特点，选择合适的收集算法，比如为新生代选择算法就要以速度为先，因为新生代中所存储的瞬时对象生命周期都非常短，且内存空间较小，则使用复制算法；而老年代中对象的生命周期都较长，而且老年代所占的堆内存也较大，因此老年代中的垃圾回收并不频繁，但是执行消费的时间却很长，所以选择标记压缩算法<br>新生代GC(Minor GC) 指发生在新生代的垃圾收集动作，因为java对象大多具备朝生夕灭的特性，所以MinorGC非常频繁<br>老年代GC(Full GC，Major GC) 指发生在老年代的GC，FullGC一般比MinorGC慢上十倍</p><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p><img src="/upload/pasted-219.png" alt="upload successful"></p><h4 id="串行回收与并行回收"><a href="#串行回收与并行回收" class="headerlink" title="串行回收与并行回收"></a>串行回收与并行回收</h4><p>串行回收是，当多个CPU可以执行垃圾回收操作时，也只能有一个CPU执行垃圾回收操作，在执行垃圾回收时，工作线程需要全部暂停，垃圾收集完成后才可继续<br>并行回收是指多个cpu可以同时进行垃圾回收，提升了程序的吞吐量<br><img src="/upload/pasted-220.png" alt="upload successful"></p><h4 id="并发和“Stop-the-World”"><a href="#并发和“Stop-the-World”" class="headerlink" title="并发和“Stop the World”"></a>并发和“Stop the World”</h4><p>“Stop the World”指的是垃圾回收进行时，会暂停所有进行中的线程<br>并发回收只不过是减少了“Stop the World”的时间</p><h4 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h4><ul><li>最基本的垃圾收集器</li><li>作用在新生代中，采用复制算法，串行回收（单线程）和“Stop the World”机制进行回收</li><li>在老年代提供Serial Old收集器，采用标记压缩算法，串行回收（单线程）和“Stop the World”机制进行回收</li><li>适合单个CPU的宿主环境</li></ul><h4 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h4><ul><li>适合在并行的条件的垃圾收集器</li><li>算法和机制与Serial相同</li><li>适合多个cpu的环境</li></ul><h4 id="Parallel"><a href="#Parallel" class="headerlink" title="Parallel"></a>Parallel</h4><ul><li>采用复制算法，并行回收和“stop the world”机制</li><li>可以控制程序的吞吐量（-XX GCTimeRatio）,提高吞吐量，可以降低内存回收的执行频率，但是会增加每次执行的时间</li><li>老年代采用Parallel old收集器，采用标记压缩，并行收集</li><li>Parallel 和Parallel Old适合Server下的内存回收</li></ul><h4 id="CMS（Concurrent-Mark-Sweep）"><a href="#CMS（Concurrent-Mark-Sweep）" class="headerlink" title="CMS（Concurrent-Mark-Sweep）"></a>CMS（Concurrent-Mark-Sweep）</h4><p>特点</p><ul><li>+为并发而生</li><li>+低延迟（每次执行时间较短）</li><li>-占用cpu内存较大</li><li>-会出现浮动垃圾</li><li>-产生内存碎片</li></ul><p><img src="/upload/pasted-226.png" alt="upload successful"><br>过程：</p><ul><li>初始标记（Initial-Mark）：程序中所有工作进程会暂停，并根据根搜素法标记对不可达对象进行标记，标记完毕后恢复暂停进程</li><li>并发标记（Concurrent-Marking）：将之前不可达对象标记为垃圾对象</li><li>再次标记（Remark）：并发标记并不能保证所有垃圾对象都已经被标记，因此该过程将进入“stop the world”再次进行标记</li><li>并发清除（Concurrent-Sweep）：清除标记垃圾对象</li></ul><h4 id="G1（Garbage-First）"><a href="#G1（Garbage-First）" class="headerlink" title="G1（Garbage First）"></a>G1（Garbage First）</h4><p>特点：</p><ul><li><p>并行于并发：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。</p></li><li><p>分代收集：分代概念在G1中依然得以保留。虽然G1可以不需要其它收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。也就是说G1可以自己管理新生代和老年代了。</p></li><li><p>空间整合：由于G1使用了独立区域（Region）概念，将java堆区划分为2048块大小相同的独立Region块,这样 可以更好的提升GC的回收效率和缩短线程暂停时间以换取更大的程序吞吐量，因而能更好的控制暂停时间G1从整体来看是基于“标记-整理”算法实现收集，从局部（两个Region）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片。</p></li><li><p>可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用这明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p></li></ul><p><img src="/upload/pasted-227.png" alt="upload successful"></p><ul><li>为了避免全堆扫描，G1使用了Remembered Set来管理相关的对象引用信息。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏了。</li></ul><p>过程：</p><p><img src="/upload/pasted-228.png" alt="upload successful"></p><ul><li><p>初始标记（Initial Making）：标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可以用的Region中创建新对象，这个阶段需要停顿线程，但耗时很短</p></li><li><p>并发标记（Concurrent Marking）：并发标记阶段是从GC Roots开始对堆中对象进行可达性分析，找出存活对象，这一阶段耗时较长但能与用户线程并发运行。而最终标记阶段需要吧Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但可并行执行</p></li><li><p>最终标记（Final Marking）：最后筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，这一过程同样是需要停顿线程</p></li><li><p>筛选回收（Live Data Counting and Evacuation）</p></li></ul><p>GC模式</p><ul><li>youngGC:发生在年轻代的GC算法，一般对象（除了巨型对象）都是在eden region中分配内存，当所有eden region被耗尽无法申请内存时，就会触发一次young gc，这种触发机制和之前的young gc差不多，执行完一次young gc，活跃对象会被拷贝到survivor region或者晋升到old region中，空闲的region会被放入空闲列表中，等待下次被使用。</li><li>mixGC:就是上面的标准过程</li><li>FullGC:如果对象内存分配速度过快，mixed gc来不及回收，导致老年代被填满，就会触发一次full gc，G1的full gc算法就是单线程执行的serial old gc，会导致异常长时间的暂停时间，需要进行不断的调优，尽可能的避免full gc.</li></ul><h1 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h1><ul><li>新对象优先在Eden区分配 ：新对象都会在Eden区进行分配，若Eden区已满，则会执行Minor GC</li><li>大对象直接进入老年代：大对象指的是需要占用大量内存的java对象，典型的是大字符串，可以通过“-XX:PretenureSizeTHreshold”设置保存在老年区的大小，应当尽量避免大对象的出现</li><li>长期存活的对象会进入老年代：虚拟机实际上为每个对象设置了一个Age计数器，如果对象在Eden出生且经过第一次垃圾回收仍存活的话，并且能被Survivor容纳的话，就会进入Survivor，将对象年龄设为1，对象在Survivor存活过一次垃圾回收，年龄就+1，年龄增加到一定程度时，就会进入老年区,可以通过“-XX:MaxTeburingThreshold”设置老年区年龄</li><li>动态对象的年龄判定：如果在Survivor中相同年龄对象大小总和大于survivor空间的一半，年龄大于或者等于该年龄的对象直接进入老年代</li><li>空间分配担保：当新生代的大部分对象都存活时，就需要老年代进行担保，把survivor无法容纳的对象直接分入老年代</li><li>逃逸分析和栈上分配：逃逸分析（Escape Analysis）是jvm在执行性能优化之前的一种分析技术，它的具体目标是分析出对象的作用域，当一个对象被定义在方法体内部之后，它的受访权限仅限于方法体内，一旦被外部成员引用后，这个对象就发生了逃逸，反之，如果方法体内的对象并没有被外部成员引用，jvm就会为其在栈帧中分配空间</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;垃圾回收&quot;&gt;&lt;a href=&quot;#垃圾回收&quot; class=&quot;headerlink&quot; title=&quot;垃圾回收&quot;&gt;&lt;/a&gt;垃圾回收&lt;/h1&gt;&lt;h2 id=&quot;GC的评估&quot;&gt;&lt;a href=&quot;#GC的评估&quot; class=&quot;headerlink&quot; title=&quot;GC的评估&quot;&gt;
      
    
    </summary>
    
      <category term="jvm学习笔记" scheme="https://www.junglezero.top/categories/jvm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="垃圾回收" scheme="https://www.junglezero.top/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>jvm学习笔记（内存）</title>
    <link href="https://www.junglezero.top/2019/03/20/vm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%86%85%E5%AD%98%EF%BC%89/"/>
    <id>https://www.junglezero.top/2019/03/20/vm学习笔记（内存）/</id>
    <published>2019-03-20T07:13:00.000Z</published>
    <updated>2019-03-21T03:19:39.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM的内存管理"><a href="#JVM的内存管理" class="headerlink" title="JVM的内存管理"></a>JVM的内存管理</h1><h2 id="基本五大区"><a href="#基本五大区" class="headerlink" title="基本五大区"></a>基本五大区</h2><p><img src="/upload/pasted-209.png" alt="upload successful"></p><h3 id="线程共享区和线程独占区"><a href="#线程共享区和线程独占区" class="headerlink" title="线程共享区和线程独占区"></a>线程共享区和线程独占区</h3><p>线程，是操作系统中能够进行调度的最小单位，线程共享区是指所有线程共同使用的区域，线程独占区是指每个线程单独创建和使用的内存区域</p><h3 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h3><p>是内存中一块较小空间，可以理解为是记录当前线程所执行的字节码的<strong>行号</strong>指示器，如果线程执行的是一个java方法，计数器记录的是正在执行的虚拟机指令码的<strong>地址</strong>； 如果是Native方法，计数器为空（undefined），程序计数器是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域</p><h3 id="Java虚拟机栈（Java-Virtual-Machine-Stacks）"><a href="#Java虚拟机栈（Java-Virtual-Machine-Stacks）" class="headerlink" title="Java虚拟机栈（Java Virtual Machine Stacks）"></a>Java虚拟机栈（Java Virtual Machine Stacks）</h3><p>虚拟机栈描述的是java方法执行的内存模型<br>栈帧（Stack Frame）：每个方法在执行完成时，都会创建一个栈帧，伴随着方法从创建到执行的完成，用于储存局部变量表【存放编译器可知道的各种基本类型，引用类型，returnAddress（一条字节码指令的地址）类型，在编译器完成分配，在方法运行期间大小不会改变】，操作数栈，动态链接，方法出口等<br>【结合栈的先进先出特性理解】<br>异常状况：线程请求的栈的深度大于虚拟机所允许的最大深度，则发生StackOverflowError【一个没有结束的递归函数】】如果虚拟机栈可以动态扩展，而扩展到无法申请到足够内存时，抛出OutOfMemoryError</p><h3 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h3><p>和虚拟机栈类似，区别是虚拟机栈为虚拟机执行java方法而服务，本地方法栈则为使用到的Native方法服务，在hot spot 中，两者是一体的</p><h3 id="java堆（Java-Heap）"><a href="#java堆（Java-Heap）" class="headerlink" title="java堆（Java Heap）"></a>java堆（Java Heap）</h3><p>用来存储对象的<strong>实例</strong>，是java虚拟机所管理的最大的内存区域</p><ul><li>大部分对象实例在此分配内存</li><li>垃圾收集器管理的主要区域</li><li>内存不够时，会抛出OutOfMemoryError异常</li><li>可以通过-Xmx和-XMS控制动态控制<h3 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h3>用以储存已被虚拟机加载的<strong>类信息【版本，字段，方法，接口】，常量，静态变量</strong>，即时编译器编译后的代码等数据<br>称作“永久代”（Permanent Generation）:在hot spot中GC分代收集扩展到了方法区，或者说使用了永久代而已，两者并不等价<br>会抛出OutOfMemoryError</li></ul><h2 id="重点区域"><a href="#重点区域" class="headerlink" title="重点区域"></a>重点区域</h2><h3 id="运行时常量池（Runtime-Constant-Pool）"><a href="#运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="运行时常量池（Runtime Constant Pool）"></a>运行时常量池（Runtime Constant Pool）</h3><p>位于方法区，用来存放编译期生成的各种字面量和符号引用<br>比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1=&quot;abc&quot;;</span><br><span class="line">String s2=&quot;abc&quot;;</span><br><span class="line">System.out.println(s1==s2)</span><br></pre></td></tr></table></figure></p><p>要按照上面的说法，虚拟机在创建s1时，会先将在虚拟机栈中的局部变量表中创建引用s1，然后再在堆中创建实例“abc”，同理s2也是，这样来看，判定s1==s2的话，由于string是引用类型，因此会比较两个的地址，则创建的两个实例虽然内容相同，但是地址是不同的，所以应当是false，但是实际操作中，却是true。答案就在于“abc”属于可以在编译器直接翻译出的字面量，会存在运行常量池中，而在运行常量池中，实际上维持的是一个Stingtable（对于string来说），而其底层是HashSet(无序性，不重复性的集合)，因此，两个引用实际上指向的是同一个“abc”，故地址相同，判定为true<br>而对于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s3=new String(&quot;abc&quot;)；</span><br><span class="line">System.out.println(s1==s3)</span><br></pre></td></tr></table></figure></p><p>其结果为false<br>关键在于关键字“new”,通过这种方式，就需要按照上面说的那样，引用在栈，实例在堆，因此地址是不相等<br>但是如果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(s1==s3.intern())</span><br></pre></td></tr></table></figure></p><p>结果为true，这是因为运行时常量池的另一个特性：动态性，它可以在运行期把常量放入常量池中，而intern()主要做的事情就是对于一个string，它会查看在栈（局部常量表）中查找是否有值相等的值，若没有，则创建并返回其在栈中的地址，若有则直接返回栈中地址</p><h3 id="直接内存（Direct-Memory）"><a href="#直接内存（Direct-Memory）" class="headerlink" title="直接内存（Direct Memory）"></a>直接内存（Direct Memory）</h3><p>实际上它不属于虚拟机运行时数据的一部分，也不是java虚拟机规范中定义的内存区域，但是还是用的到，既然是内存，会受到本机总内存影响，也会抛出OutOfMemoryError</p><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p><img src="/upload/pasted-211.png" alt="upload successful"></p><h3 id="分配内存过程"><a href="#分配内存过程" class="headerlink" title="分配内存过程"></a>分配内存过程</h3><p>对象所需的内存大小在类加载完成后就已经完全确定<br>指针碰撞（Bump the Pointer）： 如果在堆中内存时绝对齐整的，所用的内存在一边，空闲的内存在另一边，中间有一个指针作为分界，分配内存实际上就是指针向空闲内存区域移动与对象大小相等的一个空间<br>空闲列表（Free List）：在堆内存中，更多时候是不规整的，虚拟机可以维护一个列表进行记录，记录那些内存块是可用的，分配内存时，从；列表中找出一块可用区域即可<br>采取何种方式取决于堆内存是否规整，而堆内存是否规整又取决于垃圾收集器是否有压缩整理功能</p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>在分配时，由于多线，可能会引发线程安全问题<br>解决方法：</p><ul><li>线程同步，但是效率太低</li><li>本地线程分配缓冲（Thread Local Allocation Buffer）,即每个线程在java堆中预先分配一小块内存，若预分配的TALB满了，则采用同步策略</li></ul><h3 id="初始化对象"><a href="#初始化对象" class="headerlink" title="初始化对象"></a>初始化对象</h3><h3 id="对象的结构"><a href="#对象的结构" class="headerlink" title="对象的结构"></a>对象的结构</h3><p><img src="/upload/pasted-212.png" alt="upload successful"></p><ul><li>对象头（Header）<ul><li>自身运行时的数据（Mark Word）<ul><li>哈希值</li><li>GC分代年龄</li><li>锁状态标志</li><li>线程持有锁</li><li>偏向线程ID</li><li>偏向时间戳</li></ul></li><li>类型指针</li></ul></li><li>instance data:对象的有效信息</li><li>padding：填充作用,因为要求对象的内存大小要是8的整数倍</li></ul><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>这个过程指的是从reference到堆上实例的过程<br>句柄访问：<br>在java堆中划分出一块内存来作为句柄池，reference储存的对象就是句柄地址，而句柄中包含了对象实例数据和类型数据的地址<br>这种方法的好处是reference储存的是稳定的句柄地址，对象发生移动时，只会改变句柄中实例数据指针，不会改变reference<br><img src="/upload/pasted-213.png" alt="upload successful"></p><p>直接指针访问：<br>reference储存的直接是对象的地址<br>这种方法的好处是速度较快，因为节省了一次指针定位，hotspot中采用的是这种方式<br><img src="/upload/pasted-214.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JVM的内存管理&quot;&gt;&lt;a href=&quot;#JVM的内存管理&quot; class=&quot;headerlink&quot; title=&quot;JVM的内存管理&quot;&gt;&lt;/a&gt;JVM的内存管理&lt;/h1&gt;&lt;h2 id=&quot;基本五大区&quot;&gt;&lt;a href=&quot;#基本五大区&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="jvm学习笔记" scheme="https://www.junglezero.top/categories/jvm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="jvm内存相关" scheme="https://www.junglezero.top/tags/jvm%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>jvm学习笔记（入门）</title>
    <link href="https://www.junglezero.top/2019/03/20/jvm%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>https://www.junglezero.top/2019/03/20/jvm学习总结/</id>
    <published>2019-03-20T01:04:00.000Z</published>
    <updated>2019-03-20T14:24:31.461Z</updated>
    
    <content type="html"><![CDATA[<h1 id="入门概念"><a href="#入门概念" class="headerlink" title="入门概念"></a>入门概念</h1><h2 id="字节码（ByteCode）"><a href="#字节码（ByteCode）" class="headerlink" title="字节码（ByteCode）"></a>字节码（ByteCode）</h2><p>java的跨平台特性（Write Once，Run Anywhere）的根本原因就是字节码，字节码是java源代码编译以后的结果，对于不同的平台，jvm的内部实现机制可能有所不同，但是编译出的字节码却是相同的<br>大部分情况下，字节码都是储存在本地的.class文件，每一个字节码对应着全局唯一一个类或者接口的定义信息<br>扩大来说，任何编程语言只要编译结果满足并包含java虚拟机的内部指令，符号表以及其他辅助信息，这就是个有效的字节码文件，就能够被虚拟机所识别并装载运行</p><h2 id="Java-API"><a href="#Java-API" class="headerlink" title="Java API"></a>Java API</h2><p>即java应用编程接口，是预先定义好的接口，目的是让人用来进行开发，而又无需访问或者理解其内部源码（虽然为了我们自己的进步还是要去看源码）</p><h2 id="java虚拟机（JVM，java-Virtual-Machine）"><a href="#java虚拟机（JVM，java-Virtual-Machine）" class="headerlink" title="java虚拟机（JVM，java Virtual Machine）"></a>java虚拟机（JVM，java Virtual Machine）</h2><p>这是java技术的核心所在，因为所有的java程序都运行在java虚拟机内部，之所以说是虚拟机，是因为它是一组规范所定义的抽象计算机，jvm的主要任务是将字节码装载到内部，编译为对应平台的机器指令</p><p><img src="/upload/pasted-208.png" alt="upload successful"></p><h2 id="Java相对于其他几种语言的优势"><a href="#Java相对于其他几种语言的优势" class="headerlink" title="Java相对于其他几种语言的优势"></a>Java相对于其他几种语言的优势</h2><ul><li>1 体系结构独立</li><li>2 安全性优越</li><li>3 多线程</li><li>4 分布式</li><li>5 丰富的第三方开源组件</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;入门概念&quot;&gt;&lt;a href=&quot;#入门概念&quot; class=&quot;headerlink&quot; title=&quot;入门概念&quot;&gt;&lt;/a&gt;入门概念&lt;/h1&gt;&lt;h2 id=&quot;字节码（ByteCode）&quot;&gt;&lt;a href=&quot;#字节码（ByteCode）&quot; class=&quot;headerlink
      
    
    </summary>
    
      <category term="jvm学习笔记" scheme="https://www.junglezero.top/categories/jvm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="jvm基础" scheme="https://www.junglezero.top/tags/jvm%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>绘卷水浒传 20周年企划 第五章 翻译</title>
    <link href="https://www.junglezero.top/2019/03/18/%E5%8D%B7%E6%B0%B4%E6%B5%92%E4%BC%A0-20%E5%91%A8%E5%B9%B4%E4%BC%81%E5%88%92-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BF%BB%E8%AF%91/"/>
    <id>https://www.junglezero.top/2019/03/18/卷水浒传-20周年企划-第五章-翻译/</id>
    <published>2019-03-18T15:01:00.000Z</published>
    <updated>2019-03-24T15:21:25.505Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第五章-龙门决战"><a href="#第五章-龙门决战" class="headerlink" title="第五章 龙门决战"></a>第五章 龙门决战</h1><p>天刚微微亮<br>山间灰蒙蒙的，在漫天飞舞的朝霭中，史进他们被敌人包围着。<br>看着般若雷迸溅出的血花，官兵们战战兢兢的后退了<br>“是援军——敌援到了！”<br>金山大师的脸上，没有慈悲，没有愤怒，而是无念无想——那双眼睛没有犹豫和后悔，只有如利刃般的光辉<br>官军一撤退，包围史进的圈子松散了，石秀他们也向着包围圈涌去，一下子，官军就崩溃了，陈达，杨春，僧兵们也跟了上来，张开弓，并排着长枪组成枪阵，团结一致向前突破着<br>增援过来的是一百多武僧，是棍棒和拳法的高手<br>“保护金山大师！”<br>金山大师前进着，史进，石秀左右守护，人们源源不断的。但是，从街道的远处传来了马蹄声和轰鸣的呐喊声。官军的增援也到了，每次剧烈的震荡，都是不下千人的军队在行进着<br>石秀盯着天上的星辰<br>“就要死在这里了吗？”</p><p>金山大师带头向敌人中心猛冲着，蜂拥而来的敌人就像怒涛一般，般若雷拨开箭矢，迸溅出火花，每次金棒一闪，就会倒下一片士兵<br>“这个罗刹，会下地狱的”<br>官军将领破口大骂，那个声音，回响在黎明的山间<br>“这个罗刹，会下地狱的”<br>对于回声，有了回应的话<br>“你在说洒家吗？”<br>与此同时，在官军的后方，一群人发出呐喊，他们突然向前方的官军发起攻击，无论是史进他们还是官军自己都以为他们是援军，他们也是官军的打扮，那群呐喊的人中，站着个巨汉，悠然的站着，一把扔掉了士兵的头盔，史进眼前一亮<br>“鲁智深！”</p><p><img src="/upload/pasted-205.png" alt="upload successful"><br>“来迟了！”<br>伴随着这一声，六十二斤的镔铁禅杖也卷起疾风的舞动起来，鲁智深趁机在懵逼中的官军中开辟一条道路，其他人也卸下官兵的伪装，出现了一伙“丐帮”军团，大多是乞丐，以洛阳，东京的乞丐为主力还有其他反对废佛的壮士，共计三千多人<br>“什么情况？”<br>伏兵的指挥官发出悲鸣，突然想起来了，先前林灵素亲兵中的一个小头目，组织起来一批无赖和乞丐，对他们予以重金赏赐，由于待遇很好，很快就聚集了不少人，真不愧是自傲的道士——得意忘形的太早了<br>丐帮军团恢复了原有的半裸状态，将官军冲散<br>“拿你们钱就是为了吃口饭罢了，现在咱们要消灭敌人”<br>冲在最前面的鲁智深，犹如砍瓜切菜一般挥舞着禅杖，在官军篝火的映照之下，他犹如罗汉一般<br>在这群人中，也有“活闪婆”王定六的身影，此外，还有登州莱山的“解家双雄”——“双头蛇”解珍和“双尾蝎”解宝</p><p><img src="/upload/pasted-206.png" alt="upload successful"></p><p><img src="/upload/pasted-207.png" alt="upload successful"><br>解珍解宝两兄弟位居梁山泊第34,35位，见者必死的双头蛇和拥有两条毒尾的蝎子便是这兄弟二人，他们纵横于山间之中，用猎叉和弓捕获猎物，是纯粹的猎人<br>官军陷入大乱，由于自己的内部出现敌人，他们的阵型被瓦解，四处乱窜。<br>金山大师自己也在战斗着，看见了鲁智深，鲁智深也看见了金山大师。在敌我厮杀激烈的山腰，上山的人和下山的人碰撞着，一片混乱，不久就散开了<br>金山大师和鲁智深，终于在后参道口相遇了，二人罗汉般的身姿，确实像是守护嵩山的仁王</p><hr><p>响起了胜利的呐喊，不是“万岁”而是“阿弥陀佛”<br>由于史进等人的奋进和鲁智深的援军突然杀入，官军撤退了，本以为设伏打击没有防备的僧众，不想却以自己受到袭击的方式结尾，官军暂时无法重整态势<br>官军撤出后参道后，在南方的街道布阵<br>史进等人也和“丐帮军”一同撤退到了“佛掌角”，在解氏兄弟的指挥下，后参道口处封锁道路的木材被移除了，兄弟二人为了查看是否还有其他的道路官军可用来侵入，马上消失在山中<br>史进也得到了暂时的休整，为与鲁智深再会而感到高兴<br>“得救了，智深师傅，你们怎么会在这里？”<br>王定六也混在乞丐当中<br>“骨头都要断了”<br>为了联合解氏兄弟，鲁智深，并安排各个丐帮的壮士混入道士军，“活闪婆”王定六已经快跑不动了<br>“吴军师简直不是人”<br>王定六一边和鲁智深同行，一边又要和丐帮和梁山泊取得联系，梁山泊也通知了鲁智深前往少林寺，预料到少林寺将会成为主战场的吴用，也派遣了精通山岳的解氏兄弟【注：两个人最后都死在了悬崖边上，一个生生掉下去摔死的，一个活活被乱箭钉在了悬崖上，绘卷水浒传的方腊篇也有两人死时的插画】，当然，吴用也预测到了能够动用的援军<br>“能见面，还是多亏了军师，是吧，和尚”<br>鲁智深一脸不悦，把腰间的酒葫芦扔给史进<br>“明明就是冲着洒家来了，哪里那么多废话”<br>“哼”<br>鲁智深的腰间总是备着酒葫芦。“荤酒勿入山门”——就是为了防备这个的，鲁智深自己也喝了起来，润湿了干渴的喉咙，他并没有看向史进，而是看向了金山大师<br>金山大师似乎认为突然出现的“丐帮军”是某个寺庙来的援军，在向和尚外貌的鲁智深行过礼后，就着手指挥着手下受轻伤的僧人进行救助工作，而且还派出侦察和监视的人，丝毫没有因为官军的撤退而疏忽大意<br>石秀也和陈达，杨春负责起周围的境界，他们举着火把，巡视着后参道附近，突然发现草丛在动，石秀拿着刀冲了过来，此时，听见了熟悉的声音<br>“等一下，是我”<br>“‘张神剑’，你还活着？”<br>从草丛中爬出来的，正是去探索桀街道的雇佣兵队长“张神剑”<br>“下面全是士兵，他们已经陆陆续续的在集结了”<br>回少林寺侦察的莫志，不久也返回了“佛掌角”<br>“林灵素的本部队正在从北麓登上来，我们没有回头路了”<br>接到报告的金山大师坐在大岩石上，沉默不语<br>他们已经被包围在了这“佛掌角”，“张神剑”是军人出身，很了解官军的作风<br>“等早晨一到，他们就会从山上杀过来，或者在林子中放火，即使想去龙门，也不能走正道了，还有别的路吗？”<br>“张神剑”问金山大师。向西延伸的山脊被树木覆盖，浮在微明天空上的山脊陡峭地耸立着。<br>“道路——”<br>金山大师正要说时，有声音从黑暗中传来<br>“——没有”<br>在火炬的光芒下，是身着虎皮的解宝，背后站着手持叉子的解珍<br>“没有别的路”<br>兄弟二人出生于登州莱山，是和山中的野兽相伴成长的，自己也犹如野兽一般，走过了无数的险路<br>他们说道<br>“即使没有人造的路，山也有它的出路”<br>兄弟二人鼓起气来，从胸腔中发出了犹如野兽般的咆哮，对于这个连周围空气都能震动的“葛氏禁气啸”，嵩山群峰的野兽们也开始回应，整个嵩山上下，咆哮声接连不断，此起彼伏<br>深山之中，是人们所不了解的野兽之道<br>哥哥解珍向薛永打听，因为薛永出生于河南，熟悉周边环境<br>“薛永兄弟，龙门就是在这里往西的方向吗？”<br>薛永点点头<br>解珍仰望消失在曙光中的星星，指着一座山峰。<br>“那边是西边”<br>并没有出路<br>但是。莱山的解氏兄弟却在天空，在山间，读着前进的“道”</p><hr><p>只点着一只火把<br>金山大师闭上眼睛，感觉到野兽的咆哮渐渐消失了，在渐渐恢复的寂静中，他睁开眼睛，眼前正站着鲁智深<br>金山大师低声沉吟着什么<br>在火把的光芒中，鲁智深的脸闪闪发光。虽然擦了脸颊的血迹，但灰色僧袍还是红黑潮湿的。<br>（是毘沙门天【多闻天王，为佛教护法之大神，是四天尊王之一，熟悉日本战国的朋友应该知道，就是上杉谦信经常cos的】，还是罗刹？）<br>从天而降的神明，到底是出于何种目的——那是金山大师眼前刹那间的幻像【侧面证明了就阴阳学而言，金山大师还是和智真长老有差距的】<br>“你是哪个寺庙的僧人？”<br>“洒家便是在五台山出家，智真长老的弟子——‘花和尚’鲁智深”</p><p><img src="/upload/pasted-210.png" alt="upload successful"><br>“智真的……”<br>“正是”<br>鲁智深把手伸进怀中，摸出一颗念珠<br>“这是智真长老的念珠，这上面画着的，就是达摩吧”<br>鲁智深简单的说明了在东京的斗法状况，金山大师摸索着念珠，端详了一会<br>“这念珠，是本僧与智真进行宗论时，最终没有胜负，相互交换的”<br>智真长老和金山大师的宗论，是关于“智”与“武”的，佛说着慈悲，可身边的护法却手持利剑，智与武真的能共存吗，谁又能更胜一筹，真正带来和平的，又是哪个呢？<br>金山提倡的是修行本身就是战胜烦恼的过程，而智真则认为一切不昧，烦恼，已经烦恼了<br>然后，两人各自完成了自己的修行，做出了自己的选择<br>金山踏上了苦行恶行的武道，智真选择的是只管打坐冥想的智道<br>但是，在没有岔路的道路上，在天地间无边无际的荒野上，昂首前进的人，现在正站在金山的面前<br>“鲁智深啊——”<br>金山大师双手合十<br>“无道，亦无止境——你是唯一踏上旅途的人吧”<br>“什么东西啊，洒家也不晓得”<br>鲁智深擦了擦被酒弄湿的胡子，然后，像孩子一样笑了<br>“洒家就是找你的”<br>金山大师也豁然的笑了<br>“那么，金山大师啊，今后怎么办啊”<br>武僧们，受伤的尼姑们，佛教信徒们以及丐帮的兄弟们，都在看着二人，金山大师看了看手中的念珠，站在大家面前。那颗心自然已经做出了决定<br>“出发吧”<br>这样说道<br>鲁智深手中握着装满酒的葫芦，眼睛盯着大师<br>“佛法本为苦难烦恼之人而生，如果这泱泱大国的人无忧无虑的追名逐利，无忧无虑的贪图享乐。佛法已经没有必要了，吾等会毁灭，但是，吾等不能白白的死去，点燃最后的灯火，向西进发吧”<br>金山大师抬起头，指着已经被黎明染了色的西峰，那是没有出路的嵩山群峰，而龙门就在那西面，而更遥远的西面是天竺，最后的西方净土<br>“好吧！”<br>一线阳光照在了鲁智深的脸上<br>“地狱之道上，就由洒家当先锋吧”</p><hr><p>天一亮起来，战场上的惨状也就看的一清二楚了，清爽的晨光中，四处遍布尸体，是死去的僧侣，官军，尼姑，以及雇佣军<br>银树咬着嘴唇，呆呆的望着眼前的情景，有死不瞑目的尸体，也有像睡着一般宁静的尸体<br>周围的血迹，染湿了银树的鞋子，一群乌鸦犹如乌云一般开始覆盖朝阳<br>薛永的脸上也沾满了血<br>银树拿出自己的手巾为他擦去血迹，指尖犹如寒冰一样冰凉<br>“这世上，惨不忍睹的事……还真是多啊”<br>“好的是事情也很多啊”<br>“——是啊”<br>薛永和银树一起，为受伤的彭尼贴上膏药，薛家的膏药止血镇痛的效果很好，彭尼微微睁开眼睛，旋即又闭上了<br>李忠正在砍伐周围的树木制作担架，用来运送伤者，龙门之旅，是一场死亡之行。尽管如此，所有人呢都认为这也比被官军杀死好，薛永正在给伤员贴上自家的膏药，石秀站了起来<br>“薛永，你和那孩子赶紧先跑吧”<br>“石秀大哥？”<br>“两个人去什么地方都好，千万不要再去龙门送死了”<br>人群在解氏兄弟的带领下开始行动起来，向西，越过险峻的山峰<br>银树为一个老僧贴上最后一贴膏药后，站了起来，问石秀<br>“那你打算怎么办？”<br>“这种事情，我总能应付的”<br>“史进也要去吗？”<br>“他的师父好像在龙门，不去打声招呼的话，作为弟子就有些过分了”<br>银树朝着远处的天空望去，天空晴朗，朝阳耀眼<br>“——这样啊”<br>银树却笑了。插在头发上的野花，在晨风中散落。<br><img src="/upload/pasted-222.png" alt="upload successful"><br>“那我就去东京吧”</p><hr><p>“金山大师，我要去东京了”<br>银树告诉走在前面的金山大师<br>“我要去见我的父亲，我有好多事要告诉他，这种事情不能再发生下去了，人自己的信仰，不该由人自己所决定吗，我无法忍受大家就像不存在一样被抹杀，被淡忘”<br>银树正气凛然，声音中充满的强烈的决心<br>“所以我要去东京”<br>薛永很了解银树。史进说道<br>“公主殿下，报仇的事只能放一下了”<br>银树点了点头<br>“那种事，已经无关紧要了”<br>金山大师默默听银树说完，把手伸到怀里，拿出一颗念珠<br>这是金山大师和智真长老当前交换，然后智真长老有托付给鲁智深，鲁智深又返还给金山大师的念珠，上面刻着达摩祖师，连念珠也已经被血染红了，大师用粗大的手指擦去念珠上的血迹，把它放在银树的手中<br>“……人的生命，就犹如这念珠一样，人与人相识相遇，就好像一个个念珠串联起来的串，连续不断，公主啊，你的生命”<br>金山大师双手握着银树的手和念珠<br>“不要忘了自己也是这串念珠中的一颗啊”<br>随着手掌的温暖，银树也明白了，大师是想告诉自己“活下去”，不论发生什么都要坚持活下去<br>银树一直想问<br>“天有三日，满月辉耀”<br>能够知道当初“不祥预言”的机会也就只有现在了<br>“大师”<br>本打算要问，但是银树取而代之的是微笑，她紧紧的握住念珠<br>“向父亲请愿停止废佛后，我一定会回来的”<br>史进猛地推了薛永一把<br>“你也跟她一起去吧”<br>薛永正在犹豫，史进把头转到了后面的伤者方向，彭尼正要挣扎的站起来，被李忠阻止了<br>“你难道打算让彭尼去吗？薛永，除了你以外，谁还能拼命的保护银树呢？”<br>“但是，我”<br>“去吧”<br>史进把棒子扔到薛永手中</p><hr><p>在朝霞之中，薛永和银树下山到了南边的山脚，位于官军的北面，他们避开街道，沿着险峻的山腰顺着谷川而下，薛永走在前面，拨开杂草，为银树开路，两个人的身影很快就消失在山间了<br>“是个会照顾人的男人啊”<br>李忠发出不知是叹息还是哈欠的气息，伸了伸懒腰<br>“年轻还真好啊”<br>清晨的空气在这种时候让人觉得很清爽<br>“其他受伤的人……”<br>“活着的人没人比你伤的更加严重了”<br>李忠吩咐手下把彭尼抬上担架<br>解珍解宝走在前面，爬到山尖上，走了一会就回头举着叉子挥动几下，发出可以通行的信号<br>大家默默的跟着，背着朝阳前进，有背负着伤员的，有扶着拐杖的，大家互相搀扶，朝着西边的山脊一点点前进着<br>时迁和王定六正在四处侦察<br>他们是“传令”，无论周遭发生什么事情，他们都要第一时间把情况通报给梁山泊，赶得上赶不上从来不是问题<br>“你要去哪啊”<br>“不用你管”<br>“我可比你快啊”<br>时迁把肩上的老鼠放在怀中<br>“我身材瘦小，行动起来会更加方便”<br>这样说着，时迁一个人消失在覆盖山峦的草丛中。<br>史进向薛永他们离去的南方一眼后，也准备开始上路了<br><img src="/upload/pasted-223.png" alt="upload successful"><br>“向龙门出发！”</p><hr><p>林灵素到达少林寺时，太阳已经升了起来<br>本来想活捉金山大师， 品尝胜利的滋味，可此时的嵩山却空空如也<br>林灵素本来打算等待节度使的军队到达后发起总攻，但是，由于僧侣们已经准备开始逃脱了，急忙派遣了伏兵，正面的本队也发起了进攻，杀过来时，最后院中不过三个人，连一只狗都没有留下<br>（没关系，关键还是金山）<br>金山大师是“谋反”的主谋，只要讨伐了金山大师，“镇压谋反”就算大功告成了<br>林灵素走进已经烧毁的达摩堂，去检查金山大师的首级，林灵素知道金山大师什么样子<br>“这不是金山大师！”<br>林灵素一脚踢开被搬过来的天穹和尚的头，骨碌骨碌的滚着，碰到了达摩像的脚停了下来，空洞的眼神，正在向着林灵素笑着<br>林灵素相当着急，明天，郭道士已经受命在东京做法发生“奇迹”，与此同时，“林元帅成功讨伐逆贼的”的奏折，将会呈到御前<br>“赶快找到金山！”<br>林灵素命令手下的道士<br>“不论死活，抓住赏金百两”<br>道士们立刻兴奋起来，争先恐后的行动着，达摩堂的门一晃，猫儿从缝隙中无声的滑了进来<br>“节度使的军队呢？”<br>林灵素一脸不悦，却也没有招呼别人<br>“他们马上会出战的”<br>猫儿观察仔细的眼睛，在达摩堂中闪闪发光<br>“这是贵妃大人的忠告：‘不要催促，要下命令’。因为你是陛下任命的元帅，如果他们不服从命令的话，他们就是造反”<br>“那慕容贵妃现在何处”<br>“我的任务完成了，我要出发了，有更重要的事情，荣德公主已经向东京进发了”<br>“公主？”<br>猫儿急切的点了点头<br>慕容贵妃是到最后都能精明盘算的人，为了应对这种不测之事，派出了自己心腹猫儿<br>“公主想要向他父亲控诉你的恶行，而且她也知道贵妃还在四处活动”<br>“这可就不好了”<br>“公主正在一路向东，只有一个护卫，应该很好杀掉”<br>“你是不是也知道金山大师的去向啊？”<br>“我去调查一下，知道了就告诉你”<br>猫儿心不在焉<br>（我的任务是加重骚乱，引发战争）<br>战事拖长，战争形势扩大，如果节度使们不出兵，就无法完成慕容贵妃的野心<br>林灵素用怀疑的目光凝视着猫儿的脸。<br>“慕容贵妃的真正目的是什么？”<br>猫儿咂了咂嘴。<br>“磨磨蹭蹭的，会来不及的”<br>与贵妃相似的狂妄的口吻触动了林灵素的肝火<br>“你曾经是那人的弟子，那个契丹人……是叫狐狸还是狗来着？”</p><p><img src="/upload/pasted-221.png" alt="upload successful"><br>“白骨猫”【这个人是绘卷水浒自创人物，是个忍者类型的，也是喜欢四处搞事】<br>“对了，那人可是个高手，飞刀，投毒，化妆都样样精通，当年不就是她，化妆成侍女‘月仙’，让王皇后吃下毒月饼，你怎么不化妆成个尼姑把公主杀掉呢？”<br>“师父是师父，我不像她那样，但是问题不大，赶紧派人追公主吧”<br>扔下这句话，猫儿又从达摩堂无声地滑了出来。<br>她躲在院子中的松树梢上观察着【也不知是个什么操作……】不一会就有五十人的队伍出发，看到这个，猫儿离家少林寺，躲着士兵的监视，就这样悠闲的下了山<br>（可怜的金奴公主）<br>猫儿手中握着一个红衣布娃娃<br>猫儿也从师父“白骨猫”那里学来了化妆术，小时候曾化妆成小宦官潜入后宫，向慕容贵妃递送情报的也是猫儿<br>她还记得陪她一起玩耍的金奴<br>猫儿偷了玩偶，金奴还护着她<br>（我不能违抗贵妃大人……但是我绝不会杀你的）<br>猫儿深信不疑，这至少是一种“友情”<br>（再见了，金奴公主）<br>猫儿拿着娃娃走在耀眼的阳光下。然后，忽然觉得听到风的声音，想回头看向后面。<br>她的瞳孔，突然扩大了，下一个瞬间，猫儿的头就被砍下了，像皮球一样滚在地上<br>手中握着的玩偶，不可思议的睁开眼睛，映照着晚夏的蓝天<br>“你已经杀掉那个女孩了吗？”<br>林灵素看着手持沾满鲜血的弯刀的怪道士，皱起了眉头<br>“贵妃的目的还不知道，所以还不到杀她的时候啊”<br>“知道秘密的人越少越好”<br>兜帽下的怪道士似乎在嘲笑林灵素的懦弱<br>林灵素也没在说什么了<br>追兵应该已经追上金奴公主了吧<br>“通真达灵元妙先生”林灵素也在一点点的接近成功</p><hr><p>薛永和银树在山脚的农家下借了匹马，取道向东<br>金山大师告诉他们家中种麻的人家寄存着少林寺的马<br>从简陋的马厩中牵出一匹马，是一匹漂亮的白马，用来运送经典，牵引高僧的马车，负责照料的独眼老农说出了它的名字<br>“帕鲁亚提，梵语的意思是‘示现’，你们叫它示现就好了”<br>“示现”是一匹很静的马，但脚力非凡，由于只有一匹马，薛永把银树放在马鞍前，即使载着两人，速度也一点不慢</p><p><img src="/upload/pasted-224.png" alt="upload successful"><br>两个人共骑一匹马在路上奔驰，既不是士兵，也不是僧侣，没有被人追查盘问的担心，在旁人看来，只不过是私奔的年轻情侣罢了<br>从西京洛阳到东京开封，距离四百多里，其间道路平整，骑快马的话半日就能到<br>太白也紧紧跟在后面，突然叫了起来，薛永回头一看，后面尘土飞扬，沙尘越来越近。不一会就能看见人影了，是追兵到了<br>“抓住那个女孩！”<br>“追兵？怎么会有追兵？”<br>箭从他们身边飞过，薛永鞭策马，但已经开始疲惫的“示现”反而越来越慢<br>（这样下去，会被追上的）<br>薛永让银树握住缰绳<br>“练过骑马吗？”<br>“在宫中稍微练过”<br>“太好了”<br>薛永拿起挂着马鞍上的棍子，从开始减速的马上跳了下来，银树马上就知道什么情况了，自己也想从马上跳下来<br>“薛永，我也要战斗”<br>“你赶快沿着路跑吧”<br>前进吧——薛永用棒子狠狠的打了示现的屁股</p><p>银树回头一看，薛永拿着棍子，站在道路中间<br>向要经过的追兵发起攻击，用棍子把敌人从马上打下来，士兵们拔出剑，包围了薛永<br>（薛永！薛永！）<br>“示现”急速的奔跑着，和那个名字正相反，薛永的身姿消失在后面<br>（千万不要死了）<br>银树挥泪向前，风呼啸而过</p><p><img src="/upload/pasted-225.png" alt="upload successful"><br>（谁都不能再死掉了）<br>银树紧握着缰绳，泪珠在风中消散<br>视野逐渐模糊，也看不清楚前方，道路也渐渐扭曲，“示现”正在狂奔<br>奔向让人生厌的东京<br>前往令人绝望的皇宫<br>回到对人无情的父亲身边</p><hr><p>伊水河畔传来轻轻的诵经声<br>这是抚慰受伤的心灵，安抚逝去的灵魂的声音<br>龙门的僧侣，无论是谁都很安定，他们在这里做着最后的法事，即身成佛。必然能在天界轮回。<br>从长安大慈恩寺来的高僧正在木台上说道，周围聚集着从迫害中逃出的信徒们<br>“人最大的罪过就是杀生，而杀生中，杀人是最沉重的罪，这是为什么呢？因为灵魂寄宿在肉体上，是比深海底的神龟每百年上浮一次，被洞中漂浮的木板敲中头部更加难得的奇迹，那么为什么‘贵为人’呢，这是因为人能听取教化，有所领悟，能从轮回当中解脱”<br>夏末的河畔，吹过凉爽的风<br>那里已经是净土<br>死去的心也已经平静下来<br>绝望似乎是甜美的，就这么什么也不做，只是等待着结束而已——临终时，会有乘着五色云彩的佛来迎接他们<br>人们正在默默的诵经<br>鼻腔猛地被浓烈的血味刺激到了<br>抬头一看，也不知哪里来的僧侣，正沿着河岸，朝着石窟进发，一开始看到一个人，接着又看着几个人结伴而来，大家互相搀扶着前进<br>仿佛混淆与亡者之间，疲惫不堪的人们正在游荡，有僧人，有老者，有乞丐，也有武者<br>龙门的人们都忘了诵经，注视着他们的身影</p><hr><p>这一天，梦魇笼罩在皇帝的寝宫中<br>徽宗皇帝被噩梦吓醒，出了一身冷汗。宦官们为擦干身体，换上衣服后，外戚王都尉来了<br>王皇后的哥哥王晋卿是个有才之人，从年轻时代就受皇帝亲信，连寝宫也允许出入<br>“听闻陛下身体不适就赶过来了……陛下身体如何？”<br>在昏暗的烛光中，王都尉正对着龙塌上的皇上低语着什么<br>“不过是一场梦罢了”<br>“嗯……虽然记不清楚但是总感觉看见了冲天的火光”<br>“难道是天神？”<br>王都尉大吃一惊，沉默不语<br>“怎么了”<br>“没什么，不是大事”<br>“你说实话”<br>王都尉带来的小侍从在房间的角落点起了香，甜甜的香味让人昏昏欲睡，皇帝心里却产生了莫名其妙的骚动，根本就无法入睡<br>最近，无论宫中的宴席，还是东京名媛李师师，他都没有去碰，控制着自己的“悠闲自在”，忧虑的事情是在太多了<br>“太子也因废佛而悲伤，卧病在床，大臣中的反对者也很多，宿元景太尉等人，甚至还写了厚厚的奏疏来揭发道士们的恶行，虽然撤销了蔡京但是听说政事也因此拖沓，可是朝令夕改不好吧”<br>“古人云，君子豹变【比喻润饰事业、文字或迁善去恶，出处：《周易·革》】”<br>皇帝含着侍从献上的甜蜜药水，叹了口气<br>“为什么智真会反对？不就是林灵素创造的奇迹镇住了怪相吗，不过是佛道合一，把称呼改变一下而已……这种事真的怨气很大吗？”<br>“陛下能否见上智真长老一面？”<br>“朕吗？”<br>“如果陛下被说服的话，请一定……”<br>王都尉的声音飘飘悠悠，好像很远，又好像很近<br>并且，从很远的地方，传来了如天人般美丽的声音<br>“智真长老到了”</p><p><img src="/upload/pasted-229.png" alt="upload successful"><br>门一开，一只狮子跳了进来，皇帝惊呼一声，吓得后退，咆哮的狮子的鬃毛正在燃烧，其上站立着文殊菩萨，左持莲华，右持利剑，眼睛流露着笑意【文殊菩萨：惊不惊喜，意不意外？（误）】，皇帝却因为极度的恐慌而晕倒了</p><p>醒来时，皇帝已经躺在了床上，有阳光从窗户中射进来，也不知是早晨还是傍晚，不久，郑皇后就来了，这是在王皇后去世后新册封的一个皇后，没能生子，但为人贤良<br>皇帝拉着郑皇后的手<br>“王都尉不在这里吗？”<br>“没有，陛下又做了什么梦吧”<br>问了宦官，也说没人来过<br>“陛下一直在歇息，从未有人打扰”<br>皇后说，来的时候看见了不可思议的景象<br>“在走廊中，看见了一个高个子白衣老者，只是背影，未能看清面孔，简直像天上的云朵，一转眼就消失了”<br>宫中还有那样的老人吗——郑皇后默默的低下了头</p><hr><p>要抵抗到最后<br>怀着这样的决心，逃离少林寺的人们终于到了龙门，他们在解氏兄弟的带领下，傍晚时躲在剑山周边，他们就这样走在人生最艰难的路上，一路疲惫不堪，倒下的人也很多<br>尽管如此，仰望着夕阳下石窟的脸，也是感到很安心和喜悦</p><p><img src="/upload/pasted-230.png" alt="upload successful"><br>龙门石窟是在伊水两岸耸立的岩山上建造的巨大的石窟寺院。<br>开凿于北魏时期，在佛教兴盛的唐朝又建造了很多石窟，大大小小的佛像坐落在岩洞里，墙面画着五彩缤纷的极乐图<br>这人间的极乐世界，不久就会成为大宋佛法断绝之地<br>率领这群殉教者的金山大师，衣服上的血迹已经干涸，手中的般若雷掷地有声，虽然般若雷已经打翻了数十个敌人，但是棒上并没有沾染血迹，正在夕阳下闪闪发光<br>石秀在旁守护着金山大师，史进在队伍尾断后<br>队尾是伤者，由于负伤，移动缓慢，李忠背着彭尼，彭尼看上去十分痛苦，但也不曾落泪<br>他们翻山越岭，道路渐渐平缓，能看见山脚的平原了，斜坡上已经有了秋天的花，史进摘了几朵悬崖边上的红花，塞给彭尼<br>“……故乡的山上也开着这样的花”<br>虽然是件不值一提的小事，但是彭尼还是很高兴<br>“以前，我喜欢把花插在头发上”<br>“要不要高歌一曲？”<br>已经可以远远看到镶嵌着银边的伊水了<br>龙门周围还没有官兵的身影<br>但是这也只是时间问题了吧</p><p>龙门的石窟寺院中已经来了数百名僧侣，与法难做斗争的人在少林寺，而想要守护经典的人则聚集在龙门<br>现在一汇合，已经有三千多人了<br>这可给隐居于此的僧侣带来不少麻烦<br>他们已经放弃了抵抗，为了成为即身佛而坚持绝食和诵经，已经有人饿死了，被安葬在伊水河畔<br>虽然食物储备很少，但是先下山的乞丐也不知在哪里搞来了食物，除了原有的锅外还用上了青铜香炉，煮着杂粮和豆子混合的粥，巨大的石佛脚下，冒起了热腾腾的气<br>“释迦牟尼之所以敢于舍弃自身，是为了抚慰饥饿的老虎，他的自我牺牲并不是为了拯救迷途的鹿——而是为了成全自己”【没找到这个典故】<br>金山大师给绝食的僧人送上了粥<br>史进等人在大石窟前的车座上，用金盆代锅煮着杂烩粥，乞丐们还不知从哪里搞来了肉和鸡蛋<br>石秀在贡物盘子里盛满了粥，递给鲁智深<br>“最后一餐，爽吃一顿吧”<br>石秀又用勺子在锅底捞出一大块肉，放在史进的盘子里<br>陈达他们默默的吃着，佛像正代替柴火在篝火中燃烧着<br>李忠看着火焰<br>“胜算几成？”<br>杨春回答道<br>“谁还在乎这个”<br>再来一盘——陈达向锅伸出了手<br>鲁智深一边喝着仅剩的一点酒，一边眺望着金色的伊水，沐浴着夕阳，犹如流淌的黄金一般<br>河滩上有人行进着，有僧侣，有信徒<br>金山大师也站在卢遮那佛【龙门最大的佛像】面前，看着它<br>他们是为了死而聚集在此地<br>（不，是为了活下去）<br>直到最后，为了更好的活着，抛弃过去，抛弃未来，只是为了活在当下<br>（如果强大……）<br>大师这样想着<br>大师深信“强大可以战胜一切烦恼”，大师不禁想起了曾经和自己交过手的对手，许多已经不记得面孔了<br>本打算为了追求什么，守护什么而战斗，但现在手里却什么也没有。<br>大师的手静静地胸口上<br>鲁智深手持空葫芦，慢慢的站在大师的旁边<br>“没有酒吗？”<br>金山大师在黄昏中回首，笑了。<br>“有酒的话，会很开心吧。”<br>夕阳无限好</p><p><img src="/upload/pasted-231.png" alt="upload successful"><br>在这无限风光的夕阳之下，自己好像活过来一般，无论是严厉的修行，戒律，冥想，坐禅，都没有真正的解答他的疑惑<br>石窟中，人们为遇难者简单的举行了法事，将剩下的香全部烧掉，香气正在静静的流淌<br>（无论是多么强大，多么有智慧，大概都会输给“非道”吧）<br>这是正是生命的教诲<br>（但是）<br>人——只有“生存”下去，才能被真正救赎吧</p><hr><p>节度使“老风流”王焕正在思考<br>“和尚和道士在打架？这种事在另一个世界也可以做”<br>漂亮的侍女们围着王焕，有用扇子扇风的，有倒茶的，还有剥水果的，心情愉悦<br>“白马寺已经被破坏，少林寺也已经一片火海”<br>“啊，那还真是可怕啊”<br>听到“月李”说的话，“百合”微微皱眉<br>王家上下，从王焕到侍女，大多都信奉佛教，虽然也不是全信，但也是有事没事去寺庙烧上一炷香<br>“已经没有放生的机会了吗”<br>“海棠”也同情这些佛教徒，王焕问身边的部下<br>“太原的徐京怎么说？”<br>“他只是报病‘因病不能上阵’，可是接连不断的传令催促上阵，谁又能违抗敕令呢？”<br>“徐京也是个义侠心很强的男人，一定很为难吧。山西边境上又有契丹人转来转去，徐京管辖内又有个叫田虎的山贼在胡闹。近日，有谣言说要那家伙称王。这时，肯定不想随便离开任地吧。为了道士争夺权力”<br>“芍药”一边为王焕揉肩一边这样想着，青年时，王焕因风流而闻名，他是绝对不会管这种无聊的事的<br>而且，僧侣们败局已定，这是显而易见的<br>王焕手中拿着一个漂亮的梳子，是一个早年间流行的梳子<br>“好，就这么决定了”<br>王焕紧紧的攥住梳子，“牡丹”问道<br>“要去哪里？”<br><img src="/upload/pasted-232.png" alt="upload successful"><br>“当然是龙门了，要着手准备出发了”<br>侍女们熟练的为王焕换上甲胄，“水仙”和“茶花”两人带来了王焕平时爱用的长枪<br>准备完毕后，王焕捋着胡子，大步迈出宅邸<br>侍女耳边响起了王焕豪迈的声音<br>“我就是老将王焕，你们这些人觉悟吧”<br>侍女们都在歪着头，想着同样的问题<br>“老爷要做哪一边的援军呢？”</p><hr><p>银树继续奔驰在通向东京的大道上<br>太阳渐渐倾斜了，已经是下午了，街道上热闹非凡，好像什么事情也没发生一样，人们来来往往<br>人们惊讶的看着拼命抱住马的少女<br>银树所在的尼姑寺当然没有马，但是银树的骑术却很厉害<br>在宫中和哥哥练习骑马的日子好像复苏过来，哥哥因为害怕骑马吓哭了【这里好像是指的宋钦宗吧】，金奴却满不在乎的在御苑中骑着马跑来跑去<br>金奴公主真的是既聪明又勇敢<br>（一定要找到父亲，揭露慕容贵妃的阴谋，阻止官军）<br>银树第一次不是为了亡母而是为了现世的人们生存而奔走<br>白马“示现”马不停蹄，途中，在一个农家得到了水和饲料，就这么一口气跑完了四百里的路</p><p><img src="/upload/pasted-233.png" alt="upload successful"><br>夕阳下，已经可以看见东京开封的城墙了，城门开着。银树从新郑门进入，一面问路，一边跨过州桥，取道大相国寺朝着宫城走去，由于当初出奔时是在深夜，所以这也是她第一次看到东京的街道，绚丽多姿，人山人海，看起来很愉快，似乎从未想象过这个世界上的某个角落会发生战斗。<br>宫城位于开封城的北方，被称为龙台的高台。<br>银树疲劳得几乎要昏过去，竭尽全力走到了宫城。墙壁和瓦片的模样，隐约地存在于记忆中。银树找到门跑了过来。可是，有卫兵，当然，她被拦了下来<br>“我是永德公主，我要见我父亲”<br>她在马上向卫兵通报<br>从马上告诉他们，卫兵们吓得目瞪口呆，但是不一会就回过神来<br>“美丽的公主殿下呀，您找哪位父亲啊？”<br>“这还用说，当然是当今圣上了，赶快开门”<br>卫兵们笑了起来<br>“怎么会有你这么个不整洁的公主啊，太可怜了，脑子出了些问题啊”<br>银树就这样被人泼了盆冷水，赶出了宫门<br>路人也在笑话银树，她就这么默默的走在街道上，头发凌乱，衣服上也沾满灰尘，连个耳环也没有，马具是村民的简陋货，现在这个样子，真的也比乞丐强不到哪里去<br>银树离开宫门，又向人问路，从城内向西走。那是大臣们的宅邸并排的一角，以其中最奢华的住宅之一为目标。可是守门人挡住了他<br>“你个要饭的，滚一边去”<br>看门人还想揍银树<br>“赶紧的，闪一边去”<br>银树又被赶了出来，这时，门开了，出来一只华丽的队伍，打扮豪华的人们骑着漂亮的马出来了，这只队伍中心，有她的舅父——“王都尉”王晋卿<br>王晋卿是亡故的王皇后的兄长，也是皇帝很宠幸的，他有众多护卫，周围又围上来看热闹的<br>银树倒在路上，本想大叫，不想却被看门人用棍子压在地上<br>队伍陆陆续续的穿过东京的街道，王晋卿正直了身子，驱马前进，有一瞬间，目光转向了倒在地上的少女，就这样从她身边经过</p><p><img src="/upload/pasted-234.png" alt="upload successful"><br>(是乞丐吗？)<br>他曾命令对于后门的乞丐，不论谁都要施舍些东西，这个女孩大概还不知道这个规定吧<br>队伍一离开，看门人也放开了银树<br>“赶紧到后门要饭去吧”<br>银树摇摇晃晃的站了起来，她已经走投无路了，连舅父也忘了她。实际上这十年间也没有见过面，也没有写过信，不过是以管家的名义，每个季节在送东西也就仅此而已，明明知道自己在尼姑庵中，却对法难无动于衷<br>十年的时光，足以让人忘记一个不幸的侄女<br>银树感觉到了无力，现在公主已经没有家人了东京百万人，而爱金奴的只有一个<br>（母亲……）<br>刚要哭起来的银树，突然抬起头，像是在寻找着什么，从府邸的围墙的对面，散发出令人怀念的香味。七里香——银木犀的香气。<br>银树咬紧牙关，再次站了起来，队伍已经离开好远了<br>人们都在议论<br>“王都尉要去艮狱了。今天，林教主预言会发生奇迹”<br>“听说皇帝也会御驾前往”</p><hr><p>艮狱是位于宫城东北的大庭园<br>皇帝按照道士的预言建造了园子。园林方圆六里。内部设置了假山、树林、湖沼等。用从全国寄来的奇石和珍奇的植物装饰，又放养稀有动物，使之成为地上的乐园，花石纲的灾难，可以说就是为了营造这个庭院而发生的<br>平时是皇族和贵族官僚的场所，节日有时也对平民开放。<br>今天，皇帝为了让民众看到“天仙的奇迹”，特意开了门<br>在园内的寿山，郭京已经率领众道士等待皇帝的到来<br>今天，在皇帝面前，寿山前的巨大太湖石会粉碎，从中出现青华帝君的玉像，为了表现空中飘动的五色云彩，已经准备了上了色的米粉和仙鹤，正在皇帝为眼前的景象感到震惊时，会有“使者”呈上关于林灵素“谋反已被镇压”的捷报<br>（玉像的脸和林教主一模一样，肯定没问题的）<br>而且，玉像做成了中空的，里面有镜子和蜡烛，双眼看上去应该闪闪发光，郭道士也很擅长这种“表演”<br>（还是要向林教主学习啊）<br>虽然不知道林灵素何时才能取得“实质的胜利”，但是前前后后有这么多把戏，总能说明些问题的<br>（陛下还没到吗？）<br>御门突然变得热闹起来</p><p>皇帝从宫城出，乘着轿子直奔艮狱，宠臣王都尉和护卫金吾部队在旁护送着，带领护卫部队的是金吾将军曹晟，也是皇帝亲信的年轻将校，他的祖父是被誉为“宋良将第一”的曹彬，是一名仁将，拔下城池，却不曾杀过一人，在军中颇有威望，因家族的熏陶，曹晟也是名门子弟中少有的有骨气的年轻人，所率领的部队也都是精悍的年轻人，在他们的护卫下，皇帝的轿子缓缓的向寿山进发<br>道路已经提前清扫干净，周围摆上了兰花，又有孔雀正在啄食。确实是神仙世界的情调，但是，轿中的皇帝脸色并不好<br>跟随的王都尉，为了排遣皇帝的心情而搭话<br>“到底是什么奇迹呢？要是让智真长老也来看看，说不定能改变他的心意呢”<br>“长老已经停止饮食数日，一心念着文殊菩萨，已经到了无法站立的地步”<br>“那么，不远了……”<br>即使皇帝亲自劝说，智真长老也拒绝改宗，他憔悴的样子给了天生感性的皇帝以强烈的冲击<br>自打那天起，皇帝就一直为噩梦所困扰<br>智真长老的背后，冲天的文殊菩萨站了起来，目光炯炯如雷，就这么注视着皇帝<br>（朕，究竟错了什么？）<br>但是今天，如果能看到“奇迹”的话，说不定能解开自己心中疑惑</p><p>队伍正在行进着<br>银树在草丛中爬着，无论如何也要接近皇帝的轿子<br>（即使被杀也无妨）<br>周遭的树枝正刺着银树<br>她突然从草丛中跳出，推开护卫，向轿子飞奔而去<br>“请马上停止废佛，救救大家！”</p><p><img src="/upload/pasted-235.png" alt="upload successful"><br>周围护卫马上反应过来，抓住了银树，把她按在地上，情况突然有变，曹晟拔出剑来，守卫们把银树压在一旁，给轿子开路<br>“陛下，请继续上路吧”<br>皇帝拨开珠帘，露出脸来<br>“什么情况，那女孩是什么人”<br>“也不知是哪里疯掉的乞丐……”<br>皇帝瞥见了正在被按倒在地的女儿的脸，王都尉也觉得很可疑，轿子就这样从银树身边经过<br>银树想放声大喊，但是喉咙犹如堵住了一般发不出声音，银树哭了起来，一边哭一边哇哇的叫着<br>轿子渐行渐远<br>突然停了下来<br>皇帝从轿子中惊奇的看着银树</p><p><img src="/upload/pasted-236.png" alt="upload successful"><br>“是金奴吗？！”</p><p><img src="/upload/pasted-237.png" alt="upload successful"><br>最吃惊的还是银树——金奴自己<br>感到冷寂的十年时光一瞬间散开了，后宫中母亲微笑的脸，父亲抚摸头发的手<br>晴朗的天空，回响着一个声音<br>“……父皇！”<br>皇帝用龙袍擦干女儿脸上的泪水，露出了和去世皇后一模一样的脸<br>皇帝怀抱着抽泣的女儿，望着天空<br>“‘奇迹’说的就是这个吧”</p><hr><p>傍晚时候，东京的郭道士赶紧派人向林灵素汇报了情况<br>结果就是，皇帝并没有看见林灵素精心安排的“奇迹”，却把十年未见的女儿带回了宫中，之后的情况也不清楚了<br>但是知道的情况就是，王都尉，宿元景等“反废佛派”的大臣被召见，因反对废佛而被罢免的蔡京也被招了回来<br>（“法难”就这样结束了吗？）<br>郭道士望着夕阳<br>（不，他们已经来不及了）<br>最后的战斗恐怕已经开始了，或者说已经结束了<br>人少的僧侣们是不可能取胜的<br>（和尚们被全灭，结果还是“废佛”）</p><p><img src="/upload/pasted-238.png" alt="upload successful"><br>与此同时，夕阳也将伊水染成了金色，由于夏季河枯，水量少，它反射着太阳的光辉，显得更加美丽<br>但是，这一带的空气却被杀伐的战尘包围着<br>龙门的僧侣们吃完最后一餐没过多久，林灵素就率领着官军陆续抵达伊水河畔<br>官军在广阔的南岸布阵，龙门石窟建在伊水两岸，卢遮那佛所在的北岸聚集着主要的石窟。僧侣们固守的也是这个北岸。<br>最后的僧侣向龙门进发的消息很早就到了林灵素耳朵里，他在等着全部的僧侣聚集到龙门，如果“叛军”人数较少的话，即使全歼，也没什么意思<br>林灵素打算渡过伊水，直攻北岸<br>龙门石窟是著名的佛教圣地。作为佛法灭亡的舞台是无可挑剔的。而且，战后，作为“林灵素奇迹的圣地”，应该也会名留青史吧。<br>“那些节度使，已经指望不上了”<br>林灵素很得意，除了一万五千个官军之外，还聚集手下亲信的道士，组成了名为“六甲神兵”的亲卫队，其中人戒着道袍，以铜剑为兵器，为了防止有奸细混入，这里只有有道观度牒身份明确的道士<br>“这也是一万五千人”<br>林灵素在手下的道士面前。骄傲的宣言道<br>“明天，就是大宋佛教存在的最后一天了”<br>也是自己成为这个国家的“神”的日子</p><hr><p>夜无声无息的深了下来<br>夜空的星星，不知是为战争的气息而战栗，还是感到人们的不安，总是不停地闪烁着。<br>星空之下，史进正掰着手指头盘算着<br>“敌人是三万，我们是三千……不”<br>在昏暗的灯光照耀下的石窟中<br>“能够上阵的也就两千”<br>石秀啃着作为供品留下来的水果。李忠向史进也扔了个果子。<br>“和尚们也未必都能战斗，也有很多伤员啊”<br>“我要战斗”<br>莫志断然的说道<br>“吐蕃的法僧，拉金帕尔马德鲁杰，用弓箭杀死了坚持废佛的王，挽救了佛法。他没有受到佛罚。而被誉为圣人。我也会战斗的”<br>灯油快烧完了，火苗飘忽不定的摇摆着，在这缥缈的灯火下，佛像的表情看上去很不可思议<br>此后，以金山大师为中心，召开了短暂的军师会议，分发了全部的兵器，战斗准备完毕后，史进最后去看望了彭尼<br>星空之下，石窟终于迎来了短暂的休息时间<br>彭尼和其他伤员一起被运进岩山上方的石窟。僧尼们用途中得到的一点草药，尽可能的治疗<br>史进单膝跪在躺倒在地的彭尼身边<br>彭尼很平静，不过脸却因为失血而显得很苍白，石窟墙壁上画着的阿弥陀如来，供奉着红色的曼珠沙华。<br>彭尼注意到史进过来了，缓缓睁开眼睛<br>“真不好意思，这次不能战斗了”<br>史进扶起彭尼的身体</p><p><img src="/upload/pasted-239.png" alt="upload successful"><br>“你要是个男人的话，我们说不定会成为拜把子兄弟”<br>“我也这么觉得”<br>“还讨厌男人吗？”<br>彭尼仰望史进的脸，微微一笑。<br>“我本是樵夫的女儿。十三岁的时候，在山上，杀死了袭击父亲的猛虎，作为孝女受到了表扬……村里也立起了牌坊，知府就像列女传上所记载的那样，在朝廷上奏，但是，结果就是有个混蛋当官的要求‘把那孝女收做妾’罢了”<br>“所以就当了尼姑？”<br>彭尼把眼光转向了红花，花瓣被夜露打湿了<br>“救赎的是今生，还是来世？”<br>“的确啊，但是我只能帮助活着的人”<br>在没有颜色的石窟中，只有花朵娇艳的红色。两个人默默地凝视着花朵。<br>彭尼闭上眼睛喃喃道<br>“希望金奴公主能够幸福”<br>“原来如此，希望你也一样”<br>彭尼好像睡着一般，周围的尼姑们也开始默默的诵经祈祷<br>史进一出石窟，星光炯然。<br>也不知哪里的石窟传来了雕刻的声音，史进还没有找到王进，但是，他能感觉的到，师父就在身边<br>夜尽天明，最后的战斗就要开始了</p><hr><p>紫气东来，天已经亮了</p><p><img src="/upload/pasted-240.png" alt="upload successful"><br>黎明，本是一天中最具有生机的时候，也是充满喜悦的时候<br>太阳毫不吝啬的将阳光倾洒在伊水两岸的每一个身上，南岸的官军正在埋锅造饭，北岸的僧侣开始了诵经<br>不久，官军陆续抵达，填满了南岸的河岸，僧侣们诵经的声音在平静的波纹间静静的流淌着<br>庄严肃穆的诵经对于林灵素来说，是刺耳的杂音<br>“看来这些谋反的和尚已经有所觉悟了，赶快送他们上西天吧”<br>官军方面也很清楚自己是三万对阵和尚们的三千，他们悠然的向着河岸行进着，伊水由于夏季干枯，水量减少，很多地方水不是很深<br>“一口气跨过去！”<br>部队行进呐喊的声音一下子就把诵经的声音抹杀掉了<br>先锋是五千洛阳军队，后面跟着一万禁军<br>林灵素心情平静，虽说是“初阵”，尽管不知行军打仗的策略，但是手下有众多将军帐前听令，又有一万五千的“六甲神兵”护卫<br>这将是通向荣光的黎明<br>（东京，也事先准备了“奇迹”）<br>昨日，在东京的皇帝眼前，出现了和林灵素一模一样的“青华帝君”，同时也有“谋反已经被镇压”的捷报，相信不久，赞誉“通真达灵元妙先生”的特使就要到了<br>（在敕使到达之前，必须结束这场战争。）<br>林灵素站在本阵的高台上，向前挥动着手中的拂尘</p><p><img src="/upload/pasted-241.png" alt="upload successful"><br>（占领石窟，竖起太极旗帜，拆了那卢遮那佛）</p><h1 id="下集预告"><a href="#下集预告" class="headerlink" title="下集预告"></a>下集预告</h1><p>第六章 月下天堂 预告</p><p><img src="/upload/pasted-242.png" alt="upload successful"><br>佛教最后的堡垒——龙门，此地将为最后的灭佛战场，官军三万对阵僧众三千<br>“末世降临了吗？”<br>龙门石窟前喊声震天<br>“九纹龙”史进，“花和尚”鲁智深等梁山众好汉战斗在最前线<br>准备趁乱夺取少林秘经《精武大宝经典》的“一块云”满天星也在盘算着<br>皇帝会听取“荣德公主”银树赌上性命的请求吗？<br>最后王进和史进师徒两个能否重逢？<br>以废佛为开端，道教和佛教的最终对决，最终取胜的，到底是——<br>《绘卷水浒传》20周年纪念企划，下回完结</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第五章-龙门决战&quot;&gt;&lt;a href=&quot;#第五章-龙门决战&quot; class=&quot;headerlink&quot; title=&quot;第五章 龙门决战&quot;&gt;&lt;/a&gt;第五章 龙门决战&lt;/h1&gt;&lt;p&gt;天刚微微亮&lt;br&gt;山间灰蒙蒙的，在漫天飞舞的朝霭中，史进他们被敌人包围着。&lt;br&gt;看着般若雷
      
    
    </summary>
    
      <category term="绘卷水浒传" scheme="https://www.junglezero.top/categories/%E7%BB%98%E5%8D%B7%E6%B0%B4%E6%B5%92%E4%BC%A0/"/>
    
    
      <category term="绘卷水浒传 二十周年番外" scheme="https://www.junglezero.top/tags/%E7%BB%98%E5%8D%B7%E6%B0%B4%E6%B5%92%E4%BC%A0-%E4%BA%8C%E5%8D%81%E5%91%A8%E5%B9%B4%E7%95%AA%E5%A4%96/"/>
    
  </entry>
  
  <entry>
    <title>绘卷水浒传 第一回 王进 翻译</title>
    <link href="https://www.junglezero.top/2019/03/12/%E6%B0%B4%E6%B5%92%E4%BC%A0-%E7%AC%AC%E4%B8%80%E5%9B%9E-%E7%8E%8B%E8%BF%9B-%E7%BF%BB%E8%AF%91/"/>
    <id>https://www.junglezero.top/2019/03/12/水浒传-第一回-王进-翻译/</id>
    <published>2019-03-12T10:49:00.000Z</published>
    <updated>2019-03-18T08:42:24.691Z</updated>
    
    <content type="html"><![CDATA[<p><font color="#FF0000">原文作者 森下翠和插画作者 正子公也 版权所有<br><br>个人翻译<br><br>仅供个人娱乐及同好者欣赏<br></font><br><br><br><a href="http://suikoden.com/" target="_blank" rel="noopener">原文地址</a></p><hr><p><img src="/upload/pasted-136.png" alt="upload successful"></p><h1 id="第一回-王进"><a href="#第一回-王进" class="headerlink" title="第一回 王进"></a>第一回 王进</h1><p>茫茫黄沙间，走来一人<br>但见此人一身灰尘，头发凌乱，腰间挂着一柄长剑，如此而已，并无其他零碎，不时的看向远方，便低头接着赶路<br>太阳正当空<br>远处的树林传来蝉鸣<br>突然，这人停了下来</p><p><img src="/upload/pasted-137.png" alt="upload successful"><br>一个，两个……数到第十个人时，他下意识的拔出腰间的剑</p><p><img src="/upload/pasted-138.png" alt="upload successful"><br>“王进！”<br>干涸的大地上卷起的杀气，好像遮住了太阳一般<br>“觉悟吧！！”</p><p><img src="/upload/pasted-139.png" alt="upload successful"><br>飞扬的尘土中杀将出几人，片刻时间，此人已经干净利落的右出一刀，劈开一个敌人，尸体落在沙尘中，蝉鸣戛然而止<br>此人轻轻的垂下沾满鲜血的剑，伫立在杀气腾腾的包围圈中<br>这群刺客，大概有十四五个人，他们就围着此人，心里算着距离。尽管都有些身手，但也没有人贸然行动，盛夏的烈阳照在他们头上<br>此人的脸上滚过一滴汗珠<br>“就这么一个禁军教头……”<br>在要沸腾的空气中，此人——王进眯着眼睛<br>“到底值多少钱？”<br>剑开始动了，刺客们也行动起来，王进一弯身子，躲过了头上闪过的白刃，又反手出剑杀死了他，剑落下时一个拖刀又杀一人，他精准的砍向要害，招招毙命。面对更多的敌人，也是一击制敌，一点不拖泥带水。这是他长时间逃亡时学会的招式，不断的有剑刃逼近，暗出，还击，弹起，王进犹如死神附体般且战且停，不断的杀死着敌人</p><p><img src="/upload/pasted-140.png" alt="upload successful"><br>就这么战斗着，越发觉得手上的剑变得越来越重，顺手杀死背后袭来的敌人<br>就这样，也不知杀了多杀人，也不知还要杀多少人才能结束<br>这次战斗时间很长，以前从未有过<br>他的嗓子犹如着火一般，气喘吁吁着<br>一人一边叫喊着一边拿着长枪突杀过来，王进好像无法躲避一般，就在即将被刺中的一刹那出剑，砍向这人的腹部，由于这人反应迅速，本来要砍向鸠尾，却只砍到了肋骨，王进迅速扫到他，顺势骑在他身上，用身体的重量结果了他<br>颈椎破碎的声音，在远方微妙的回荡着<br>男人痉挛，停下了动作<br>王进用剑支撑着强站起身来<br>太阳愈发耀眼<br>尽管如此，热气消散后，背上却用一种毛骨悚然的冷颤<br>周围已经陈列着超过十具尸体<br>本以为终于结束了，却突然从角落里感到了什么，又重新拿起剑<br>只剩下一人了，似乎是这群刺客的领头人歪着脸笑了起来，他在远处望着手下们的死去，看着王进一点点体力不支<br>王进慢慢的转动脖子，低头看了眼手中的剑，剑上已经满是鲜血。他就这么站着，也没什么反应<br>（——终于要结束了吗？）<br>已经三年了，他已经逃亡了三年了<br>终于，走到这里，在这片无名的荒野丧命<br>赢了的，究竟是自己，还是“那个男人”——<br>刺客面无表情的握着剑<br>闪耀的太阳，太阳下反射阳光的刀刃，渗入王进的视野<br>突然听到起风了，风中夹杂着什么声音<br>好像有什么人呼唤着王进</p><p><img src="/upload/pasted-141.png" alt="upload successful"><br>应该还能打<br>他是这么想的<br>风在清吟着，王进只觉得自己轻飘飘的，好像长了翅膀飞起来一样<br>王进本想站起身来，看看谁在唤他<br>可身体却重重的摔在了黄土上</p><hr><p>浓雾之中，王进强站起身子<br>眼前白茫茫的犹如流水一般<br>本来想隔着雾看看远处，忽然听到什么细碎的声响，也不知从哪里滚过一个小东西</p><p><img src="/upload/pasted-154.png" alt="upload successful"><br>低头一看，那是个花绣球<br>王进伸出手，打算捡起那个滚到脚边的球<br>但是手无法动弹<br>雾气越来越深<br>不安感像波浪般涌来<br>不久昏暗就变成了黑暗，只有脚边的球奇异的亮着，王进呆呆的看着那个熠熠生辉，向有生命一样飞来飞去的球<br>突然，包围着王进的黑暗消散眼前突然浮现出刺眼的七色彩虹，锐利的光芒贯穿双眼<br>（住手……啊！）<br>王进猛的惊醒<br>发现自己躺在柔软的床上，傍晚柔和的夕阳正透过窗帘射进屋里，窗边插着一只野花<br>他听见了少女的声音<br>“大侠，您醒了吗？”<br>下意识的想要爬起来，右肩膀却突然疼了起来，裹着的布上渗出殷红的鲜血<br>枕边站着一位貌似是小间使的少女。少女服侍王进躺下后，对着庭院用快活的声音呼唤着。<br>“大老爷，客人醒了”<br>王进环视四周。<br>（这里……）<br>这个小客房配备了一些简单的家具，应当是在某个富庶人家，枕边的长桌上，放着王进的剑，但是已经被擦拭干净<br>门打开了，屋外是宽阔的庭院是，虽然是田舍的构造，但是已经经过了精细的装修，花绿相间，生机盎然，不久，花丛之间，出现了一个白胡子老人，看着大概六十多岁，是个面向温和的老人</p><p><img src="/upload/pasted-155.png" alt="upload successful"><br>“不要硬撑着”<br>想要从床上爬起身子的王进，被老人赶忙制止了<br>是个稳健，善良的老者，可王进还是无意识的估量着自己与剑的距离<br>老人自称是这华阴县史家村的村长，人们都称作史太公，好像颇有些资产<br>“老先生，您救了我？”<br>“不，是拙子救下了你”<br>“令郎？”<br>“唉，是个不争气的孩子啊”<br>老人一边这么说，一边笑了起来<br>“单字一个进，虽说是独生子，但从来不帮忙家事，只只由着自己的性子，真让人头疼，今天带着家丁出去打猎，偶然间遇上了大侠”<br>老人眯着眼睛点了点头<br>“被强盗袭击，真是不幸啊”<br>老人把椅子拉过来，坐在王进旁边<br>“一会让他过来跟您打个招呼，他身上刺着九条龙，那是我特地从城里找来的纹身师绣上去的，做的很漂亮，人们都叫他‘九纹龙’<br>王进答谢了老人，并告诉老人他本是客商，姓张，正打算去延安府做生意”<br>史太公大方的点了点头<br>“您现在身受重伤，哪也去不了了，还是养些时日，过后再上路”<br>“给您添麻烦了”<br>“要是招待不周的话，会被我那儿子数落的”<br>老人笑着走出房间<br>（看来通缉文书还没到这边）<br>王进取过剑，看了看刀刃还好，就抱着剑睡下了，这是他的习惯<br>怀中抱着剑，王进终于安下心来，把头托付给了枕头<br>院子里树梢上，有一只蝉悠闲地叫着。<br>蝴蝶懒洋洋地在盛开的五颜六色的花上飞去。<br>隐约的花香，混杂在风中<br>王进闭上眼睛，突然，悄悄的拔出剑<br>他听见了悄悄靠近的脚步声，紧紧的握着刀柄，调整了呼吸<br>进来的是一个端着碗的侍女，为了不让药汤撒出来，她慢慢的走过来<br>王进为了不让少女察觉，又把剑放了回去<br>“这药很苦”<br>少女把药汤送到王进的口边<br>王进慢慢地站起来，接过药汤。只是这么一动，全身就出现了尖锐的疼痛。<br>“疼吗？”<br>少女天真地注视着王进的脸<br>“还好——只是稍微有些疼而已。”<br>王进略微踌躇了一下，一口气喝干了药汤。</p><hr><p>已经歇息几日了，王进逐渐了解到这家本是农家，却有着侠义的家风。让来历不明的王进留在这里，并且热情款待，什么也不过问，可以说是很豪迈大气的家风了<br>史太公虽说儿子不久就会过来打招呼，可是丝毫没有那个迹象，王进却比较在意，如果救下了他，那就该知道王进不是什么商人，而那群人也不是什么盗贼<br>有一天，王进问了一个服侍他的侍女<br>“你家少爷，是个什么样的人？”<br>“这个……我不太清楚，因为他从来不跟女人说话”<br>侍女耸了耸肩<br>据侍女说，少爷是个很奇怪的人，和村中任何男人都不一样，一天到晚，只是挥刀弄棒，据说这还不够，他还要四处找旅行的武者带回家，学习新的功夫<br>（原来如此）<br>王进了解了<br>对于武术如此狂热的“九纹龙”，应当对自己也有所期待<br>（但是，我没告诉任何人）<br>即使不知道理由，史太公也慷慨相待，进出房间的也只有侍女，从来没人问过王进的来历<br>秋风初起之际，王进的伤口明显愈合，恢复到站起来在院子里走路的程度。</p><p><img src="/upload/pasted-156.png" alt="upload successful"></p><p>中秋之夜<br>王进坐在皎洁的月光中，大概是三更时间。正房中的中秋宴会也已经结束了，院子里一下子变的静悄悄的<br>王进坐在床上，看着在地板上流淌的月光<br>王进慢慢拔出了剑，月光散落在被磨平的刀刃上，轻轻一挥，风在清吟，光在摇曳<br>在白银般的光芒中，他看见了血<br>他看见的，是至今已经倒下的追杀者的血，以及今后自己所流淌的血<br>也许是飘来一块云，屋中暗了下来<br>王进收起剑，扛起行李站了起来<br>伤的最严重的肩膀还没有痊愈，但是应该还能战斗吧<br>王进瞥了一眼收拾整齐的床铺，朝门走去，突然站住了，朝着熟悉的小房间看了看。院子里虫子在叫。<br>王进又回到屋中，把剑放在了床上<br>满是划痕的剑鞘，磨损的剑柄——那是王进如生命般宝贵的东西。不过，他也没有什么别的东西可以留下了<br>放下剑后，他来到院子中<br>因长期卧病在床而疲倦的身体，清凉的夜风让人心情舒畅<br>王进穿过树林，悄悄地走着，王进在安静的院子中寻找着大门，不久，停下了脚步<br>从什么地方传过来切开空气的声响，那是在拱形墙的深处的中庭里传来的，王进悄悄挨了上去，从围墙往院里看，透过云层的月光，浮现出几道黑色巨岩的影子，有一个白色的身影在岩石间跃动<br>这时，一阵凉风吹动了月亮上的云彩<br>射过来一道月光<br>王进不由的屏住呼吸<br><img src="/upload/pasted-157.png" alt="upload successful"></p><p><img src="/upload/pasted-158.png" alt="upload successful"><br>那是月光下跃动的龙<br>（“九纹龙”——）<br>那是个背上刺了九条龙，看上去不过十七八岁的年轻人，光着膀子，手上拿着一根齐眉棒子，九条龙犹如白玉一般在年轻人背后跃动着<br>（这就是——史进吗？）<br>每次一动，栩栩如生的龙就会飞跃起来，从身上升起的热气反射着月光，仿佛全身都闪耀着光芒。<br>王进驻足侧耳倾听棒子切断的风的轰鸣，注视着年轻人跳跃的样子。<br>只是，他皱着眉头<br>“……真可惜啊”</p><p><img src="/upload/pasted-159.png" alt="upload successful"><br>年轻人突然停了下来，慢慢的在月光中回过头来，眼睛有明显的敌意</p><p><img src="/upload/pasted-160.png" alt="upload successful"><br>“是谁？”<br>王进后悔自己说了话，本想就这样默默的离开，可年轻人若无其事的走向王进，反而挡在他的前面<br>“你刚才说啥？”<br>“动作很优美，但这不过是追求虚荣艺人的奇巧罢了”<br>“那你让我领教一下你的手段”<br>年轻人——史进拿起靠在墙上的棒子，向王进扔了出去。王进并没有理会，棒子打在王进的肩头，应声落地<br>“哼~”<br>史进手扶着腰，用冷漠的眼光瞥视了王进的肩膀。<br>“赢了受伤的人，也没什么可骄傲的啊”<br>“强大可不是用来骄傲的”<br>“你说什么？”<br>史进止步不前，回头一看，说时迟那时快，王进用鞋尖轻巧的挑起滚在地上的棒子，左手迅速抓住棒子，就那样朝着史进的脸上扔去，犹如有生命一般神速飞出的棒子，突然在距离史进鼻尖半寸的地方紧紧地止住了<br>“——去捡根棒子”<br>王进的低沉声音在月下回响。<br>史进凝视着王进的眼睛，弯下膝盖，捡起棒子<br>“来吧”<br>王进一下子收回了棒子，这次又向史进的肚子攻来，史进向后一倾，迅速躲开，不料王进马上用回转的棒子扫到了他的侧腹，史进无法承受那种速度，快速向后躲去，两人的距离比棒子的长度要稍大一些，因而，史进放松了警惕，准备起身攻击时，不想王进却迈出一步，手中的棒子也飞了出来<br>不会达到的吧</p><p><img src="/upload/pasted-161.png" alt="upload successful"><br>还在想着，棒子就打到了史进前胸，史进漂亮的躺倒在地<br>“‘飞龙登门’这样可以使棒子的长度当原来的两倍来用”<br>王进只是用两根手指夹住棒子的一寸，支撑着八尺多的棒子<br>史进凝视着王进的脸。<br>“你腰的位置太高了。集中精力于丹田，腰落下，依靠肚脐处的力量站着就好了”<br>王进淡淡的说着，把棒子放回了武器架。<br>“直觉也好，气魄也好。只要有合乎道理的排练技巧，就一定会变得更强”<br>“还能比你强吗？”<br>“啊？——那是一定”<br>“那么，可以收我为徒吗？”<br>史进站起身来，在玲珑的月光下，不情愿的行了徒弟礼<br>“我曾有过许多师父，但你是第一个让我感觉必须要拜为师父的”<br>王进抬头仰望月亮。<br>漆黑的天空皎洁的月亮既美丽又无情。<br>王进深深地叹了一口气。<br>“那么，首先别再叫‘你’了”<br>“我还不知道师父的真正名字”<br>“姓王，名——和你一样”</p><p><img src="/upload/pasted-162.png" alt="upload successful"><br>“王……进”</p><p><img src="/upload/pasted-163.png" alt="upload successful"><br>王进笑了起来<br>三年来第一次笑</p><hr><p>史进大吃一惊<br>史进看见王进正面打倒了十几个人，知道他的厉害。可是，作为师父，他的指导却和史进以前遇上的那些师父截然不同，不，在史进看来，这种教育方式并不是“指导”,以前的师父大多都是先传授华丽的“必杀技”和“绝招”，可是王进，别说招式，就连棒子也不让史进碰<br>把石头放在腹部训练腹肌；倒立，单脚站立；在院子中奔跑一整天，抬着水桶在圆木棒上走；也曾练过“筷子夹豆子”，右手在锅中夹起豆子，然后左手握住筷子放回去<br>起初史进也是默默的按照王进的命令做下去，但是一个月后，史进终于受不了了<br>那天，王进交给史进木头和小刀，让他刻龙，史进刻出来的却像蛇一样，莫名其妙的东西，又刻了一次，但是无论怎么刻都不成型<br>史进终于扔下木头，瞪着王进的脸<br>“我可不是为了干这个才认你为师的”<br>王进端详了史进一会<br>“那你去把棒子拿过来吧”<br>史进取来棒子后，王进说你做个样子看看，史进展示了几个拿手的招式，不一会，脸逐渐阴沉先来，撇下了棒子<br>“怎么了，继续啊”<br>“不行了”<br>史进抱怨道<br>“完全没有感觉了，一个月没碰，身体的感觉已经没了”<br>史进瞪着王进的脸，修行好几年的成果，仅仅一个月，就因为这种莫名其妙的训练废掉了<br>王进慢慢弯下腰，拾起棒子<br>“——这样就对了”<br>“你什么意思？”<br>王进向准备反驳的史进打了一棒，用的正是在中秋夜的那招“飞龙登门”，只是这次，史进不过后退了四五步而已，没有滚到一边<br>“腰力有些长进啊”<br>史进低头看自己的腹部，觉得好不可思议<br>“你究竟……”<br>“你问题太多了”<br>史进赶忙闭上了嘴<br>“你所谓的技巧，全都是习惯罢了，因为你以自己的方式掌握了诸多门派不同师父的技巧，如果不消除这个习惯，你是绝对不会变强的，所以我才说那样就对了”<br>王进继续说道<br>“首先要彻底掌握基本的身形”<br>王进开始演示基本三十二形，史进也在一旁模仿起来，无论哪个动作，乍一看都是基本的身法。王进对史进手腕和脚的位置进行了严格的修正。接下来是坐在椅子上练习二十四形，通常的棒术，都是为步战做准备的，可是，王进的流派却包含了马战。花了两个月的时间，史进终于掌握了全部的基本身形，可以开始对打形式的练习了</p><p><img src="/upload/pasted-174.png" alt="upload successful"><br>现在的史进，对自己很有信心，但是无论试多少次，史进的棒子都无法触及王进的一根毫毛，史进已经无数次的被王进击倒，一站起来，脚又被打，又摔倒了。尽管如此，史进也没有放弃，一天之内，被打倒数百次，即使全身都是伤，也还是默默的练习，在王进说好之前，即使被打的失去意识，也不会停歇，倒了一会后又站了起来，摇摇晃晃的，但那张脸却让人很感兴趣<br>（可笑的家伙）<br>王进坐在庭院的石头上，专心致志的看着已经初具形态的年轻人背后跃动的龙<br>雪悄悄的下了起来</p><hr><p><img src="/upload/pasted-175.png" alt="upload successful"><br>岁月转眼即逝，冬去春来，又是一年<br>对于王进来说，这是一个久违的平和的春节，元旦的早晨，身着盛装的史进来到王进身边致辞<br>这一年，史进已经十八岁了【看看人家十八岁，再想想自己-_-|||| 】，少年的身形和相貌一天天发生着改变，最大的变化则是武艺上的精进<br>史进是王进所看重“练武奇才”，尽管已经修炼多年，掌握了基本的招式，可他还是坚持了王进的高强度训练，史进也向王进展现了自身惊人的进步<br>不过，还是史进自己最为感到吃惊<br>起初，也是不知道自己该干什么，只是一味的模仿王进，但是，有一次，史进终于领悟了，棒子可不是以前认为的“物”,而是自己身体的一部分，从棒子到腕，胸，腰，足，零散的部位合为一体，自由自在的行动，不用太用力，就能比以前更快，出力更大，现在用起棒子来，就如同呼吸一般流畅自然<br>（师父毕竟不是一般人）<br>王进不仅擅长棒子，十八般兵器样样精通<br>除了棍子外，剑、枪、矛、戈、戟、鞭、简、弓、弩、斧、锤、链、扠，矛，白打，根据流派不同，着十八样技能成为十八般武艺<br>从正月开始，王进除了棒术外，也开始传授这些武艺，史进几乎一整天都在和王进训练，如果是一般人的话，即使是一样兵器也需要数年才能学成，但是现在，史进无论学习什么武艺都如同水渗沙子一般领悟的很透彻<br>不久已经是梅花盛开的时节，史进的武艺已经相当成熟了<br>今年庭院中红梅初开时，史进首次在练习中打中了王进的手腕<br>从开始练习已经四个月过去了，这是史进第一次打中王进，是真的第一次，史进大吃一惊，但是，比他更吃惊的是王进，史进飞升的速度，已经超过了王进的预想<br>正如史进第一次尝到武术的神秘一样，王进也第一次感觉到喜悦<br>一天傍晚<br>为了进行练习，王进总在院子中等着，可今天的史进却一副心神不定的样子<br>“怎么了？”<br>王进问道，史进从怀里取出一张纸，是华阴县县衙下发的通缉文书，写着抓捕少华山山贼的奖金<br>“头目三人，共值三千贯，他们可真的不值钱啊”<br>史进放下了通缉文书，拿起棒子练习起来，但是总是无法集中，王进察觉到了这一点<br>“你隐瞒什么了吗？”<br>“没有什么”<br>王进坐在庭院中的石头上，就那样看着史进，面对这种观望，史进最终从怀里又取出一份文书<br>“……是我吗？”<br>通缉文书上盖有东京开封府的章，有人的面孔特征和罪状，那张脸毫无疑问是王进的<br>“原禁军教头王进，犯有盗窃，杀人，欺诈，通奸……奖金已经增加到了五千贯吗？”<br>王进已经意识到是时候要离开了<br>王进将通缉文书还给史进，拂袖而去<br>“我已经没什么可以教你的了，明日便启程离开”<br>“我可不信这个文书”<br>史进跟在王进后面<br>“追杀师父的那些人，已经被我们埋在了树林里，剩下的一个大汉，也被我射杀了，因此，没人知道师父在这”<br>王进停下脚步<br>“为什么现在才告诉我？”<br>“我不想对师父做忘恩负义的事”<br>“你已经成器了”<br>“能教导你，实属荣幸”<br>史进从未见过王进如此平静，王进背对着史进，又重新回到远方，无名的不安感，冲到了史进的胸头<br>“——师父！！”<br>王进终未回头</p><hr><p>第二天早上，东方天空刚刚泛白之时，王进已经打点好行装，站在门口<br>初春大气清凉，星光闪耀<br>昨晚，他向在冬初染上风寒，至今仍未康复的史老太，侍女也过来送别，但是，却没有看见史进的身影<br>（心里不痛快吗？）<br>王进微微一笑，快步离开了宅邸<br>过了一会儿，路边的树荫下出现了人影。王进手持剑，快步奔跑<br>“师父，我也跟你一同去”</p><p><img src="/upload/pasted-177.png" alt="upload successful"><br>史进出现了，他拿着棒子，提着行李，也是一身准备出远门的行装<br>“你也想让人追杀吗？”<br>王进冷冷的说道<br>“通缉书上描述的罪状，我一点也不相信，师父不会做那些无聊的事的”<br>王进脸上笼罩着阴影<br>“那么，我到底做了什么，你知道吗？”<br>面对王进不寻常的声音，史进停下了要迈出的脚步。</p><hr><p>王进徐徐道来<br>那是在距今十几年前的时候，那是王进和现在的史进同龄<br>王进也有个师父<br>名叫王升<br>并没有血缘关系<br>王升是王家棍法的第三十六代传人，王家棍法并不是为世人所知晓，因为继承者大多隐姓埋名，打着别家流派的幌子，暗中从弟子中选出一人传承<br>正确的叫法应该是王家春秋棍法，据说起源于春秋末期的乱世。棒法是枪尖被敌人砍掉时，为了继续战斗而诞生的武术。没有刃的武器，可以保护身体，但不能杀人。<br>可是，王家的棍法打出的却是取人性命的招式<br>如果正是天下太平，那么就要把这种必杀技传承给正确的人，他们不问血缘关系，只是从王姓人中选一个人品能力都很优秀的人作为传承者，王进就是被选中的，也是“奇才”<br>“王进啊”</p><p><img src="/upload/pasted-180.png" alt="upload successful"><br>在昏暗的武馆中，老师父对王进说道<br>“已经没有什么可以教你的了”<br>那是王进已经完成所有修行的日子<br>“你现在已经比我强多了，过去的三十五个徒弟，恐怕比他们任何一个人都要厉害。但是，这种强大对你来说却是危险，这种强大折磨着你，恐怕会毁掉我们王家棍法”<br>王进默默的低下头，他被禁止和武馆其他的同辈对决，只能和老师父一起修行，即使是这位老师父，和王进对决不过三胜一，王进即使被说强，也没有感觉<br>“你的使命是传承，为了应对接下来的乱世，传承王家棍法，不要去战斗——你可千万要谨慎而行啊”<br>当王进成为第三十七代传人后，王升好像完成使命一样，不久离开了人世<br>之后，王进成为了禁军教头，所谓禁军，是指直属于皇帝的亲军，进入枪棒班进行教授，是为了生计，也是为了寻找下一个继承人。王进教的大多是下级士兵，是贫困人家的次子，三子，很多都是只会炫耀本领的流氓，能够继承王家棍法的人，怎么找也找不到，也并不是，只有一个“奇才”，可这人姓林不姓王<br>王进按照他的方式热心的教导他，心中却空落落的，就这样，一天天的过着<br>不知不觉，王进就把继承人的事给忘了<br>那是某年春天<br>王进完成公务，正要回家时，看见桥边人山人海，人海之内，传来年轻人欢乐的笑声，好像在进行着什么比试，王进家在桥对面，无意间拨开人群，走到近前<br>在桥上，五六个年轻人围着圈站着，都是有钱人家的纨绔子弟，在他们之间，一个球飞来飞去。原来是在玩蹴鞠，只用脚，且能保证球不落地的传递，是最近流行的玩法，踢皮球的招式也很多，飞起来踢，反身踢<br>为了玩而妨碍人们过桥，这群人真是很烦啊，还有人们怎么不过去呢，也是不可思议。这样想着，王进上了桥<br>年轻人一直在踢球，王进又发现一件不可思议的事，有老人的哭泣声混杂在年轻人的声音中，近前一看，才知道理由，年轻人间，有个老人在地上打滚<br>王进也曾见过，是街边唱小曲的瞎老头，已经八十多岁了，衣服破破烂烂的，总是在桥栏杆旁坐着，王进也曾给过好几次钱，也不知老头从哪里学来的一手风雅的胡琴<br>有五六个年轻人在欺负老人，踢着皮球打老人，头是十分，脚是二分，他们在比看谁踢的分数高<br>王进走上前去。伸出胳膊，一把抓住了球<br>“如果你们是在闲的没事干的话，就该去学武，皮球不过儿戏，不是男人该学的”<br>“你又是什么东西啊？”<br>王进无视年轻人，把球扔进了河里，卖唱的老人一边哭一边爬到栏杆边，王进本想直接过桥走了，一扭脸，一个球飞了过来，王进一把用棍子把球打在一边<br>踢这脚球的，是一个鼻子略大，眼神让人厌恶的年轻人，大概比王进年轻几岁，一边咬着橄榄，一边慢慢接近王进</p><p><img src="/upload/pasted-181.png" alt="upload successful"><br>“是耍棍子的吗？”<br>男人说着，被抢去球的年轻人围上前去<br>“大哥”<br>“你们给我滚一边去”<br>男人把橄榄扔了，王进迎着男人险恶的目光，他和其他人明显不同<br>“这些是你的手下吗？请不要在做这种事了”<br>“大家只是痛快的踢了几脚球罢了，只是头脑不太清醒”<br>“你们在这里踢，大家过不了桥，而且，那个老人很可怜”<br>“那个老头？”<br>那人哼着鼻子嘲笑道<br>“那我付钱还不行？”<br>“你道歉吧”<br>王进指着靠着栏杆卖唱的老人<br>“道歉？”<br>男人一听来劲了<br>“你跟我说道歉了吗？”<br>手下们哄堂大笑<br>“我昨天揍了我爹三拳都没道歉”<br>男人向手下们努了努下巴，转过身去<br>“走了走了，完全没兴致了”<br>“慢着”<br>王进把手按在这个人的肩上，就在那一瞬间，那人顺手超起栏杆边的棍子，嗖的转了一下，甩开了王进的手，王进意识到这个人速度很快，退过身去，取过棒子。男人扭头笑了<br>以此为号，这群人开始袭击王进，手持棍子，一起打来，王进棒子一闪，扫倒右手边三人，还用手推倒了左手边的四人，王进的棒子宛如活过来一般，击中年轻人的要害，手下们在桥上相继昏倒。这不过是一瞬间发生的事。</p><p><img src="/upload/pasted-182.png" alt="upload successful"><br>王进跨过倒在地下的喽啰，一鼓作气的打了过来，又轻又快，而且，是毫不留情的冷酷打法，是在纵情于痛打对手，彰显自己厉害的，除了在武馆中学到的技巧外，又加入了自己的个人风格。<br>好久没和别人打过了，在武馆时，他从未和王升以外的人对决过，私下的格斗也被严令禁止，现在是禁军教头，也不会个手下的士兵战斗，好久都没有战斗了——不，应该说是第一次，而且，对方是个陌生人，也不知会采取什么样的战斗方式，在十合，二十合的战斗过程中，王进感到了一种不可思议的浮游感【东北话说叫飘了】，一股巨大的力量，从王进到棒，从棒到王进，一直涌现着，此时他心中已经无他，只有全力以赴的战斗<br>王进自己也不知道，不知不觉的展现了自己真正的实力<br>老师父说王进很强，但是，从未和别人对决过的却浑然不知，但是王进现在却感觉到了，包围全身的热气一下子高涨起来，源源不断的集中在棒上<br>那个时候，王进发现了真正的自己<br>那个人倒在桥上，王进的棒子指着那人的眉间，以棒子为中心的区域一点点青肿起来，如果晚一下停下来，那人大概会脑浆迸溅吧<br>那人呆呆的睁着眼睛，愣愣不动，因为吓得失禁，衣服已经湿透了<br><img src="/upload/pasted-196.png" alt="upload successful"><br>人们远离两人，屏住呼吸注视着，这时，王进第一次意识到自己在笑。没有发出声音，只有脸在笑。王进感到恐怖。深深地吸气，吐出。于是，他揪起男子的领子，向老人的地方拖去。<br>“谢罪”<br>自己的声音，听起来像是别人的一样<br>“——对，对不起”<br>那人呻吟地说。然后被手下们带走了。本来，那人想赶走那些想帮助他的手下们，但他已经站不起来了。<br>王进过了桥，回到了家<br>那天晚上，王进想起了老师父亲的话。于是，为了不再用棒子伤害别人，他强烈地告诫自己。<br>王进的日常生活过得很平静。不久时光流逝，桥上的事不知不觉忘记了，那伙泼皮和受伤的老人，也再也没有见过<br>他每天去禁军校场，教导手下新兵武艺，照顾老母的起居生活，就这样过着每一天，要说遇上的不寻常的事，大概就是皇帝驾崩，新皇帝登基，就这样一年后<br>有天，因母亲卧病在床，王进向上级报假，上午，有通报的士兵前来，说是在王进请假期间，他所属的殿帅府的最高长官——殿帅府的太尉换人了，今天是新太尉的就职典礼，说是只有王进没有到，因为新太尉下了命令，又派人来接，王母对犹豫不决的王进说<br>“去吧，新的太尉大人，一定找你有要事”<br>“但是，母亲……”<br>“昨晚做梦，梦见有条龙下到我们的屋顶，一定是好是的”<br>王进煮了药，服侍母亲吃完就去了。殿帅府的庭院中，各级将校整齐的站列着，王进鞠了一躬，打算进入禁军教头的队列，却被左右士兵扭倒在地，被束缚的王进抬不起头，低头跪在那里。<br>遥远的正堂内传来声音<br>“王进吗？”<br>是冷淡的声音<br>“为什么不来本帅的就职典礼”<br>“我已经请过假了，母亲生病了——”<br>“本帅怎么不知道？”<br>当时有很多士兵，官员在场，但是一片冷寂，没人敢为他出头辩解<br>“教头是负有培养对天下有用士兵的重大责任，是奠定军队基础的重要任务，本帅看了你的工作表，结果都是请假，工作态度也不认真，教出的士兵也一无是处，比起其他的教头，成绩也非常差，你这是怠慢值守的重罪”<br>王进懵了，这个新太尉为什么会这么说，简直莫名其妙<br>“我事先请过假了，母亲生病了——”<br>“就算士兵打败仗，也要怪你娘的病吗？”<br>“那是……”<br>“你这厮不该全身心的教导士兵吗？”<br>王进无语了<br>“你这厮如此狂妄，领着国家的俸禄，却不做人事，左右，与我痛打他几十大板”<br>王进不由分说的就被拉下石阶，被杖打着，浑身上下都挨着痛打，这种杖罚，三十下就会失去意识，一百下就会被活活打死，王进受了四五十下，浑身是血，莫名其妙的望着堂中的太尉<br>想要求救，但是没说出口</p><p><img src="/upload/pasted-197.png" alt="upload successful"><br>王进第一次看到新任太尉的脸，那张脸和以前在桥上痛打的那个泼皮长得一模一样<br>在沾满鲜血的视线中，那人露出与当时一样的笑容。<br>王进确认自己注意到的时候，没有发出声音，只是动着嘴低声私语。<br>“谢罪吧”</p><hr><p>史进震惊了<br>“怎么这厮就成了太尉了？”<br>王进也是后来从被人那里知道了来龙去脉<br>新太尉叫高俅，就是当年在开封的那个泼皮无赖，不过，当时本叫高毬，因为其擅长蹴鞠，踢得一手好球。后来他因为四处欺诈被放逐出开封城，不允许入城，不过，这也是他的契机<br>有一天偶然去了一家酒楼，偶然遇上了一个意气相投的贵人，那个贵人喜欢有特长的人，看见高毬会蹴鞠，就很喜欢。于是就招高毬当个侍从，本来他也是个善于来事的人，很快就深受主人的新任<br>就这么有一天，他的主子有幸迎娶皇帝的女儿——公主为妻，成为驸马，后来一天他和主人一同去端王——一个年轻皇子的宅邸，这位皇子是个爱玩的人，还有个外号叫做“浪子”，那一阵子对蹴鞠特别感兴趣，正巧高俅他们过去时，看见端王正在蹴鞠，也是偶然，球就向着高毬飞过来了，高毬轻巧的接住球，又华丽的把球踢出，秀了一段球技，这位皇子也是从未见过<br>“踢得漂亮！”<br>端王很喜欢高俅，便请求把他留在身边，高毬很快就成了端王最亲近的宠臣<br>最近，高毬又把毬改成了俅<br>端王是皇帝的异母弟弟，但是因为母亲身份很低，几年前刚刚被册封为王，也是没有什么事情的皇子，过着悠闲的生活，但是，因为哥哥宋哲宗年仅二十五岁就驾崩了，又没有儿子，于是命运突变，端王就成了皇帝<br>端王才二十岁，本来就没想当皇帝，还是“浪子”的天性，就像平常发礼物一样，宠臣一个接一个获得了高官厚禄，对于最中意的宠臣高俅，他的赏赐就是禁军的统帅——殿帅府太尉<br>这也改变了王进命运<br>高俅并未忘记当年的王进<br>此时，王进已经被打昏在地<br>这个时候，都教头张彻【林冲的岳父】从教头的队伍中站了出来，他头发和胡子都已经斑白，是个沉默寡言的军人，他的严格治军，不说禁军中，就是开封也人人知晓。面对高俅，老将静静的低下头说：</p><p><img src="/upload/pasted-198.png" alt="upload successful"></p><p>“今天是太尉到任的大喜日子，不宜在公堂之上流血，还请太尉三思”<br>面对这种说话的风格，沉静的腔调，高俅眼中责备的眼光消失了，人们也纷纷抓住机会，为王进求情<br>“啊，好吧，就依着你们，不要坏了本帅的大事”<br>高俅摸着胡子，深深的坐在椅子上<br>“今天给你们个面子吧。”<br>高求满足地注视着为王进求情的人们。<br>王进在张彻和众弟子的扶持下回家了<br>张彻让众弟子回去，告诉了因为背上的重伤而无法躺下的王进，高俅是怎么成了太尉的<br>“你怕是以前什么时候得罪了那厮，那人尖酸刻薄，你最终会被杀的”<br>王进说了自己和高俅的遭遇<br>房间的角落中，王母低声哭泣着<br>不久，一个弟子回来了。张彻低声问道。<br>“什么情况？”<br>“有两个人在”<br>门前有两个士兵<br>“应当是那厮派来监视的”<br>张彻点了点头，向王进进言到<br>“赶快逃命吧”<br>张彻从怀里拿出布包，让王进握在手里。里面有一些银子。实际上王进和张彻不过是同事，平常只是点头之交罢了。<br>“张教头，你这是？”<br>“你的棒法出众，可惜了”<br>凝视的双眼让王进不禁想起了师父王升</p><hr><p><img src="/upload/pasted-199.png" alt="upload successful"><br>凌晨时，王进趁机杀死了监视的两个人，城门打开的同时，和母亲骑着马逃离了开封<br>也就是从那天起，王进开始了他的逃亡之旅<br>高俅因此更加记恨王进，不断的提高赏金抓拿他<br>“你埋在树林里的那些人，就是想要拿下我的赏金猎人”<br>王进凝视着史进的脸<br>“我的罪过，就是当年打了一个泼皮，就这些事”</p><p><img src="/upload/pasted-200.png" alt="upload successful"><br>比起从脚下爬上来的冷气，那声音更冷，更沉重<br>患病的母亲不到半年就死在了安旅篮的角落。埋葬在连名字都不知道的山的松树根下，王进在墓前，立起了自己贴身的棒子，作为王家棍法的传承者，他也埋葬了作为禁军教头的自己<br>“看到高俅的脸的时候……我，爬上去谢罪说不定就行了。但是，没能做到。所以，我选择了逃走。从今以后也只能──继续逃避”<br>王进转过头去，又开始了自己的逃亡之旅<br>“被这么个混蛋缠上，也是无能为力啊”<br>“——师父”<br>王进渐行渐远<br>“师父！！”<br>“史进啊”<br>王进背过身去，用强大，温和的声音呼唤着史进<br>“我要感谢你，不管如何，有你这么徒弟，即使最终被人杀掉，我也能此生无憾，含笑九泉了”</p><p><img src="/upload/pasted-201.png" alt="upload successful"><br>王进其实也不能雕刻出木龙，那是他摒弃以前的自己，是否有能力收徒的最后测试，只有天真无邪，从无到有的人才能成为传承者，史进也不能雕刻出木龙，那是王进已经削好上好的木材，一切准备妥当，却在快要完成的时候不得不作罢<br>但是，王升把武功传给王进，而王进又把武功传给史进<br>曾经，王升无法雕刻出龙<br>但是，现在的话——<br>仰望星空，王进静静的微笑了<br>然后，在黑暗中沉没的黎明之路上，加快步伐，一路向北</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;font color=&quot;#FF0000&quot;&gt;原文作者 森下翠和插画作者 正子公也 版权所有&lt;br&gt;&lt;br&gt;个人翻译&lt;br&gt;&lt;br&gt;仅供个人娱乐及同好者欣赏&lt;br&gt;&lt;/font&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;a href=&quot;http://suikoden.com/&quot; target
      
    
    </summary>
    
      <category term="绘卷水浒传" scheme="https://www.junglezero.top/categories/%E7%BB%98%E5%8D%B7%E6%B0%B4%E6%B5%92%E4%BC%A0/"/>
    
    
      <category term="绘卷水浒传 正篇" scheme="https://www.junglezero.top/tags/%E7%BB%98%E5%8D%B7%E6%B0%B4%E6%B5%92%E4%BC%A0-%E6%AD%A3%E7%AF%87/"/>
    
  </entry>
  
  <entry>
    <title>绘卷水浒传 20周年企划 第四章 翻译</title>
    <link href="https://www.junglezero.top/2019/03/06/%E6%B0%B4%E6%B5%92%E4%BC%A0-20%E5%91%A8%E5%B9%B4%E4%BC%81%E5%88%92-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BF%BB%E8%AF%91/"/>
    <id>https://www.junglezero.top/2019/03/06/水浒传-20周年企划-第四章-翻译/</id>
    <published>2019-03-06T07:57:00.000Z</published>
    <updated>2019-03-19T01:02:25.819Z</updated>
    
    <content type="html"><![CDATA[<hr><p><font color="#FF0000">原文作者 森下翠和插画作者 正子公也 版权所有<br><br>个人翻译<br><br>仅供个人娱乐及同好者欣赏<br></font><br><br><br><a href="http://suikoden.com/" target="_blank" rel="noopener">原文地址</a></p><hr><h1 id="第四章-地狱罗汉"><a href="#第四章-地狱罗汉" class="headerlink" title="第四章 地狱罗汉"></a>第四章 地狱罗汉</h1><p>洛阳，是一座大都市<br>曾经是许多代王朝的首都，虽时有战乱之煎熬，但闻名的精华却脉脉不断的成长着，尽管不及西都长安的繁华富裕，可她那清雅的姿态是其他城市所不能企及的<br>佛教繁盛时，洛阳曾有“千寻塔”之称，但是现在，城内到处都是自以为是的道士<br>道观多了起来，强改为道观的寺院也多了起来，甚至酒楼，妓院，瓦市等游乐场所也多了起来。道士们漫步其中，阔步向前<br>其中金冠道士们更是飞黄腾达，他们是“通真达灵元妙先生”林灵素挑选出的嫡传弟子<br>今夜，洛阳城中心的大酒楼“大汉楼”也聚集着这些金冠道士，有一张不满的脸孔，冷眼旁观着。一众道士围着一个年轻道士<br>“喂，郭京啊，“通真达灵元妙先生”中意你，所以你大概知道吧，林教主为什么把那么一个穷酸道士安排在身边呢？”<br>嘴上蓄着漂亮胡须的年轻道士摇了摇头<br>“这个，我也完全不明白”<br>“如果连你也不知道，那就更奇怪了，说起来，咱们怎么突然来洛阳？”<br>道士们把目光转向了里屋的客厅<br>深屋之内，林灵素与一个怪道士面对而坐<br>“接下来怎么办？”<br>林灵素很焦急的样子，用好像被什么紧紧抓住的声音说道<br>“好不容易才把这些反对废佛的和尚聚集在少林寺，却也不顺利”<br>林灵素是为了少林寺的灭亡——即“道教的大胜利”，从东京而来<br>发出假的檄文，把反抗的和尚聚集在少林寺。这是林灵素的计谋，以此为契机，一举将这些反对者消灭<br>“这样一来，废佛之事就算完成了，世上也当全为道教的颜色，因废佛之功绩，我也会成为宋的唯一国师，荣华富贵，应有尽有”<br>但是，少林寺在初战时却击退官军，严守山林，封锁要道。嵩山地势险要，洛阳军队也停下了进攻的脚步，只剩下数日的对峙<br>因宇文将军战死，正都指挥使上阵了，不过，他本来就不想打这场战争，他声称要耗尽敌人的粮草再一举攻克，于是没有采取任何进攻行动。少林寺本来就是靠山吃山，自给自足，在此期间，朝廷内的反佛势力也慢慢削弱<br>“没办法了吗？”<br>坐在林灵素面前的是一个戴着兜帽的怪人，也不知其来历，就成了拉青牛嚼子的仆人。在那场斗法大战中出现了降雨的怪相，以天子为首的人们都认为这是林灵素的法术，但实际上他没有那个法力<br>也是那个时候，林灵素知道那个丑陋的仆人才是“真人”，从此以礼相待<br>但是，怪人沉吟不语<br>林灵素皱起眉头<br>（虽说有点用处，但实在是让人觉得恶心，说不定他打算……总之不能不提防他）<br>林灵素也算是身经百战的道士，年幼就被送进了佛寺，但是他受不了严酷的修行出奔了，此后进入道观，成为了一个有名道士的弟子，不过他主修的是“魔术”——欺骗大众的障眼法<br>（到最后还是这些伎俩最有利于处事）<br>地板崩塌是因为事先挖了坑，流血泪的神像则是事先安排了猪血，仙鹤也是事先准备好的<br>（真的有“术”吗？）<br>“相信我”<br>小声品酒的怪人，用咕嘟咕嘟的声音嘟囔着。</p><p><img src="/upload/pasted-102.png" alt="upload successful"><br>“信则成”<br>然后，破布下的双眼，锐利的注视着门的方向<br>门开了，一个美丽的小间使拿着铫子进来了<br>“是这屋的客官要添酒吗”<br>微笑之后，小间使感到了屋中异样的氛围，突然变了脸色，接着说弄错房间了，急忙关上门跑掉了</p><p>小巧的身影轻快的登上楼梯，滑进了“大汉楼”最上层的房间，虽然很小，但却是最奢华的单间，是高官贵族们密会的地方，今天这里，有一个美女正用玉杯饮酒<br>“——是猫儿吗”<br>化装成小间使的猫儿把带来的铫子献给了主人慕容贵妃。<br>“没错，那人正是林灵素，还带着个可疑的道士”<br>“那是谁”<br>“不清楚，但是眼神缥缈不定”<br>在陈列着美酒佳肴的客厅中，慕容贵妃和几名侍女在等着猫儿的回报，慕容贵妃享受着这种奢华，委身于铺满长椅的丝绸被褥中，窗户边琉璃色的香炉燃着高香<br>猫儿的鼻子很灵敏<br>“贵妃，这香味是？”<br>“很怀念吧，这是从红菊中提炼出的味道，也是突然想起了后宫的生活啊”<br>“马上就可以回到那种生活了”<br>贵妃用鼻子止住了猫儿说的话<br>“那个小姑娘——金奴离开少林寺了吗？”<br>“没有，我本以为在开战前就会下山的……还没有”<br>“当时在尼姑庵的时候，稍微收拾一下就好了，没有找到她的住处”<br>慕容贵妃懊悔的饮尽杯中酒<br>“那个金山大师还巧妙的把她藏了起来，王皇后，王都尉，太子以及公主……这些王家的人，都在妨碍我”<br>“还有那个老婆的预言，请您放心，一有机会猫儿就会收拾她”<br>“你是我心腹之人的第一弟子，可你师傅‘白骨猫’却背叛我们逃跑了，你是忠心之人吗？”<br>“养育身为孤儿的我的，是贵妃大人，这份恩情，即使牺牲性命——”<br>“好了，那就把那扇门打开吧”<br>猫儿一开门，林灵素一个人站在那里。潇洒的道服被悬挂的灯笼照射着，给人一种仙人临世的感觉，那张嘴边，浮现着淡淡的笑容<br>“还在想怎么又是那个奇怪的小间使呢……哎呀哎呀，遇到贵人了”<br>林灵素关上身后的门<br>慕容贵妃的眼中泛起秋波，婉然的微笑着<br><img src="/upload/pasted-103.png" alt="upload successful"><br>“灵素啊，和我再会不觉得欣喜吗？”<br>“用一封可疑的信，把我唤到洛阳的，就是你吧”<br>林灵素用蜡烛把那封信点燃，信上只写了一手诗<br>“很怀念吧，那首诗是你过去写给我的”<br>“不要幼稚了”<br>“那么，怎么不让陛下把孩子处理掉，本来是打了胎的……可那孩子现在是朝气蓬勃”<br>林灵素脸上的淡笑消失了，贵妃瞳孔中的秋波也消失了，这一对男女，就像摘掉面具一样，展现出他们原本的面孔<br>林灵素坐在椅子上，拿起贵妃喝酒的铫子，自饮自酌<br>“那么，有什么事吗？”<br>“我想告诉你一件好事”<br>林灵素为贵妃也倒了杯酒<br>“是你要返回宫中了吗？”<br>“我现在被朝廷追捕，已经是苟活的人了，已经没有什么野心了”<br>“你除了野心，大概也没别的东西了”<br>“你不也是一样吗？”<br>贵妃眯着眼睛，第一次真心的呵呵的笑了<br>“灵素啊，我知道你想攻下少林寺，除了东京的禁军，再把河南节度使王焕，太原节度使徐京的军队也招来，你来做统帅”，如果被那样的军队进攻，那少林寺就如沙子筑成的塔一般一催击垮，换句话说，那座山如果不是大军讨伐，是无法攻下的”<br>“调遣节度使，那可是个难题”<br>“为什么？”<br>“这些节度使是守卫边关的重要将领，和洛阳军的行动是划分开的，朝中也有反对派，各种各样的麻烦事，甚至宰相蔡京也反对废佛，与其说是担心佛教存亡，不如说是担心世间动荡不安的大臣也不少。即使是陛下，也并不是那么憎恨佛教”<br>“那么，就用幻术吧”<br>“什么样的幻术？”<br>“真是个迟钝的男人啊，关在东京监牢里的智真长老和少林寺的金山大师是莫逆之交，可现在这位金山大师却企图‘谋反’，召集少林寺的武僧，煽动全国百万的佛教徒，打算颠覆大宋，计划袭击东京开封”<br>林灵素思考起来，慕容贵妃有密谋的才能，他是最清楚的<br>“原来如此，但是陛下会相信吗？”<br>“你这家伙，真是让人着急啊，‘仙人传信’不是掌握在你手里吗？天书下凡，地上突然出现刻着‘金山谋反’的石板……历史上有不少先例吧，如果能镇压这场叛乱，必定能功成名就，成为武勋赫赫的救国英雄，定能获得国师以上的荣誉，也能凌驾于蔡京童贯之上”<br>“救国英雄——救世主吗？”<br>林灵素摸着胡子<br>“不错”<br>“可不要忘了我的恩情”<br>两人满脸笑意，干了杯中酒<br>“如果进展顺利，下一步就为你考虑‘仙人传信’”<br>“呵呵，我很期待啊”<br>猫儿伫立在房间的角落里，侧耳倾听着两人的对话。<br>（无论哪一边，估计都不是真心的啊）<br>猫儿忍住笑意，在配餐台上重新温热了冷却了的铫子<br>案子上的蜡烛周围，两只蛾像嬉戏一样飞舞着。</p><p><img src="/upload/pasted-104.png" alt="upload successful"></p><p>深夜，林灵素凭栏而望，目送贵妃一行人离去<br>（那个女人究竟什么目的）<br>马车之后，有一个黑影尾随着，这是林灵素派遣的密探<br>（但是，她还是一如既往的擅长‘诡计’啊）<br>林灵素返回房间，心腹郭道士正在待命<br>“通真达灵元妙先生，您的命令是？”<br>“——回东京”<br>林灵素在写一封密信的同时，在年轻弟子的耳边嘀咕着什么</p><p>数日之后，童贯受皇帝之命，下令两节度使王焕徐京出征<br>皇帝从林灵素那里收到“少林寺谋反”的神谕的秘信，不过，他一度拒绝了调遣节度使的请求，大臣们也是极力谏言先要调查此事再做决断<br>但是，同一天，皇帝在东京万岁山散步时，发现神木的树干上浮现出“金山叛”的字样，人们还在惊愕时，文字突然消失了——但是在场的人都看见那几个字<br>因此，皇帝终于下定决心，下达了讨伐少林寺的宣言<br>这个玄幻的“带话”，不过是“虫文字”——受林灵素之命的道士郭京，事先用蜂蜜在树干上写下文字，没人注意有虫子聚在那里</p><hr><p>那个夜晚，终于下了些小雨<br>薛永站在哨岗上。官军虽然围堵了嵩山的出入口，但这边防守坚固，看不见官军的进攻<br>雨越发的大了，他到了有屋顶的监视小屋，在地上铺的破布上，太白团成一团。薛永走进屋里，太白只是抬了抬眼皮，银树蜷着身子熟睡着<br>战斗以来，即使尼姑们阻拦，她也要待在薛永身边<br>山间夜晚很冷，薛永把肩上的布盖在银树身上<br>银树微微睁开双眼<br>“把你吵醒了啊”<br>“……谈谈薛永你吧”<br>银树裹在布里低声私语<br>“我？”<br>银树点了点头，睡意朦胧地闭上了眼睛。伸出的手指紧紧抓住薛永的下摆。<br>“薛永是在哪里出生，又是怎样活下来的呢……快说！”<br>“我……我出生在洛阳，祖父是一名出色的武官。可是，不善处世，被上司疏远，被罢黜了。我父亲不能做官，开始做生意了，但是失败了，破产了。家人都离散了，我的家已经没有了”<br>“这样就成了艺人了吗？”<br>“那时，讨债人只给我剩了一根棒子，我走投无路，就在那洛水畔坐着，这时，有只又瘦又脏的小狗靠近我的膝盖，我抱着小狗回到街上，模仿着人家卖艺，赚到了自己的第一桶金”<br>“那是太白吗？”<br>银树用双手抱住太白的脸，皱巴巴的鼻子贴近脸颊，银树看上去就像个年幼的孩子<br>“你真幸福啊——你”<br>雨敲打着屋顶。在这个广阔的世界里，只有这里才是安全的巢穴。银树又开始静静的入睡了<br>（一定要守护她）</p><p><img src="/upload/pasted-105.png" alt="upload successful"><br>在一切的伤害中——<br>也不知能不能做到，薛永感到很不安，他知道自己既没有史进的那一身武艺，也没有石秀的胆量<br>（索性带她上梁山）<br>突然出现了那个名字，薛永也觉得很吃惊<br>大宋朝廷和“贼寇”梁山泊是不共戴天的敌人，怎么说也是不能把堂堂大宋的公主带上梁山的<br>薛永屏住呼吸，注视着银树的侧颜<br>不知不觉雨已停歇，轻微的月光透过窗子，静静的照耀着两人</p><p>雨后，史进沿着泥泞的道路走向山腰的食堂<br>好久没有酒喝了，想喝上两碗<br>问了在井旁刷锅的小和尚，他指向了屋子那边<br>“水屋里，还有为客人准备的酒”<br>“我能喝一些吗？”<br>“可以啊，反正客人已经来不了了……”<br>小僧又开始刷锅<br>史进拿到酒后，无意看了深处的碗橱一眼<br>“喂，这是？”<br>小和尚拿着洗碗的锅进了屋，看见史进的手中，握着随意摆放在碗橱上的木雕龙<br>“啊，那是管灶台的木龙行者雕刻的，看，那边也有……有不少呢”<br>史进环视四周，确实，在灶台上，窗框角落处，放置着好几条龙，好像守护神一般，无论哪个，都栩栩如生，出神入化<br>史进想起了王进的手，王进身为武者，有纤细的手指和柔软的手掌，史进靠近小和尚<br>“那个行者是个什么样的人呢？善使棍棒？”<br>“大概不是吧，是个沉默寡言的人，只是坐在灶前刻着木头，五十多岁……也不知是何许人”<br>“那此人现在何处？”<br>“数月之前，突然走了，最近，好像有人看见他在龙门雕刻佛像……”<br>“龙门？那是什么地方？”<br>“您不知道吗？是有着雄伟石窟的寺院。在悬崖边上，雕刻着大佛像”<br>史进早已把喝酒的事抛在脑后，拿着木雕走出房间<br>雨后天空，月光皎洁<br>“龙门啊！”</p><p>黎明——<br>“少林寺谋反!”<br>正是那天早上，东京禁军，河南节度使老将王焕，太原节度使“徐京”共计五万大军出征的情报，被作为间谍在山外活动的王定六通报到少林寺</p><hr><p><img src="/upload/pasted-106.png" alt="upload successful"></p><p>已到黎明，仍然一片黑暗，有几个人悄悄的行动着<br>那是横穿荒野的街道旁的旅馆。后面是堤坝，下面是茶色的河流。<br>旅馆是两层建筑，而且还附有马厩，显得特别大，有人悄悄潜入角落的房间中，黑暗中，有女人在低声私语<br>“来了——请做好准备”<br>“这么早啊”<br>一个困倦的声音作答<br>“连夜赶来的吧，这么着急”<br>院子里一片喧哗。这里是郊外街道附近的驿站，是官员和军队主要使用的停歇换马的地方。门前吵闹起来的原因是运送货物的部队到达了这里。<br>“您们来的真早”<br>店家亲切地去迎接，把士兵们带到一楼的餐厅。<br>“马已经派人栓好了，请用餐吧”<br>餐厅早已准备好了酒菜，盛妆打扮的老板娘对着饥肠辘辘的士兵们温柔的劝酒<br>“都累了吧，赶快趁热吃吧”<br>老板娘把做好的饭菜端到士兵中间，士兵们争先恐后的喝酒吃菜<br>“多吃些，也喝些酒”<br>老板娘一边殷勤的服务着，一边听着士兵们的对话<br>“连夜赶路，可是累死了”<br>“没办法啊，这是急令”<br>“禁军已经集结完毕了吧，洛阳军加上东京禁军的人数是大概有三万吧……真是了不得啊，再加上节度使的军队，那少林寺就更不堪一击了”<br>这些事官军的辎重部队，是做各种杂事的地方杂兵“厢军”<br>“武器要多少有多少，在下一站换班，咱们加油吧”<br>“不过是真的太困了”<br>不一会士兵们相继昏倒，摔下椅子<br>屋里静悄悄的，不知哪里的门开了，传来粗壮厚实的男声<br>“完事了吗？‘小尉迟’？”<br>“可以了，过来搭把手”<br>旅店的主人——“小尉迟”孙新，跨过倒下的士兵，走了出去。端着饭菜的妻子顾大嫂也挽着袖子忙碌着</p><p><img src="/upload/pasted-107.png" alt="upload successful"></p><p>“小尉迟”孙新，梁山泊座次一百，他受哥哥“病尉迟”孙立传授，善用铁鞭，本是黑赌坊店家</p><p><img src="/upload/pasted-108.png" alt="upload successful"><br>其妻顾大嫂，座次一百零一，她是被唤做“母大虫”即雌虎的女中豪杰，撸起袖子干架的话，丈夫孙新自不必说，普通男人是不能与之较量的<br>孙新夫妇检查了辎重，大多是箭，枪，盔甲等装备，信号一发出，后面的堤坝上出现了几男人，把辎重都藏在了渔船中<br>划船的，是“立地太岁”阮小二</p><p><img src="/upload/pasted-109.png" alt="upload successful"><br>梁山泊座次第二十七，是梁山泊水军统领阮氏三雄的兄长，本是石碣村的渔民，年轻时总被人唤做“祸星”，阮小二巧妙的把那些辎重藏了起来<br>“那么，小二哥，之后就交给你了”<br>顾大嫂把做好的饭菜递给了阮小二<br>“我们走了，去找下一个猎物了”<br>阮小二拿起撸，茶色的水缓缓的流淌着，不由的让他想起了故乡石碣村<br>后面的船上，刚刚被顾大嫂叫醒的“玉幡竿”孟康无精打采的坐了起来<br><img src="/upload/pasted-110.png" alt="upload successful"><br>梁山泊座次七十位，船匠出身，善使高丽拳法，也曾坐船出海，远赴异国他乡，也是梁山泊的挖苦家，现在正对这条河流恶语相向<br>“这脏泥河，看一眼都觉得要倒霉”<br>“这是吴学究的命令，听得话总归是好事”<br>“行吧”<br>【<font color="#FF0000">注：以上两人已经在绘卷水浒正篇的方腊篇中双双阵亡，且死相异常的猎奇，且还被画了出来(ಥ_ಥ)</font>】<br>船要开了，孙新向他们道别<br>“到下一个码头，一定要到‘店’里去，新的情报应该到了”<br>吴用每掌握新的情报，都会发出新的指示，这个指示会通过信鸽，快马等各种手段传达。实际行动的人，完全不明白事态的发展<br>“‘走钢丝’啊，我又不是哪门子卖艺人”<br>孟康让手下人掌舵，靠在船边<br>天亮了，毒辣的朝霞，好像燃烧一般<br>孙新和顾大嫂收拾行李，离开了旅馆。<br>而被麻药麻翻的士兵们，醒来就会发现自己全省疼痛，被扔在荒郊野岭的屋子里<br>到那时，他们的辎重和马匹，早已离他们远去了<br>孟康闭上双眼<br>玄幻的旅店，不光是这里一个，最近，在大宋西部的各个地方，官军的各种辎重，都莫名其妙的没了，被盗的东西，大概是被梁山泊的人乔装打扮带到洛阳<br>人们默默地在荒凉干燥的黄土高原上前进。船逆流而上。<br>从天上鸟瞰，这些赶路的人，就像小河涓涓而流，汇入大江</p><hr><p>清晨的少林寺，被一片诵经和叹息声笼罩，被派往少林寺的官军，除了洛阳军外，再加上东京的禁军，两个节度使的部队，少说也有五万<br>“如此大军压境，即使是嵩山，也是无法坚守的”<br>被冠以“谋反”“叛贼”的污名，山中一片悲寂之感<br>“我们有什么过错，给国家带来灾祸的，还不是那些和奸臣结党的道士”<br>当天，也有想要逃出山的人，金山大师也并未加以阻挠，但是最终，尝试逃跑的人，又回来了<br>通往山脚的路，大小的参道，几乎全部被官军封锁<br>官军陆续集结，终于，“元帅”林灵素出现了，他们有神仙庇护——画着八卦太极的旗子已经遍布山脚，少林寺那边看的清清楚楚<br>史进也出来侦察，官兵数以万计，团团围在山脚<br>即便是如此令人绝望的情形，金山大师也没有一丝动摇</p><p>林灵素的驻营设在了李村的道观中。“通真达灵元妙先生”的到来，这边的道士也是竭尽全力的款待<br>林灵素悠然地坐在法座上<br>清净旁人的房间中，还有两个道士，一个是蓄着漂亮胡须的郭道士，还有一个头上裹着布的道士。郭道士刚从东京回来，东京据此不算遥远，而且洛阳和开封之间道路通畅，如果骑快马不过是半天左右的距离<br>郭道士完成了在东京的“重任”，意气风发的进行了回报<br>“按照您的吩咐，我已近全部完成了，由于童枢密使上奏，皇上立即派遣王焕，徐京两个节度使出征”<br>“好，干的不错”<br>在林灵素的道冠之下，隐藏着一个不小的伤疤，因家境贫寒，他在年幼时就被抛弃在了寺院，可是，他却染上了自私堕落的恶习，被长老用锡杖狠狠的教训了一顿，因此，他逃出寺院，为了复仇而成为一个道士，时至今日，伤疤处的疼痛，长久的怨念，他也不曾忘记<br>“军队集结完毕，就开始发动攻击吧”<br>如今，林灵素已经有了复仇的资本<br>“你们这些和尚，尽情的恐惧吧，现在开始，你们真正的‘法难’就要降临了”</p><hr><p>戴宗返回梁山泊</p><p><img src="/upload/pasted-111.png" alt="upload successful"></p><p>梁山泊座次二十位，是拥有“神行太保”之名的韦驮天。<br>只要脚上绑上甲马，就能日行八百里，因此，他正在收集东京周边的情报<br>聚义厅中，吴用常在此待命，接到通报后，宋江，朱武等人也聚集过来<br>“节度使已经发兵，此时的少林寺就如风中残烛一般”<br>听到戴宗的汇报，宋江满面愁容<br>“一般官军还好说，但是节度使的话就有些麻烦了，听说他们都是山贼出身，有些能耐，吴军师，咱们得赶快采取一些措施啊”<br>吴用沉默了一会儿。虽然吹入聚议厅的风很热，但白羽扇却没有动。<br>“林灵素、法难、慕容贵妃、节度使……如此多的人物聚集在一起，这也许是超乎想象的大阴谋”<br>吴用已经获悉慕容贵妃已成为辽国的走狗。<br>扇子开始动了<br>他命令待命的“铁扇子”宋清准备信鸽<br>“需要几只鸽子？”<br>“有几只用几只”<br>吴用已经开始动笔了</p><p>黄昏时刻，无数鸽子从聚义厅起飞出发<br>“对了，再补一手吧”<br>吴用想起来，立刻唤来“铁叫子”乐和</p><p><img src="/upload/pasted-112.png" alt="upload successful"><br>梁山泊座次第七十七位，是天下第一的歌者，一个有着天籁之声的年轻人<br>接到指示后乐和叹了口气<br>“去东京倒是没问题……让我来做吗？需要我做什么？”<br>“还是要靠你啊”<br>接着“锦豹子”杨林也被叫了上来</p><p><img src="/upload/pasted-113.png" alt="upload successful"><br>杨林座次五十一位，本是一说书人，和搭档乌鸦“小乌龙”执笔走天下，因此宋国自不必说，就连外国的地理，风俗他也清清楚楚。他记忆力超群，可以说过目不忘，而且说出来也是明明白白<br>【<font color="#FF0000">注：此人为绘卷水浒传的潜在作者，即绘卷水浒传可以说是他的回忆录</font>】<br>见杨林到了，吴用拿过一张地图<br>“洛阳周边，有可以以寡敌众的地方吗？”<br>“洛阳是古都，自古便战争不断，周边土地平坦，视野开阔，不依仗城池是不好打的”<br>“抱着死亡觉悟的僧众们，必定会坚守营寨的”<br>“这可是一出叫座的好戏了”<br>杨林想了一下，把手指放在了地图的一点<br>伊水之畔——龙门石窟<br>河边画着优美的大佛</p><hr><p>傍晚时分，少林寺<br>随着黑暗涌来，笼罩在少林寺上空的绝望愈加强烈<br>人们聚集在达摩堂那里，盼着金山大师能指出一条生路，金山大师从容不迫的姿态，就宛如发现光明一般<br>在智真长老被捕入狱，龙门大长老迁化的现在，只有金山大师是护法的导师，这个关键的夜晚，会有什么样的觉悟呢——人么在篝火下等待着<br>史进也混在人群当中<br>薛永和银树在一起，石秀，李忠等人也齐聚一堂<br>“张神剑”等雇佣兵聚集在别的地方，商量着善后的对策<br>他们也邀请了史进，不过史进拒绝了<br>（金山大师，接下来会怎么样啊）<br>他比较在意<br>史进的目光一直注视着大师<br>坐禅的大师，久久未动，一旁守护的天穹和尚，手持长棍，如隔扇佛一般伫立着<br>“——问诸位”<br>金山大师终于开口了<br>外面挤满了人，但达摩堂却安静下来<br>“非我问，是佛问，我们有三条路：其一，与官军作战，违犯不杀生戒堕落到地狱的轮回之道；其二，投降，改信道教，其三，不战不降，与伽蓝共入毁灭之道，是时候做出选择了”<br>顿时人声鼎沸<br>“官军是不可能接受投降的”<br>“殉教也可，这正是我等的信念啊”<br>达摩堂中充满了悲观绝望的声音，史进愤然道<br>“这样一来，正中了那林灵素的下怀，你们死了，那群腐败的道士举杯庆祝，不后悔吗？”<br>“那怎么办”<br>史进也哑口无言，银树突然向前<br>“路还有一条——逃”<br>僧侣们又开始吵闹起来<br>“原来是这样”<br>史进不禁笑了出来，看了石秀一眼<br>“石秀，你说怎么样”<br>“我虽厌恶逃跑，但就这么白白等死，我更不能接受”<br>“时迁”<br>时迁刚刚侦察归来<br>“是这样的，在西南的山脚下，看不到官军的身影。因为很险峻，没有路啊”<br>达摩堂里无数的眼睛，在摇曳的灯光中看着史进<br>“那就这样吧，那么我们——出逃吧”<br>一出门，正碰见“张神剑”等佣兵，“张神剑”越过敞开的门向金山大师抱拳<br>“事到如今，我们也帮不上什么忙了，也不能一直在这里待着”<br>然后向史进咨询了对策<br>“咱们摸着黑四处散去吧，如若你跟我们到甘肃，我们必定请你做个队长”<br>“我会考虑的，满天星，你怎么打算的”<br>满天星并没有从达摩堂中走出，而是站在门框边，尼姑们一边滚着念珠，一边痛苦流涕<br>“我……我不能弃她们而去”<br>即使是逃跑，也可能会死，但是没人想坐以待毙，无数双眼睛诉说着求生的欲望<br>无数的目光汇聚在金山大师身上，大师似乎在等着什么<br>“天穹，去把东西拿过来”<br>接到命令后，天穹从达摩像中取出一个小柜子，看那柜子，一个人可搬不动。一打开，溢出了金银<br>“这些是我寺的应急资金，就拿这些雇佣你们吧”<br>金山大师把箱子搬到“张神剑”他们面前<br>“我希望这座山里一人不留，让他们逃出生天”<br>只有在敌人集结完毕前逃走大家才能生存下去<br>佣兵们面面相觑，不久“张神剑”打头，一人一把的递送黄金，史进，满天星，石秀他们没拿<br>“我们可不算是‘工作’，应当算是发酒疯吧”<br>这样说着，史进谢绝了“张神剑”递来的钱<br>然后问金山大师<br>“有能够放下这么多人，还能抵御官军的地方吗？”<br>“只有一个地方”<br>“哪里？”<br>“龙门”<br>史进眼睛亮了起来，怀里抱着木龙道人雕刻的龙<br>“听说龙门有石窟？”<br>金山大师点点头<br>“那是北魏时代开凿的石窟寺院。以山为基，在河流前建造了的坚固地方，那本是古都长安洛阳发生变故时，僧众们所固守的要塞！”</p><hr><p>嵩山之上，星空闪耀<br>星空之下，六个男人并排站着</p><p><img src="/upload/pasted-114.png" alt="upload successful"><br>“大家都到齐了”<br>史进看着每个人的脸。石秀，薛永，李忠，陈达，杨春——都是老样子</p><p><img src="/upload/pasted-115.png" alt="upload successful"></p><p><img src="/upload/pasted-116.png" alt="upload successful"><br>陈达说道<br>“这不是很豪华的阵容吗？”<br>李忠把棒子抵在地上，一脸涩涩的望着院子内<br>他们安静地屏住气息，正准备逃离<br>调查山脚下官军情况的“满天星”又回来了。<br>“没有发现，大部分士兵都睡着了。”<br>人们趁着夜色，离开了大山。<br>塔林是历代僧侣的坟墓，有无数的塔林鳞次栉比。他们经过这里，沿着少溪河取道下参道，越过少室山就到了大路边。<br>僧尼们被分为几队，跟随“张神剑”等雇佣兵依次离开了寺庙。彭尼担任了尼姑们的护卫。<br>银树决定和金山大师一起去。彭尼手拿着心爱的大钺，向银树行了个礼。<br>“公主殿下，我先走一步”<br>“嗯”<br>银树看着彭尼的脸<br>“彭尼，一直以来谢谢你了”<br>彭尼惊讶的回头看着银树，银树笑了<br>“很快就能在龙门见面了”</p><p><img src="/upload/pasted-117.png" alt="upload successful"></p><p>月亮微微的照亮了他们的去路<br>在院内，金山大师留到了最后，为了欺骗官军<br>需要有敲钟的人，一开始，就有一个九十多岁高龄的老僧请求留到最后，但大师却把他和伤者一同安排撤离了<br>天穹和尚正带着年轻力壮的武僧搬运密藏经典和佛像，也是为了保护这些东西，就像白马寺的僧人把《四十二章经》运送到龙门一样，篝火熊熊的燃烧着，四周几乎无人，为了不让火熄灭，有两个人在添柴<br>金山大师所允许留下的，并不是真正的僧人，而是两个还了俗的人<br>在逃到此地的僧人中，有两个被唤做“心色清”、“神灵静”的僧人，被大家所厌恶，这两人本是一寺住持高僧，“心色清”却犯下了邪淫戒，“神灵静”犯下了偷盗戒。他们虽然被破门，但求佛的心灵仍然忍受法难之耻，奔赴此地<br>“金山大师啊，请赐予我们切断因果的缘由”<br>“心色清”右手无指尖，“心灵静”的独眼一片白浊。深知自己是罪孽深重的人就如此惩罚自己<br>即便如此，他们还是认为自己的罪行不会消失，只有为佛法而献身方能赎清自身罪过。</p><p>金山大师敲响了深夜的钟声<br>所有的人都已经离开，只剩下天穹和尚和史进的队伍，天穹和尚本打算和大师一起留守，但他不能违抗大师的命令<br>“——那么就出发去龙门了”<br>拜见了金山大师，天穹和尚和众高僧一起走了。莫志也向史进等人打了招呼，跟在后面。<br>这支部队由雇佣兵中留到最后的满天星担任护卫。<br>“大师打算和少林寺共同赴死吗？”<br>“满天星”回头看了看远离的少林寺。沉默寡言的天穹和尚没有回答，道路一片黑暗，异常凶险，已经没有回头路了，在龙门保护这些经典，佛像，就是他的修行<br>越过险峻的山岭后，下到南麓的斜面上，有一个被当地居民称为“佛掌角”的略宽阔的山脊。平安翻越过山的人们聚集在那里，要向龙门进发<br>护卫的“满天星”询问走在前面天穹和尚<br>“珍贵的经典都在这里了吗？”<br>“都在这里了”<br>就在这时，眼神好的莫志看见了远方点起的火<br>“那是什么情况”<br>在“佛掌脚”的方向，看见了火光<br>“难道是官军？”<br>突然，有人在背后袭击天穹和尚，背上的柜子掉到了地上<br>“‘满天星’你想干什么？”<br>发起攻击的正是满天星，跟随天穹的少林武僧立刻准备战斗，但是满天星早已拿起柜子跑出去好远<br>“难道，你？”</p><p><img src="/upload/pasted-118.png" alt="upload successful"><br>“只要拿到《精武大宝藏经》，少林寺对我就没有利用价值了，再见”<br>就这样背着柜子消失了，武僧们本打算追上去，但是，埋伏在“佛掌角”的官军已经开始了屠杀</p><hr><p>随着钟声的余韵消失，史进竖起了耳朵。<br>虽然觉得听到了什么，可嵩山的天空却沉吟不语<br>在香炉后闭目养神的李忠站起身来<br>“那么，我们也该出发了”<br>看到僧侣们已经撤离，他们也在盘算着出发时间，直到响起最后的钟声，他们都要尽力争取时间<br>大师刚刚敲响了最后的钟声，<br>好汉们行动起来<br>金山大师从钟楼上下来，走到史进他们身边<br>“去吧”<br>说的是史进所预想到的话<br>“大师，请和我们一同撤离吧”<br>金山大师手持般若雷，掷地有声<br>“一旦你们离开，我会让这里一片火海，即使夷为平地，也不会变成道观的”<br>大师一开始就做好了与少林寺共存亡的觉悟<br>寺院起火，肯定会让官兵误以为僧侣自杀，能推延他们的追进<br>史进并没有同意<br>为了让金山大师和银树也平安逃离，他们留到了最后，可是，大师却从篝火中拿起一根火把，沉默的走向达摩堂<br>石秀也催促着史进<br>“想死的人，就让他去死吧”<br>“不行！”<br>史进想追随大师。杨春抓住了他的手臂。杨春的目光注视着北麓。<br>“官军来了！”<br>官军的篝火登上大参道。起初像星星一样稀稀落落，数量逐渐增加，变成了一条火河。<br>“夜袭吗？”<br>听了史进的话，陈达摇了摇头<br>“唉，可是袭击正在包围的寡军，根本就没意义啊”<br>“那他们这是干什么？”<br>他们有种不祥的预感，把视线击中在了南侧的参道上，听见了声音<br>“——大师！”<br>那是被莫志搀扶的天穹和尚的声音<br>“‘佛掌角’有伏兵……满天星背叛我们了”</p><hr><p>“找不到……”<br>满天星一边听着四处凄惨的喊叫声，一边喃喃自语，他手持火把，在树林中检查柜子中的经典，找完最后一个柜子后，他面目狰狞，好像地狱的阿修罗一般<br>“根本就没有！”<br>满天星一脚踢翻散落在地上的经典<br>“《精武大宝藏经》不在这里！”<br>《精武大宝藏经》是一部被少林寺所秘藏的传说中的武术书，相传，读罢此书，将会拥有最高的武艺，因此有不少武者，或出家为僧，或偷偷潜入进入少林寺，企图获得《精武大宝藏经》，但最终都断绝了消息，不知所踪<br>满天星也是以法难为契机，混入了少林寺，也暗中给官军传信，告诉了他们僧侣们的逃脱地点<br>（《精武大宝藏经》到底在哪里？）<br>如果是珍贵的经典，肯定会被带出来的<br>（不过……）<br>满天星盯着四处火光的少林寺<br>正当这时，午夜的钟声响了<br>敲响这钟声的，就是那个金山大师<br>“是这样啊，为了自己的武艺天下第一，就亲自保护吗？”<br>那可不行——咬牙切齿的满天星，恢复了原本的端庄<br>然后，“一块云”满天星再一次消失在黑暗中</p><hr><p>被砍中肩膀的天穹和尚，血正在从身上披着的袈裟上渗出<br>不久，天微微亮了<br>嵩山最黑暗的时候也来临了<br>“——来了！”<br>石秀低声说道<br>陈达和杨春手持武器面向山门<br>黑暗中，如同火海般汹涌而来的，正是林灵素所率领的一万精锐禁军，目标是压制金山大师和少林寺<br>原本担心陷阱的官军的进军速度却加快了<br>，甲胄撞击的声音迫近，似乎连迸溅的火星也看到一清二楚。声势浩大犹如鲸鱼掀起的波涛<br>“砍下谋反者‘金山’的首级”<br>夜鸦从少林寺的屋顶成群的飞走<br>而且，从西南麓传来呼唤声,战斗的声音，悲鸣，微弱的诵经，很快就消失了。<br>退路有埋伏，正面是大军压境——大家都在望着金山大师<br>大师脱下袈裟，披在了因失血而颤抖的天穹和尚身上<br>“快跑——要抱着牺牲的觉悟”<br>【<font color="#FF0000">这金山大师是真的不地道啊orz<br>  </font>】<br>天穹和尚握住竖立在钟楼柱子上的般若雷，站了起来，猛地向破败的山门跑去<br>“大师，再见了，我总有一天还会重归净土的”<br>破戒僧“心色清”和“神灵静”两人也跑了起来，天穹和尚竭尽全力，用般若雷打碎了冲在前面的官兵的脑袋<br>天穹和尚就这样突入敌阵，面对正面的对抗，官军一瞬间胆怯了，但还是很快做出反击，”心色清”和”神灵静”一下就被砍倒了<br>“抓住金山！”<br>天穹和尚的背后，是烈火中熊熊燃烧的少林寺，他静静的矗立在参道上</p><p><img src="/upload/pasted-119.png" alt="upload successful"><br>“我就是金山！”</p><p>熊熊烈火，星光朦胧<br>金山大师正在钟楼和附近的建筑放火，急忙的向着山门反方向的南方赶去，这是通往僧侣们逃离的“佛掌角”的道路。<br>背后可以清晰的听到官兵的叫嚣<br>薛永牵着银树的手。那只手虽然像孩子一样纤细，但银树反握的力量很强。<br>薛永也紧握住银树的手</p><p>“佛掌角”和少林寺隔着一座山岭，其间是一片没有路的山林，如果设法进入山里，就不怕追兵了<br>以金山大师为首，一行人健步如飞<br>头上松籁喧嚣，脚下草丛密集。但是，长期在少林寺修行的大师却能看到看不见的道路<br>他们在山顶停顿片刻，遥望着焚烧少林寺的火焰。<br>被青白色的月光照耀着越过山峰，不经意间，眼下战场一览无余。<br>战斗的人遍地是，可是尸体的数量却更多，雇佣兵们，武僧们，护国禅师们，尸体遍布在这残酷的战场上<br>大师在月光下读着战报、<br>“敌人的数量是我们的三倍，这里已经是死地了，最终不过是全灭”<br>史进他们从斜面赶到战场<br>此处是少溪河被削出的山谷，在仅仅一小片平地上聚集了僧人和士兵。官军拦截着往下走的山谷出口，迅速地攻了进去，正如“佛掌台”的名字一样，道路贴在了手腕的位置，入口很小，官兵进军很难<br>武僧们的迎击也集中在了那一点，雇佣兵队长的“张神剑”正在积极布阵，防卫的主力是武僧和“白光尊师”等白衣护国禅僧。在位于“手指”的狭窄地带，尼姑和受伤者正在歇息<br>为了护卫尼姑们的彭尼，挥舞着大钺，挡住进发的敌军，此时已经全身受伤，脚又被枪击中<br>“彭尼！”<br>银树不禁叫出声来<br>薛永和银树一起赶到彭尼身边。李忠不知道要去哪里。是守护尼姑们，还是和僧侣们并肩战斗？薛永说道<br>“李忠大哥，我们守在这里即可”<br>“战斗异常残酷，但是，拜托你们了”<br>李忠环顾战场四周。史进冲到了防守的第一线，那里战斗最为激烈，那里正是凄惨的地狱，官军凭借人数蜂拥而至，南北少林的武僧们不断的向官兵发起攻击，他们的棍子和拳头上都沾满了鲜血，梵净寺的护国禅僧们抛开绳索，用锡杖戳倒官兵。“白光尊师”像幽鬼一样在空中，用锡杖打碎了敌人的脑门，一击一人，一刀三人。此时，“天三奇”本觉上人的身姿异样，巨大的身躯一动不动，护着周围的尼姑，徒手抓住攻上来的敌人的脖子，一击打断骨头，撕裂身体，双手迸溅的血液，滴落在上人的笑脸上<br>薛永用手掌挡住银树的眼睛<br>“不能看！”<br>这是一个修罗，恶鬼的世界<br>清廉的护国禅僧们，正是以前从漠北的监狱集体逃跑了的死刑犯们。笑容满面的本觉上人本是在江湖成为传说的杀手吗，这正是他们真正的样子，数年的修行犹如梦一场<br>官军陆续从街道上来。从通向龙门的街道到小路上到处都是敌人<br>正如大师所预想的那样，狭窄的“佛掌角”是无处可逃的，武僧，雇佣兵们和官兵肉搏，一个个的倒下，无法战斗的尼姑也无处可逃，一个个被杀<br>有不少人专挑着这些没有战斗力的人下手，薛永舞枪阻止着他们。棒子之类的东西是没用的，如果不能让敌人站不起来，就没什么意义了。银树也拔出剑来，可是，薛永却让她退到后面<br>银树不想杀人<br>薛永犹如鬼神一般战斗。平日温柔的青年的面容消失了，他的眼睛里不是——病虎，而是闪耀着野虎的光辉。</p><p><img src="/upload/pasted-120.png" alt="upload successful"></p><p>史进的注意力集中在通往街道的小路上<br>（走到街上，就能逃掉了）<br>只要离开这个死地，哪里都有退路可逃<br>注意到这一点的人们也跟着史进，帮助着他，护国禅僧开辟了一条道路，他们的白色外衣被染得通红。“白光尊师”头发和皮肤都染成了红色，最终战死在敌人的尸体上<br>本觉上人在将最后一个敌人劈成两半后，全身中枪而亡，那张脸，就像弥勒佛的笑颜。<br>史进在另一侧，放眼望去，密密麻麻的敌军，好像都涌向史进一样<br>“史进大哥！”<br>史进一边飞出了一支箭，一箭一人，他解除了被母亲封禁的双手，第一次射人<br>眼前突然浮现出母亲悲伤的脸。突然，他听到背后有悲鸣声，一回头，一个被彭尼砍翻的士兵倒在地上，银树还是无法杀人。彭尼和银树相拥，看着莫志。<br>莫志搭起下一只箭</p><p><img src="/upload/pasted-121.png" alt="upload successful"><br>“啊，我不是杀了你们……我是救赎了你们，救赎你们”<br>此时，史进仍然在战斗，没有停止前进<br>石秀也跟在史进身边，但是，史进觉得周围遍布敌人。碰撞身体的冲击，迸溅的火花，驱使着史进加速狂奔<br>面对无尽的敌人，向着更远方，加速奔跑。棍子打断了，就拾起了地上的枪<br>史进的每一击，都是致命的一击，一边跑着，一边打到五六十个敌人，开辟着前进的道路<br>就好像有王进在一旁一同战斗<br>“师父！”<br>打倒下一个敌人后，史进大叫<br>“史进，站住！”<br>陈达在呼唤他，但史进好像无视了一般<br>“无论如何也不能停下来啊”<br>陈达和杨春也追随着史进<br>天快亮了，也看不到战斗的结束<br>史进在前面带路，试图杀出一条血路，后面还跟着杨春，陈达，少林寺的武僧们。他们团结一致，把官军又推回了山脚<br>不久，他终于看见了后参道的入口<br>可以看到官军的篝火熊熊地燃烧着。<br>“不要冲出去，会被当成靶子！”<br>他也不听石秀的话，径直杀入敌阵，天已经开始亮了<br>官军埋没了视野，无论哪里都有官军<br>史进一个人突出，正跳进了当中。无论是陈达，还是杨春，谁也赶不上史进的势头。<br>官军的怒吼好像卷起旋涡一般<br>“终于来了，赶快灭了他们”<br>史进一瞬间被包围了。包围缩小，一圈长枪指着史进。<br>就在这时，史进周围突然发出了头骨崩裂的声音，宛如被大手拂过一般，一连五六个人倒下了<br>在史进的血雨朦胧的眼中，映出了巨大的僧形的身姿。</p><p><img src="/upload/pasted-122.png" alt="upload successful"><br>月亮渐渐沉入低空<br>金山大师站在那白色的光芒中，举着沾满鲜血的般若雷。</p><p>【<font color="#FF0000">下集 龙门决战 预告</font>】</p><p><img src="/upload/pasted-123.png" alt="upload successful"><br>命运六星，齐聚嵩山<br>“——走吧，出发到龙门”<br>龙门——那里是佛教的“圣地”。北魏时代，伊水岸建造了石窟寺院。<br>而且那里是佛教的“最后的堡垒”。<br>舞台到了决战之地——龙门！</p><p>独自一人，想要走自己的路的银树，她向着前方……<br>下章「龙门决战」，敬请期待！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;&lt;font color=&quot;#FF0000&quot;&gt;原文作者 森下翠和插画作者 正子公也 版权所有&lt;br&gt;&lt;br&gt;个人翻译&lt;br&gt;&lt;br&gt;仅供个人娱乐及同好者欣赏&lt;br&gt;&lt;/font&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;a href=&quot;http://suikoden.com/&quot; t
      
    
    </summary>
    
      <category term="绘卷水浒传" scheme="https://www.junglezero.top/categories/%E7%BB%98%E5%8D%B7%E6%B0%B4%E6%B5%92%E4%BC%A0/"/>
    
    
      <category term="绘卷水浒传 二十周年番外" scheme="https://www.junglezero.top/tags/%E7%BB%98%E5%8D%B7%E6%B0%B4%E6%B5%92%E4%BC%A0-%E4%BA%8C%E5%8D%81%E5%91%A8%E5%B9%B4%E7%95%AA%E5%A4%96/"/>
    
  </entry>
  
</feed>
