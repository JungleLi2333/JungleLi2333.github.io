<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>淋中之虹</title>
  
  <subtitle>向来不知道该说些什么</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.junglezero.top/"/>
  <updated>2019-08-07T14:09:52.064Z</updated>
  <id>https://www.junglezero.top/</id>
  
  <author>
    <name>JungleZero</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title> 春牛</title>
    <link href="https://www.junglezero.top/2019/08/07/%E6%98%A5%E7%89%9B/"/>
    <id>https://www.junglezero.top/2019/08/07/春牛/</id>
    <published>2019-08-07T13:51:53.000Z</published>
    <updated>2019-08-07T14:09:52.064Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://suikoden.com/graphies/images/grp_gai2_p01.jpg" width="70%"></p><a id="more"></a><hr><p>搬运自水浒吧的“出云流泉月花”的帖子，原贴找不到了。。。</p><hr><h1 id="水浒外传-春牛"><a href="#水浒外传-春牛" class="headerlink" title="水浒外传 春牛"></a>水浒外传 春牛</h1><p>男人撒播了种子<br>时值春天。阳光明朗，照耀着干燥的田间小路。萌发的新绿之色刺痛眼睛。但是，男人低着头，在落在地面的自己的黑影之中默默地播下种子<br>没有比他更喜欢春天的男人了。犁开冬日的干硬土地，细细研碎土块，种下种子。一本正经的男人。比起常人喜爱的酒和戏剧，农作能带给他更大的喜悦<br>但是，只有今年，这工作给男人带来了痛苦<br>他被卷入了兄长的官司里。正确的说，是他的哥哥，被卷入了某个案件里。在城里工作的哥哥，满怀侠义之心——他很讨厌听到这样的流言——被卷入了诉讼案，被关进牢房拘留了一个多月。为了救人出来，必须要筹钱。金额很是不少<br>“把田卖掉一半，那之后的生活，怎么办？”<br>男人询问自己的老父亲。父亲十分溺爱兄长。至少，在男人眼中看来，是这样的<br>“三郎总会有办法的”<br>“总惹麻烦的，不就是那个哥哥”<br>“没事的。如果是三郎的话——喂，四郎，你去哪里”<br>去田里。男人一边这样回答着，离开了家<br>向着干燥的土地上，深深地挥下锄头<br>他家里，除了种植麦子和杂粮的田地以外，还有种着蔬菜和果树的菜园。有几个佃户交租，在这个村子里也算富裕。收入供父子两人生活，也能给街上的哥哥提供足够的生活费<br>但是，那也结束了<br>男人思考着兄长的事情。越想越气<br>没有一个人憎恨哥哥。从孩提时分就开始做学问，不仅是在家里，全村的期待都集于他一身。到今天也仍然没有改变<br>另一方面，一直很认真的弟弟，却没有人爱慕，也没有人憎恨。也没有学问。一开始是兄弟二人一起去私塾念书，但学会千字文以后就退学了。开始种田<br>他喜欢田地——可以说是超越喜欢的感情。从记事开始就和曾祖父一起在田里劳作，玩耍的伙伴们也都是农家子弟。另一方面，哥哥完成学业，到了城里。交往的从书生到官员到黑道人员都游刃有余。哥哥在城里也集中了众人的好意和期待<br>但是，没有人知道，在背后支撑那个哥哥的美名的，是弟弟的田地。哥哥的工作，有权力，却没有收入。使用官僚特权的话可以赚钱，但是，人们的好哥哥从不那样做。帮助人们，是要花钱的。人们都叫他“及时雨”<br>播下最后一粒种子，男人停住铁锹，站起身<br>看见了田间小道上的三个人影<br>买地的是隔壁村的老柳三。男人转过了头。合同是父亲签字的吧。他不想亲手卖掉自己的土地<br>老柳三挖地为池养鸭子，赚了不少钱。这块地也要被挖成池塘吗。光是这样想想，胸中就疼痛不已<br>男人再次握紧了锄头。举起，再挥下的锄头，慢慢地停在了地上。被卖掉的是他的土地，他花了五年的岁月亲手开垦的土地。还是要自己亲眼看一下才好。这样想着的男人，赶紧跑回了家<br>但是，回到家里，字已经签过，合同也拿走了，买主老柳三早已不见踪影。父亲也不在。房子里只剩下空空荡荡</p><p>男人又往田里去了<br>在想这损失该怎么办<br>土地出卖，收入减少是一回事。在思考今后的生活，还有阿梨的事情<br>阿梨的父亲很贪婪。前两个女儿早早就订了娃娃亲，但成人后个个出落的很漂亮，感觉本来可以攀高枝的，很是后悔。因此，小女儿出生时就没有和任何人定亲。和父亲的预测一样，阿梨比姐姐们更美丽<br>父亲开出了天价的彩礼。阿梨自己虽然是小鸟一样活泼的眼睛，但是本质还是老实听话。每天，她都到男人家后院的井去打水。他总是帮她把水桶提上来。也不说话，只是默默地帮她拎起水桶。阿梨也一样，什么也不说，只是微微点点头，拎着水回去。就这样，过了五年<br>最近，老柳三的外甥托人说媒了，听说聘金的数量还没有谈好。村里人议论着“莫非要像哪里的老爷一样拿轿子来接不成”，都惊讶地笑了。但是，男人笑不出来<br>哪里的鞭炮响了<br>抬起头。天空的碧蓝之色刺痛了眼睛<br>鞭炮声再一次炸响<br>不久，看到田间小路上有几个人跑过来。其中一人站住了，向着男人挥手<br>“斗羊啊。去看不？”<br>大声喊着的，是青梅竹马的蒋七郎<br>人是个好人。明明知道顽固的朋友不可能去，每年有活动时还是招呼他去。因为是自己比什么都喜欢的斗羊，不邀请朋友就过意不去吧<br>“我不去”<br>男人的目光移回了田地上。春天举行斗羊，是这一带的风俗。经过特别训练的粗野雄羊互相争斗，为其胜败赌上金钱。有人因此破产，也有人因此一夜暴富<br>“没有理由去”<br>男人向等在路上的蒋七郎说。但是，对方早已不见踪影了</p><p>斗羊在河边的平原上剧情<br>一个简单的栅栏，人们一个接一个地牵着引以为豪的羊们过来。男人们聚集在栅栏周围，专心致力于品评羊的等级。巨大的角，筋骨发达的身躯，皮毛像钢丝一样支棱，每一头都是不一般的羊。半月形的羊眼似乎也被会场的气氛感染，耀眼地充血发红<br>第一场是王武的“朱指天王”和丘三叔的“满身肝”。初战一般是年轻力壮缺少经验的羊，会场的声势一般。但是，第二场，是去年的人气选手“黑雷霆”，数回合就败给了初次出场的年轻种子选手“黄金天香”，会场轰然沸腾<br>“切”<br>在“黑雷霆”上押了大钱的蒋七郎咂了咂嘴<br>一年来，省吃俭用攒下来的闲钱不过五六贯，就期待着在这一天大赚。光是这一场，就输了一半。下一场是本命的“蹂泰山”和“双珠铁汉子”，被拉上场的两头大羊喷着鼻息，频繁地用蹄子刨土。蒋七郎咽了口唾沫。“蹂泰山”身躯庞大，“双珠铁汉子”气魄非凡<br>（该下哪边的注）<br>蒋七郎冥思苦想，纠结得浑身颤抖。这时，有人从背后敲了敲他肩膀<br>蒋七郎回头看去，不禁瞪大了眼睛。是刚才说了“不去”，不对，是说了十年以上“不去”的幼驯染。是自己的邀请终于奏效了吗，蒋七郎大吃一惊<br>“怎么了”<br>“我来赌了”<br>男人像是平常一样答道。但是，蒋七郎听到的是更加意外的话<br>“刚才那一场，我赢了”<br>“什么”<br>男人一脸轻蔑地从怀里拿出了钱<br>“你，赌钱了？”<br>男人轻轻点了点头。他的视线，已经转向了下面场上的胜负。羊角的撞击声震动了空气。男人又赢了<br>那一天，男人出乎意料地大胜，赢了不少钱。平时不怎么赌博，却想当然地赢了。朋友的壮举让蒋七郎兴高采烈，眉飞色舞<br>“果然，你很有才啊”<br>蒋七郎也不介意自己空空如也的钱包，兴奋地拍着朋友的背。但是，男人一脸不高兴<br>“回去了”<br>“等等，明天还有啊”<br>蒋七郎嚷着“让我来教你明天押注的诀窍”，硬是把男人拉到了路边的小酒馆。店里已经客满，济济一堂，都是来看斗羊的男人们。倒酒，祝酒，热气腾腾，到处是煽动的空气，不过，每张脸都是通红，仿佛轻飘飘地脱离尘世。蒋七郎穿过拥挤的人群，抢了张桌子坐下。男人还是第一次出入这种店，但蒋七郎一副熟练的样子点了酒菜<br>蒋七郎一边喝酒，一边滔滔不绝的评论明天将要出场的羊。阴天时“疾风四蹄”就发挥差，“玉阎魔”持久力强，“赛蚩尤”空负盛名……<br>男人小口喝着酒，有一搭没一搭地听着<br>在思考<br>斗羊要持续三天。如果一直赢下去，能买回多少亩地？<br>（还是不够）<br>男人往喉咙深处灌入了苦涩的液体。然后，像是不想让人听到一样低声说道<br>“明天，把这些钱全部赌上。还不够的话，就把田抵押了做本钱”<br>“你说啥”<br>“有钱”<br>“喂”<br>蒋七郎放下了酒碗<br>“你说什么”<br>“还有钱”<br>“不行哟，你这样可不行”<br>蒋七郎惊慌失措<br>“有什么不行”<br>“要说为什么”<br>蒋七郎不知怎么回答。男人的眼睛深处闪着光，斜视着惊恐的蒋七郎。蒋七郎缩起了背<br>“要说为什么，我也不知道啊”<br>无言以对的蒋七郎喝起了酒。男人也继续畅饮。喧嚣之中，两个人默默地饮酒。这期间，似乎有什么人路过了<br>“没见过的脸啊”<br>沉重嘶哑的声音。蒋七郎像蝗虫一样惊跳起来<br>“孟老板”<br>是组织斗羊的幕后老大。蒋七郎谄媚地低下了头，而对方并不看他，只是把手放在男人的肩膀上。男人正一点点地舔着酒<br>“年轻人，赢了不少钱嘛”<br>男人的眼神焦急，甩开了对方的手。蒋七郎慌忙说道<br>“老板，这个男人虽然不爱说话，但也不容小看。毕竟是那个‘及时雨’的弟弟”<br>“哦”<br>“如假包换，唯一的弟弟”<br>“那就好。那是个仁义的人物，值得结交。”<br>被太阳晒得很黑，像是狒狒一样的面孔上，露出了奇妙的笑容<br>“今天的酒钱，我请了。大家随便喝”<br>孟老板喊了一声，酒馆欢声雷动<br>男人皱了皱眉<br>（说得大气。这么多酒菜得多少钱，是我看到都会头痛的数额吧）<br>不管男人的困惑，老板坐在了男人对面的座位上。一边和周围的人寒暄，一边自己也吃喝了一阵。屡次跟男人搭话，但男人沉默着一言不发<br>“这家伙平时就很无口”<br>和他大哥完全不一样。听到这句，男人越发不高兴了。仿佛注意到了男人的不满，老板露出了山犬一样的微笑<br>“新手入局，手气大多都不错。你就属于运气不错的那类。但是，明天的赌局，就会有些难了。对了，告诉你一件事。明天，会有一头新羊上场，名字叫做‘五花八门’。又瘦又小，脏兮兮的家伙。但是，有了这家伙的乱入，人生也会变成一件很有趣的事情”<br>男人眼睛也不抬一下。听到老板的低声之语，只微微动了一下肩膀<br>不久，老板起身走了，男人也松了一口气。喝多了不习惯的酒，醉意涌上来了。头很烫，但是，意识还很清醒。猛地头脑运动的感觉。感觉现在自己的想法，非常幼稚和婆婆妈妈<br>“什么破田。这个时代，我们只要赚钱，就能过好日子。总不能一直像鼹鼠一样，整天和泥巴黄土打交道”<br>是酒劲的原因。身后，喝醉的女人过来又倒了酒。醉意烧的全身发热。男人又倒了一杯。想喝的更醉一些<br>“一群土老帽”<br>耳边传来了酒馆角落中爆发的声音。回头看去，两个冷笑的男人正在一脸怪相地对着男人挤眉弄眼。是城里人<br>“听说有斗羊就来瞧个热闹，搞了半天是乡下佬的胡闹游戏。几毛钱的穷人可是永远不懂有钱人的世界”<br>那些是城里来的流氓。手里有几个钱，所以仗势欺人。蒋七郎向着男人耳边悄声道<br>“还带着杆棒和弩箭来的。别惹他们”<br>仿佛被那句话激怒一样，男人站了起来。两腿摇摇晃晃，用力地踩过泥地。在四周客人的注视下，男人走近了两人<br>“斗羊是没意思。那么，来玩玩‘斗人’如何”<br>“你说啥”<br>问话的同时，流氓的脸上挨了一拳。看到鼻血喷出来，村民们轩然起哄。另一个流氓踢开椅子，店里的男人们全都站了起来<br>“这头蠢牛”<br>城里的流氓扛起昏倒的同伴，逃出了酒店。男人好像什么事也没发生一样回到了座位上<br>“刚才那一拳好帅啊”<br>蒋七郎拍拍男人的肩膀。但是，没有听到回答。男人枕在潮湿的桌面上，就那样睡熟了</p><p>醒来的时候，趴在桌子上。胸口憋闷，胃里难受，头痛得要命。蒋七郎在隔壁打鼾<br>酒馆里很安静，很多人都在横七竖八地睡着。所有人都喝的酩酊大醉。有人睡在几张椅子搭起来的临时铺上，桌子下面的地板上，角落里也有人蜷缩着。陪酒的歌女在抱着胡琴打盹<br>空气污浊，弥漫着馊味<br>到处都是酒迹和剩菜和人制造的污物<br>他睡着的大桌上，米饭、肉块、鸡蛋、堆得山一样高的蔬菜从盘子里溢出，像垃圾一样散落得到处都是<br>这样的骚动还要持续三天<br>像是被垃圾的味道刺激，男人在房间的角落里呕吐起来<br>天就快要亮了<br>沉淀的空气从口中抹去<br>男人摇摇晃晃地走出了酒馆。想着要不要丢下酒钱，想了想又没扔<br>感觉自己从内心深处变得稀薄。羊骚味，酒精味，统统黏在口中，喉咙非常渴。记忆模糊，但是发生的每件事情都很鲜明<br>男人感到耻辱。露出这样的丑态还是第一次。这次和蒋七郎相会后发生的一系列的事情，想把所有的目击者都掐死灭口，男人一时有了这种凶暴的狂想<br>在空无一人的道路上，男人摇摇晃晃地走下去<br>突然，发现前方出现了几个站着的人影。男人停住了脚步。黑暗之中，有什么东西隐约在闪闪发光<br>很明显，是来打劫的。大概有四五人。但是，借着星光，看到对方的脸，男人明白了。是城里那两个流氓。带着同伙回来报仇的。想要杀人的凶暴感再次涌上心头<br>肮脏的家伙们<br>男人恶狠狠地瞪着对方，挺立在路正中<br>下定决心，如果要来的话，就把所有人都杀光<br>那种气魄，一瞬间让男人们畏缩了一下。但是，有个人怒吼着，一跃向男人扑来，所有人一哄而上<br>男人猛地出拳揍向扑上来的人，但是事与愿违，打了个空。力量和气魄十足，但是，男人从出生时起，就没有打过架<br>就这样，群殴持续了很长时间<br>也许，并没有那么长时间。天空中还有两三颗星星，夜晚还没有过去。或许是上天的慈悲也说不定<br>在黑暗中，男人像虫子一样撑起身体。身上这里那里都很疼。口中混合了血和土的味道。想吐出去，一瞬间想起了什么，停住了<br>（爷爷）<br>孩提时分，大概五六岁的时候、他和曾祖父一起种地。午饭是馒头。坐在田边小路上啃的时候，手上一个没拿牢，馒头掉到了田里。急忙捡了起来，馒头已经被潮湿的泥巴弄脏了。正在发呆时，曾祖父说<br>“吃吧。土是不脏的”<br>他孩子的心灵对自己的踌躇感到了耻辱，猛地一口咬住了馒头<br>现在，男人吞下了混合了自己的血和土的唾沫。然后，仰面向天，大声笑了起来。笑声回荡在四面的群山之中，在黎明前的天空中反复回响<br>男人笑着站起了身。低头看去，脚边的泥土上还掉着一点钱。是强盗们没抢走的零钱吧。男人捡起铜钱，挥手扔进了路边的河里。扑通一声，轻快畅然的声音。男人这次不出声地笑了。脱下被泥巴染污的靴子，脱掉被血和酒和汗，还有自己的呕吐物弄脏的外衣。男人只穿着内衣，在黎明前的道路上大步流星地走向前去</p><p>那一天，男人也扛着锄头向田地走去<br>途中，碰到了扛着色彩鲜艳的牛塑像游行的队伍。人们不断追逐着，热闹的铜锣声在春日的天空中回响<br>今天是立春。男人终于想起来了<br>这头牛被称作春牛。庆祝春天到来，祈愿农作丰收的仪式。竟然忘了这么重要的一天，男人很吃惊。带着全新的心情，凝视着每年都见到的这头牛<br>男人扛着锄头，跟在春牛队伍的最后面<br>村民们扛着列队游行的牛，最后被安置在广场上。然后，仪式开始了。牛被很多人猛烈地鞭打，形态渐渐崩溃，彩色涂料下面的泥土显露出来。这是土做的牛。不久，牛被打成了一堆土块。人们争先恐后地抢夺，想要抓一把土。只要抓住这土，今年就能有丰富的收成，多少年来，人们一直这样毫无疑义地相信着<br>这个时候，男人明白了，外行的自己，为什么会了解斗羊的胜败了。农民们为祈祷丰年，抓夺一把土，心如止水地在田地里耕种。而羊们也一样，无心地、拼命地争斗。所以，他才会知道，究竟哪一头羊，是真正在拼命地战斗<br>至于那些押上钱来赌博胜负的人们，跟他们又有什么关系呢<br>这样思考着，想起了失去的土地<br>那块地被挖成了池塘吧。但是，池子早晚也会干涸的，会恢复成田地。养过家鸭的土地，会比之前更加肥沃。还有很长的时间可以等，不必那么着急<br>男人回到田里，向着大地挥下锄头<br>潮湿，柔软的味道。怀念的味道<br>（养蚕怎么样呢）<br>闻着泥土的味道，想到了这一茬。听说不容易。这一代本来就盛产丝绸，很多人懂养蚕的知识。雇些有经验的人，指导下佃户的老婆们就好了。一定，过几年就能产出丝线。有了现金收入，买回田地的希望也就增加了<br>刚刚挖出来的泥土，深厚丰腴，仿佛闪耀着光辉</p><p>几天后，男人久违地到了县城，去买桑树苗<br>那个时候，看到县衙前面被很多人簇拥的哥哥。父亲用卖地筹措的钱，保释了哥哥。哥哥被很多人包围着，笑眯眯地接受群众的祝福<br>男人没有发出声音，但是用平静的面容目送着哥哥<br>采购了桑树苗回来，看到阿梨在后院的井里汲水。男人默默地走过她身边<br>就这样扛着锄头，到了田地里<br>认真谨慎地耕作，即将种上桑树的土地<br>田地里有几座旧坟墓。母亲、祖父、祖母——新的墓也很快被田地同化了。曾祖父的墓因为地势高半分，还能辨认出来<br>等他有孩子的时候，这里就会是一片桑树林了吧。饲养很多的蚕，产出很多蚕茧，制造出上等的丝线的话，孙子辈就能把失去的田地买回来。那个时候，估计他的身体也被土埋没，重新化为泥土了吧<br>所有人都将归于尘土<br>为此，男人郑重地耕种土地<br>思考着<br>也许，他并不是在为这片大地播种、耕耘，绽放花朵。是这片大地，在为他完成这一切也说不定<br>为了他，他的儿子，他的孙子，还有所有的生物<br>路过的男人们，纷纷议论着蒋七郎把全部财产押在“五花八门”上，赚了大钱，离开村子的事情<br>汗水从男人的下巴上滴落，啪嗒一声，滴入大地。汗水转眼间就被吸入，消失在黄土的颜色之中<br>大地和天空接壤的地平线上，映出了一个孤零零的小影子。男人不断地耕种，直到傍晚</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://suikoden.com/graphies/images/grp_gai2_p01.jpg&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算机网络总结（5）</title>
    <link href="https://www.junglezero.top/2019/08/02/%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93%EF%BC%885%EF%BC%89-1/"/>
    <id>https://www.junglezero.top/2019/08/02/算机网络总结（5）-1/</id>
    <published>2019-08-02T12:07:31.000Z</published>
    <updated>2019-08-02T12:18:51.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计网总结-五-一运输层"><a href="#计网总结-五-一运输层" class="headerlink" title="计网总结(五)一运输层"></a>计网总结(五)一运输层</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>网络层是为主机之间提供逻辑通信，而运输层为应用进程之间提供<strong>端到端的逻辑通信</strong>。</p><p>即: <strong>为相互通信的应用进程提供了逻辑通信</strong>。</p><h3 id="1、基本功能"><a href="#1、基本功能" class="headerlink" title="1、基本功能"></a>1、基本功能</h3><ul><li>传输层是<strong>只有主机才有的层次</strong>；</li><li><strong>为相互通信的应用进程提供了逻辑通信</strong>；</li><li>为应用层提供<strong>通信服务</strong>，使用网络层的服务；</li><li>复用和分用；</li><li>传输层对收到的报文进行差错检测；</li></ul><p><div align="center"><img src="/images/5_3.png" width="700"> </div><br></p><p><strong>复用: 应用层所有的应用进程都可以通过传输层再传输到网路层</strong>。</p><p><strong>分用: 传输层从网路层收到数据后交付指明的应用进程</strong>。</p><h3 id="2、传输层协议和应用层协议之间的关系"><a href="#2、传输层协议和应用层协议之间的关系" class="headerlink" title="2、传输层协议和应用层协议之间的关系"></a>2、传输层协议和应用层协议之间的关系</h3><p>应用层协议很多，传输层就两个协议，如何使用传输层两个协议标识应用层协议呢? 通常传输层协议加一个<strong>端口号</strong>来标识一个应用层协议，如下图所示，展示了传输层协议和应用层协议之间的关系。</p><p>端口用一个 16 位端口号进行标志。</p><p>是逻辑端口/软件端口: 是传输层的SAP，标识主机中的应用进程。只有本地意义。</p><blockquote><p>由此可见，两个计算机中的进程要互相通信，不仅必须知道对方的 IP 地址（为了找到对方的计算机），而且还要知道对方的端口号（为了找到对方计算机中的应用进程）。</p></blockquote><p>端口号以及常用的熟知端口:</p><p><div align="center"><img src="/images/4_59.png" width="530"></div><br></p><blockquote><p>(1)、服务器端使用的端口号</p><ul><li>熟知端口，数值一般为 0~1023(包括)。</li><li>登记端口号，数值为 1024~49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。<br>(2)、客户端使用的端口号</li><li>又称为短暂端口号，数值为 49152~65535，留给客户进程选择暂时使用。</li><li>当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。</li></ul></blockquote><blockquote><p>套接字: <strong>网络中采用发送方和接收方的套接字组合来识别端点，套接字唯一标识了网络中的一个主机和它上面的一个进程</strong>。即套接字Socket = (主机IP地址，端口号)</p></blockquote><p>整体过程:</p><p><img src="/images/5_4.png" alt="/images/5_4.png"></p><blockquote><p>网络层到传输层，用数据包中的<strong>协议号</strong>来标识是TCP还是UDP协议。</p><p><code>TCP : 6， UDP : 17</code>。</p></blockquote><p>下图展示了A、B、C计算机访问服务器数据包的过程。</p><p>客户端使用IP地址定位服务器，<strong>使用目标端口，定位服务</strong>。</p><p><img src="/images/5_5.png" alt="5_5.png"></p><p>TCP和UDP相当于网络中的两扇大门，门上开的洞就相当于开发TCP和UDP的端口。如果想让服务器更加安全，就把能够通往应用层的TCP和UDP的两扇大门关闭，在大门上只开放必要的端口。</p><p><img src="/images/5_6.png" alt="5_6.png"></p><p>上面讲的是设置服务器的防火墙只开放必要的端口，以加强服务器的网络安全。也可以在路由器上设置访问控制列表<code>ACL</code>来实现网络防火墙的功能，控制内网访问Internet的流量。</p><p><img src="/images/5_7.png" alt="5_7.png"></p><h2 id="二、UDP"><a href="#二、UDP" class="headerlink" title="二、UDP"></a>二、UDP</h2><h3 id="1、UDP协议的特点"><a href="#1、UDP协议的特点" class="headerlink" title="1、UDP协议的特点"></a>1、UDP协议的特点</h3><p><strong>无连接的用户数据报协议</strong>。</p><p>用户数据报协议 (UDP) 只在IP地址的数据报服务之上增加了很少一点功能，就是<strong>复用和分用的功能以及差错检测</strong>的功能，复用和分用，就是使用端口标识不同的应用层协议。</p><ul><li>传送数据之前不需要建立连接，收到UDP报文后也不需要给出任何确认；</li><li><p>使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表(这里面有许多参数)，通信的两端不用保持连接，因此节省系统资源；</p><p>一个数据包就能完成数据通信、不分段、不需要建立会话、不需要流量控制、不可靠传输。</p></li></ul><p>简言之: 不可靠、无连接、时延小、适用于小文件。</p><p>接收方 UDP 对 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动地交付上层的应用进程，<strong>一次交付一个完整的报文</strong>。</p><h3 id="2、UDP首部格式"><a href="#2、UDP首部格式" class="headerlink" title="2、UDP首部格式"></a>2、UDP首部格式</h3><p>用抓包工具捕获的域名解析的数据包，域名解析使用DNS协议，在传输层使用UDP协议。如下图:</p><p><img src="/images/5_8.png" alt="5_8.png"></p><p>UDP 用户数据报有两个字段: 数据字段和首部字段。如图所示，首部字段很简单，只有8 个字节，由 4 个字段组成，每个字段的长度都是两个字节，各字段含义如下:</p><ul><li>1)、 源端口。源端口号。在需要对方回信时选用。不需要时可用全 0。</li><li>2)、<strong>目的端口。目的端口号。在终点交付报文时必须要使用到</strong>。</li><li>3)、长度。UDP 用户数据报的长度，其最小值是8(仅有首部)。</li><li>4)、检验和。检测 UDP 用户数据报在传输中是否有错。有错就入弃。</li></ul><p><img src="/images/5_9.png" alt="5_9.png"></p><p>UDP 用户数据报首部中检验和的计算方法有些特殊。在计算检验和时，要在 UDP 用户数据报之前增加 12 个字节的<strong>伪首部</strong>。所谓“伪首部” 是因为这种伪首部并不是 UDP 用户数据报真正的首部。</p><p><strong>UDP校验</strong>:</p><p>在发送端:</p><ul><li>1)、填上伪首部；</li><li>2)、全0填充检验和字段；</li><li>3)、全0填充数据部分(UDP数据报要看成许多4B的字串接起来)；</li><li>4)、伪首部+首部+数据部分采用二进制及码求和；</li><li>5)、把和求反码填入检验和字段；</li><li>6)、去掉伪首部，发送；</li></ul><p>在接收端:</p><ul><li>1)、填上伪首部；</li><li>2)、伪首部+首部+数据部分采用二进制反码求和；</li><li>3)、结果全为1则无差错，否则丢弃数据报/交给应用层附上出差错的警告(ICMP)；</li></ul><p><img src="/images/5_10.png" alt="5_10.png"></p><h2 id="三、TCP"><a href="#三、TCP" class="headerlink" title="三、TCP"></a>三、TCP</h2><p><strong>面向连接的传输控制协议</strong>。</p><p>传送数据之前必须建立连接，数据传送结束后要释放连接。适用于大文件。</p><p><strong>不提供广播或多播服务</strong>。</p><p>由于TCP要提供可靠的面向连接的传输服务，因此不可避免增加了许多开销:确认、流量控制、计时器及连接<br>管理等。</p><h3 id="1、TCP协议的特点"><a href="#1、TCP协议的特点" class="headerlink" title="1、TCP协议的特点"></a>1、TCP协议的特点</h3><ul><li>1)、TCP是面向连接 (<strong>虚连接</strong>) 的传输层协议；(类似打call)</li><li>2)、每一条TCP连接只能有两个端点，每一条TCP连接<strong>只能是点对点的</strong>；</li><li>3)、TCP提供可靠交付的服务，无差错、不丢失、不重复、按序到达；(可靠有序，不丢不重)</li><li>4)、TCP提供<strong>全双工通信</strong>。<ul><li>“<strong>发送缓存</strong>“ : 准备发送的数据 &amp; 已发送但尚未收到确认的数据；</li><li>“<strong>接收缓存</strong>“ : 按序到达但尚未被接受应用程序读取的数据 &amp;不按序到达的数据；</li></ul></li><li>5)、TCP面向字节流。TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流。流: 流入到进程或从进程流出的字节序列。</li><li>6)、TCP 不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系；但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样；</li><li>7)、TCP 对应用进程一次把多长的报文发送到TCP 的缓存中是不关心的。 <strong>TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节</strong>（UDP 发送的报文长度是应用进程给出的）。</li></ul><h3 id="2、TCP连接"><a href="#2、TCP连接" class="headerlink" title="2、TCP连接"></a>2、TCP连接</h3><p>TCP 连接的端点不是主机，不是主机的IP 地址，不是应用进程，也不是运输层的协议端口。TCP 连接的端点叫做<strong>套接字 (socket) 或插口</strong>。<br> <strong>端口号拼接到 (contatenated with) IP 地址即构成了套接字</strong>。</p><p>套接字 <code>socket = (IP地址: 端口号)</code>。</p><p><strong>每一条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）所确定</strong>。</p><p>TCP 连接<code>::= {socket1, socket2} = { (IP1: port1)，(IP2: port2) }</code></p><p>同一个 IP 地址可以有多个不同的 TCP 连接。</p><p>同一个端口号也可以出现在多个不同的 TCP 连接中。</p><h3 id="3、TCP首部格式"><a href="#3、TCP首部格式" class="headerlink" title="3、TCP首部格式"></a>3、TCP首部格式</h3><p>首部格式:</p><p><div align="center"> <img src="/images/5_11.png" width="670"></div><br></p><p>相关字段解释(对于理解TCP很重要)</p><ul><li>序号: 在一个TCP连接中传送的字节流中的每一个字节都按顺序编号，本字段表示本报文段所发送数据的第一个字节的序号，例如发送报文段<code>1-2-3</code>，则序号是<code>1</code>。</li><li>确认号: <strong>期望收到对方下一个报文段的第一个数据字节的序号</strong>。若确认号为N,则证明到序号N-1为止的所有数据都已正确收到。例如 B 正确收到 A 发送来的一个报文段，序号为 301，携带的数据长度为 100 字节，因此 B 期望下一个报文段的序号为 401，B 发送给 A 的确认报文段中确认号就为 401；</li><li>数据偏移(<strong>首部长度</strong>) : TCP报文段的数据起始处距离TCP报文段的起始处有多远，以4B位单位，即1个数值是4B。</li><li>6个控制位。<ul><li><strong>紧急位URG</strong> : URG=1时，标明此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用在缓存里排队，配合<strong>紧急指针字段</strong>使用；</li><li><strong>确认位ACK</strong> : ACK=1时确认号有效，在连接建立后所有传送的报文段都必须把ACK置为1；</li><li><strong>推送位PSH</strong> : PSH=1时，<strong>接收方尽快交付接收应用进程，不再等到缓存填满再向上交付</strong>；</li><li><strong>复位RST</strong> : RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再<strong>重新建立</strong>传输链接；</li><li><strong>同步位SYN</strong> : SYN=1时，表明是一个连接请求/连接接受报文；</li><li><strong>终止位FIN</strong> : FIN=1时，表明此报文段发送方数据已发完，<strong>要求释放连接</strong>。</li></ul></li><li><strong>窗口</strong> ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</li><li>检验和: 占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。 </li><li>紧急指针: URG = 1时才有意义，指出本报文段紧急数据的字节数；</li><li>选项: 最大报文段长度MSS、窗口扩大、时间戳、时间确认….；</li></ul><blockquote><p>MSS (Maximum Segment Size)是 TCP 报文段中的数据字段的最大长度。<strong>数据字段加上 TCP 首部才等于整个的 TCP 报文段</strong>。所以，MSS是 <code>TCP 报文段长度 -  TCP 首部长度</code>；</p></blockquote><p>捕获的TCP报文段:</p><p><img src="/images/5_12.png" alt="5_12.png"></p><h3 id="4、TCP和UDP的区别"><a href="#4、TCP和UDP的区别" class="headerlink" title="4、TCP和UDP的区别"></a>4、TCP和UDP的区别</h3><ul><li>1、TCP面向连接（如打电话要先拨号建立连接）；UDP是无连接的，即发送数据之前不需要建立连接。</li><li>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，即不保证可靠交付。</li><li>3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流；UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）。</li><li>4、每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信。</li><li>5、TCP首部开销20字节；UDP的首部开销小，只有8个字节。</li><li>6、TCP的逻辑通信信道是全双工的可靠信道；UDP则是不可靠信道。</li></ul><h2 id="三、TCP连接管理"><a href="#三、TCP连接管理" class="headerlink" title="三、TCP连接管理"></a>三、TCP连接管理</h2><h3 id="1、TCP的连接建立"><a href="#1、TCP的连接建立" class="headerlink" title="1、TCP的连接建立"></a>1、TCP的连接建立</h3><h4 id="1-、三次握手"><a href="#1-、三次握手" class="headerlink" title="1)、三次握手"></a>1)、三次握手</h4><p>TCP连接传输三个阶段:</p><ul><li>连接建立；</li><li>数据传送；</li><li>连接释放；</li></ul><p>TCP连接的建立采用客户端服务器方式，主动发起连接建立的应用进程叫做客户端(A)，而被动等待连接建立的应用进程叫服务器(B)。</p><p>假设运行在一台主机(客户)上的一个进程想与另一台主机（服务器）上的一个进程建立一条连接，客户应用进程首先通知客户TCP，他想建立一个与服务器上某个进程之间的连接，客户中的TCP会用以下步骤与服务器中的TCP建立一条TCP连接:</p><p><div align="center"><img src="/images/5_13.png"></div><br></p><p>步骤:</p><ul><li>1)、A 向 B 发送连接请求报文段，SYN=1，ACK=0，选择一个初始的序号 seq = x；</li><li>2)、B 收到连接请求报文段，，如果同意建立连接，服务器为该TCP连接分配缓存和变量，向 A 发送连接确认报文段，SYN=1，ACK=1，确认号<code>ack</code>为 <code>x+1</code>，同时也选择一个初始的序号 seq = y (随机)；</li><li>3)、A 收到 B 的连接确认报文段后，为该TCP连接分配缓存和变量，同时还要向 B 发出确认，ACK = 1，确认号为 ack = y+1，序号为 <code>seq = x+1</code>(接上一开始的<code>x</code>)；(SYN = 0，因为只有在连接请求和连接请求接受的时候才会置为1)；</li><li>4)、最后，B收到A确认报文，状态变为ESTABLISHED(连接建立)，双方就可以进行双向通信了；</li></ul><p>实战:</p><p>(1)、第一次握手</p><p><div align="center"><img src="/images/5_14.png" width></div><br></p><p>(2)、第二次握手</p><p><div align="center"><img src="/images/5_15.png" width></div><br></p><p>(3)、第三次握手</p><p><div align="center"><img src="/images/5_16.png" width></div><br></p><h4 id="2-、为什么TCP连接需要三次握手，两次不可以吗，为什么"><a href="#2-、为什么TCP连接需要三次握手，两次不可以吗，为什么" class="headerlink" title="2)、为什么TCP连接需要三次握手，两次不可以吗，为什么?"></a>2)、为什么TCP连接需要三次握手，两次不可以吗，为什么?</h4><p>主要是 : <strong>为了防止已失效的连接请求报文段突然又传送到了服务端，占用服务器资源</strong> 。(A是客户端，B是服务器)</p><p>现假定出现一种异常情况，即A发出的第一个连接请求报文段并没有丢失，而是在某些网络节点长时间滞留了，以致延误到连接释放以后的某个时间才到B。本来这是一个已失效的报文段，但是B收到此失效的连接请求报文段后，就误认为是A又发出一次新的连接请求。于是就向A发出确认报文段，同意建立连接。假定不采用三次握手，那么只要B发出确认，新的连接就建立了。</p><p>由于现在A并没有发出建立连接的请求，因此不会理睬B的确认，也不会向B发送数据。但B却以为新的运输连接已经建立了，并一直等待A发来数据。B的许多资源就这样白白浪费了。</p><p>采用三次握手的办法可以防止上述现象的发生。例如在刚才的情况下，A不会向B的确认发出确认。B由于收不到确认，就知道A并没有要求建立连接。</p><h4 id="3-、SYN攻击"><a href="#3-、SYN攻击" class="headerlink" title="3)、SYN攻击"></a>3)、SYN攻击</h4><p>SYN洪泛攻击发生在OSI第四层，这种方式利用TCP协议的特性，就是三次握手。<strong>攻击者发送TCP SYN，SYN是TCP三次握手中的第一个数据包，而当服务器返回ACK后，该攻击者就不对其进行再确认，那这个TCP连接就处于挂起状态，也就是所谓的半连接状态</strong>，服务器收不到再确认的话，还会重复发送ACK给攻击者。这样更加会浪费服务器的资源。攻击者就对服务器发送非常大量的这种TCP连接，由于每一个都没法完成三次握手，所以在服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务了。</p><h3 id="2、TCP的连接释放"><a href="#2、TCP的连接释放" class="headerlink" title="2、TCP的连接释放"></a>2、TCP的连接释放</h3><h4 id="1-、四次挥手"><a href="#1-、四次挥手" class="headerlink" title="1)、四次挥手"></a>1)、四次挥手</h4><p>过程:</p><p><img src="/images/5_17.png" alt="5_17.png"></p><p>数据传输结束后，通信的双方都可释放连接。现在 A 的应用进程先向其 TCP <strong>发出连接释放报文段</strong>，并停止再发送数据，主动关闭 TCP连接。</p><ul><li>A 把连接释放报文段首部的 FIN = 1，其序号 seq = u，等待 B 的确认。</li><li>B 发出确认(会送一个确认报文段)，ACK = 1，确认号 ack = u+1，而这个报文段自己的序号 seq = v(随机)。（TCP 服务器进程通知高层应用进程）</li><li>从 A 到 B 这个方向的连接就释放了，TCP 连接处于<strong>半关闭状态</strong>。A 不能向 B 发送数据；<strong>B 若发送数据，A 仍要接收</strong>。</li><li>当 B 不再需要连接时，发送连接释放请求报文段，FIN=1，ACK =1，seq = w(随机)，确认号ack = u + 1(为什么确认号是一样的，因为在这段时间内，A没有发送数据) (这时B进入<code>LAST-ACK</code>(最后确认阶段))。</li><li>A 收到后发出确认，ACK =1, seq = u + 1（因为FIN要消耗一个序号，所以从u+1开始），进入 TIME-WAIT 状态，等待 2 MSL（2*2 = 4 mins）时间后释放连接。</li><li>B 收到 A 的确认后释放连接。</li></ul><h4 id="2-、四次挥手的原因"><a href="#2-、四次挥手的原因" class="headerlink" title="2)、四次挥手的原因"></a>2)、四次挥手的原因</h4><p>因为TCP有个半关闭状态，假设A、B要释放连接，那么A发送一个释放连接报文给B，B收到后发送确认，<strong>这个时候A不发数据，但是B如果发数据A还是要接受，这叫半关闭</strong>。然后B还要发给A连接释放报文，然后A发确认，所以是4次。</p><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。<strong>这个状态是为了让服务器端发送还未传送完毕的数据</strong>，传送完毕之后，服务器会发送 FIN 连接释放报文。 </p><p>在tcp连接握手时为何ACK是和SYN一起发送，这里ACK却没有和FIN一起发送呢。原因是因为tcp是<strong>全双工模式</strong>，<strong>接收到FIN时意味将没有数据再发来，但是还是可以继续发送数据。</strong></p><h4 id="3-、为什么A在TIME-WAIT状态必须等待2MSL的时间内？"><a href="#3-、为什么A在TIME-WAIT状态必须等待2MSL的时间内？" class="headerlink" title="3)、为什么A在TIME-WAIT状态必须等待2MSL的时间内？"></a>3)、为什么A在TIME-WAIT状态必须等待2MSL的时间内？</h4><p>MSL是<code>Maximum Segment Lifetime</code>英文的缩写，中文可以译为 “报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。2MSL = 2*2mins = 4mins<br>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p><ul><li><strong>确保最后一个确认报文段能够到达B</strong>。如果 B 没收到 A 发送来的确认报文段，那么就会重新发送连接释放请求报文段，接着 A 重传一次确认，重新启动 2MSL 计时器。A 等待一段时间就是为了处理这种情况的发生。</li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文段都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文段。</li></ul><h3 id="3、三次握手和四次挥手涉及的状态"><a href="#3、三次握手和四次挥手涉及的状态" class="headerlink" title="3、三次握手和四次挥手涉及的状态"></a>3、三次握手和四次挥手涉及的状态</h3><p>三次握手</p><ul><li>CLOSED：初始状态。</li><li>LISTEN：服务器处于监听状态。</li><li>SYN_SEND：客户端socket执行CONNECT连接，发送SYN包，进入此状态。</li><li>SYN_RECV：服务端收到SYN包并发送服务端SYN包，进入此状态。</li><li>ESTABLISH：表示连接建立。客户端发送了最后一个ACK包后进入此状态，服务端接收到ACK包后进入此状态。</li></ul><p>四次挥手:</p><ul><li>FIN_WAIT_1：终止连接的一方（通常是客户机）发送了FIN报文后进入。等待对方FIN。</li><li>CLOSE_WAIT：（假设服务器）接收到客户机FIN包之后等待关闭的阶段。在接收到对方的FIN包之后，自然是需要立即回复ACK包的，表示已经知道断开请求。但是本方是否立即断开连接（发送FIN包）取决于是否还有数据需要发送给客户端，若有，则在发送FIN包之前均为此状态。</li><li>FIN_WAIT_2：此时是半连接状态，即有一方要求关闭连接，等待另一方关闭。客户端接收到服务器的ACK包，但并没有立即接收到服务端的FIN包，进入FIN_WAIT_2状态。</li><li>LAST_ACK：服务端发动最后的FIN包，等待最后的客户端ACK响应，进入此状态。</li><li>TIME_WAIT：客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，在此之后的2MSL时间称为TIME_WAIT状态。</li></ul><h2 id="四、TCP可靠传输和流量控制"><a href="#四、TCP可靠传输和流量控制" class="headerlink" title="四、TCP可靠传输和流量控制"></a>四、TCP可靠传输和流量控制</h2><p><strong>所谓流量控制就是让发送发送速率不要过快，让接收方来得及接收。利用滑动窗口机制就可以实施流量控制</strong>。</p><p>原理这就是运用TCP报文段中的窗口大小字段来控制，发送方的发送窗口不可以大于接收方发回的窗口大小。考虑一种特殊的情况，就是接收方若没有缓存足够使用，就会发送零窗口大小的报文，此时发送放将发送窗口设置为0，停止发送数据。</p><p>之后接收方有足够的缓存，发送了非零窗口大小的报文，但是这个报文在中途丢失的，那么发送方的发送窗口就一直为零导致死锁。解决这个问题，<strong>TCP为每一个连接设置一个持续计时器</strong>（persistence timer）。</p><p>只要TCP的一方收到对方的零窗口通知，就启动该计时器，周期性的发送一个零窗口探测报文段。对方就在确认这个报文的时候给出现在的窗口大小</p><p>（<strong>注意：TCP规定，即使设置为零窗口，也必须接收以下几种报文段：零窗口探测报文段、确认报文段和携带紧急数据的报文段</strong>）。</p><p>针对可靠传输和流量控制有三种协议: 停止等待协议、后退N帧协议、选择重传协议。</p><p><img src="/images/3_10.png" alt="3_10.png"></p><h3 id="1、停止等待协议"><a href="#1、停止等待协议" class="headerlink" title="1、停止等待协议"></a>1、停止等待协议</h3><p>停止等待协议也可以在传输层讨论。</p><p>停止等待协议是<strong>为了实现流量控制</strong>。</p><p>简言之: <strong>就是每发送一个分组就停止发送，等待对方确认，在收到确认后再发送下一个分组</strong>。</p><p>主要分为: <strong>无差错情况和有差错情况</strong>。</p><h4 id="1-、无差错的情况"><a href="#1-、无差错的情况" class="headerlink" title="1)、无差错的情况"></a>1)、无差错的情况</h4><p><img src="/images/3_12.png" alt="3_12.png"></p><p>这里应注意以下三点。</p><ul><li>第一，A 在发送完一个分组后，必须<strong>暂时保留已发送的分组的副本</strong>(发生超时重传时使用)。只有在收到相应的确认后才能清除暂时保留的分组副本。</li><li>第二，<strong>分组和确认分组都必须进行编号</strong>。这样才能明确是哪一个发送出去的分组收到了确认，而哪一个分组还没有收到确认。</li><li>第三，超时计时器设置的重传时间应当比数据分组传输的平均往返时间(RTT)更长一些。</li></ul><blockquote><p>ACK (Acknowledgement）即是确认字符，在数据通信中，接收站发给发送站的一种传输类控制字符。表示发来的数据已确认接收无误。</p><p>在TCP/IP协议中，如果接收方成功的接收到数据，那么会回复一个ACK数据。通常ACK信号有自己固定的格式,长度大小,由接收方回复给发送方。</p></blockquote><h4 id="2-、有差错的情况"><a href="#2-、有差错的情况" class="headerlink" title="2)、有差错的情况"></a>2)、有差错的情况</h4><p>又可以分为两种:</p><ul><li><p>数据帧丢失或者检验到帧出错；</p></li><li><p>ACK丢失；</p></li><li>ACK迟到；</li></ul><p>数据帧丢失的情况:</p><p><img src="/images/3_13.png" alt="3_13.png"></p><p>ACK丢失和ACK迟到:</p><p><img src="/images/3_14.png" alt="3_14.png"></p><h4 id="3-、缺点"><a href="#3-、缺点" class="headerlink" title="3)、缺点"></a>3)、缺点</h4><p>信道利用率太低:</p><ul><li>大部分时间都在路上；</li><li>即RTT（传输往返时延）太长；</li></ul><p><img src="/images/3_15.png" alt="3_15.png"></p><p>针对上面停止等待协议的缺点，于是就有了在传输数据时的流水线发送数据，也就引出了两种协议:</p><ul><li>后退N帧协议；</li><li>选择重传协议；  </li></ul><p>解决停等协议的流水线解决方案:</p><p><img src="/images/3_16.png" alt="3_16.png"></p><h3 id="2、后退N帧协议-ARQ"><a href="#2、后退N帧协议-ARQ" class="headerlink" title="2、后退N帧协议(ARQ)"></a>2、后退N帧协议(ARQ)</h3><p>用图来看一下步骤:</p><p><div align="center"> <img src="/images/3_17.png" width></div><br></p><p><div align="center">  <img src="/images/3_18.png"></div><br></p><p>在这个过程中，发送方可以分成几个部分:</p><ul><li>发送完被确认的；</li><li>已经发送但等待确认的；</li><li>还能发送的；</li><li>还不能发送的；</li></ul><h4 id="1-、GBN发送方必须做的三件事"><a href="#1-、GBN发送方必须做的三件事" class="headerlink" title="1)、GBN发送方必须做的三件事"></a>1)、GBN发送方必须做的三件事</h4><p>1)、上层的调用</p><p>上层要发送数据时，发送方先检查发送窗口是否已满，如果未满，则产生一个帧并将其发送， 如果窗口已满，<br>发送方只需将数据返回给上层，暗示上层窗口已满。上层等一会再发送。 (实际实现中，发送方可以缓存这<br>些数据，窗口不满时再发送帧) 。</p><p>2)、收到了一个ACK (重要)</p><p>GBN协议中，对n号帧的确认采用<strong>累积确认</strong>的方式，<strong>标明接收方已经收到n号帧和它之前的全部帧</strong>。</p><p>3)、超时事件</p><p><strong>协议的名字为后退N帧/回退N帧</strong>，来源于出现丢失和时延过长帧时发送方的行为。就像在停等协议中一样，<br>定时器将再次用于恢复数据帧或确认帧的丢失。如果出现超时，发送方重传所有已发送但未被确认的帧。</p><h4 id="2-、GBN接收方必须要做的事"><a href="#2-、GBN接收方必须要做的事" class="headerlink" title="2)、GBN接收方必须要做的事"></a>2)、GBN接收方必须要做的事</h4><p>1)、如果正确收到n号帧，并且按序，那么接收方为n帧发送一个ACK，并将该帧中的数据部分交付给上层。</p><p>2)、<strong>其余情况都丢弃帧，并为最近按序接收的帧重新发送ACK。接收方无需缓存任何东西，只需要维护一个信息: expectedseqnum</strong> (下一个按序接收的帧序、我期待的下一个的帧的序号，如果一直没来我就一直丢弃你的不符合的帧) 。</p><blockquote><p>注意发送窗口不能无限大，范围是<code>1 ~ 2^n-1</code>，<code>n</code>是代表用<code>n</code>个比特对帧编号。</p></blockquote><h4 id="3-、GBN总结和注意事项"><a href="#3-、GBN总结和注意事项" class="headerlink" title="3)、GBN总结和注意事项"></a>3)、GBN总结和注意事项</h4><p><img src="/images/3_19.png" alt="3_19.png"></p><p>几个重点:</p><ul><li>累积确认( 偶尔捎带确认)；</li><li><strong>接收方只按顺序接收帧，不按序无情丢弃</strong>；</li><li>确认序列号最大的、按序到达的帧；</li><li><strong>发送窗口最大为 2<sup>n</sup> - 1，接收窗口大小为1</strong>；</li></ul><p><img src="/images/3_20.png" alt="3_20.png"></p><h3 id="3、选择重传协议"><a href="#3、选择重传协议" class="headerlink" title="3、选择重传协议"></a>3、选择重传协议</h3><p>后退N帧协议的缺点 : 有些帧发送的好好的(由于<code>exceptedSeqNum</code>不对)，为什么让我重传呢?</p><p>解决办法:</p><p>设置单个确认，同时加大接收窗口，设置接收缓存，缓存乱序到达的帧。</p><p>基本方法:</p><p><img src="/images/3_21.png" alt="3_21.png"></p><h4 id="1-、SR发送方必须做的三件事"><a href="#1-、SR发送方必须做的三件事" class="headerlink" title="1)、SR发送方必须做的三件事"></a>1)、SR发送方必须做的三件事</h4><p>1)、从上层收到数据后，<strong>SR发送方检查下一个可用于该帧的序号，如果序号位于发送窗口内，则发送数据帧</strong>；否<br>则就像GBN一样，要么将数据缓存，要么返回给上层之后再传输；</p><p>2)、如果收到ACK，加入该帧序号在窗口内，则SR发送方将那个被确认的帧标记为已接收。如果该帧序号是窗口<br>的下界(最左边第一个窗口对应的序号) ，<strong>则窗口向前移动到具有最小序号的未确认帧处</strong>。如果窗口移动了<br>并且有序号在窗口内的未发送帧，则发送这些帧。</p><p>3)、每个帧都有自己的定时器，一个超时时间发生之后只重传一个帧。</p><h4 id="2-、SR接收方必须要做的事"><a href="#2-、SR接收方必须要做的事" class="headerlink" title="2)、SR接收方必须要做的事"></a>2)、SR接收方必须要做的事</h4><p>1)、<strong>SR接收方将确认一个正确接收的帧而不管其是否按序</strong>。<strong>失序的帧将被缓存</strong>，并返回给发送方一个该帧的确认帧【收谁确认谁】，直到所有帧(<strong>即序号更小的帧)</strong>皆被收到为止，这时才可以将一批帧按序交付给上层，然后向前移动滑动口上。</p><p>2)、<strong>如果收到了小于窗口下界的帧，就返回一个ACK，否则就忽略该帧</strong>。</p><h4 id="3-、SR总结和注意事项"><a href="#3-、SR总结和注意事项" class="headerlink" title="3)、SR总结和注意事项"></a>3)、SR总结和注意事项</h4><p><img src="/images/3_22.png" alt="3_22.png"></p><p>SR重点:</p><ul><li>对数据帧逐一确认，收一个确认一个(先来着不拒)；</li><li>只重传出错帧；</li><li>接收方有<strong>缓存</strong>；</li><li>W<sub>发送方</sub> = W<sub>接收方</sub> = 2 <sup>n-1</sup>；</li></ul><p><img src="/images/3_23.png" alt="3_23.png"></p><p>以字节为单位的滑动窗口技术详解（总的流程图）:</p><p><img src="/images/滑动窗口.png" alt="滑动窗口.png"></p><p><strong>窗口是缓存的一部分，用来暂时存放字节流</strong>。发送方和接收方各有一个窗口，<strong>接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小</strong>。</p><p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。<strong>如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离</strong>，直到左部第一个字节不是已发送并且已确认的状态；</p><p>接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p><p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {1, 2, 4, 5}，其中 {1, 2} 按序到达，而 {4, 5} 就不是，因此只对字节 {1, 2}  进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p><blockquote><p>发送缓存用来暂时存放：</p><ul><li>发送应用程序传送给发送方 TCP 准备发送的数据；</li><li>TCP 已发送出但尚未收到确认的数据。</li></ul><p>接收缓存用来暂时存放：</p><ul><li>按序到达的、但尚未被接收应用程序读取的数据；</li><li><strong>不按序到达的数据</strong>。</li></ul></blockquote><h3 id="4、流量控制"><a href="#4、流量控制" class="headerlink" title="4、流量控制"></a>4、流量控制</h3><p><img src="/images/流量控制.png" alt="流量控制.png"></p><blockquote><p>rwnd : Receive Window，即接收窗口。注意TCP的窗口单位是字节，不是报文段。</p></blockquote><p>这个过程主机B进行了三次流量控制，第一次把窗口减小到<code>rwnd = 300</code>，第二次又减到<code>rwnd = 100</code>，最后减到<code>rwnd = 0</code>，即不允许发送方再发送数据了。</p><blockquote><p>可能发生死锁的问题:</p><p>B 向 A 发送了零窗口的报文段后不久，B 的接收缓存又有了一些存储空间。于是 B 向 A 发送了 rwnd =<br>400 的报文段。<br>但这个报文段在传送过程中丢失了。A 一直等待收到B 发送的非零窗口的通知，而 B 也一直等待 A 发送的<br>数据。<br>如果没有其他措施，这种互相等待的死锁局面将一直延续下去。<br>为了解决这个问题，TCP 为每一个连接设有一个<strong>持续计时器</strong> (persistence timer)。</p></blockquote><h2 id="五、TCP拥塞控制"><a href="#五、TCP拥塞控制" class="headerlink" title="五、TCP拥塞控制"></a>五、TCP拥塞控制</h2><h3 id="1、拥塞控制原理"><a href="#1、拥塞控制原理" class="headerlink" title="1、拥塞控制原理"></a>1、拥塞控制原理</h3><p>拥塞控制原理</p><ul><li>在某段时间，若<strong>对网络中某资源的需求超过了该资源所能提供的可用部分</strong>，网络的性能就要变坏——产生拥塞(congestion)。</li><li>出现资源拥塞的条件：<strong>对资源需求的总和  &gt; 可用资源</strong>；</li><li>若网络中有许多资源同时产生拥塞，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降。</li></ul><p>拥塞控制: 防止过多的数据注入到网络中。</p><p>注意流量控制和拥塞控制的本质区别: <strong>流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度</strong>。</p><p><div align="center"> <img src="/images/5_18.png" width="550"></div><br></p><blockquote><p>rwnd : Receive Window，即接收窗口。接收方根据接受缓存设置的值，并告知给发送方，反映接收方容量。</p><p>cwnd: Congestion Window，即拥塞窗口。发送方根据自己估算的网络拥塞程度而设置的窗口值，反映网络当前容量。</p><p>接收窗口: 是接收方设置的。拥塞窗口: 是发送方设置的</p><p>拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p></blockquote><p><div align="center"> <img src="/images/5_19.png" width="550"></div><br></p><blockquote><p>提供的负载，就是往网络上放的数据的量。</p></blockquote><p>TCP 主要通过四种算法来进行拥塞控制：<strong>慢开始、拥塞避免、快重传、快恢复</strong>。</p><p>虽然 TCP 的窗口基于字节，但是这里按照窗口的大小单位为报文段来讨论。</p><h3 id="2、慢开始和拥塞避免"><a href="#2、慢开始和拥塞避免" class="headerlink" title="2、慢开始和拥塞避免"></a>2、慢开始和拥塞避免</h3><p>慢开始的原理: <strong>由小到大逐渐增大拥塞窗口数值</strong>。每次可以按照收到的确认的个数来判断成功的概率。逐步增大发送方的拥塞窗口 cwnd，可以使分组注入到网络的速率更加合理。发送方每收到一个对新报文段的确认（重传的不算在内）就使 cwnd 加 1。</p><p><div align="center"> <img src="/images/5_20.png" width="650"></div><br></p><p>过程:</p><p><div align="center"> <img src="/images/5_21.png" width="690"></div><br></p><p>发送的最初执行慢开始，令 cwnd=1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p><p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能也就更高。</p><p>设置一个慢开始阈值 (门限)ssthresh，当 <code>cwnd &gt;= ssthresh</code> 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p><p>如果出现了超时(最大拥塞窗口)，则令 <code>ssthresh = cwnd/2</code>，然后重新执行慢开始。</p><blockquote><p> 慢开始门限 ssthresh 的用法如下：</p><ul><li>当 cwnd &lt; ssthresh 时，使用慢开始算法。</li><li>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</li><li>当cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。</li></ul></blockquote><h3 id="3、快重传和快恢复"><a href="#3、快重传和快恢复" class="headerlink" title="3、快重传和快恢复"></a>3、快重传和快恢复</h3><p>思想: 发送方只要一连收到<strong>三个重复确认</strong>，就知道接收方确实没有收到报文段，因而应当立即进行重传（即“快重传”），这样就不会出现超时，发送方也不就会误认为出现了网络拥塞。</p><p>不难看出，快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。</p><p><div align="center"><img src="/images/5_22.png" width"690"></div><br></p><p>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。</p><p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。</p><p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令<code>ssthresh = cwnd/2 ，cwnd = ssthresh</code>，注意到此时直接进入拥塞避免。</p><p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p><blockquote><p>注意: </p><p>发送方的发送窗口的上限值应当取为接收方窗口 rwnd 和拥塞窗口 cwnd 这两个变量中较小的一个，即应按以下公式确定：</p><p>发送窗口的上限值 = <code>min {rwnd, cwnd}</code><br>当 rwnd &lt; cwnd 时，是接收方的接收能力限制发送窗口的最大值。<br>当 cwnd &lt; rwnd 时，则是网络的拥塞限制发送窗口的最大值。</p></blockquote><h3 id="4、流量控制和拥塞控制区分"><a href="#4、流量控制和拥塞控制区分" class="headerlink" title="4、流量控制和拥塞控制区分"></a>4、流量控制和拥塞控制区分</h3><ul><li>拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。</li><li>流量控制往往指在给定的发送端和接收端之间的<strong>点对点</strong>通信量的控制。</li><li>流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</li><li>流量控制属于通信双方协商；拥塞控制涉及通信链路<strong>全局</strong>。</li><li>流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定；拥塞控制的拥塞窗口大小变化由<strong>试探性</strong>发送一定数据量数据探查网络状况后而自适应调整。 </li></ul><h3 id="5、超时重传、RTO、RTT"><a href="#5、超时重传、RTO、RTT" class="headerlink" title="5、超时重传、RTO、RTT"></a>5、超时重传、RTO、RTT</h3><ul><li>超时重传：发送端发送报文后若长时间未收到确认的报文则需要重发该报文。可能有以下几种情况：<ul><li>发送的数据没能到达接收端，所以对方没有响应。    </li><li>接收端接收到数据，但是ACK报文在返回过程中丢失。</li><li>接收端拒绝或丢弃数据。</li></ul></li><li>RTO(<code>Retransmission TimeOut</code>)：<strong>从上一次发送数据，因为长期没有收到ACK响应，到下一次重发之间的时间</strong>。就是重传间隔。通常每次重传RTO是前一次重传间隔的两倍，计量单位通常是RTT。例：1RTT，2RTT，4RTT，8RTT……重传次数到达上限之后停止重传。</li><li>RTT (<code>Round Trip Time</code>)：<strong>数据从发送到接收到对方响应之间的时间间隔</strong>，即数据报在网络中一个往返用时。大小不稳定。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计网总结-五-一运输层&quot;&gt;&lt;a href=&quot;#计网总结-五-一运输层&quot; class=&quot;headerlink&quot; title=&quot;计网总结(五)一运输层&quot;&gt;&lt;/a&gt;计网总结(五)一运输层&lt;/h1&gt;&lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算机网络总结（4）</title>
    <link href="https://www.junglezero.top/2019/08/01/%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93%EF%BC%884%EF%BC%89/"/>
    <id>https://www.junglezero.top/2019/08/01/机网络总结（4）/</id>
    <published>2019-08-01T06:26:11.000Z</published>
    <updated>2019-08-02T02:25:03.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计网总结-四-一网络层"><a href="#计网总结-四-一网络层" class="headerlink" title="计网总结(四)一网络层"></a>计网总结(四)一网络层</h1><p>先上一张总结图:</p><p><img src="/images/第四章总结脑图.png" alt="第四章总结脑图.png"></p><h2 id="一、数据交换方式"><a href="#一、数据交换方式" class="headerlink" title="一、数据交换方式"></a>一、数据交换方式</h2><p>第一章提到数据交换方式分为电路交换、报文交换、分组交换。</p><p>其中在网络层。分组交换又可以分为<strong>数据报方式和虚电路方式</strong>。</p><p>其中，<strong>数据报方式为网络层提供无连接服务</strong>。<strong>虚电路方式为网路层提供连接服务</strong>。</p><blockquote><p>无连接服务: 不事先为分组的传输确定传输路径，每个分组独立确定传输路径，不同分组传输路径可能不同。</p><p>连接服务: 首先为分组的<strong>传输确定传输路径</strong>(建立连接) ，然后沿该路径传输系列分组，系列分组传输路径相同，传输结束后拆除连接。</p></blockquote><p>几种传输单元在各层的位置:</p><p><img src="/images/4_1.png" alt="4_1.png"></p><p>下面看数据包方式和虚电路交换方式:</p><p><img src="/images/4_2.png" alt="4_2.png"></p><p>对比:</p><p><img src="/images/4_3.png" alt="4_3.png"></p><h2 id="二、IP数据报"><a href="#二、IP数据报" class="headerlink" title="二、IP数据报"></a>二、IP数据报</h2><h3 id="1、IP数据报格式"><a href="#1、IP数据报格式" class="headerlink" title="1、IP数据报格式"></a>1、IP数据报格式</h3><p><img src="/images/4_6.png" alt="4_6.png"></p><p>一个 IP 数据报由首部和数据两部分组成。首部的前一部分是固定长度，共<code>20</code>字节，是所有 IP 数据报必须具有的。在首部的固定部分的后面是一些可选字段，其长度是可变的。 </p><ul><li><p>版本——占 4 位，指 IP 协议的版本。目前的 IP 协议版本号为 4 (即 IPv4)；</p></li><li><p>首部长度——占 4 位，可表示的最大数值是 15 个单位(一个单位为 4 字节)，因此 IP 的首部长度的最大值是 60 字节；</p></li><li><p>总长度——占 16 位，指首部和数据之和的长度，单位为字节，因此数据报的最大长度为 65535 字节。总长度必须不超过最大传送单元 MTU(数据链路层规定)；</p></li><li><p>标识(identification) ——占 16 位，它是一个计数器，用来产生 IP 数据报的标识。；</p></li><li><p>标志(flag) ——占 3 位，目前只有前两位有意义。标志字段的最低位是 MF (More Fragment)。MF = 1 表示后面“还有分片”。MF = 0 表示最后一个分片。标志字段中间的一位是 DF (Don’t Fragment) 。只有当 DF = 0 时才允许分片； </p></li><li><p>片偏移——占13 位，指出：较长的分组在分片后某片在原分组中的相对位置。片偏移以 8 个字节为偏移单位；</p></li><li><p>生存时间——占8 位，记为 TTL (Time To Live)，指示数据报在网络中可通过的路由器数的最大值；</p></li><li><p>协议——占8 位，指出此数据报携带的数据使用何种协议，以便目的主机的 IP 层将数据部分上交给那个处理过程；</p></li><li><p>首部检验和——占16 位，只检验数据报的首部，不检验数据部分。这里不采用 CRC 检验码而采用简单的计算方法。 </p></li></ul><p><img src="/images/4_14.png" alt="在这里插入图片描述"></p><h3 id="2、IP数据报分片"><a href="#2、IP数据报分片" class="headerlink" title="2、IP数据报分片"></a>2、IP数据报分片</h3><p>当IP数据报传送到链路层的时候，如果IP数据报长度超过MTU，就需要分片。</p><p><img src="/images/4_16.png" alt="4_16.png"></p><p>具体的分片过程:</p><p><img src="/images/4_7.png" alt="4_7.png"></p><blockquote><p>中间位 DF(Don’t Fragment)</p><ul><li>DF = 1 ，禁止分片；</li><li>DF = 0，允许分片；</li></ul><p>最低位MF(More Fragment)</p><ul><li>MF = 1，后面”还有分片”；</li><li>MF = 0，代表最后一片/没分片；</li></ul></blockquote><h2 id="三、IP地址"><a href="#三、IP地址" class="headerlink" title="三、IP地址"></a>三、IP地址</h2><h3 id="1、IP地址概念"><a href="#1、IP地址概念" class="headerlink" title="1、IP地址概念"></a>1、IP地址概念</h3><ul><li><code>IP</code> 地址就是给每个连接在互联网上的主机（或路由器）分配一个在全世界范围是唯一的 <code>32</code> 位的标识符，用来定位网络中的计算机和网络设备；</li><li>IP 地址用 <code>32</code> 位二进制来表示， 也就是<code>32</code> 比特， 换算成字节， 就 是 <code>4</code> 个字节。例如一个采用二进制形式的 IP 地址是<code>10101100 00010000 00011110 00111000</code>， 这么长的地址， 处理起来太费劲。于是这些位被分割为<code>4</code>    个部分， 每一部分<code>8</code>位二进制， 中间使用符号 <code>.</code>分开 ，上面的 <code>IP</code> 地址可以表示为<code>172.16.30.56</code>。<code>IP</code> 地址的这种表示法叫做“点分十进制表示法”；</li><li>计算机的 <code>IP</code> 地址由两部分组成， <strong>一部分为网络标识， 一部分为主机标识</strong>；同 一网段的计算机网络部分相同。路由器连接不同网段，负责不同网段之间的数据转发，交换机连接的则是同一网段的计算机；见下图:<br><img src="/images/4_9.png" alt="在这里插入图片描述"></li></ul><blockquote><p>计算机在和其他计算机通信之前， 首先要判断目标 <code>IP</code>  地址和自己的<code>IP</code>  地址是否在一个网段， 这决定了数据链路层的目标 <code>MAC</code> 地址是目标计算机的还是路由器接口的。 </p></blockquote><p><strong>IP地址和硬件地址的区别</strong> </p><p><img src="/images/4_8.png" alt="在这里插入图片描述"></p><h3 id="2、子网掩码"><a href="#2、子网掩码" class="headerlink" title="2、子网掩码"></a>2、子网掩码</h3><ul><li>子网掩码 ( <code>Subnet Mask</code>) 又叫网络掩码、地址掩码，它是一种用来指明一个<code>IP</code>地址的哪些位标识的是主机所在的子网以及哪些位标识的是主机的位掩码。<strong>子网掩码只有一个作用，就是将某个<code>IP</code>  地址划分成网络地址和主机地址两部分</strong>。</li><li>例如: 计算机的 <code>IP</code> 地址是 <code>131.107.41.6</code>,  子网掩码是 <code>255.255.0.0</code>,  计算机所在网段是<code>131.107.0.0</code>。该计算机和远程计算机通信 ，目标 <code>IP</code> 地址只要前面两部分是 <code>131.107</code>就认为和 该计算机在同一个网段；</li></ul><p>通过<code>IP</code>和子网掩码计算网段: </p><p>方法:  IP 地址和子网掩码做<strong>与运算</strong>：</p><p><img src="/images/4_10.png" alt="在这里插入图片描述"></p><p>有关二进制的特殊转换和特征(和划分子网有关系):<br>|二进制|十进制|备注|<br>|  —-  | —-  | —-  |<br>|1000 0000    |128||<br>|1100 0000|192| 1000 0000+ 10 0000 也就是 128 + 64=192|<br>|1110 0000|224| 1000 0000 + 100 0000 + 10 0000 也就是 128  + 64 + 32=224|<br>|1111 0000|240| 128 + 64 + 32 + 16 = 240|<br>|1111 1000|248| 128 + 64 + 32 + 16 + 8 = 248|<br>|1111 1100|252| 128 + 64 + 32 + 16 + 8 + 4 = 252|<br>|1111 1110|254| 128 + 64 + 32+ 16 + 8 + 4 + 2=254|<br>|1111 1111|255| 128 + 64 + 32 + 16 + 8 + 4 + 2 + 1=255|</p><p><img src="/images/4_11.png" alt="在这里插入图片描述"></p><p>一个规律，<strong>如果要你写出十进制转换成二进制后，后n位二进制是多少</strong>: </p><blockquote><ul><li>能够被 <code>2</code> 整除的数， 写成二进制形式， 后一位是 <code>0</code>。如果余数是<code>1</code>,  则最后一位是 <code>1</code>。 </li><li>能够被 <code>4</code>整除的数， 写成二进制形式， 后两位是 <code>00</code>。如果余数是<code>2</code> , 那就把 <code>2</code>写成二进制，后两位是<code>10</code>。</li><li>能够被 <code>8</code> 整除的数， 写成二进制形式， 最后三位是 <code>000</code>。如果余 <code>5</code> , 就把<code>5</code>写成二进制， 后三位是 <code>101</code>。</li><li>能够被 <code>16</code> 整除的数， 写成二进制形式， 最后四位是 <code>0000</code> 。如果余 <code>6</code> ,   就把<code>6</code>写成二进制， 最后四位是 <code>0110</code> 。</li></ul></blockquote><p>我们可以找出规律， 如果让你写出一个十进制数转换成二进制数后面的 <code>n</code> 位二进制数 ，你可以将该数除以 2<sup>n</sup>,    将余数写成 <code>n</code> 位二进制即可。</p><p>举例:  写出十进制数 242 转换成二进制数后的最后 4 位:<br>2<sup>4</sup>   是 <code>16</code> ,  <code>242</code> 除以 <code>16</code>,  余 <code>2</code> ,  将余数写成 4 位二进制，就是 <code>0010</code> 。</p><h3 id="3、IP地址分类"><a href="#3、IP地址分类" class="headerlink" title="3、IP地址分类"></a>3、IP地址分类</h3><p>如图所示: </p><ul><li>A类地址: <strong>网络地址最高位是 <code>0</code> 的地址为 A 类地址</strong>。网络 ID 全 <code>0</code> 不能用，<code>127</code> 作为保留网段，因此 A 类地址的第 1 部分取值范围为 <code>1~126</code>；A 类网络默认子网掩码为<code>255.0.0.0</code>。主机ID 由第 2 部分、第 3 部分和第 4 部分组成，每部分的取值范围为 <code>0~255</code>，共 256 种取值，由排列组合知道，一个 A 类网络主机数量是 <code>256 * 256 * 256=166777216</code>，这里还需减去<code>2</code>，主机 ID 全 0 的地址为网络地址，而主机ID 全 <code>1</code> 的地址为广播地址，如果你给主机 ID 全 <code>1</code> 的地址发送数据包，计算机产生一个数据链路层广播帧，<strong>发送到本网段全部计算机</strong>；</li><li>B类地址: <strong>网络地址最高位是<code>10</code>的地址为B类地址</strong>。IP地址第一部分取值范围为<code>128 ~ 191</code>。B类网络默认子网掩码为 <code>255.255.0.0</code>。主机 ID 由第 3 部分和第 4 部分组成，每个 B 类网络可以容纳的最大主机数量为 <code>256X256-2=65023</code> ；</li><li>C类地址: <strong>网络地址最高位是<code>110</code>的地址为C类地址</strong>。IP地址第一部分取值范围为<code>192 ~ 223</code>。子网掩码是<code>255.255.255.0</code>，主机ID由第4部分组成，每个C类网络可以容纳的最大主机数量为<code>256 - 2 = 254</code>；</li></ul><p><img src="/images/4_12.png" alt="在这里插入图片描述"></p><p> 数轴表示:<img src="/images/4_13.png" alt="在这里插入图片描述"></p><ul><li>一个<code>A</code>类网络的主机数量是<code>256</code><em><code>256</code></em><code>256</code>个，这里还需要减去<code>2</code>，因为主机<code>ID</code>全<code>0</code>的地址为网络地址，而主机<code>ID</code>全<code>1</code>的地址为广播地址，如果给主机<code>ID</code>全1的<code>IP</code>地址发送数据包，这个电脑将产生一个数据链路层广播帧，发送到本网段全部计算机；</li><li>在电脑中，我们只需要写出自己的<code>IP</code>地址，按下<code>TAB</code>键，就能自动将子网掩码补全，这就说明，可以按照前<code>8</code>位来推断是哪一类地址，然后推断子网掩码。子网掩码可以来划分网络部分(<code>net-id</code>)和主机部分(<code>host-id</code>)；</li><li>在同一个局域网上的主机或路由器的IP 地址中的网络号(<code>net-id</code>)必须是一样的。</li><li>路由器总是具有两个或两个以上的 IP 地址。路由器的每一个接口(<code>fastethernet</code>或者<code>serial</code>)都有一个不同网络号的 IP 地址。</li></ul><p><strong>保留的IP地址</strong><br>有些 IP 地址被保留用于某些特殊目的， 网络管理员不能将这些地址分配给计算机。</p><ul><li>主机 <code>ID</code> 全为 0 的地址： 特指某个网段， 比如 <code>192.168. 10.0 255.255.255.0</code>,  指 <code>192.168.10.0</code>网段(<strong>网段也叫网络地址</strong>)；</li><li>主机<code>ID</code> 全为 1 的地址： 特指该网段的全部主机 ，如果你的计算机发送数据包使用主机 ID 全是 1 的 IP  地址， 数据链路层地址用广播地址 <code>FF-FF-FF-FF-FF-FF</code>。同一网段计算机名称解析就需要发送名称解析的广播包。比如你的计算机 lP 地址是<code>192.168.10.10</code> ,  子网掩码是 <code>255.255.255.0</code>, 它要发送一个广播包， 如目标 IP 地址是 <code>192.168.10.255</code> , 帧的目标MAC  地址是 <code>FF-FF-FF-FF-FF-FF</code>，该网段中全部计算机都能收到；</li><li><code>127.0.0.1</code>：  是回送地址， 指本机地址， 一般用作测试使用。回送地址 ( <code>127.x.x.x</code> )  即本机回送地址 ( <code>Loopback Address</code> ) , 指主机 IP 堆栈内部的 IP 地址， 主要用于网络软件测试以及本地机进程间通信， 无论什么程序， 一旦使用回送地址发送数据， 协议软件立即返回， 不进行任何网络传输。任何计算机都可以用该地址访问自己的共享资源或网站，如果  ping该地址能够通， 说明你的计算机的 <code>TCP/IP</code>协议栈工作正常， 即便你的计算机没有网卡，ping <code>127.0.0.1</code> 还是能够通的；</li><li><code>169. 254.0.0</code>： <code>169.254.0.0 ~ 169.254.255.255</code> 实际上是自动私有 IP 地址。 如果计算机无法获取 IP 地址， 对于Windows  2000 以后的操作系统， 则在无法获取 IP  地址时自动配置成 <code>&quot; IP地址： 169.254.x.x &quot;，&quot; 子网掩码：255.255.0.0“</code>，这样可以使所有获取不到IP地址的计算机能够通信；</li></ul><p><strong>私网地址和公网地址</strong></p><p>私网 IP 地址可以被用于私有网络 ，在 lnternet 上没有这些 IP 地址， Internet 上的路由器也没有到私有网络的路由表。<strong>我们在 Internet 上不能访问这些私网地址， 从这一点来说使用私网地址的计算机更加安全 ，也有效地节省了宝贵的公网IP 地址</strong>。使用私网地址的计算机可以通过 <strong>NAT</strong> ( Network Address Translation , 网络地址转换）技术访问Internet。</p><p>下面列出保留的私有IP 地址。</p><ul><li>A 类： <code>10.0.0.0 [255.0.0.0]</code>，  保留了一个 A 类网络。</li><li>B 类： <code>172.16.0.0 [255.255.0.0] ~ 172.31.0.0 [255.255.0.0]</code>,    保留了16个B类网络。</li><li>C 类： <code>192.168.0.0 [255.255.255.0]  ~ 192.168.255.0 [255.255.255.0]</code>，   保留了 256 个C类网络。</li></ul><p>关于<strong>网络地址转换NAT</strong></p><p>由于<strong>路由器对目的地址是私有IP地址的数据包一律不转发</strong>。所以需要使用<code>NAT</code>来使得私有地址访问<code>Internet</code>。</p><p>在专用网链接到因特网的路由器上安装了NAT软件，安装了NAT软件的路由器叫NAT路由器。</p><p><img src="/images/4_18.png" alt="4_18.png"></p><p>IP地址分类总结(<strong>下面的表格重要</strong>):</p><p><img src="/images/4_36.png" alt="4_36.png"></p><p><img src="/images/4_47.png" alt="4_47.png"></p><h3 id="4、子网划分"><a href="#4、子网划分" class="headerlink" title="4、子网划分"></a>4、子网划分</h3><p>子网划分就是<strong>将一个网段等分成多个网段，也就是等分成多个子网</strong>。</p><p>任务:</p><ul><li>确定子网掩码的长度；</li><li>确定子网中第一个可用的IP地址和最后一个可用的IP地址；</li></ul><p>在划分子网后，有些人将原来的网络号(地址)和主机号(地址)变成了三部分，即<strong>网络号、子网号、主机号</strong>：</p><p><img src="/images/4_37.png" alt="4_37.png"></p><p><img src="/images/4_38.png" alt="4_38.png"></p><blockquote><p>例题1:</p><p>已知IP地址是<code>141.14.72.24</code>，子网掩码是<code>255.255.192.0</code>，求网络地址。如果子网掩码是<code>255.255.224.0</code>，求网络地址。</p><p>(1)、答:　网络地址就是直接将子网掩码和IP地址逐位相与，这里只需要将<code>72和192</code>相与:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">01001000</span></span><br><span class="line">&gt; <span class="number">11000000</span></span><br><span class="line">&gt; --------</span><br><span class="line">&gt; <span class="number">01000000</span>   =  <span class="number">64</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>所以: 网络地址是 <code>141.14.64.0</code>。<strong>这里子网号占2位，剩下的主机号占6 + 8 = 14位</strong>。</p><p>(2)、同理:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">01001000</span></span><br><span class="line">&gt; <span class="number">11100000</span></span><br><span class="line">&gt; --------</span><br><span class="line">&gt; <span class="number">01100000</span>  = <span class="number">64</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>可见网络地址还是<code>141.14.64.0</code>。<strong>这里子网号占3位，剩下的主机号占5 + 8 = 13位</strong>。</p><p><strong>这个例子说明同样的IP地址可以和不同的子网掩码相与得出不同的网络地址</strong>。</p><p>例题2:</p><p>某主机的IP地址为<code>180.80.77.55</code>，子网掩码为<code>255.255.252.0</code>。若该主机向其所在子网发送广播分组，则目的地址可以是:  (<strong>D</strong>)</p><p>A、 <code>180.80.76.0</code>          B、<code>180.80.76.255</code>        C、<code>180.80.77.255</code>       D、<code>180.80.79.255</code></p><p>首先发现子网掩码是划分了子网的，因为第三位是<code>252</code>，对应二进制是<code>11111100</code>，则可以知道IP地址的<strong>网络号是16位、子网号是6位、主机号是2+8=10位</strong>。</p><p>将<code>77</code>写成二进制<code>01001101</code>，由于子网号是<code>6</code>位，所以我们取掉前<code>6</code>位 即<code>01001100</code>即<code>76</code>，但由于是广播地址，所以后面<code>+11</code>，即<code>01001111 11111111</code>，也就是<code>79.255</code>，即D。</p></blockquote><p>划分后的路由器分组转发算法(<strong>下面(五)路由算法那里也有讲</strong>)</p><ul><li>1、提取目的IP地址；</li><li>2、是否直接交付；</li><li>3、特定主机路由；</li><li>4、检测路由表中有无路径；</li><li>5、默认路由0.0.0.0；</li><li>6、丢弃，报告转发分组出错； </li></ul><h4 id="1-、无分类编址CIDR"><a href="#1-、无分类编址CIDR" class="headerlink" title="1)、无分类编址CIDR"></a>1)、无分类编址CIDR</h4><p><img src="/images/4_39.png" alt="4_39.png"></p><blockquote><p>IP地址后面跟<code>/24</code>表示掩码位是24位，即子网掩码是255.255.255.0的IP地址，其主机位最多有254个。 　<br>子网掩码通常有以下2种格式的表示方法： </p><ul><li>1、通过与IP地址格式相同的点分十进制表示。如：<code>255.0.0.0</code> 或 <code>255.255.255.128</code>等。</li><li>2、在IP地址后加上<code>&quot;/&quot;</code>符号以及<code>1-32</code>的数字，其中<code>1-32</code>的数字表示子网掩码中<strong>网络标识位</strong>的长度 　　如：<code>192.168.1.1/24</code> 的子网掩码也可以表示为<code>255.255.255.0</code>。</li></ul></blockquote><p>下面举几个划分的例子。</p><h4 id="2-、C类地址等分成两个子网"><a href="#2-、C类地址等分成两个子网" class="headerlink" title="2)、C类地址等分成两个子网"></a>2)、C类地址等分成两个子网</h4><p>下面以一个 C 类网络划分为两个子网为例，讲解子网划分的过程。</p><p>如图 所示，某公司有两个部门，每个部门 100 台计算机，通过路由器连接 Internet。给这200台电脑分配一个 C 类网络 <code>192.168.0.0</code>，该网段的子网掩码为 <code>255.255.255.0</code>，连接局域网的路由器接口使用该网段的第一个可用的IP地址 <code>192.168.0.1</code>。</p><p><img src="/images/4_19.png" alt="4_19.png"></p><p>为了安全考虑，打算将这两个部门的计算机分为两个网段，中间使用路由器隔开。计算机数量没有增加，还是 200 台，因此一个 C 类网络的IP地址是足够用的。现在将 <code>192.168.0.0 [255.255.255.0]</code>这个 C 类网络划分成两个子网。</p><p>如图所示，将IP地址的第 4 部分写成二进制形式，子网掩码使用两种方式表示: 二进制和十进制。<strong>子网掩码往右移一位，这样C类地址主机ID 第1位就成为网络位, 该位为 0 是 A子网，该位为1是B子网</strong>。</p><p><img src="/images/4_20.png" alt="4_20.png"></p><p>如图所示，IP 地址的第 4 部分，其值在 <code>0~127</code> 之间的，第 1 位均为 0；其值在 <code>128~255</code>之间的，第 1 位均为 1。分成A、B 两个子网，以 128 为界。现在的子网掩码中的1变成了 25 个，写成十进制就是 255.255.255.128。子网掩码向后移动了 1 位，就划分出 2 个子网。<strong>A和B 两个子网的子网掩码都为255.255.255.128</strong> 。</p><p>A子网可用的地址范围为 <code>192.168.0.1~192.168.0.126</code>，IP 地址 192.168.0.0 由于主机位全为 0，不能分配给计算机使用，如图 所示，<code>192.168.0.127</code> 由于主机位全为 1，也不能分配计算机。</p><p><img src="/images/4_21.png" alt="4_21.png"></p><p>B 子网可用的地址范围为<code>192.168.0.129~192.168.0.254</code>，IP 地址 <code>192.168.0.128</code> 由于主机位全为0，不能分配给计算机使用，IP 地址 <code>192.168.0.255</code> 由于主机位全为 1，也不能分配给计算机。划分成两个子网后网络规划如图所示。</p><p><img src="/images/4_22.png" alt="4_22.png"></p><h4 id="3-、C类地址等分成四个子网"><a href="#3-、C类地址等分成四个子网" class="headerlink" title="3)、C类地址等分成四个子网"></a>3)、C类地址等分成四个子网</h4><p>假如公司有 4 个部门，每个部门有 50 台计算机，现在使用 <code>192.168.0.0/24</code> 这个 C 类网络。从安全考虑，打算将每个部门的计算机放置到独立的网段，这就要求将 <code>192.168.0.0  [255.255.255.0]</code> 这个 C 类网络划分为4个子网，那么如何划分成4 个子网呢?</p><p>如图 所示， 将 <code>192.168.0.0  [255.255.255.0]</code> 网段的地址的第 4 部分写成二进制，要想分成4个子网，需要将子网掩码<strong>往右移动两位</strong>，这样第 1 位和第 2 位就变为网络位。<strong>就可以分成4个子网，第 1 位和第2 位为00是A子网，01是B子网，10是C子网，11是D子网</strong>。</p><p><img src="/images/4_23.png" alt="4_23.png"></p><p>A、B、C、D 子网的子网掩码都为 <code>255.255.255.192</code>。</p><ul><li>A子网可用的开始地址和结束地址为 <code>192.168.0.1~192.168.0.62</code>；</li><li>B子网可用的开始地址和结束地址为 <code>192.168.0.65~192.168.0.126</code>；</li><li>C子网可用的开始地址和结束地址为 <code>192.168.0.129~192.168.0.190</code>；</li><li>D子网可用的开始地址和结束地址为 <code>192.168.0.193~192.168.0.254</code>；</li></ul><p>注意: 如图所示，<strong>每个子网的最后一个地址都是本子网的广播地址</strong>，不能分配给计算机使用，如A子网的63、B子网的 127、C子网的191和D子网的 255。</p><p><img src="/images/4_24.png" alt="4_24.png"></p><h4 id="4-、C类地址等分成八个子网"><a href="#4-、C类地址等分成八个子网" class="headerlink" title="4)、C类地址等分成八个子网"></a>4)、C类地址等分成八个子网</h4><p>如果想把一个C类网络等分成 8 个子网，如图所示，子网掩码需要往右移 3 位，才能划分出 8个子网，<strong>第 1 位、第 2 位和第 3 位都变成网络位</strong>。</p><p><img src="/images/4_25.png" alt="4_25.png"></p><p>每个子网的子网掩码都一样，为<code>255.255.255.224</code>。</p><ul><li>A 子网可用的开始地址和结束地址为<code>192.168.0.1 ~ 192.168.0.30</code>；</li><li><p>B 子网可用的开始地址和结束地址为 <code>192.168.0.33 ~ 192.168.0.62</code>；</p></li><li><p>C 子网可用的开始地址和结束地址为 <code>192.168.0.65 ~ 192.168.0.94</code>；</p></li><li><p>D 子网可用的开始地址和结束地址为 <code>192.168.0.97 ~ 192.168.0.126</code>；</p></li><li><p>E 子网可用的开始地址和结束地址为 <code>192.168.0.129 ~ 192.168.0.158</code>；</p></li><li><p>F 子网可用的开始地址和结束地址为 <code>192.168.0.161 ~ 192.168.0.190</code>；</p></li><li><p>G 子网可用的开始地址和结束地址为 <code>192.168.0.193 ~ 192.168.0.222</code>；</p></li><li><p>H 子网可用的开始地址和结束地址为 <code>192.168.0.225 ~ 192.168.0.254</code>；</p></li></ul><p>注意: 每个子网能用的主机 IP地址，都要去掉主机位全 0 和主机位全 1 的地址。 如上图所示，31、63、95、127、159、191、223、255 都是相应子网的广播地址。</p><p>每个子网是原来的了<code>1/2 * 1/2 * 1/2</code>，即3个<code>1/2</code>， 子网掩码往右移 3 位。</p><p>总结: 如果一个子网地址是原来网段的<code>(1/2)^n</code> ，子网掩码就在原网段的基础上后移<code>n</code>位。</p><h4 id="5-、B类地址划分子网"><a href="#5-、B类地址划分子网" class="headerlink" title="5)、B类地址划分子网"></a>5)、B类地址划分子网</h4><p>将<code>131.107.0.0 [255.255.0.0]</code>等分成2个子网。子网掩码往右移动1位，就能等分成两个子网。</p><p><img src="/images/4_28.png" alt="4_28.png"></p><p>这两个子网的子网掩码都是 <code>255.255.128.0</code>。</p><p>先确定 A 子网第一个可用地址和最后一个可用地址，按照下图将主机部分写成二进制，<strong>主机位不能全是 0，也不能全是 1</strong>，然后再根据二进制写出第一个可用地址和最后一个可用地址。同理B也是。</p><p><img src="/images/4_29.png" alt="4_29.png"></p><h4 id="6-、A类地址划分子网"><a href="#6-、A类地址划分子网" class="headerlink" title="6)、A类地址划分子网"></a>6)、A类地址划分子网</h4><p>和 C 类地址和 B 类地址划分子网的规律一样，A 类地址子网掩码往右移动 1 位，也能划分出两个子网。只是写出每个网段第一个和最后一个可用的地址时，需要谨慎。</p><p>下面以 A 类网络 <code>42.0.0.0 [255.0.0.0]</code> 等分成4 个子网为例，写出各个子网的第一个和最后一个可用的IP地址。如图所示，划分出 4 个子网，子网掩码需要右移 2 位。每个子网的子网掩码为<code>255.192.0.0</code>。</p><p><img src="/images/4_26.png" alt="4_26.png"></p><p>参照上图，可以很容易地写出这些子网能够使用的第一个IP地址和最后一个IP地址。</p><ul><li>A子网可用的第一个地址为 <code>42.0.0.1</code>，最后一个可用的地址为<code>42.63.255.254</code>；</li><li>B 子网可用的第一个地址为<code>42.64.0.1</code>，最后一个可用的地址为 <code>42.127.255.254</code>；</li><li>C 子网可用的第一个地址为 <code>42.128.0.1</code>，最后一个可用的地址为 <code>42.191.255.254</code>；</li><li>D 子网可用的第一个地址为 <code>42.192.0.1</code>，最后一个可用的地址为 <code>42.255.255.254</code>；</li></ul><p>具体如图:</p><p><img src="/images/4_27.png" alt="4_27.png"></p><h3 id="5、变长子网划分"><a href="#5、变长子网划分" class="headerlink" title="5、变长子网划分"></a>5、变长子网划分</h3><p>如图所示，有一个 C 类网络 <code>192.168.0.0  [255.255.255.0]</code>，需要将该网络划分成5个网段以满足以下网络需求，该网络中有 3 个交换机，<strong>分别连接 20 台电脑、50 台电脑和 100 台电脑</strong>，路由器之间的连接接口也需要地址，这两个地址也是一个网段，这样网络中一共有 5 个网段。</p><p>如图所示，将 <code>192.168.0.0  [255.255.255.0]</code> 的主机位从 0~255 画一条数轴。</p><p>从 <code>128~255</code> 的地址空间给 100 台电脑的网段比较合适， 该子网的地址范围是原来网络的， 子网掩码往后移 1位，写成十进制形式就是 <code>255.255.255.128</code>。第一个能用的地址是<code>192.168.0.129</code>，最后一个能用的地址是 <code>192.168.0.254</code>。<br>64~128 之间的地址空间给 50 台电脑的网段比较合适，该子网的地址范围是原来的<code>1/2 * 1/2</code>，子网掩码往后移 2 位，写成十进制就是 <code>255.255.255.192</code>。第一个能用的地址是 <code>192.168.0.65</code>，最后一个能用的地址是<code>192.168.0.126</code>。</p><p>32~64之间的地址空间给 20 台电脑的网段比较合适， 该子网的地址范围是原来的<code>1/2 * 1/2 * 1/2</code> ，<br>子网掩码往后移 3 位，写成十进制就是 <code>255.255.255.224</code>。第一个能用的地址是 <code>192.168.0.33</code>，最后<br>一个能用的地址是 <code>192.168.0.62</code>。</p><p><img src="/images/4_30.png" alt="4_30.png"></p><p>当然我们也可以使用以下的子网划分方案，100 台电脑的网段可以使用 <code>0~128</code> 之间的子网，50 台电脑的网段可以使用 <code>128~192</code> 之间的子网, 20 台电脑的网段可以使用 <code>192~224</code> 之间的子网，如图所示。</p><p><img src="/images/4_31.png" alt="4_31.png"></p><p>总结规律: <strong>如果一个子网地址块是原来网段的<code>(1/2) ^ n</code>，子网掩码就在原网段的基础上后移n位，不等长子网，子网掩码也不同</strong>。</p><h3 id="6、超网合并网段"><a href="#6、超网合并网段" class="headerlink" title="6、超网合并网段"></a>6、超网合并网段</h3><p>前面讲的子网划分是将一个网络的主机位当作网络位, 来划分出多个子网。我们也可以将多个网段合并成一个大的网段，合并后的网段称为超网，下面就来讲解合并网段的方法。</p><p>如图所示，某企业有一个网段，该网段有 200 台计算机，使用 <code>192.168.0.0 [255.255.255.0]</code>网段，后来计算机数量增加到 400 台。</p><p><img src="/images/4_32.png" alt="4_32.png"></p><p>在该网络中添加交换机，可以扩展网络的规模，一个C类 IP 地址不够用，再添加一个 C 类地址 <code>192.168.1.0 [255.255.255.0]</code>。这些计算机物理上在一个网段，但是IP地址没在一个网段，即逻辑上不在一个网段。</p><p>如果想让这些计算机之间能够通信，可以在路由器的接口添加这两个 C 类网络的地址作为这两个网段的网关。</p><p>在这种情况下，A 计算机到 B 计算机进行通信，必须通过路由器转发，这样两个子网才能够通信，本来这些计算机物理上在一个网段，还需要路由器转发，可见效率不高。</p><p>有没有更好的办法？，可以让这两个 C 类网段的计算机认为在一个网段，这就需要将<code>192.168.0.0/24</code> 和 <code>192.168.1.0/24</code> 两个 C 类网络合并。如图所示，将这两个网段的 IP地址第 3 部分和第 4 部分写成二进制，可以看到将子网掩码往左移动1位，两个网段的网络部分就一样了，两个网段就在一个网段了。</p><p><img src="/images/4_33.png" alt="4_33.png"></p><p>合并后的网段为 <code>192.168.0.0/23</code>， 子网掩码写成十进制 <code>255.255.254.0</code>，可用地址为<code>192.168.0.1　~　192.168.1.254</code>，网络中计算机的 IP 地址和路由器接口的地址配置，如图所示。</p><p><img src="/images/4_34.png" alt="4_34.png"></p><p><img src="/images/4_35.png" alt="4_35.png"></p><p>有关超网合并的题目: (有一个<strong>最长匹配算法</strong>)</p><p><img src="/images/4_40.png" alt="4_40.png"></p><blockquote><p>附加题目:</p><p>某网络的IP地址空间为<code>192.168.5.0/24</code>，采用定长子网划分，子网掩码为<code>255.255.255.248</code>，则该网络中的最大子网个数、每个子网内的最大可分配地址个数分别是(  <strong>B</strong> ) 。<br>A. 32，8     B. 32，6     C. 8，32     D. 8，30</p><p>答:由于 248 的二进制 <code>11111000</code>，子网号占<code>5</code>位，所以最大可以分配子网的个数<code>2 ^ 5 = 32</code>(注意CIDR中不要去掉全0和全1)。</p><p>而主机位只剩下<code>3</code>位，就是<code>2 ^ 3 - 2 = 6</code>(这里要减去全0和全1)。</p></blockquote><h2 id="四、重要协议"><a href="#四、重要协议" class="headerlink" title="四、重要协议"></a>四、重要协议</h2><p>网络层的四个主要的协议: <code>ARP</code>、<code>IP</code>、<code>ICMP</code>、<code>IGMP</code>。</p><p><img src="/images/4_4.png" alt="在这里插入图片描述"></p><h3 id="1、ARP协议-地址解析协议"><a href="#1、ARP协议-地址解析协议" class="headerlink" title="1、ARP协议(地址解析协议)"></a>1、ARP协议(地址解析协议)</h3><p>ARP是为IP服务的。<code>Address Resolution Protocol</code>。</p><p><img src="/images/4_15.png" alt="在这里插入图片描述"></p><p>由于在实际网络的链路上传送数据帧时，最终必须使用MAC地址。</p><p>ARP协议: <strong>完成主机或路由器IP地址到MAC地址的映射。 解决下一跳走哪的问题</strong>。</p><p>ARP协议使用过程:</p><p><strong>检查ARP高速缓存，有对应表项则写入MAC帧，没有则用目的MAC地址为<code>FF-FF-FF-FF-FF-FF</code>的帧封装并广播ARP请求分组，同一局域网中所有主机都能收到该请求。目的主机收到请求后就会向源主机单播一个ARP响应分组，源主机收到后将此映射写入ARP缓存 (10-20min更新一次)</strong> 。ARP协议是自动进行的。</p><p>先看<strong>源主机和目的主机在同一个网络内的情况</strong>:</p><p>比如1号主机要和3号主机进行通信:</p><p><img src="/images/4_41.png" alt="4_41.png"></p><p>再看<strong>源主机和目的主机不在同一个网络内的情况</strong>:</p><p>则1号主机会先判断一下，即将自己IP和目的IP相与一下，判断在不在同一个网段。</p><p>则需要先查询默认网关的MAC地址，即需要先跳到<code>MAC6</code>，在路由器需要封装，然后从路由器到目的主机再进行ARP转发请求:</p><p>这个过程要进行三次APR请求：①第一次是PC1到路由器1； ②第二次是路由器1到路由器2(因为这里我画的是点到点的，但是实际上第一个路由器可能连着多个路由器)；③ 第三次是路由器2到目的主机PC5。</p><p><img src="/images/4_42.png" alt="4_42.png"></p><p>给个图，<strong>注意如果R1和R2中间是点到点的连接</strong>(中间没有别的路由器)，则不需要ARP协议解析MAC地址。</p><p><img src="/images/4_17.png" alt="4_17.png"></p><blockquote><p>ARP协议4种典型情况:</p><ul><li>1、主机A发给本网络上的主机B: 用ARP找到主机B的硬件地址;</li><li>2、主机A发给另一网络上的主机B: 用ARP找到本网络上一个路由器(网关) 的硬件地址，</li><li>3、路由器发给本网络的主机A: 用ARP找到主机A的硬件地址;</li><li>4、路由器发给另一网络的主机B: 用ARP找到本网络上的一个路由器的硬件地址。</li></ul></blockquote><h3 id="2、DCHP-动态主机设置协议，传输层协议"><a href="#2、DCHP-动态主机设置协议，传输层协议" class="headerlink" title="2、DCHP(动态主机设置协议，传输层协议)"></a>2、DCHP(动态主机设置协议，传输层协议)</h3><p><code>Dynamic Host Configuration Protocol</code>。</p><p>静态主机配置: 例如机房的电脑的配置，你左边同学的配置的IP和你的IP一般是相邻的。</p><p>动态主机配置: 例如我们大学教师上课，是需要经常移动的，到了某个教室，会选择动态分配一个暂用IP。</p><p><img src="/images/4_43.png" alt="4_43.png"></p><h3 id="3、ICMP-网际控制报文协议"><a href="#3、ICMP-网际控制报文协议" class="headerlink" title="3、ICMP(网际控制报文协议)"></a>3、ICMP(网际控制报文协议)</h3><p><code>Internet Control Message Protocol</code>。</p><p> ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会(桥梁作用)。它封装在 IP 数据报中，但是不属于高层协议。主要有两种: <strong>ICMP差错报文、ICMP询问报文</strong>。</p><p><img src="/images/4_44.png" alt="4_44.png"></p><h4 id="1-、ICMP差错报文"><a href="#1-、ICMP差错报文" class="headerlink" title="1)、ICMP差错报文"></a>1)、ICMP差错报文</h4><p>主要有四种:</p><ul><li>1)、终点不可达: 当路由器或主机不能交付数据报时就向源点发送终点不可达报文。</li><li>2)、时间超过: 当路由器收到生存时间<code>TTL=0</code>的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。</li><li>3)、参数问题: 当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。</li><li>4)、路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器(可通过更好的路由) </li></ul><p><img src="/images/4_45.png" alt="4_45.png"></p><h4 id="2-、ICMP询问报文"><a href="#2-、ICMP询问报文" class="headerlink" title="2)、ICMP询问报文"></a>2)、ICMP询问报文</h4><p>也有两种：</p><ul><li>1)、<strong>回送请求和回答报文</strong> :  主机或路由器向特定目的主机发出的询问，收到此报文的主机必须给源主机或路由<br>器发送ICMP回送回答报文。<strong>测试目的站是否可达以及了解其相关状态</strong>；</li><li>2)、<strong>时间戳请求和回答报文</strong> : 请某个主机或路由器回答当前的日期和时间。<strong>用来进行时钟同步和测量时间</strong>。</li></ul><p>一表总结差错报文和询问报文:</p><p><img src="/images/4_46.png" alt="4_46.png"></p><h4 id="3-、ICMP应用"><a href="#3-、ICMP应用" class="headerlink" title="3)、ICMP应用"></a>3)、ICMP应用</h4><p>ICMP有两个应用命令: <code>PING</code>和<code>Traceroute</code>。</p><p><strong>PING</strong></p><p>测试两个主机之间的连通性，<strong>使用了ICMP回送请求和回答报文</strong>。</p><p>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p><p><strong>Traceroute</strong></p><p>跟踪一个分组从源点到终点的路径，<strong>使用了ICMP时间超过差错报告报文</strong>。</p><p>a)、源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；<br>b)、源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文；<br>c)、不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文；<br>d)、最后源主机就知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间；</p><h3 id="4、IGMP"><a href="#4、IGMP" class="headerlink" title="4、IGMP"></a>4、IGMP</h3><h4 id="1-、IP数据报的三种传输方式"><a href="#1-、IP数据报的三种传输方式" class="headerlink" title="1)、IP数据报的三种传输方式"></a>1)、IP数据报的三种传输方式</h4><p>分为<strong>单播、广播、组播(多播)</strong>。</p><ul><li>单播:用于发送数据包到单个目的地，且每发送一份单播报文都使用一个单播IP地址作为目的地址。是一种<strong>点对点</strong>传输方式。</li><li>广播: 广播是指发送数据包到同一广播域或子网内的所有设备的一种数据传输方式。是一种<strong>点对多点</strong>传输方式。</li><li>组播(多播): 当网络中的某些用户需要特定数据时，<strong>组播数据发送者仅发送一次数据</strong>，借助<strong>组播路由协议</strong>为组播数据包建立<strong>组播分发树</strong>，被传递的数据到达距离用户端尽可能近的节点后才开始复制和分发，是一种<strong>点对多点</strong>传输方式。</li></ul><p><img src="/images/4_56.png" alt="4_56.png"></p><h4 id="2-、IP组播地址"><a href="#2-、IP组播地址" class="headerlink" title="2)、IP组播地址"></a>2)、IP组播地址</h4><p>IP组播地址让源设备能够将分组发送给一组设备。<strong>属于多播组的设备将被分配一个组播组IP地址</strong>(一群共同需求主机的相同标识) 。</p><p>组播地址范围为<code>224.0.0.0一239.255.255.255</code>(D类地址) ，一个D类地址表示一个组播组。<strong>只能用作分组的目标地址。源地址总是为单播地址</strong> 。</p><ul><li>1)、组播数据报也是“尽最大努力交付”，不提供可靠交付，应用于UDP；</li><li>2)、对组播数据报不产生ICMP差错报文；</li><li>3)、并非所有D类地址都可以作为组播地址；</li></ul><h4 id="3-、IGMP"><a href="#3-、IGMP" class="headerlink" title="3)、IGMP"></a>3)、IGMP</h4><p>IGMP 实现如下双向的功能:</p><ul><li>(1)、主机通过 IGMP 通知路由器<strong>希望接收或离开某个特定组播组</strong>的信息。</li><li>(2)、路由器通过 IGMP 周期性地查询局域网内的组播组成员是否处于活动状态，实现所连网</li></ul><p>段组成员关系的收集与维护。</p><p>IGMP工作的两个阶段:</p><ul><li>1)、某主机要加入组播组时，该主机向组播组的组播地址发送一个IGMP报文，声明自己要称为该组的成员。</li></ul><p>本地组播路由器收到IGMP报文后，要利用<strong>组播路由选择协议</strong>把这组成员关系发给因特网上的其他组播路由器。</p><ul><li>2)、本地组播路由器周期性探询本地局域网上的主机，以便知道这些主机是否还是组播组的成员。只要有一个主机对某个组响应，那么组播路由器就认为这个组是活跃的，如果经过几次探询后没有一个主机响应，组播路由器就认为本网络上的没有此组播组的主机，因此就不再把这组的成员关系发给其他的组播路由器。</li></ul><p>ICMP和IGMP都使用<strong>IP数据报</strong>传递报文。</p><p><img src="/images/4_57.png" alt="4_57.png"></p><blockquote><p>组播路由协议:</p><ul><li>目的: 找出以源主机为根节点的组播转发树；</li><li>对不同的多播组对应于不同的多播转发树，同一个多播组，对不同的源点也会有不同的多播转发树。</li></ul></blockquote><h2 id="五、路由算法和路由选择协议"><a href="#五、路由算法和路由选择协议" class="headerlink" title="五、路由算法和路由选择协议"></a>五、路由算法和路由选择协议</h2><h3 id="1、路由器结构"><a href="#1、路由器结构" class="headerlink" title="1、路由器结构"></a>1、路由器结构</h3><p>路由器从功能上可以划分为：<strong>路由选择和分组转发</strong>。</p><p>分组转发结构由三个部分组成：交换结构(<code>Switch fabric</code>)、一组输入端口、一组输出端口。</p><p><img src="/images/4_48.png" alt="4_48.png"> </p><h3 id="2、路由转发分组流程"><a href="#2、路由转发分组流程" class="headerlink" title="2、路由转发分组流程"></a>2、路由转发分组流程</h3><p>流程:</p><ul><li>从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。</li><li>若 N 就是与此路由器直接相连的某个网络地址，则进行<strong>直接交付</strong>；</li><li>若路由表中有目的地址为 D 的<strong>特定主机路由</strong>，则把数据报传送给表中<strong>所指明</strong>的下一跳路由器；</li><li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所<strong>指明的下一跳路由器；</strong></li><li>若路由表中有一个<strong>默认路由</strong>，则把数据报传送给路由表中所指明的默认路由器；</li><li>报告转发分组出错。</li></ul><h3 id="3、路由算法概括"><a href="#3、路由算法概括" class="headerlink" title="3、路由算法概括"></a>3、路由算法概括</h3><p>静态路由算法和动态路由算法:</p><p><img src="/images/4_49.png" alt="4_49.png"></p><p>分层次的路由选择协议: 分成自治系统内(<code>RIP</code>和<code>OSPF</code>)的和自治系统外(<code>BGP</code>)的。</p><blockquote><p>由于因特网规模很大，许多单位不想让外界知道自己的路由选择协议，但还是想连入因特网。于是有了自治系统<code>AS</code>。</p><p>自治系统AS: 在单一的技术管理下的一组路由器，而这些路由器使用一种AS内部的路由选择协议和共同的度<br>量以确定分组在该AS内的路由，同时还使用一种AS之间的路由协议以确定在AS之间的路由。一个As内的所有网络都属于一个行政单位来管辖，一个自治系统的所有路由器在本自治系统内都必须连通。</p></blockquote><p><img src="/images/4_50.png" alt="4_50.png"></p><h3 id="4、RIP-距离向量"><a href="#4、RIP-距离向量" class="headerlink" title="4、RIP(距离向量)"></a>4、RIP(距离向量)</h3><p><code>Routing Information Protocol</code>，路由信息协议。<strong>RIP其实是应用层的协议</strong>。</p><p>RIP是一种分布式的基于<strong>距离向量</strong>的路由选择协议，是因特网的协议标准，最大优点是简单。</p><p>RIP协议要求网络中每一个路由器都维护<strong>从它自己到其他每一个目的网络的唯一最佳距离记录</strong> (即一组距离) 。</p><p>距离 :  通常为“跳数”，<strong>即从源端口到目的端口所经过的路由器个数，经过一个路由器跳数+1。特别的，从一路</strong><br><strong>由器到直接连接的网络距离为1。RIP允许一条路由最多只能包含15个路由器，因此距离为16表示网络不可达</strong>。所以RIP只适用于小型网络。</p><p>看个路由表例子:</p><p><img src="/images/4_51.png" alt="4_51.png"></p><p>相关问题: <strong>RIP协议和谁交换? 多久交换一次？ 交换什么？</strong></p><ul><li>仅和<strong>相邻路由器</strong>交换信息；</li><li><strong>路由器交换的信息是自己的路由表</strong>；</li><li><strong>每30秒交换一次路由信息</strong>，然后路由器根据新信息更新路由表。若超过180s没收到邻居路由器的通告，则判定邻居没了，并更新自己路由表；</li></ul><p><strong>距离向量算法(重要)</strong>:</p><p><img src="/images/4_52.png" alt="4_52.png"></p><p>例题:</p><p><img src="/images/4_53.png" alt="4_53.png"></p><p>RIP协议报文格式:</p><p><img src="/images/4_54.png" alt="4_54.png"></p><h3 id="5、OSPF-开放式最短路径优先"><a href="#5、OSPF-开放式最短路径优先" class="headerlink" title="5、OSPF(开放式最短路径优先)"></a>5、OSPF(开放式最短路径优先)</h3><p><code>Open Shortest Path First</code>。开放式最短路径优先算法。</p><p>RIP协议当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。且只使用小型网络。而OSPF就是为了克服RIP协议的缺点的。</p><p>开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。</p><p>OSPF 具有以下特点：</p><ul><li>向本自治系统中的<strong>所有路由器发送信息</strong>，这种方法是<strong>洪泛法</strong>(即路由器通过输出端口向所有相邻的路由器发送信息)。</li><li>发送的信息<strong>就是与相邻路由器的链路状态</strong>，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。</li><li><strong>只有当链路状态发生变化时，路由器才会发送信息</strong>。</li></ul><p>所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程<strong>收敛的很快</strong>。</p><h3 id="6、BGP-边界网关"><a href="#6、BGP-边界网关" class="headerlink" title="6、BGP(边界网关)"></a>6、BGP(边界网关)</h3><p>边界网关协议。<code>Border Gateway Protocol</code>。</p><ul><li>和谁交换? : 与其他AS的邻站BGP发言人交换信息；</li><li>交换什么? : <strong>交换的网络可达性的信息</strong>，即要到达某个网络所要经过的一些列AS；</li><li>多久交换? : 发生变化时更新有变化的部分；</li></ul><p><strong>BGP 只能寻找一条比较好的路由，而不是最佳路由</strong>。</p><p><strong>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息</strong>。</p><p><strong>BGP的邻站是交换整个的BGP路由表，但以后只需要在发生变化时更新有变化的部分</strong>。</p><p><img src="/images/4_55.png" alt="4_55.png"></p><h2 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h2><h3 id="1、数据包传输过程以及简单的静态路由配置实验"><a href="#1、数据包传输过程以及简单的静态路由配置实验" class="headerlink" title="1、数据包传输过程以及简单的静态路由配置实验"></a>1、数据包传输过程以及简单的静态路由配置实验</h3><p><img src="/images/4_5.png" alt="在这里插入图片描述"></p><p>发送过程: </p><ul><li>应用程序准备要传输的文件；</li><li>传输层: 将文件分段 并编号；</li><li>网络层: 添加目标<code>IP</code>地址和源<code>IP</code>地址，路由器根据路由表来选择路径(出口)；</li><li>数据链路层 两种情况： 先使用自己的子网掩码，判断自己在哪个网段，然后判断目标地址在哪个网段， 如果是同一个网段 <code>arp</code>协议广播解析目标IP地址的<code>MAC</code> ；这一层的交换机接收到数字信号，看<code>MAC</code>地址，决定发送到下一个哪个交换机，即数据转发或存储转发。 (交换机看不到<code>ip</code>地址，只能看<code>MAC</code>地址)；</li><li>物理层负责转换成比特流，进行数字信号的传输(注意这一层的集线器只是负责传输比特流)；</li></ul><blockquote><p>数据包的目标 <code>IP</code> 地址决定了数据包最终到达哪一个计算机， 而目标 <code>MAC</code>地址决定了该数据包下一跳由哪个设备接收。</p></blockquote><p>附上路由器<code>Router0</code>和<code>Router1</code>的配置代码<br><code>Router0</code>配置: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Router&gt;en</span><br><span class="line">Router<span class="meta">#conf ter</span></span><br><span class="line">Router(config)<span class="meta">#int f0/0</span></span><br><span class="line">Router(config-<span class="keyword">if</span>)<span class="meta">#no shut</span></span><br><span class="line">Router(config-<span class="keyword">if</span>)<span class="meta">#ip address 10.0.0.1 255.0.0.0</span></span><br><span class="line">Router(config-<span class="keyword">if</span>)<span class="meta">#exit</span></span><br><span class="line">Router(config)<span class="meta">#interface serial 2/0</span></span><br><span class="line">Router(config-<span class="keyword">if</span>)<span class="meta">#no shutdown</span></span><br><span class="line">Router(config-<span class="keyword">if</span>)<span class="meta">#clock rate 64000</span></span><br><span class="line">Router(config-<span class="keyword">if</span>)<span class="meta">#ip address 11.0.0.1 255.0.0.0</span></span><br><span class="line">Router(config-<span class="keyword">if</span>)<span class="meta">#end</span></span><br><span class="line">Router<span class="meta">#show ip route</span></span><br><span class="line">Router<span class="meta">#conf ter</span></span><br><span class="line">Router(config)<span class="meta">#ip route 12.0.0.0 255.0.0.0 11.0.0.2</span></span><br><span class="line">Router<span class="meta">#show ip route</span></span><br></pre></td></tr></table></figure><p><code>Router1</code>路由器配置: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Router&gt;en</span><br><span class="line">Router<span class="meta">#conf ter</span></span><br><span class="line">Router(config)<span class="meta">#interface fastethernet 0/0</span></span><br><span class="line">Router(config-<span class="keyword">if</span>)<span class="meta">#ip address 12.0.0.1 255.0.0.0</span></span><br><span class="line">Router(config-<span class="keyword">if</span>)<span class="meta">#no shut</span></span><br><span class="line">Router(config-<span class="keyword">if</span>)<span class="meta">#exit</span></span><br><span class="line">Router(config)<span class="meta">#interface serial 2/0</span></span><br><span class="line">Router(config-<span class="keyword">if</span>)<span class="meta">#ip address 11.0.0.2 255.0.0.0</span></span><br><span class="line">Router(config-<span class="keyword">if</span>)<span class="meta">#no shutdown</span></span><br><span class="line">Router(config)<span class="meta">#exit</span></span><br><span class="line">Router<span class="meta">#show ip route</span></span><br><span class="line">Router<span class="meta">#conf ter</span></span><br><span class="line">Router(config)<span class="meta">#ip route 10.0.0.0 255.0.0.0 11.0.0.1</span></span><br><span class="line">Router(config)<span class="meta">#end</span></span><br><span class="line">Router<span class="meta">#show ip route</span></span><br><span class="line">Router<span class="meta">#show running-config</span></span><br></pre></td></tr></table></figure><h3 id="2、IPV6"><a href="#2、IPV6" class="headerlink" title="2、IPV6"></a>2、IPV6</h3><p>解决IPV4不够用的问题。</p><p>注意点：</p><ul><li><strong>IPv6将地址从32位(4B) 扩大到128位(16B)</strong> ，更大的地址空间；</li><li>IPv6将IPv4的校验和字段彻底移除，以减少每跳的处理时间；</li><li>IPv6将IPv4的可选字段移出首部，变成了<strong>扩展首部</strong>，成为灵活的首部格式，路由器通常不对扩展首部进行检查，大大提高了路由器的处理效率。</li><li>IPv6支持即播即用(即自动配置) ，<strong>不需要DHCP协议</strong>。</li><li><strong>IPv6首部长度必须是8B的整数倍，IPv4首部是48B的整数倍</strong>。</li><li>IPv6只能在主机处分片，IPv4可以在路由器和主机处分片；</li></ul><p><img src="/images/4_58.png" alt="4_58.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计网总结-四-一网络层&quot;&gt;&lt;a href=&quot;#计网总结-四-一网络层&quot; class=&quot;headerlink&quot; title=&quot;计网总结(四)一网络层&quot;&gt;&lt;/a&gt;计网总结(四)一网络层&lt;/h1&gt;&lt;p&gt;先上一张总结图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算机网络总结（3）</title>
    <link href="https://www.junglezero.top/2019/07/31/%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93%EF%BC%883%EF%BC%89/"/>
    <id>https://www.junglezero.top/2019/07/31/机网络总结（3）/</id>
    <published>2019-07-31T14:28:36.000Z</published>
    <updated>2019-08-01T06:21:55.183Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计网总结-三-一数据链路层"><a href="#计网总结-三-一数据链路层" class="headerlink" title="计网总结(三)一数据链路层"></a>计网总结(三)一数据链路层</h1><hr><h2 id="一、概括"><a href="#一、概括" class="headerlink" title="一、概括"></a>一、概括</h2><p>七层模型中所处位置以及涉及知识概括: </p><p><img src="/images/3_1.png" alt="在这里插入图片描述"></p><p>数据链路层使用的信道主要有以下两种类型：</p><ul><li><strong>点对点信道</strong>。这种信道使用一对一的点对点通信方式。</li><li><strong>广播信道</strong>。这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。<blockquote><p>结点：主机、路由器；</p><p>帧：链路层的协议数据单元、封装网络层数据报；</p></blockquote></li></ul><p><strong>区分链路与数据链路:</strong></p><ul><li>链路(<code>link</code>):  是一条点到点的物理线路段，中间没有任何其他的交换结点。一条链路只是一条通路的一个组成部分。</li><li>数据链路(<code>data link</code>) : 除了物理线路外，还必须有通信协议来控制这些数据的传输(<strong>逻辑链路</strong>)。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。现最常用的方法是使用适配器(即网卡)来实现这些协议的硬件和软件。一般的适配器都包括了数据链路层和物理层这两层的功能。</li></ul><h2 id="二、链路层的功能"><a href="#二、链路层的功能" class="headerlink" title="二、链路层的功能"></a>二、链路层的功能</h2><p>三个基本功能: <strong>封装成帧、透明传输、差错检测</strong></p><p>数据链路层在物理层提供服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据<strong>可靠地传输到</strong><br><strong>相邻节点的目标机网络</strong>层。</p><p>其主要作用是<strong>加强物理层传输原始比特流的功能</strong>，将物理层提供的可能出错的物理连接改造成为<strong>逻辑上无差错的数据链路</strong>，使之对网络层表现为一条无差错的链路。</p><ul><li>功能一 : 为网络层提供服务。无确认无连接服务，有确认无连接服务，有确认面向连接服务；</li><li>功能二 : 链路管理，即连接的建立、维持、释放(用于面向连接的服务) ；</li><li>功能三 : 组帧 (封装成帧)；</li><li>功能四 : 流量控制；</li><li>功能五 : 差错控制(帧错/位错)；</li></ul><h3 id="1、封装成帧和透明传输"><a href="#1、封装成帧和透明传输" class="headerlink" title="1、封装成帧和透明传输"></a>1、封装成帧和透明传输</h3><p><strong>点到点信道的数据链路层的协议数据单元 一 帧</strong></p><p><img src="/images/3_2.png" alt="在这里插入图片描述"></p><p><img src="/images/3_3.png" alt="在这里插入图片描述"></p><p>封装成帧:</p><ul><li>封装成帧(framing)就是<strong>在一段数据的前后分别添加首部和尾部</strong>，然后就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。</li><li>首部和尾部包含许多的控制信息，他们的重要作用就是进行帧定界；</li></ul><p>帧同步: 接收方应当能从接收到的二进制比特流中区分出帧的起始和终止。</p><p>透明传输:</p><ul><li>指不管所传数据是什么样的比特组合，都应当能在链路上传送；</li><li>因此，链路层就看不见有什么妨碍数据传输的东西；</li></ul><p><strong>组帧的四种方法: 1.字符计数法，2.字符(节) 填充法，3.零比特填充法，4.违规编码法</strong>。</p><p><img src="/images/3_4.png" alt="3_4.png"></p><p>这里简单介绍一下字符计数法和字符填充法:</p><p>字符计数法：</p><p><img src="/images/3_5.png" alt="3_5.png"></p><p>字符填充法:</p><p><div align="center"> <img src="/images/3_6.png" width="700"></div><br></p><blockquote><p>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入<strong>转义字符</strong>。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。<strong>这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在</strong>。</p></blockquote><h3 id="2、差错检验"><a href="#2、差错检验" class="headerlink" title="2、差错检验"></a>2、差错检验</h3><p>概括来说，传输中的差错都是由于噪声引起的。</p><ul><li>全局性: 由于线路本身电气特性所产生的随机噪声(热噪声)，是信道固有的，随机存在的。解决办法: 提高信噪比来减少或避免干扰。( 对传感器下手)</li><li>局部性: 外界特定的短暂原因所造成的冲击噪声，<strong>是产生差错的主要原因</strong>。解决办法: 通常利用编码技术来解决。</li></ul><p>局部性的又可以分为:</p><p><div align="center"> <img src="/images/3_7.png"></div><br></p><blockquote><p>如果通信质量好，且用有线传输链路，一般会是<strong>无确认无连接服务</strong>。</p><p>如果通信质量差，采用无线传输链路，则会采用<strong>有确认面向连接服务</strong>。</p></blockquote><p>几种处理的方式</p><p><div align="center"> <img src="/images/3_8.png"> </div><br></p><p>检错编码:</p><p><img src="/images/3_9.png" alt="3_9.png"></p><h3 id="3、流量控制"><a href="#3、流量控制" class="headerlink" title="3、流量控制"></a>3、流量控制</h3><p>较高的发送速度和较低的接收能力的不匹配，会造成传输出错，因此流量控制也是数据链路层的一项重要工作。</p><p>数据链路层的流量控制和传输层的流量控制不同：<strong>数据链路层的流量控制是点对点的，而传输层的流量控制是端到端的 </strong>: </p><ul><li>数据链路层流量控制手段: <strong>接收方收不下就不回复确认</strong>；</li><li>传输层流量控制手段: <strong>接收端给发送端一个窗口公告</strong>。</li></ul><p>注意可靠传输和流量控制都和滑动窗口有关:</p><p><img src="/images/3_11.png" alt="3_11.png"></p><p>TCP的滑动窗口主要有两个作用，一是提供TCP的可靠性，二是提供TCP的流控特性。同时滑动窗口机制还体现了TCP面向字节流的设计思路。</p><p>滑动窗口：<br>（一）、“窗口”对应的是一段可以被发送者发送的字节序列，其连续的范围称之为“窗口”；<br>（二）、“滑动”则是指这段“允许发送的范围”是可以随着发送的过程而变化的，变化的方式就是按顺序“滑动”。</p><p>滑动窗口协议是传输层进行流控的一种措施，接收方通过通告发送方自己的窗口大小，从而控制发送方的速度，从而达到防止发送方发送速度过快导致网络故障的目的。<br>滑动窗口的基本原理是：<br>TCP使用窗口机制进行流量控制。当连接建立后，发送方和接收方都要分配一块自己的缓冲区来存储接收的数据，为了防止接收方已经没有缓冲区进行接收而发送方在在继续发送，出现网络拥塞和故障。所以用滑动窗口进行了流控。<br>具体实现：接收方将缓冲区剩余的尺寸和期待接收的下一个字节序号在确认信息中发送给发送方，发送方根据接收方剩余的大小空间来定量的发送合适的数据给接收方。它也是建立在“确认重传”的基础之上。</p><p>滑动窗口的原理图如下所示：</p><p><img src="/upload/pasted-476.png" alt="upload successful"></p><p>窗口的大小属性：</p><p>TCP的window是一个16bit位字段，它代表的是窗口的字节容量，也就是TCP标准窗口最大为2^16-1=65535个字节；另外在TCP的选项字段中还包含了一个TCP窗口的扩展因子，option-kind为3，option-length为3个字节，option-data取值范围0-14。窗口扩大因子用来扩大TCP窗口，可把原来的16bit的窗口，扩大为31bit。</p><p>发送窗口和接收窗口：<br>TCP是双工的协议，会话的双方都可以同时接收、发送数据。TCP会话的双方都各自维护一个“发送窗口”和一个“接收窗口”。其中各自的“接收窗口”大小取决于应用、系统、硬件的限制，但是tcp的传输速率不能大于应用的数据处理能力，否则就会缓冲区淹没。各自的“发送窗口”则取决于对端通告的“接收窗口”，也就是取决于接收的缓冲区的大小。</p><p>发送窗口只有在收到对端对于本段发送窗口内字节的ACK确认，才会移动发送窗口的左边界。<br>接收窗口只有在前面的所有数据确认收到的情况下，才会移动左边的窗口。当在前面还有未接受的字节，而后面的字节已接收的情况下，窗口也不会移动，并不会对后续的字节进行确认。一次确保对端会对这些未收到的数据进行重传。主要涉及到接收端的累积确认接收机制。</p><h2 id="三、介质访问控制"><a href="#三、介质访问控制" class="headerlink" title="三、介质访问控制"></a>三、介质访问控制</h2><p>数据传输时使用的两种链路:</p><ul><li><strong>点对点信道</strong>: 一对一通信。因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。</li><li><strong>广播信道</strong>: 一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。</li></ul><p>介质访问控制就是解决避免广播信道产生冲突的:</p><p>采取一定的措施，使得两个节点之间的通信不会发生互相干扰的情况。 例如一堆对讲机，不能同时有两个人同时的讲话。</p><p>主要的措施:</p><p><img src="/images/3_24.png" alt="3_24.png"></p><h3 id="1、静态划分信道－信道划分介质访问控制-信道复用技术"><a href="#1、静态划分信道－信道划分介质访问控制-信道复用技术" class="headerlink" title="1、静态划分信道－信道划分介质访问控制-信道复用技术"></a>1、静态划分信道－信道划分介质访问控制-信道复用技术</h3><p>信道划分介质访问控制: 将使用介质的每个设备与来自同一信道上的其他设备的通信隔离开，把时域和<br>频域资源合理地分配给网络上的设备。</p><p><img src="/images/3_25.png" alt="3_25.png"></p><h4 id="1-、频分多路FDM"><a href="#1-、频分多路FDM" class="headerlink" title="1)、频分多路FDM"></a>1)、频分多路FDM</h4><p><img src="/images/3_26.png" alt="3_26.png"></p><h4 id="2-、时分多路TDM"><a href="#2-、时分多路TDM" class="headerlink" title="2)、时分多路TDM"></a>2)、时分多路TDM</h4><p><img src="/images/3_27.png" alt="3_27.png"></p><p>使用频分复用和时分复用进行通信，在通信的过程中主机会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其它用户使用，因此这两种方式对信道的利用率都不高。更好的方法是统计时分复用。</p><p><strong>统计时分复用</strong>:</p><p><img src="/images/3_28.png" alt="3_28.png"></p><h4 id="3-、波分多路WDM"><a href="#3-、波分多路WDM" class="headerlink" title="3)、波分多路WDM"></a>3)、波分多路WDM</h4><p>波分多路复用就是<strong>光的频分多路复用</strong>，在一根光纤中传输多种不同波长(频率) 的光信号，由于波长(频率)<br>不同，所以各路光信号互不干扰，最后再用波长分解复用器将各路波长分解出来。</p><h4 id="4-、码分多路CDM"><a href="#4-、码分多路CDM" class="headerlink" title="4)、码分多路CDM"></a>4)、码分多路CDM</h4><p>码分多址(CDMA) 是码分复用的一种方式。</p><p>1个比特分为多个码片/芯片 (chip) ，每一个站点被指定一个唯一的m位的蕊片序列。<br>发送1时站点发送芯片序列，发送0时发送芯片序列反码(通常把0写成-1) 。</p><h3 id="2、动态划分信道"><a href="#2、动态划分信道" class="headerlink" title="2、动态划分信道"></a>2、动态划分信道</h3><h4 id="1-、随机访问介质访问控制-随机访问MAC协议"><a href="#1-、随机访问介质访问控制-随机访问MAC协议" class="headerlink" title="1)、随机访问介质访问控制(随机访问MAC协议)"></a>1)、随机访问介质访问控制(随机访问MAC协议)</h4><h5 id="a-、ALOHA协议-不听就说，想说就说"><a href="#a-、ALOHA协议-不听就说，想说就说" class="headerlink" title="a)、ALOHA协议(不听就说，想说就说)"></a>a)、ALOHA协议(不听就说，想说就说)</h5><p>分为两种: 纯ALOHA协议和时隙ALOHA协议。</p><p>纯ALOHA协议: 不按时间槽发送，随机重发。想发就发。</p><p>时隙ALOHA协议: 把时间分成若干个相同的时间片，所有用户在时间开始时刻同步接入网络信道，若发生冲突，则必须等到下一个时间片开始时刻再发送。</p><p>纯ALOHA协议比时隙ALOHA协议吞吐量更低，效率更低。</p><h5 id="b-、CSMA协议-先听再说"><a href="#b-、CSMA协议-先听再说" class="headerlink" title="b)、CSMA协议(先听再说)"></a>b)、CSMA协议(先听再说)</h5><p>协议思想: <strong>发送帧之前，监听信道</strong>。发送数据之前要检测一下总线上是否有其他计算机在发送数据。</p><p>具体又可以分为三种：</p><p><img src="/images/3_29.png" alt="3_29.png"></p><p>具体:</p><ul><li>1)、1-坚持CSMA: 空闲则直接传输，不必等待；忙则一直监听，直到空闲马上传输；(可能冲突)</li><li>2)、非坚持CSMA: 空闲则直接传输，不必等待；忙则等待一个随机的时间之后再进行监听；</li><li>3)、p-坚持: 空闲则以<code>p</code>概率直接传输，以<code>1-p</code>概率等待到下一个时间槽再传输；忙则等待一个随机的时间之后再进行监听；</li></ul><p><img src="/images/3_30.png" alt="3_30.png"></p><h5 id="c-、CSMA-CD协议-重点"><a href="#c-、CSMA-CD协议-重点" class="headerlink" title="c)、CSMA/CD协议(重点)"></a>c)、CSMA/CD协议(重点)</h5><p>英文名：<code>Carrier sense multiple access with collision detection</code>。(CSMA/CD)</p><p>主要用于<strong>总线式以太网</strong>。</p><p>CSMA/CD协议思想: <strong>先监听再发送，边监听边发送</strong>。</p><p>CSMA/CD 表示载波监听多点接入 / 碰撞检测。</p><ul><li><strong>载波监听(CS)</strong> ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</li></ul><ul><li><strong>多点接入(MA)</strong> ：说明这是总线型网络，许多主机以多点的方式连接到总线上。</li><li><strong>碰撞检测(CD)</strong> ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞(冲突检测)。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞(所以适用在半双工网络)。</li></ul><p>传播时延对载波监听的影响:</p><p><img src="/images/3_31.png" alt="3_31.png"></p><p>记端到端的传播时延为 <code>τ</code>，最先发送的站点最多经过 <code>2τ</code> 就可以知道是否发生了碰撞，称 <code>2τ</code> 为 <strong>争用期</strong> 。<strong>只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞</strong>。</p><p>当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 <strong>截断二进制指数退避算法</strong> 来确定。从离散的整数集合 <code>{0, 1, 2, 4 .., (2^k-1)}</code> 中随机取出一个数，记作 <code>r</code>，然后取 <code>r</code> 倍的争用期作为重传等待时间。</p><p>帧的传播时延至少要两倍于信号在总线中的传播时延。</p><p>即 <strong>帧长(bit) / 数据传输速率 &gt;= 2τ</strong>。</p><h5 id="d-、CSMA-CA协议"><a href="#d-、CSMA-CA协议" class="headerlink" title="d)、CSMA/CA协议"></a>d)、CSMA/CA协议</h5><p>英文名: <code>Carrier sense multiple access with collision avoidance</code>。(后面是碰撞<strong>避免</strong>)。</p><p>主要用于<strong>无线网</strong>，可以全面的检测碰撞。</p><p>过程:</p><p>1)、发送数据前，先检测信道是否空闲-空闲则发出<code>RTS</code>(<code>request to send</code>) ，<code>RTS</code>包括发射端的地址、接收端的地址、下一份数据将持续发送的时间等信息。 信道忙则等待。</p><p>2)、接收端收到<code>RTS</code>后，将响应<code>CTS</code> ( <code>clear to send</code>) 。</p><p>3)、发送端收到<code>CTS</code>后，开始发送数据帧，同时<strong>预约信道:</strong> 发送方告知其他站点自己要传多久数据)。</p><p>4)、接收端收到数据帧后，将用<code>CRC</code>(循环冗余)来检验数据是否正确，正确则响应ACK帧-发送方收到ACK就可以进行下一个数据帧的发送，若没有则一直重传至规定重发次数为止（采用<strong>二进制指数退避算法</strong>来确定随机的推迟时间) 。</p><h4 id="2-、轮询访问介质访问控制"><a href="#2-、轮询访问介质访问控制" class="headerlink" title="2)、轮询访问介质访问控制"></a>2)、轮询访问介质访问控制</h4><p>主要有两个: <strong>轮询协议和令牌传递协议</strong>。</p><p><strong>轮询协议</strong>: 主节点轮流“邀请”从属节点发送数据。</p><p><strong>令牌传递协议</strong>: 在所有主机之间，有一个特殊格式的令牌(MAC控制帧，不含任何信息)来控制信道的使用，确保同一时刻只有一个节点独占信道。</p><h2 id="四、局域网和广域网体系结构"><a href="#四、局域网和广域网体系结构" class="headerlink" title="四、局域网和广域网体系结构"></a>四、局域网和广域网体系结构</h2><h3 id="1、局域网"><a href="#1、局域网" class="headerlink" title="1、局域网"></a>1、局域网</h3><p>英文: Local Area Network，简称LAN，<strong>指在某一区域由多态计算机互联组成的计算机组，使用广播信道</strong>。</p><p>决定局域网的主要因素: <strong>网络拓扑、传输介质和介质访问控制方法</strong>。</p><p>局域网拓扑结构有: <strong>星型拓扑、总线型拓扑、环形拓扑、树型拓扑</strong>。</p><p>传输介质: </p><ul><li>有线局域网 常用介质: 双绞线、同轴电缆、光纤</li><li>无线局域网 常用介质: 电磁波</li></ul><p>局域网分类</p><ul><li>1)、以太网，应用最广泛，符合<code>IEE802.3</code>系列标准。逻辑拓扑是总线型，物理拓扑是星型。</li><li>2)、令牌环网: 不用了。</li><li>3)、FDDI网: 双环拓扑。</li><li>4)、ATM网。</li><li>5)、无线局域网(WLAN): 采用<code>IEE802.11</code>标准<br><img src="/images/3_32.png" alt="3_32.png"></li></ul><blockquote><p>MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（<strong>网卡</strong>）。</p><p>一台主机拥有多少个<strong>网络适配器</strong>就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。</p></blockquote><h3 id="2、以太网-属于局域网"><a href="#2、以太网-属于局域网" class="headerlink" title="2、以太网(属于局域网)"></a>2、以太网(属于局域网)</h3><p><strong>以太网是一种星型拓扑结构局域网</strong>。</p><p>早期使用<strong>集线器</strong>进行连接，集线器是一种物理层设备， 作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，<strong>并将其能量强度放大</strong>，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞()。</p><p>目前以太网使用<strong>交换机替代了集线器</strong>，交换机是一种链路层设备，它不会发生碰撞，<strong>能根据 MAC 地址进行存储转发</strong>。</p><p>以太网帧格式(<strong>图可以看最文章上面那张图的下方</strong>)：</p><ul><li><strong>类型</strong> ：标记上层使用的协议；</li><li><strong>数据</strong> ：长度在 46-1500 之间，如果太小则需要填充；</li><li><strong>FCS</strong> ：帧检验序列，使用的是 CRC 检验方法；</li></ul><p><img src="/images/3_33.png" alt="3_33.png"></p><p>以太网提供<strong>无连接、不可靠</strong>的服务。</p><p>无连接: 发送方和接收方之间无握手过程。</p><p>不可靠: 不对发送方的数据帧编号，接收方不向发送方进行确认，帧错直接丢弃，差错纠正由高层负责。</p><h3 id="3、广域网和PPP协议"><a href="#3、广域网和PPP协议" class="headerlink" title="3、广域网和PPP协议"></a>3、广域网和PPP协议</h3><p>广域网 (<code>WAN</code>，Wide Area Network) ，通常跨接很大的物理范围。</p><p>广域网的通信子网主要使用<strong>分组交换技术</strong>。因特网 (Internet)是世界范围内最大的广域网。</p><p>PPP(Point-to-Point Protocol)协议是目前使用最广泛的数据链路层协议，<strong>是在广域网使用的协议，只支持全双工链路</strong>。</p><p>特点:</p><ul><li>简单: 对于链路层的帧，无需纠错，无需序号，无需流量控制。</li><li>封装成帧: 加上帧定界符</li><li>透明传输: 与帧定界符一样比特组合的数据应该如何处理: 异步线路用字节填充，同步线路用比特填充。</li><li>多种网络层协议: 封装的IP数据报可以采用多种协议。</li><li>多种类型链路”串行/并行，同步/异步，电/光…</li><li>差错检测: 错就丢弃</li><li>检测连接状态 : 链路是否正常工作。</li><li>最大传送单元: <strong>数据部分最大长度MTU</strong>。</li><li>网络层地址协商: 知道通信双方的网络层地址</li></ul><blockquote><p>（1）PPP具有动态分配IP地址的能力，允许在连接时刻协商IP地址；<br>（2）PPP支持多种网络协议，比如TCP/IP、NetBEUI、NWLINK等；<br>（3）PPP<strong>具有错误检测能力，但不具备纠错能力，所以ppp是不可靠传输协议</strong>；</p></blockquote><p>组成部分:</p><p>(1)、高级数据链路控制协议<br>高级数据链路控制协议是将 卫 数据报封装到串行链路的方法。PPP 既支持异步链路 (无奇偶校验的 8 比特数据)，也支持面向比特的同步链路。IP 数据报在 PPP 帧中就是其信息部分，这个信息部分的长度受最大传送单元 MTU 的限制。<br>(2)、链路控制协议<br>链路控制协议(Link Control Protocol，LCP) 用来建立、配置和测试数据链路连接，通信的双方可协商一些选项(进行<strong>身份验证</strong>)。<br>(3)、网络控制协议<br>网络控制协议 NCP (Network Control Protocol) 中的每一个协议支持不同的网络层协议, 如IP、IPv6、DECnet，以及 AppleTalk 等。</p><p><img src="/images/3_34.png" alt="3_34.png"></p><p>PPP 的帧格式：</p><ul><li>F 字段为<strong>帧的定界符</strong></li><li>FCS 字段是使用 CRC 的检验序列</li><li><p>信息部分的长度不超过 1500</p><p><img src="/images/3_35.png" alt="3_35.png"></p></li></ul><h3 id="4、链路层设备"><a href="#4、链路层设备" class="headerlink" title="4、链路层设备"></a>4、链路层设备</h3><p>物理层设备: 中继系统，即转发器（repeater）或集线器（hub）。  </p><p>数据链路层:  即交换机(switch)或网桥（交换机前身）。</p><p><strong>网桥根据MAC帧的目的地址对帧进行转发和过滤</strong>。当网桥收到一个帧时，并不向所有接口转发此帧，而是<br><strong>先检查此帧的目的MAC地址，然后再确定将该帧转发到哪一个接口</strong>，或者是把它丢弃 (即过滤) ，这就是比集线器好的地方。</p><p><img src="/images/3_36.png" alt="3_36.png"> </p><p>集线器既不能分割冲突域也不能分割广播域，它就像一根接口比较多的网线一样。</p><p><img src="/images/3_37.png" alt="3_37.png"></p><p>一个小例题:</p><p><img src="/images/3_38.png" alt="3_38.png"></p><p>关于冲突域和广播域更多可以看<a href="https://blog.csdn.net/gui951753/article/details/79402528" target="_blank" rel="noopener"><strong>这篇博客</strong></a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计网总结-三-一数据链路层&quot;&gt;&lt;a href=&quot;#计网总结-三-一数据链路层&quot; class=&quot;headerlink&quot; title=&quot;计网总结(三)一数据链路层&quot;&gt;&lt;/a&gt;计网总结(三)一数据链路层&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;一、概括&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算机网络总结（2）</title>
    <link href="https://www.junglezero.top/2019/07/31/%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93%EF%BC%882%EF%BC%89/"/>
    <id>https://www.junglezero.top/2019/07/31/机网络总结（2）/</id>
    <published>2019-07-31T12:50:30.000Z</published>
    <updated>2019-07-31T14:24:51.516Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计网总结-二-一物理层"><a href="#计网总结-二-一物理层" class="headerlink" title="计网总结(二)一物理层"></a>计网总结(二)一物理层</h1><p>知识总览:</p><p><img src="/images/2_8.png" alt="2_8.png"></p><h2 id="一、物理层基本概念"><a href="#一、物理层基本概念" class="headerlink" title="一、物理层基本概念"></a>一、物理层基本概念</h2><p>简单定义以及涉及相关知识: </p><ul><li>定义: 为传输数据所需要的物理链路创建、维持、拆除，而提供具有机械的，电子的，功能的和规范的特性。简单的说，<strong>物理层确保原始的数据可在各种物理媒体上传输</strong>，即传输数据比特流。</li><li>物理层设计的相关知识点:  数字信号、双绞线 、同轴电缆 、 光纤 、  时分多路 、波分复用 、 编码方式 、模拟信号、  频分多路复用  、  码分复用技术、  全双工 、半双工 、单工通信；</li></ul><p>四大特性:</p><ul><li><strong>机械特性</strong>: 指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等。</li><li><strong>电器特性</strong>: 指明在接口电缆的各条线上出现的电压的范围；</li><li><strong>功能特性</strong>: 指明某条线上出现的某一电平的电压的意义；</li><li><strong>过程特性</strong>: 定义了在信号线上进行二进制比特流传输的一组操作过程，包括各信号线的工作顺序和时序，使得比特流传输得以完成；</li></ul><h2 id="二、数据通信基础"><a href="#二、数据通信基础" class="headerlink" title="二、数据通信基础"></a>二、数据通信基础</h2><h3 id="1、数据通信模型"><a href="#1、数据通信模型" class="headerlink" title="1、数据通信模型"></a>1、数据通信模型</h3><p>分别看局域网通信模型和广域网通信模型:</p><p><img src="/images/2_1.png" alt="在这里插入图片描述"></p><blockquote><p>不过现在很多用户已经通过<strong>光纤</strong>接入<code>Internet</code>了，这就需要将计算机网卡的数字信号通过<strong>光电转换设备</strong>转换成光信号进行长距离传输，在接收端通过光电转换设备转换成数字信号。</p></blockquote><h3 id="2、数据通信的一些术语"><a href="#2、数据通信的一些术语" class="headerlink" title="2、数据通信的一些术语"></a>2、数据通信的一些术语</h3><p><img src="/images/2_2.png" alt="在这里插入图片描述"></p><h3 id="3、模拟信号和数字信号"><a href="#3、模拟信号和数字信号" class="headerlink" title="3、模拟信号和数字信号"></a>3、模拟信号和数字信号</h3><ul><li>模拟信号: 代表消息的参数的取值是<strong>离散</strong>的，在一定的范围内可以有无限多个不同的取值； </li><li>数字信号: 代表消息的参数的取值是<strong>连续</strong>的；在数字信号中通常用码元(时间间隔相同的符号)来表示一个二进制数字；</li><li>码元: 在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形。(可以表示一、二、三、四位二进制数)；</li><li>模拟信号和数字信号之间的转换；</li></ul><p>看下图: </p><p><img src="/images/2_3.png" alt="在这里插入图片描述"></p><h3 id="4、信道"><a href="#4、信道" class="headerlink" title="4、信道"></a>4、信道</h3><p>信道: 一般用来表示向某一个方向传送信息的媒体。</p><p>按照信号传送方向与时间的关系，数据通信分为三种类型: </p><ul><li>单向通信（单工通信）: 只能有一个方向的通信而没有反方向的交互。</li><li>双向交替通信（半双工通信) :  通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。</li><li>双向同时通信（全双工通信) : 通信的双方可以同时发送和接收信息。</li></ul><p><img src="/images/2_4.png" alt="在这里插入图片描述"></p><h3 id="5、调制"><a href="#5、调制" class="headerlink" title="5、调制"></a>5、调制</h3><p>调制分为两大类：</p><ul><li>基带调制：仅对基带信号的波形进行变换，使它能够与信道特性相适应。变换后的信号仍然是基带信号。把这种过程称为编码 (<code>coding</code>)。</li><li>带通调制：使用载波 (<code>carrier</code>)进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，这样就能够更好地在模拟信道中传输（即仅在一段频率范围内能够通过信道） 。</li><li>带通信号：经过载波调制后的信号。</li></ul><p>常用编码方式: </p><ul><li>不归零制：正电平代表 <code>1</code>，负电平代表 <code>0</code>。(效率最高，但是如果发送端发送连续的<code>0</code>或者<code>1</code>，接收端不容易判断码元的边界)；</li><li>归零制：正脉冲代表 <code>1</code>，负脉冲代表 <code>0</code>。</li><li>曼彻斯特编码：位周期中心的向上跳变代表 <code>0</code>，位周期中心的向下跳变代表 <code>1</code>。但也可反过来定义。(<code>1</code>比特需要<code>2</code>码元)</li><li>差分曼彻斯特编码：在每一位的中心处始终都有跳变。位开始边界有跳变代表 <code>0</code>，而位开始边界没有跳变代表 <code>1</code>。</li></ul><p>基本带通调制方法: </p><ul><li>基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。为了解决这一问题，就必须对基带信号进行调制 (<code>modulation</code>)。 </li><li>最基本的二元制调制方法有以下几种：①　调幅(AM)。②调频(FM)。③调相(PM) 。</li></ul><p><img src="/images/2_5.png" alt="在这里插入图片描述"></p><ul><li>从信号波形中可以看出，曼彻斯特 (Manchester) 编码和差分曼彻斯特编码产生的信号频率比不归零制高。</li><li>从自同步能力来看，不归零制不能从信号波形本身中提取信号时钟频率（这叫作没有自同步能力），而曼彻斯特编码和差分曼彻斯特编码具有自同步能力。</li></ul><blockquote><p>不是码元越多越好。若每一个码元可表示的比特数越多，则在接收端进行解调时要正确识别每一种状态就越困难，出错率增加。</p></blockquote><h3 id="6、信道极限容量"><a href="#6、信道极限容量" class="headerlink" title="6、信道极限容量"></a>6、信道极限容量</h3><p>基本概念:</p><ul><li>任何实际的信道都不是理想的，在传输信号时会产生各种失真以及带来多种干扰。 </li><li>影响信道上的数字信息传输速率的因素有两个: <strong>码元的传输速度和每个码元承载的比特信息量</strong>，码元传输的速率越高，或信号传输的距离越远，或传输媒体质量越差，在信道的输出端的波形的失真就越严重。 </li></ul><p>从概念上讲，限制码元在信道上的传输速率的因素有以下两个：</p><ul><li>信道能够通过的频率范围</li><li>信噪比</li></ul><p>①信道能够通过的频率范围</p><ul><li>具体的信道所能通过的频率范围总是有限的。信号中的许多高频分量往往不能通过信道。</li><li>1924年，奈奎斯特 (Nyquist) 就推导出了著名的奈氏准则。<strong>他给出了在假定的理想条件下，为了避免码间串扰，码元的传输速率的上限值</strong>。</li><li>在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题，使接收端对码元的判决（即识别）成为不可能。</li><li><strong>如果信道的频带越宽，也就是能够通过的信号高频分量越多，那么就可以用更高的速率传送码元而不出现码间串扰</strong>。  (可以通过信道的传输速度，计算码元的最高传输速率) </li></ul><p>②信噪比(香农公式)</p><ul><li>噪声存在于所有的电子设备和通信信道中。噪声是随机产生的，它的瞬时值有时会很大。因此噪声会使接收端对码元的判决产生错误；</li><li>但噪声的影响是相对的。如果信号相对较强，那么噪声的影响就相对较小；</li><li>信噪比就是信号的平均功率和噪声的平均功率之比。常记为 <code>S/N</code>，并用分贝 (<code>dB</code>) 作为度量单位。即：<br>信噪比(<code>dB</code>) = <strong>10 log10(S/N)</strong>   (<code>dB</code>) 。例如，当 S/N = 10 时，信噪比为 10 <code>dB</code>，而当 S/N = 1000时，信噪比为 30 <code>dB</code>。 例如，当 S/N = 10 时，信噪比为 10 dB，而当 S/N = 1000时，信噪比为 30 dB；</li><li>1984年，香农 (Shannon) 用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率（香农公式）。</li><li>信道的极限信息传输速率 C 可表达为：<code>C = W log2(1+S/N)</code>   (<code>bit/s</code>) ；其中，<code>W</code> 为信道的带宽（以 Hz 为单位）；<code>S</code> 为信道内所传信号的平均功率；<code>N</code> 为信道内部的高斯噪声功率。  </li></ul><p>香农公式表明: </p><ul><li>信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。 </li><li>只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输。 </li><li>若信道带宽 W 或信噪比 S/N 没有上限（当然实际信道不可能是这样的），则信道的极限信息传输速率 C 也就没有上限。</li><li>实际信道上能够达到的信息传输速率要比香农的极限传输速率低不少。  </li><li>对于频带宽度已确定的信道，如果信噪比不能再提高了，并且码元传输速率也达到了上限值，那么还有办法提高信息的传输速率。这就是：<strong>用编码的方法让每一个码元携带更多比特的信息量</strong>。 </li></ul><h2 id="三、物理层下的传输媒体"><a href="#三、物理层下的传输媒体" class="headerlink" title="三、物理层下的传输媒体"></a>三、物理层下的传输媒体</h2><ul><li>传输媒体也称为传输介质或传输媒介，它就是<strong>数据传输系统中在发送器和接收器之间的物理通路</strong>。</li><li>传输媒体可分为两大类，即导引型传输媒体和非导引型传输媒体。<ul><li>在导引型传输媒体中，<strong>电磁波被导引沿着固体媒体（铜线或光纤）传播</strong>。</li><li>非导引型传输媒体就是指自由空间。<strong>在非导引型传输媒体中，电磁波的传输常称为无线传输</strong>。</li></ul></li></ul><h3 id="1、导引型传输媒体"><a href="#1、导引型传输媒体" class="headerlink" title="1、导引型传输媒体"></a>1、导引型传输媒体</h3><h4 id="1-、双绞线-网线"><a href="#1-、双绞线-网线" class="headerlink" title="1)、双绞线(网线)"></a>1)、双绞线(网线)</h4><ul><li>最常用的传输媒体；</li><li>模拟传输和数字传输都可以使用双绞线，其通信距离一般为几到十几公里。  屏蔽双绞线 <code>STP</code> 无屏蔽双绞线 <code>UTP</code>；</li></ul><p><img src="/images/2_6.png" alt="在这里插入图片描述"></p><h4 id="2-、同轴电缆"><a href="#2-、同轴电缆" class="headerlink" title="2)、同轴电缆"></a>2)、同轴电缆</h4><ul><li>同轴电缆具有很好的抗干扰特性，被广泛用于传输较高速率的数据。</li><li>同轴电缆的带宽取决于电缆的质量。<br>50  同轴电缆 —— LAN / 数字传输常用<br>75  同轴电缆 —— 有线电视 / 模拟传输常用<h4 id="3-、光缆"><a href="#3-、光缆" class="headerlink" title="3)、光缆"></a>3)、光缆</h4></li><li>光纤是光纤通信的传输媒体。</li><li>由于可见光的频率非常高，约为 <code>108</code> MHz 的量级，因此一个光纤通信系统的传输带宽远远大于目前其他各种传输媒体的带宽。</li></ul><p>多模光纤和单模光纤: </p><ul><li>多模光纤 : 可以存在多条不同角度入射的光线在一条光纤中传输。这种光纤就称为多模光纤(适合近距离)。</li><li>单模光纤 :  若光纤的直径减小到只有一个光的波长，则光纤就像一根波导那样，它可使光线一直向前传播，而不会产生多次反射。这样的光纤称为单模光纤。<h3 id="2、非导引型传输媒体"><a href="#2、非导引型传输媒体" class="headerlink" title="2、非导引型传输媒体"></a>2、非导引型传输媒体</h3></li><li>将自由空间称为“非导引型传输媒体”。</li><li>无线传输所使用的频段很广。</li><li>短波通信（即高频通信）主要是靠电离层的反射，但短波信道的通信质量较差，传输速率低。</li><li>微波在空间主要是直线传播。</li><li>传统微波通信有两种方式：①地面微波接力通信；②卫星通信  ；</li></ul><p><img src="/images/2_7.png" alt="在这里插入图片描述"></p><h2 id="四、物理层设备"><a href="#四、物理层设备" class="headerlink" title="四、物理层设备"></a>四、物理层设备</h2><p>两个主要设备:</p><ul><li>中继器；</li><li>集线器；</li></ul><p>中继器：</p><p><img src="/images/2_9.png" alt="2_9.png"></p><p>集线器:</p><p><img src="/images/2_10.png" alt="2_10.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计网总结-二-一物理层&quot;&gt;&lt;a href=&quot;#计网总结-二-一物理层&quot; class=&quot;headerlink&quot; title=&quot;计网总结(二)一物理层&quot;&gt;&lt;/a&gt;计网总结(二)一物理层&lt;/h1&gt;&lt;p&gt;知识总览:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2_8
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算机网络总结（1）</title>
    <link href="https://www.junglezero.top/2019/07/28/eInternet1/"/>
    <id>https://www.junglezero.top/2019/07/28/eInternet1/</id>
    <published>2019-07-28T09:18:02.000Z</published>
    <updated>2019-07-30T07:57:54.107Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计网总结-一-一计算机网络和协议"><a href="#计网总结-一-一计算机网络和协议" class="headerlink" title="计网总结(一)一计算机网络和协议"></a>计网总结(一)一计算机网络和协议</h1><hr><h2 id="一、互联网概述"><a href="#一、互联网概述" class="headerlink" title="一、互联网概述"></a>一、互联网概述</h2><ul><li>计算机网络: 由若干节点和连接这些节点的链路组成，网络中的节点可以是计算机、集线器、交换机、或路由器等；</li><li>网络之间可以通过路由器相互连接，这就构成了一个更大范围的计算机网路，这样的网路称为<strong>互连网</strong>，因此互连网是<strong>网路的网路</strong>；</li><li>因特网(互联网):  全球最大的特定互连网；</li></ul><p>注意以下两个意思相差很大的名词 <code>internet</code> 和 <code>Internet</code> [RFC 1208]:</p><ul><li><p>以小写字母 i 开始的 <code>internet</code> (互连网) 是一个通用名词，它泛指由多个计算机网络互连而成的计算机网络。在这些网络之间的通信协议〈即通信规则) 可以任意选择，不一定非要使用<code>TCP/IP</code> 协议；</p></li><li><p>以大写字母 I 开始的 <code>Internet</code> 〈互联网或因特网) 则是一个专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定互连网，它采用 <code>TCP/IP</code> 协议族作为通信的规则，且其前身是美国的 ARPANET；</p></li><li><p>可见，任意把几个计算机网络互连起来〈不管采用什么协议)，并能够相互通信，这样构成的是一个互连网(<code>internet</code>，而不是互联网(<code>Internet</code>)。</p></li></ul><p><img src="/images/1_1.png" alt="在这里插入图片描述"></p><ul><li>路由器（Router），是连接因特网中各局域网、广域网的设备，它会根据信道的情况自动选择和设定路由，以最佳路径，按前后顺序发送信号。</li><li>路由器是互联网络的枢纽，”交通警察”。<strong>路由和交换机之间的主要区别就是交换机发生在OSI参考模型第二层（数据链路层），而路由发生在第三层，即网络层</strong>。这一区别决定了路由和交换机在移动信息的过程中需使用不同的控制信息，所以说两者实现各自功能的方式是不同的。</li><li>路由器（<code>Router</code>）又称网关设备（<code>Gateway</code>）是用于连接多个逻辑上分开的网络，所谓逻辑网络是代表一个单独的网络或者一个子网。当数据从一个子网传输到另一个子网时，可通过路由器的路由功能来完成。因此，路由器具有判断网络地址和选择IP路径的功能。</li><li><strong>交换机是将不同IP地址的电脑连在一起，共享一根网线；路由器是将同一个IP给不同的电脑使用，就像一条大路分成很多条小路。一句话，路由器是接外网的,交换机是接内网的。(交换机没有开关，路由器有开关)</strong></li></ul><p><img src="/images/1_2.png" alt="在这里插入图片描述"></p><hr><h2 id="二、互联网组成"><a href="#二、互联网组成" class="headerlink" title="二、互联网组成"></a>二、互联网组成</h2><h3 id="1、基本组成"><a href="#1、基本组成" class="headerlink" title="1、基本组成"></a>1、基本组成</h3><p>基本组成:</p><ul><li>①边缘部分: 由所有连接在互联网上的主机组成，这部分是用户直接使用的，用来进行通信（传送数据，音频或视频）和资源共享；</li><li>②核心部分: 由大量网络 和连接这些网络的<strong>路由器</strong> 组成，这部分是为边缘部分提供服务的(提供连通性和交换)；</li></ul><p><img src="/images/1_3.png" alt="在这里插入图片描述"></p><p>边缘部分的主机间的通信方式: </p><p><img src="/images/1_4.png" alt="在这里插入图片描述"></p><p><strong>(1)客户程序:</strong></p><ul><li>被用户调用后运行，在通信时主动向远地服务器发起通信(请求服务)。因此，客</li></ul><p>户程序必须知道服务器程序的地址。</p><ul><li>不需要特殊的硬件和很复杂的操作系统。</li></ul><p><strong>(2)服务器程序:</strong></p><ul><li>是一种专门用来提供某种服务的程序，可同时处理多个远地或本地客户的请求。</li><li>系统启动后即自动调用并一直不断地运行着，被动地等待并接受来自各地的客户的</li></ul><p>通信请求。因此，服务器程序不需要知道客户程序的地址。</p><p><strong>客户与服务器的通信关系建立后，通信可以是双向的，客户和服务器都可发送和接收数据。</strong></p><h3 id="2、数据交换方式"><a href="#2、数据交换方式" class="headerlink" title="2、数据交换方式"></a>2、数据交换方式</h3><p><strong>电路交换</strong></p><p><div align="center"> <img src="/images/1_6.png" width="550"></div><br></p><p><strong>分组交换</strong></p><p><div align="center"> <img src="/images/1_7.png" width="750"></div><br></p><p><strong>三种交换方式的比较</strong></p><ul><li>电路交换: 整个报文的比特流连续地从源点直达终点，好像在一个管道中传送。</li><li><p>报文交换: 整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。</p></li><li><p>分组交换 : 单个分组(这只是整个报文的一部分) 传送到相邻结点，存储下来后查找转发表，转发到下一个结点。</p></li></ul><p><div align="center"> <img src="/images/1_8.png" width></div><br></p><p>选择: </p><ul><li>报文交换和分组交换都采用存储转发。</li><li>传送数据量大，且传送时间远大于呼叫时选择电路交换。电路交换传输时延最小。</li><li>从信道利用率看，报文交换和分组交换优于电路交换，其中分组交换时延更小。</li></ul><hr><h2 id="三、计算机网络的性能指标"><a href="#三、计算机网络的性能指标" class="headerlink" title="三、计算机网络的性能指标"></a>三、计算机网络的性能指标</h2><h3 id="1、速率"><a href="#1、速率" class="headerlink" title="1、速率"></a>1、速率</h3><ul><li>网络技术中的速率是指每秒钟传输的比特数量，称为数据率或比特率，速率的单位是<code>bit/s</code>，或<code>b/s</code>(比特每秒)；</li><li>速率较高时，就可以使用kb/s，Mb/s，Gb/s，Tb/s，人们现在所说的10M网速，其实是10Mb/s；</li><li>360等可以显示网速的软件，测试你电脑的那个网速，这里单位是B/秒，大写的B是字节(byte)，8bit = 1byte，也就是说如果测速为3.82MB/s，则下载速率为3.82 * 8Mb/s。</li></ul><h3 id="2、带宽"><a href="#2、带宽" class="headerlink" title="2、带宽"></a>2、带宽</h3><ul><li>带宽用来表示网络通信线路传输数据的能力(数字信道所能传送的最高数据率)，即最高速率；</li><li>比如说家里使用ADSL拨号，有4M带宽、8M带宽，这里说的带宽就是你访问Internet的最高带宽，你家里的带宽由电信运营商控制；</li></ul><h3 id="3、吞吐量"><a href="#3、吞吐量" class="headerlink" title="3、吞吐量"></a>3、吞吐量</h3><ul><li>吞吐量表示在单位时间内通过某个网络或接口的数据量，包括全部上传和下载的流量；</li><li>吞吐量受网络带宽或网络额定速率的限制，计算机的网卡如果连接交换机，网卡就可以工作在全双工模式，即能够同时接收和发送数据；如果计算机的网卡连接的是集线器，网卡就只能工作在半双工模式，即不能同时发送和接收数据；</li></ul><p><img src="/images/1_10.png" alt="在这里插入图片描述"></p><h3 id="4、时延"><a href="#4、时延" class="headerlink" title="4、时延"></a>4、时延</h3><ul><li>时延(delay)是指数据(一个数据包或bit)从网络的一段传送到另一端所需要的时间，是一个很重要的性能指标；</li><li>时延包括: 发送时延、传播时延、处理时延、排队时延；（数据在网络中经历的的总时延就是这四种时延的累加和）；</li></ul><h4 id="1-、发送时延"><a href="#1-、发送时延" class="headerlink" title="1)、发送时延"></a>1)、发送时延</h4><p><img src="/images/1_11.png" alt="在这里插入图片描述"></p><h4 id="2-、传播时延"><a href="#2-、传播时延" class="headerlink" title="2)、传播时延"></a>2)、传播时延</h4><p>传播时延是电磁波在信道中传播一定的距离要花费的时间； </p><p><img src="/images/1_12.png" alt="在这里插入图片描述"></p><h4 id="3-、排队时延和处理时延"><a href="#3-、排队时延和处理时延" class="headerlink" title="3)、排队时延和处理时延"></a>3)、排队时延和处理时延</h4><p><img src="/images/1_13.png" alt="在这里插入图片描述"></p><h4 id="4-、时延带宽积"><a href="#4-、时延带宽积" class="headerlink" title="4)、时延带宽积"></a>4)、时延带宽积</h4><p><img src="/images/1_14.png" alt="在这里插入图片描述"></p><h3 id="5、往返时间"><a href="#5、往返时间" class="headerlink" title="5、往返时间"></a>5、往返时间</h3><p>表示从发送端发送数据开始，到发送端接收到来自接收端的确认(发送端收到确认立即发送确认)，总共经历的时间；</p><h3 id="6、利用率"><a href="#6、利用率" class="headerlink" title="6、利用率"></a>6、利用率</h3><p><img src="/images/1_15.png" alt="在这里插入图片描述"></p><hr><h2 id="四、OSI参考模型以及TCP-IP四层模型、五层协议"><a href="#四、OSI参考模型以及TCP-IP四层模型、五层协议" class="headerlink" title="四、OSI参考模型以及TCP/IP四层模型、五层协议"></a>四、OSI参考模型以及TCP/IP四层模型、五层协议</h2><p>分层的方法可以是7层、5层、4层。</p><p><img src="/images/1_18.png" alt="在这里插入图片描述"></p><p>七层中各层的作用一览:</p><p><img src="/images/1_31.png" alt="1_31.png"></p><p>具体:</p><ul><li>应用层：提供用户接口，特制能够发起网络通信的应用程序，比如客户端程序，QQ，浏览器等，服务器程序有Web服务器，邮件服务器，流媒体服务器等。</li><li>表示层：使用何种编码方式。比如要传输的数据使用ASCI编码，Unicode编码还是二进制文件，是否要加密和压缩。发送端和接收端程序必须使用相同的编码方式，才能正确显示，否则就产生乱码。</li><li>会话层: 通信的应用程序之间建立、维护和释放面向用户的连接。通信的应用程序之间立会话，需要传输层建立1个或多个连接。</li><li>传输层: 负责在通信的两个计算机之间建立连接，实现可靠的或不可靠的数据通信， 能够发现发送端和接收端的丢包重传，访量控制。</li><li>网路层: 路由器查看数据包目标IP地址，根据路由表为数据包选择路径。路由表中的条目可以人工添加静态路由) 也可以动态生成(动态路由) 。</li><li>数据链路层: 不同的网络类型，发送数据的机制不同，数据链路层就是将数据包封装成能够在不同网络传输的帧。能够进行差错检查，但不纠错，检测出错误去掉该帧。</li><li>物理层: 该层规定了网络设备接口标准、电压标准。尽可能的通过频分复用、时分复用技术在通信和链路上更快的传输数据。</li></ul><p>七层模型各层作用:</p><p><div align="center"> <img src="/images/1_17.png" width="650"></div><br></p><p>TCP/IP只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p><p>TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p><p>最后看一下<code>TCP/IP</code>和<code>ISO/OSI</code>的对比:</p><p><img src="/images/1_32.png" alt="1_32.png"></p><hr><h2 id="五、通信过程、数据传输、网络设备"><a href="#五、通信过程、数据传输、网络设备" class="headerlink" title="五、通信过程、数据传输、网络设备"></a>五、通信过程、数据传输、网络设备</h2><h3 id="1、通信过程"><a href="#1、通信过程" class="headerlink" title="1、通信过程"></a>1、通信过程</h3><p><img src="/images/1_20.png" alt="在这里插入图片描述"></p><blockquote><p><strong>注意: MAC地址由48位二进制数组成，在Windows操作系统命令提示符下，    输入”ipconfig / all”能够看到计算机网卡的MAC地址，物理地址…. : C8-60-00-2E-6E-EB，这里显示的是十六进制表示的MAC地址，使用MA和MB代替MAC地址是为了简化说明。</strong></p></blockquote><p>相关解释</p><p><img src="/images/1_21.png" alt></p><p><img src="/images/1_22.png" alt></p><p><img src="/images/1_23.png" alt></p><blockquote><p>为什么计算机通信需要物理地址和IP地址?，物理地址决定了数据帧下一跳给谁，而 IP地址决定了数据包最终给谁。如果全球的计算机都使用集线器或交换机连接，就可以只使用 MAC 地址进行通信了。</p></blockquote><p><img src="/images/1_24.png" alt></p><p>通过本图也可以看出:</p><ul><li><strong>目标MAC地址决定了数据帧下一跳由哪个设备接收；</strong></li><li><strong>目标IP地址决定了数据包最终到达那个计算机；</strong></li><li><strong>不同的网络数据链路层使用不同的协议，帧格式也不相同，路由器在不同网络转发数据包，需要将数据包重新封装；</strong></li></ul><p><strong>通信过程上面四层是端到端的，下面三层是点到点的</strong>。</p><p><img src="/images/1_29.png" alt="1_29.png"></p><h3 id="2、数据封装和解封-数据传输"><a href="#2、数据封装和解封-数据传输" class="headerlink" title="2、数据封装和解封(数据传输)"></a>2、数据封装和解封(数据传输)</h3><p>下面看几张类似的图，来理解这个过程:</p><p><img src="/images/1_25.png" alt="在这里插入图片描述"></p><p><img src="/images/1_30.png" alt="1_30.png"></p><p><strong>网络的传输过程(从客户端和服务器的角度来看)</strong></p><p><img src="images/1_5.png" alt="在这里插入图片描述"></p><h3 id="3、网络设备"><a href="#3、网络设备" class="headerlink" title="3、网络设备"></a>3、网络设备</h3><p>现实中各个网络设备的样子: </p><p><div align="center"><img src="/images/1_28.png" width="650"></div><br></p><h2 id="六、小结"><a href="#六、小结" class="headerlink" title="六、小结"></a>六、小结</h2><ul><li><p>计算机网络〈可简称为网络) 把许多计算机连接在一起，而互连网则把许多网络连接在一起，是网络的网络。</p></li><li><p>以小写字母<code>i</code>开始的 <code>internet</code> 〈互连网) 是通用名词，它泛指由多个计算机网络互连而成的网络。在这些网络之间的通信协议〈即通信规则) 可以是任意的。</p></li><li><p>以大写字母 <code>I</code>开始的 Internet (互联网) 是专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定互连网，并采用 TCP/P 协议族作为通信规则，且其前身是美国的 ARPANET。Internet 的推荐译名是“因特网” 但很少被使用。</p></li><li><p>互联网现在采用存储转发的分组交换技术，以及三层 ISP 结构。</p></li><li><p>互联网按工作方式可划分为<strong>边缘部分与核心部分</strong>。<strong>主机在网络的边缘部分，其作用是进行信息处理。路由器在网络的核心部分，其作用是按存储转发方式进行分组交换。</strong></p></li><li><p>计算机通信是计算机中的进程〈即运行着的程序) 之间的通信。<strong>计算机网络采用的通信方式是客户-服务器方式和对等连接方式 (P2P 方式)。</strong></p></li><li><p>客户和服务器都是指通信中所涉及的应用进程。客户是服务请求方，服务器是服务 提供方。</p></li><li><p>按作用范围的不同，计算机网络分为广域网 WAN、城域网 MAN、局域网 LAN 和个人区域网 PAN。</p></li><li><p>计算机网络最常用的性能指标是: <strong>速率、带宽、吞吐量、时延〈发送时延、传播时延、处理时延、排队时延)、时延带宽积、往返时间和信道(或网络)利用率。</strong></p></li><li><p>网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层及其协议的集合，称为网络的体系结构。</p></li><li><p>五层协议的体系结构由应用层、运输层、网络层〈或网际层)、数据链路层和物理层组成。<strong>运输层最重要的协议是 <code>TCP</code> 和 <code>UDP</code> 协议，而网络层最重要的协议是 <code>IP</code>协议。</strong></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计网总结-一-一计算机网络和协议&quot;&gt;&lt;a href=&quot;#计网总结-一-一计算机网络和协议&quot; class=&quot;headerlink&quot; title=&quot;计网总结(一)一计算机网络和协议&quot;&gt;&lt;/a&gt;计网总结(一)一计算机网络和协议&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;一、互联
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式总结（3）【模板方法模式、迭代器模式、代理模式、桥接模式】</title>
    <link href="https://www.junglezero.top/2019/07/26/%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>https://www.junglezero.top/2019/07/26/模式总结/</id>
    <published>2019-07-26T07:40:10.000Z</published>
    <updated>2019-08-06T07:26:25.617Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.3dmgame.com/uploads/images/news/20190331/1554021622_367580.jpg" width="70%"></p><a id="more"></a><h1 id="模板方法设计模式"><a href="#模板方法设计模式" class="headerlink" title="模板方法设计模式"></a>模板方法设计模式</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p><strong>模板方法模式是类的行为模式。准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。这就是模板方法模式的用意。</strong></p><blockquote><p>例如: 在现实生活中，完成某件事情是需要 n 个固定步骤的。如”在淘宝进行购物”这件事情的完成一般需要三个步骤: <strong>登录网站、挑选商品、 付款</strong>。但对于登录网站与付款这两步，每个人几乎都是相同的操作。但不同的地方是，每个人所挑选的商品是不同的。<br>在软件开发过程中同样存在这样的情况。某类的某个方法的实现，需要几个固定步骤。在这些固定步骤中,对于该类的不同对象， 有些步骤的实现是固定不变的，有些步骤的实现是大相径庭的，有些步骤的实现是可变可不变的。对于这种情况，就适合使用模板方法设计模式编程。</p></blockquote><h2 id="二、结构"><a href="#二、结构" class="headerlink" title="二、结构"></a>二、结构</h2><p>基本结构:</p><p>在模板方法设计模式中，存在一个<strong>父类</strong>(一般是<strong>抽象</strong>的)。其中包含 两类方法:  模板方法 和 3 种步骤方法；</p><ul><li>模板方法: 即实现某种算法的方法步骤。这些步骤都是调用的步骤方法实现的。</li><li>步骤方法:即完成模板方法的每个阶段性方法。<ul><li>抽象方法: 子类必须实现的方法。即子类的个性化定义；</li><li>最终方法(固定方法): 子类不能重写的方法，即所有子类都要做的步骤；</li><li>钩子方法: 父类给了默认实现，子类可以重写，也可以不重写的方法；</li></ul></li></ul><p>结构:</p><p><img src="/images/09_template_02.png" alt="09_template_02.png"></p><h2 id="三、案例"><a href="#三、案例" class="headerlink" title="三、案例"></a>三、案例</h2><blockquote><p>实现在网站上购物的案例。</p></blockquote><p>基本逻辑图:</p><p><img src="/images/09_template_01.png" alt="09_template_01.png"></p><p>代码:</p><p>首先看<code>Shopping</code>类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shopping</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模板方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyGoods</span><span class="params">()</span></span>&#123;</span><br><span class="line">        useLogin(); <span class="comment">//固定的方法，子类不能重写</span></span><br><span class="line">        buy();      <span class="comment">//抽象方法，子类必须实现</span></span><br><span class="line">        pay();      <span class="comment">//钩子方法(hook)，子类可以重写</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 固定方法(最终方法)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">useLogin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用户登录"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 钩子方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用银联支付"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是两个子类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShoesShopping</span> <span class="keyword">extends</span> <span class="title">Shopping</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"购买Nike鞋子!!!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClothesShopping</span> <span class="keyword">extends</span> <span class="title">Shopping</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"购买海澜之家男装!!!!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写了钩子方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用支付宝支付"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Shopping shoesShopping = <span class="keyword">new</span> ShoesShopping();</span><br><span class="line">        shoesShopping.buyGoods();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">        Shopping clothesShopping = <span class="keyword">new</span> ClothesShopping();</span><br><span class="line">        clothesShopping.buyGoods();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">用户登录</span><br><span class="line">购买Nike鞋子!!!!</span><br><span class="line">使用银联支付</span><br><span class="line">-----------------------</span><br><span class="line">用户登录</span><br><span class="line">购买海澜之家男装!!!!!</span><br><span class="line">使用支付宝支付</span><br></pre></td></tr></table></figure><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>有时候为了防止恶意操作，模板方法也会加上 <code>final</code> 关键词。</p><h2 id="五、实际使用"><a href="#五、实际使用" class="headerlink" title="五、实际使用"></a>五、实际使用</h2><p>Spring对数据库的操作在jdbc上面做了深层次的封装，使用spring的注入功能，可以把DataSource注册到JdbcTemplate之中。<br>这个JdbcTemplate用的是一种更高级的模板思想，具体说来，它引入了一种回调模式<br>对于JdbcTemplate，它是个抽象类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplate</span> </span>&#123;  </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">final</span> Object execute（String sql）&#123;  </span><br><span class="line">        Connection con=<span class="keyword">null</span>;  </span><br><span class="line">        Statement stmt=<span class="keyword">null</span>;  </span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            con=getConnection（）;  </span><br><span class="line">            stmt=con.createStatement（）;  </span><br><span class="line">            Object retValue=executeWithStatement（stmt,sql）;  </span><br><span class="line">            <span class="keyword">return</span> retValue;  </span><br><span class="line">        &#125;<span class="keyword">catch</span>（SQLException e）&#123;  </span><br><span class="line">             ...  </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;  </span><br><span class="line">            closeStatement（stmt）;  </span><br><span class="line">            releaseConnection（con）;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Object executeWithStatement（Statement   stmt, String sql）;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>要是想使用，就必须要实现，但是其中的方法太多<br>因此就引出了中间态的回调<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StatementCallback</span></span>&#123;  </span><br><span class="line">    Object doWithStatement（Statement stmt）;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后在进行具体的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplate</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object execute（StatementCallback callback）&#123;  </span><br><span class="line">        Connection con=<span class="keyword">null</span>;  </span><br><span class="line">        Statement stmt=<span class="keyword">null</span>;  </span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            con=getConnection（）;  </span><br><span class="line">            stmt=con.createStatement（）;  </span><br><span class="line">            Object retValue=callback.doWithStatement（stmt）;  </span><br><span class="line">            <span class="keyword">return</span> retValue;  </span><br><span class="line">        &#125;<span class="keyword">catch</span>（SQLException e）&#123;  </span><br><span class="line">            ...  </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;  </span><br><span class="line">            closeStatement（stmt）;  </span><br><span class="line">            releaseConnection（con）;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    ...<span class="comment">//其它方法定义  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><h2 id="一、基本概念-1"><a href="#一、基本概念-1" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>迭代器模式属于行为型模式。</p><p>这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。</p><p>如果我们需要统一遍历不同的集合(容器)，也可以利用迭代器模式解决(下面的案例就是解决这个问题)。</p><h2 id="二、结构-1"><a href="#二、结构-1" class="headerlink" title="二、结构"></a>二、结构</h2><p>结构:</p><p><img src="/images/10_iterator_01.png" alt="10_iterator_01.png"></p><ul><li><code>Container</code> 是聚合类，其中 <code>getIterator()</code> 方法可以产生一个 <code>Iterator</code>；</li><li><code>Iterator</code> 主要定义了 <code>hasNext()</code> 和 <code>next()</code> 方法；</li><li>每一个<code>Container</code>的实现类都会有一个具体的<code>Iterator</code>实现类来帮助实现迭代；</li></ul><h2 id="三、案例-1"><a href="#三、案例-1" class="headerlink" title="三、案例"></a>三、案例</h2><blockquote><p>实现两个容器能够统一遍历。(或者两个以上)</p></blockquote><p>先看代码结构: (<strong>这里我将两个迭代器实现类写在两个容器内部</strong>)</p><p><img src="/images/10_iterator_02.png" alt="10_iterator_02.png"></p><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="function">Iterator <span class="title">getIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个容器类，他们内部的容器不同，内部有自带不同的迭代器:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteContainer1</span> <span class="keyword">implements</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteContainer1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> Integer[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) arr[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteIterator1&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator1</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(index &lt; arr.length)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(hasNext())</span><br><span class="line">                <span class="keyword">return</span> arr[index++];</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteContainer2</span> <span class="keyword">implements</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArrayList arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteContainer2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) arr.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteIterator1&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator1</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(index &lt; arr.size())</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(hasNext())</span><br><span class="line">                <span class="keyword">return</span> arr.get(index++);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果不这么做，需要区分c1和c2的遍历方式, 一个是数组，一个是List</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Container c1 = <span class="keyword">new</span> ConcreteContainer1();</span><br><span class="line">        Container c2 = <span class="keyword">new</span> ConcreteContainer2();</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Iterator&gt;its = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        its.add(c1.getIterator()); <span class="comment">// 将c1迭代器加入its</span></span><br><span class="line">        its.add(c2.getIterator()); <span class="comment">// 将c1迭代器加入its</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现了统一遍历, 只需要将迭代器加入到 its中即可</span></span><br><span class="line">        <span class="keyword">for</span>(Iterator it : its) &#123;</span><br><span class="line">            <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">                System.out.print( it.next() + <span class="string">" "</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><h2 id="四、总结-1"><a href="#四、总结-1" class="headerlink" title="四、总结"></a>四、总结</h2><p>优点:</p><ul><li>在同一个聚合上可以有多个遍历；</li><li>在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码；</li></ul><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><h2 id="一、基本概念-2"><a href="#一、基本概念-2" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>代理模式是对象的结构模式。</p><p><strong>代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用(接口的引用)</strong></p><h2 id="二、静态代理"><a href="#二、静态代理" class="headerlink" title="二、静态代理"></a>二、静态代理</h2><p>静态代理是指，代理类在程序运行前就已经定义好，其与<strong>目标类(被代理类)</strong>的关系在程序运行前就已经确立。</p><p>静态代理类似于企业与企业的法律顾问间的关系。<strong>法律顾问与企业的代理关系，并不是在“官司“发生后才建立的，而是之前就确立好的一种关系</strong>。</p><p>而动态代理就是外面打官司一样，是官司发生了之后临时请的律师。</p><p>代理可以看做就是在被代理对象外面包裹一层（和装饰者类似但又不同）:</p><p><strong>案例: 比如我们有一个可以移动的坦克，它的主要方法是<code>move()</code>，但是我们需要记录它移动的时间，以及在它移动前后做日志，其静态代理的实现模式就类似下面的图</strong>:</p><p><img src="/images/11_proxy_01.png" alt="11_proxy_01.png"></p><p>两个代理类以及结构关系:</p><p><img src="/images/11_proxy_02.png" alt="11_proxy_02.png"></p><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tank</span> <span class="keyword">implements</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 坦克移动</span></span><br><span class="line">        System.out.println(<span class="string">"Tank Moving......"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5000</span>)); <span class="comment">// 随机产生 1~5秒, 模拟坦克在移动　</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个代理类: <code>TankTimeProxy</code>和<code>TankLogProxy</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TankTimeProxy</span> <span class="keyword">implements</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Movable tank;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TankTimeProxy</span><span class="params">(Movable tank)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tank = tank;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在前面做一些事情: 记录开始时间</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"start time : "</span> + start);</span><br><span class="line"></span><br><span class="line">        tank.move();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在后面做一些事情: 记录结束时间,并计算move()运行时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"end time : "</span> + end);</span><br><span class="line">        System.out.println(<span class="string">"spend all time : "</span> + (end - start)/<span class="number">1000</span> + <span class="string">"s."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TankLogProxy</span> <span class="keyword">implements</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Movable tank;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TankLogProxy</span><span class="params">(Movable tank)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tank = tank;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// tank 移动前记录日志</span></span><br><span class="line">        System.out.println(<span class="string">"Tank Log start......."</span>);</span><br><span class="line"></span><br><span class="line">        tank.move();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// tank 移动后记录日志</span></span><br><span class="line">        System.out.println(<span class="string">"Tank Log end......."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Movable target = <span class="keyword">new</span> TankLogProxy(<span class="keyword">new</span> TankTimeProxy(<span class="keyword">new</span> Tank()));    <span class="comment">//先记录时间，再记录日志</span></span><br><span class="line"><span class="comment">//        Movable target = new TankTimeProxy(new TankLogProxy(new Tank())); //先记录日志，再记录时间</span></span><br><span class="line">        target.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Tank Log start.......</span><br><span class="line">start time : <span class="number">1551271511619</span></span><br><span class="line">Tank Moving......</span><br><span class="line">end time : <span class="number">1551271514522</span></span><br><span class="line">spend all time : <span class="number">2</span>s.</span><br><span class="line">Tank Log end.......</span><br></pre></td></tr></table></figure><p>这其中有两个很重要的点，那就是:</p><ul><li>两个代理对象内部都<strong>有着被代理对象(target)实现的接口的引用</strong>；</li><li>且两个代理对象都<strong>实现了被代理对象(target)实现的接口</strong>；</li></ul><h2 id="三、基本动态代理"><a href="#三、基本动态代理" class="headerlink" title="三、基本动态代理"></a>三、基本动态代理</h2><p>上面静态代理的缺点在哪?</p><p><strong>现在单看做时间这个代理，如果我们现在多了一个飞机，飞机里面的方法是<code>fly()</code>，现在要给飞机做代理，那么我们不能用之前写的<code>TankTimeProxy</code>，我们需要额外的写一个<code>PlaneTimeProxy</code>，这明显是冗余代码，所以这就是静态代理最大的缺点，这可以用动态代理解决</strong>。</p><p>动态代理是指，<strong>程序在整个运行过程中根本就不存在目标类的代理类(在JDK内部叫<code>$Proxy0</code>，我们看不到)</strong>，目标对象的代理对象只是由代理生成工具(如代理工厂类) 在程序运行时由 JVM 根据反射等机制动态生成的。代理对象与目标对象的代理关系在程序运行时才确立。</p><p>对比静态代理，静态代理是指在程序运行前就已经定义好了目标类的代理类。代理类与目标类的代理关系在程序运行之前就确立了。</p><p>首先看动态代理的一些特点:</p><ul><li>动态代理不需要写出代理类的名字，你要的代理对象我直接给你产生，是使用的时候生成的；</li><li>只需要调用<code>Proxy.newProxyInstance()</code>就可以给你产生代理类；</li></ul><p>JDK动态代理相关API:</p><p><img src="/images/12_proxy_07.png" alt="12_proxy_07.png"></p><p>下面看使用动态代理解决上面的问题(可以用<code>TimeProxy</code>代理一切对象):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tank</span> <span class="keyword">implements</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 坦克移动</span></span><br><span class="line">        System.out.println(<span class="string">"Tank Moving......"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5000</span>)); <span class="comment">// 随机产生 1~5秒, 模拟坦克在移动　</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增的飞机:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plane</span> <span class="keyword">implements</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Plane Flying......"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5000</span>)); <span class="comment">// 随机产生 1~5秒, 飞机在飞行　</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的关键处理，即编写<code>MyTimeProxyInvocationHandler</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态代理做不到既为飞机做时间代理，又为坦克做时间代理，但是动态代理可以为所有对象做代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTimeProxyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;<span class="comment">//注意这里是 Object ，不是Movable或者Flyable</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTimeProxyInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// proxy  : 代理对象  可以是一切对象 (Object)</span></span><br><span class="line">    <span class="comment">// method : 目标方法</span></span><br><span class="line">    <span class="comment">// args   : 目标方法的参数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在前面做一些事情: 记录开始时间</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"start time : "</span> + start);</span><br><span class="line"></span><br><span class="line">        method.invoke(target, args); <span class="comment">// 调用目标方法  invoke是调用的意思, 可以有返回值的方法(我们这里move和fly都没有返回值)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在后面做一些事情: 记录结束时间,并计算move()运行时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"end time : "</span> + end);</span><br><span class="line">        System.out.println(<span class="string">"spend all time : "</span> + (end - start)/<span class="number">1000</span> + <span class="string">"s."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后测试类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Movable tank = <span class="keyword">new</span> Tank();</span><br><span class="line">        <span class="comment">//可以为所有对象产生时间代理的 InvocationHandler</span></span><br><span class="line">        MyTimeProxyInvocationHandler myInvocationHandler = <span class="keyword">new</span> MyTimeProxyInvocationHandler(tank);</span><br><span class="line">        Movable tankProxy = (Movable) Proxy.newProxyInstance(</span><br><span class="line">                tank.getClass().getClassLoader(),</span><br><span class="line">                tank.getClass().getInterfaces(),</span><br><span class="line">                myInvocationHandler</span><br><span class="line">        );</span><br><span class="line">        tankProxy.move();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line"></span><br><span class="line">        Flyable plane = <span class="keyword">new</span> Plane();</span><br><span class="line">        myInvocationHandler = <span class="keyword">new</span> MyTimeProxyInvocationHandler(plane);</span><br><span class="line">        <span class="comment">// 为飞机产生代理, 为..产生代理，这样可以为很多东西产生代理，静态代理做不到</span></span><br><span class="line">        Flyable planeProxy = (Flyable) Proxy.newProxyInstance(</span><br><span class="line">                plane.getClass().getClassLoader(),</span><br><span class="line">                plane.getClass().getInterfaces(),</span><br><span class="line">                myInvocationHandler</span><br><span class="line">        );</span><br><span class="line">        planeProxy.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出(同时为<code>Tank</code>和<code>Plane</code>做了代理):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">start time : <span class="number">1551275526486</span></span><br><span class="line">Tank Moving......</span><br><span class="line">end time : <span class="number">1551275531193</span></span><br><span class="line">spend all time : <span class="number">4</span>s.</span><br><span class="line">--------------------</span><br><span class="line">start time : <span class="number">1551275531195</span></span><br><span class="line">Plane Flying......</span><br><span class="line">end time : <span class="number">1551275532996</span></span><br><span class="line">spend all time : <span class="number">1</span>s.</span><br></pre></td></tr></table></figure><p>我们分析一下这个代理过程:</p><p><img src="/images/11_proxy_03.png" alt="11_proxy_03.png"></p><p>调用过程(重要):</p><ul><li>JDK内部的<code>Proxy</code>类在内部创建了一个<code>$Proxy0</code>的代理对象(它实现了目标对象所在接口<code>Movable</code>；</li><li><code>$Proxy0</code>内部有<code>InvocationHandler</code>接口的引用，然后在<code>$Proxy</code>中调用了接口的<code>invoke()</code>方法；</li><li>而我们将<code>InvocationHandler</code>接口的实现类传入了<code>Proxy</code>，所以我们在实现类中加入的前后逻辑就会得到执行；</li></ul><p>如果这里还不够理解，可以看代理模式(二)，会模拟实现JDK的底层实现。</p><h2 id="四、CGLIB动态代理"><a href="#四、CGLIB动态代理" class="headerlink" title="四、CGLIB动态代理"></a>四、CGLIB动态代理</h2><p>问题: 使用 JDK 的 Proxy 实现代理，要求目标类与代理类实现相同的接口。<strong>若目标类不存在接口，则无法使用该方式实现</strong>。</p><p>可以用 CGLIB 来解决上面的问题。</p><p>CGLIB 代理的生成原理是<strong>生成目标类的子类，而子类是增强过的，这个子类对象就是代理对象</strong>。</p><p>所以，使用CGLIB 生成动态代理，<strong>要求目标类必须能够被继承，即不能是 final 的类</strong>。 </p><p>基本结构:</p><p><img src="images/12_proxy_06.png" alt="12_proxy_06.png"></p><p>代码:</p><p><code>Tank</code>类(没有接口)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tank</span>   </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 坦克移动</span></span><br><span class="line">        System.out.println(<span class="string">"Tank Moving......"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5000</span>)); <span class="comment">// 随机产生 1~5秒, 模拟坦克在移动　</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MyCglibFactory</code>类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要实现MethodInterceptor, 当前这个类的对象就是一个回调对象</span></span><br><span class="line"><span class="comment">// MyCglibFactory 是 类A，它调用了Enhancer(类B)的方法: setCallback(this)，而且将类A对象传给了类B</span></span><br><span class="line"><span class="comment">// 而类A 的 方法intercept会被类B的 setCallback调用，这就是回调设计模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCglibFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;  <span class="comment">//public interface MethodInterceptor extends Callback</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Tank target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCglibFactory</span><span class="params">(Tank target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Tank <span class="title">myCglibCreator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置需要代理的对象 :  目标类(target) , 也是父类</span></span><br><span class="line">        enhancer.setSuperclass(Tank.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置代理对象， 这是回调设计模式:  设置回调接口对象 :</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>); <span class="comment">// this代表当前类的对象，因为当前类实现了Callback</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (Tank) enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个就是回调方法（类A的方法）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 在前面做一些事情: 记录开始时间</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"start time : "</span> + start);</span><br><span class="line"></span><br><span class="line">        method.invoke(target, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在后面做一些事情: 记录结束时间,并计算move()运行时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"end time : "</span> + end);</span><br><span class="line">        System.out.println(<span class="string">"spend all time : "</span> + (end - start)/<span class="number">1000</span> + <span class="string">"s."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Tank proxyTank = <span class="keyword">new</span> MyCglibFactory(<span class="keyword">new</span> Tank()).myCglibCreator();</span><br><span class="line">        proxyTank.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出(进行了时间代理<code>TimeProxy</code>):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start time : <span class="number">1551327522964</span></span><br><span class="line">Tank Moving......</span><br><span class="line">end time : <span class="number">1551327526214</span></span><br><span class="line">spend all time : <span class="number">3</span>s.</span><br></pre></td></tr></table></figure><blockquote><p> 上面的设计模式用到了回调设计模式:<br> 在 Java 中，类 <code>A</code>调用类 <code>B</code> 中的某个方法 <code>b()</code>，然后类 <code>B</code> 又在某个时候反过来调用类 <code>A</code>中的某个方法 <code>a()</code>，对于 <code>A</code>来说，这个<code>a()</code> 方法便叫做回调方法。</p><p> Java 的接口提供了一种很好的方式来实现方法回调。这个方式就是定义一个简单的接口，在接口之中定义一个我们希望回调的方法。这个接口称为回调接口。(<code>Callback</code>)<br> 在前面的例子中，我们定义的 <code>MyCglibFactory</code> 类就相当于前面所说的 <code>A</code>类，而 <code>Enhancer</code> 类则是 <code>B</code> 类。<code>A</code> 类中调用了<code>Enhancer</code> 类的 <code>setCallback(this)</code>方法，并将回调对象 <code>this</code> 作为实参传递给了Enhancer 类。Enhancer 类在后续执行过程中，会调用<code>A</code>类中的<code>intercept()</code>方法，<strong>这个 intercept()方法就是回调方法</strong>。 </p></blockquote><h2 id="五、实际应用"><a href="#五、实际应用" class="headerlink" title="五、实际应用"></a>五、实际应用</h2><p>Spring的AOP<br><a href="https://www.cnblogs.com/flowwind/p/4782606.html" target="_blank" rel="noopener">https://www.cnblogs.com/flowwind/p/4782606.html</a></p><h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><h2 id="一、基本概念-3"><a href="#一、基本概念-3" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>桥接模式属于结构型模式。</p><p>桥接模式其实只需要记住关键的一点: <strong>解决的是不同的子类之间排列组合可以构成巨多的类的问题</strong>。</p><p>比如:</p><p><img src="/images/13_brige_01.png" alt="13_brige_01.png"></p><p>举个例子，你要画画了，画画本身是一个类，你画画要考虑画什么形状(<code>Shape</code>) (<code>A</code>)，你画画还需要考虑用什么颜色去画(<code>Color</code>)(<code>B</code>)。</p><p>形状可以有圆、长方形、正方形….，而颜色可以用红、蓝、绿…..。</p><p>那我现在要用蓝笔画长方形，这是一种新的组合，用红笔画长方形，又是一种组合，这样会产生很多的排列组合，如果我们都写一个类，那就是不好的设计了。</p><h2 id="二、案例"><a href="#二、案例" class="headerlink" title="二、案例"></a>二、案例</h2><p>就用上面那个画画的例子来引出我们的桥接模式。</p><p>我们的改造就是。不需要那个<code>A</code>类了，而是在形状类<code>B</code>类这边有这<code>C</code>类(这里改成接口， 也可以用类)的引用。</p><p>具体结构如下:</p><p><img src="/images/13_bridge_02.png" alt="13_bridge_02.png"></p><p>然后还有一个关键的点:</p><p>注意一定要在<code>Shape</code>中有<code>ColorAPI</code>的引用，而且子类也要调用父类的构造函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ColorAPI</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>颜色(<code>B</code>)这边的三个实现类:    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BluePen</span> <span class="keyword">implements</span> <span class="title">ColorAPI</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用蓝笔画 "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreenPen</span> <span class="keyword">implements</span> <span class="title">ColorAPI</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用绿笔画 "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedPen</span> <span class="keyword">implements</span> <span class="title">ColorAPI</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用红笔画 "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>形状这边的大父类(<code>A</code>):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> ColorAPI colorAPI;  <span class="comment">//这个父类必须要有 另一边的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Shape</span><span class="params">(ColorAPI colorAPI)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.colorAPI = colorAPI;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">dw</span><span class="params">()</span></span>; <span class="comment">// color</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>形状的实现类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(String name, ColorAPI colorAPI)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(colorAPI);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        colorAPI.draw(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">(String name, ColorAPI colorAPI)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(colorAPI);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        colorAPI.draw(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//桥接模式简单的说:  解决排列组合导致组合类巨多的问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Shape blueRectangle = <span class="keyword">new</span> Rectangle(<span class="string">"长方形"</span>, <span class="keyword">new</span> BluePen());</span><br><span class="line">        blueRectangle.dw();</span><br><span class="line"></span><br><span class="line">        Shape redCircle = <span class="keyword">new</span> Circle(<span class="string">"圆"</span>, <span class="keyword">new</span> RedPen());</span><br><span class="line">        redCircle.dw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用蓝笔画 长方形</span><br><span class="line">用红笔画 圆</span><br></pre></td></tr></table></figure><p>再看一下整体框架图:</p><p><img src="/images/13_bridge_03.png" alt="13_bridge_03.png"></p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>对于两个独立变化的维度，使用桥接模式再适合不过了。实现减少排列组合减少的类。<br>可以这样理解：当想要使用某一模块的完整功能时，就把这一模块的基类和接口扩展到这个类中，这个类就充当了一个桥的作用（对于要使用的方法）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.3dmgame.com/uploads/images/news/20190331/1554021622_367580.jpg&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式总结（2）【策略模式、观察者模式、装饰者模式，适配器模式】</title>
    <link href="https://www.junglezero.top/2019/07/25/signpattern2/"/>
    <id>https://www.junglezero.top/2019/07/25/signpattern2/</id>
    <published>2019-07-25T14:27:09.000Z</published>
    <updated>2019-07-27T00:05:00.779Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.3dmgame.com/uploads/images/thumbpicfirst/20190219/1550567116_731464.jpg" width="70%"></p><a id="more"></a><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>策略模式是<strong>行为型</strong>设计模式。</p><p>其用意是针对一组算法，<strong>将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换</strong>。</p><p>策略模式使得算法可以在不影响到客户端的情况下发生变化。</p><h2 id="二、结构"><a href="#二、结构" class="headerlink" title="二、结构"></a>二、结构</h2><p>下面是基本结构:</p><p><img src="/images/01_stratgy_01.png" alt></p><p>三类角色:</p><ul><li><strong>环境(Context)角色</strong>：持有一个<code>Strategy</code>的引用。</li><li><strong>抽象策略(Strategy)角色</strong>：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</li><li><strong>具体策略(ConcreteStrategy)角色</strong>：包装了相关的算法或行为。</li></ul><h2 id="三、案例"><a href="#三、案例" class="headerlink" title="三、案例"></a>三、案例</h2><p>案例实现:</p><blockquote><p>定义一族算法，可以实现对两个数的操作，例如<code>+、-、*、/</code>等。</p></blockquote><p>实现代码整体框架图:</p><p><img src="/images/01_stratgy_02.png" alt="pic"></p><p>具体代码实现:</p><p><code>Context</code>类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Context 是一个使用了某种策略的类。 实现了 Strategy 接口的实体策略类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeStrategy</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strategy.doOperation(num1, num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Strategy</code>接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**策略的公共接口*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种对应的算法实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 算法１: 实现加法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationAdd</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 算法2：实现减法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationSubstract</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 算法3: 实现乘法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationMultiply</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 * num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Context context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationAdd());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"10 + 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationSubstract());</span><br><span class="line">        System.out.println(<span class="string">"10 - 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationMultiply());</span><br><span class="line">        System.out.println(<span class="string">"10 * 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> + <span class="number">5</span> = <span class="number">15</span></span><br><span class="line"><span class="number">10</span> - <span class="number">5</span> = <span class="number">5</span></span><br><span class="line"><span class="number">10</span> * <span class="number">5</span> = <span class="number">50</span></span><br></pre></td></tr></table></figure><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><ul><li>策略模式的重心不是如何实现算法，而是如何组织、调用这些算法；</li><li>策略模式一个很大的特点就是各个策略算法的平等性。对于一系列具体的策略算法，大家的地位是完全一样的，正因为这个平等性，才能实现算法之间可以相互替换；</li><li>使用策略模式可以避免使用多重条件(if-else)语句；</li></ul><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="一、基本概念-1"><a href="#一、基本概念-1" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>观察者模式是行为型设计模式。</p><ul><li><strong>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新</strong>；</li><li>被依赖的对象为<code>Subject</code>(被观察者)，依赖的对象为<code>Observer</code>，<code>Subject</code>通知<code>Observer</code>变化；</li><li><code>Subject</code> : 登记注册<code>register/attach</code>、移除<code>remove</code>、通知<code>notify</code>；</li><li><code>Observer</code> : 接收变化<code>update</code>； </li><li>可以把观察者模式想象成订报纸一样，<strong>出版者+订阅者 = 观察者模式</strong>；</li></ul><h2 id="二、结构-1"><a href="#二、结构-1" class="headerlink" title="二、结构"></a>二、结构</h2><p>观察者模式所涉及的角色有：</p><p>　　● <strong>抽象主题(Subject)角色：</strong>抽象主题角色把所有对<strong>观察者对象</strong>的引用保存在一个聚集（比如<code>List</code>对象）里。抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色；</p><p>　　● <strong>具体主题(ConcreteSubject)角色</strong>：将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色；</p><p>　　● <strong>抽象观察者(Observer)角色</strong>：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。</p><p>　　● <strong>具体观察者(ConcreteObserver)角色</strong>：存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。如果需要，具体观察者角色可以保持一个指向具体主题对象(Concrete Subject)的引用；</p><p><img src="/images/02_observer_02.png" alt="02_observer_02.png"></p><h2 id="三、案例-1"><a href="#三、案例-1" class="headerlink" title="三、案例"></a>三、案例</h2><p>案例：</p><blockquote><p>实现的功能是气象站的管理，给你一个<code>WeatherData</code>类(<strong>被观察者</strong>)，提供了获取温度，湿度，和气压的函数，要你设计类并添加一些公告板(<strong>观察者</strong>)，可以显示相关的信息；</p></blockquote><p>基本结构图:</p><p><img src="/images/02_observer_01.png" alt="02_observer_01.png"></p><p><strong>下面使用自定义的观察者和Java内置观察者实现</strong>。</p><h3 id="1、自定义的观察者实现"><a href="#1、自定义的观察者实现" class="headerlink" title="1、自定义的观察者实现"></a>1、自定义的观察者实现</h3><p>基本代码结构组织图:</p><p><img src="/images/02_observer_03.png" alt="02_observer_03.png"></p><p>先看被观察者包<code>subjects</code>里面的两个:</p><p><code>Subject</code>接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**被观察者接口*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerObservers</span><span class="params">(Observer o)</span></span>;<span class="comment">//注册</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeObservers</span><span class="params">(Observer o)</span></span>; <span class="comment">//移除</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span>; <span class="comment">//通知</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WeatherData</code>类 (被观察者的实现):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被观察者的实现</span></span><br><span class="line"><span class="comment"> * 里面有:</span></span><br><span class="line"><span class="comment"> *   1、观察者接口的集合数据结构</span></span><br><span class="line"><span class="comment"> * 　2、实现添加观察者方法(registerObservers)</span></span><br><span class="line"><span class="comment"> *   3、移除观察者方法(removeObservers)</span></span><br><span class="line"><span class="comment"> *   4、通知所有观察者的方法(notifyObservers)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> pressure;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以提供getter()方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Observer&gt;observers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">double</span> temperature, <span class="keyword">double</span> humidity, <span class="keyword">double</span> pressure)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line"></span><br><span class="line">        dataChanged();<span class="comment">//更新完信息就马上通知观察者</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据改变之后就通知观察者(从气象站得到更新的观测值之后，通知观察者)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">()</span></span>&#123;</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObservers</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObservers</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = observers.indexOf(o);</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            observers.remove(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; observers.size(); i++)&#123;</span><br><span class="line">            Observer observer = observers.get(i);</span><br><span class="line">            observer.update(temperature, humidity, pressure);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 然后再看<code>observers</code>包的接口和实现类:</p><p><code>Observer</code>接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 观察者 接口*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">double</span> temperature, <span class="keyword">double</span> humidity, <span class="keyword">double</span> pressure)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个实现类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 观察者1 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentConditionDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> pressure;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">double</span> temperature, <span class="keyword">double</span> humidity, <span class="keyword">double</span> pressure)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"CurrentDisplay : "</span> +</span><br><span class="line">                <span class="string">"["</span> + temperature  +</span><br><span class="line">                <span class="string">", "</span> + humidity  +</span><br><span class="line">                <span class="string">", "</span> + pressure + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 观察者2  明天的天气展示 : Math.random * 当前设置值, 主要是为了展示和上一个观察者的不同*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TomorrowConditionDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> pressure;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">double</span> temperature, <span class="keyword">double</span> humidity, <span class="keyword">double</span> pressure)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ( (int)(10 * Math.random())/2 + 1)  生成 [1,5]的随机数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"TomorrowDisplay : "</span> +</span><br><span class="line">                <span class="string">"["</span> + temperature * ( (<span class="keyword">int</span>)(<span class="number">10</span> * Math.random())/<span class="number">2</span> + <span class="number">1</span>) +</span><br><span class="line">                <span class="string">", "</span> + humidity * ( (<span class="keyword">int</span>)(<span class="number">10</span> * Math.random())/<span class="number">2</span> + <span class="number">1</span>) +</span><br><span class="line">                <span class="string">", "</span> + pressure * ( (<span class="keyword">int</span>)(<span class="number">10</span> * Math.random())/<span class="number">2</span> + <span class="number">1</span>) + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WeatherData weatherData = <span class="keyword">new</span> WeatherData(); <span class="comment">// 创建一个被观察者(Subject的实现类)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建两个观察者 (Observer的实现类)</span></span><br><span class="line">        CurrentConditionDisplay current = <span class="keyword">new</span> CurrentConditionDisplay();</span><br><span class="line">        TomorrowConditionDisplay tomorrow = <span class="keyword">new</span> TomorrowConditionDisplay();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在被观察者的List中注册两个观察者</span></span><br><span class="line">        weatherData.registerObservers(current);</span><br><span class="line">        weatherData.registerObservers(tomorrow);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置完(天气更新)就会自动通知两个观察者</span></span><br><span class="line">        weatherData.setData(<span class="number">10</span>,<span class="number">100</span>,<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"----------移除Tomorrow公告板----------"</span>);</span><br><span class="line">        weatherData.removeObservers(tomorrow);</span><br><span class="line"></span><br><span class="line">        weatherData.setData(<span class="number">20</span>,<span class="number">200</span>,<span class="number">25</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CurrentDisplay : [<span class="number">10.0</span>, <span class="number">100.0</span>, <span class="number">50.0</span>]</span><br><span class="line">TomorrowDisplay : [<span class="number">10.0</span>, <span class="number">100.0</span>, <span class="number">150.0</span>]</span><br><span class="line">----------移除Tomorrow公告板----------</span><br><span class="line">CurrentDisplay : [<span class="number">20.0</span>, <span class="number">200.0</span>, <span class="number">25.0</span>]</span><br></pre></td></tr></table></figure><h3 id="2、Java内置观察者实现"><a href="#2、Java内置观察者实现" class="headerlink" title="2、Java内置观察者实现"></a>2、Java内置观察者实现</h3><p>被观察者继承自<code>Observable</code>类，观察者实现<code>Observer</code>接口:</p><ul><li><code>Observable</code>类中有<code>addObserver()</code>方法，类似于我们的<code>registerObserver()</code>；</li><li><code>Observable</code>类中有<code>deleteObserver()</code>方法，类似与我们的<code>removeObserver()</code>；</li><li>此外<code>Observable</code>类中还有两个<code>notifyObservers()</code>方法。为什么两个呢?<ul><li>Java内置的被观察者更新的方法有两种，一种是推，一种是拉；</li><li><code>public void notifyObservers(Object arg)</code>对应的是”推”；意思就是推送给观察者；</li><li><code>public void notifyObservers()</code>对应的是”拉”；意思就是需要观察者自己拉取数据；</li></ul></li><li>内置的和自己定义的在更新的时候有一个很大的不同就是: Java内置观察者在更新的时候，需要先调用一个<code>setChanged()</code>方法，标记状态已经被改变的事实。这个可以更加灵活的使用观察者模式(在调用<code>setChanged()</code>之前添加一些条件)；</li></ul><p>基本代码结构组织图:</p><p><img src="/images/02_observer_04.png" alt="02_observer_04.png"></p><p>代码如下:</p><p>首先看被观察者: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里需要继承Java的Observable类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> pressure;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTemperature</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> temperature;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getHumidity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> humidity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPressure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pressure;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">double</span> temperature, <span class="keyword">double</span> humidity, <span class="keyword">double</span> pressure)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">        dataChanged();<span class="comment">//更新完信息就马上通知观察者</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据改变之后就通知观察者(从气象站得到更新的观测值之后，通知观察者)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setChanged(); <span class="comment">//这个很重要，一定要设置这个，java底层有一个boolean值 changed = true; , 可以不那么灵活 (可以设置一些条件然后调用setChanged()方法)</span></span><br><span class="line">        notifyObservers(<span class="keyword">new</span> Data(temperature, humidity, pressure)); <span class="comment">//这个是 "推" 数据</span></span><br><span class="line"><span class="comment">//        notifyObservers();  // 靠观察者自己 "拉" 数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个类的作用就是为了 适应Observable里面的这个方法(推数据) : public void notifyObservers(Object arg)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Data</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span> temperature;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span> humidity;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span> pressure;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Data</span><span class="params">(<span class="keyword">double</span> temperature, <span class="keyword">double</span> humidity, <span class="keyword">double</span> pressure)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">            <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">            <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTemperature</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> temperature;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getHumidity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> humidity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPressure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> pressure;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是两个观察者:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentConditionDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> pressure;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里表示的是直接接受　被观察者的数据("推"　过来的数据　)　　--&gt;  也可以自己获取("拉")数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object data)</span> </span>&#123; <span class="comment">//注意这里还有被观察者的引用</span></span><br><span class="line">        <span class="keyword">this</span>.temperature = ((WeatherData.Data)data).getTemperature(); <span class="comment">//强制类型转换一下</span></span><br><span class="line">        <span class="keyword">this</span>.humidity = ((WeatherData.Data)data).getHumidity();</span><br><span class="line">        <span class="keyword">this</span>.pressure = ((WeatherData.Data)data).getPressure();</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"CurrentDisplay : "</span> +</span><br><span class="line">                <span class="string">"["</span> + temperature  +</span><br><span class="line">                <span class="string">", "</span> + humidity  +</span><br><span class="line">                <span class="string">", "</span> + pressure + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TomorrowConditionDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> pressure;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个就是</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable observable, Object data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 两种设值方式  "推" | "拉"</span></span><br><span class="line">        <span class="comment">// "推"　过来的</span></span><br><span class="line"><span class="comment">//        this.temperature = ((WeatherData.Data)data).getTemperature();</span></span><br><span class="line"><span class="comment">//        this.humidity = ((WeatherData.Data)data).getHumidity();</span></span><br><span class="line"><span class="comment">//        this.pressure = ((WeatherData.Data)data).getPressure();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自己 "拉" 过来的</span></span><br><span class="line">        <span class="keyword">this</span>.temperature = ((WeatherData)observable).getTemperature();</span><br><span class="line">        <span class="keyword">this</span>.humidity = ((WeatherData)observable).getHumidity();</span><br><span class="line">        <span class="keyword">this</span>.pressure = ((WeatherData)observable).getPressure();</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ( (int)(10 * Math.random())/2 + 1)  生成 [1,5]的随机数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"TomorrowDisplay : "</span> +</span><br><span class="line">                <span class="string">"["</span> + temperature * ( (<span class="keyword">int</span>)(<span class="number">10</span> * Math.random())/<span class="number">2</span> + <span class="number">1</span>) +</span><br><span class="line">                <span class="string">", "</span> + humidity * ( (<span class="keyword">int</span>)(<span class="number">10</span> * Math.random())/<span class="number">2</span> + <span class="number">1</span>) +</span><br><span class="line">                <span class="string">", "</span> + pressure * ( (<span class="keyword">int</span>)(<span class="number">10</span> * Math.random())/<span class="number">2</span> + <span class="number">1</span>) + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WeatherData weatherData = <span class="keyword">new</span> WeatherData();<span class="comment">// 创建被观察者</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建两个观察者</span></span><br><span class="line">        CurrentConditionDisplay current = <span class="keyword">new</span> CurrentConditionDisplay();</span><br><span class="line">        TomorrowConditionDisplay tomorrow = <span class="keyword">new</span> TomorrowConditionDisplay();</span><br><span class="line"></span><br><span class="line">        weatherData.addObserver(current);</span><br><span class="line">        weatherData.addObserver(tomorrow);</span><br><span class="line"></span><br><span class="line">        weatherData.setData(<span class="number">11</span>,<span class="number">222</span>,<span class="number">33</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"----------移除Tomorrow公告板----------"</span>);</span><br><span class="line">        weatherData.deleteObserver(tomorrow);</span><br><span class="line">        weatherData.setData(<span class="number">22</span>,<span class="number">444</span>,<span class="number">66</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TomorrowDisplay : [<span class="number">33.0</span>, <span class="number">666.0</span>, <span class="number">33.0</span>]</span><br><span class="line">CurrentDisplay : [<span class="number">11.0</span>, <span class="number">222.0</span>, <span class="number">33.0</span>]</span><br><span class="line">----------移除Tomorrow公告板----------</span><br><span class="line">CurrentDisplay : [<span class="number">22.0</span>, <span class="number">444.0</span>, <span class="number">66.0</span>]</span><br></pre></td></tr></table></figure><h2 id="四、总结-1"><a href="#四、总结-1" class="headerlink" title="四、总结"></a>四、总结</h2><p><strong>使用场景</strong></p><ul><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li><li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li><li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li><li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li></ul><h2 id="五、实际应用"><a href="#五、实际应用" class="headerlink" title="五、实际应用"></a>五、实际应用</h2><p>在spring中，通过ApplicationEvent类和ApplicationListener接口，可以实现ApplicationContext事件处理，这种机制就是利用的观察者模式<br>spring有一些内置的事件，当完成某种操作时会发出某些事件动作。比如监听ContextRefreshedEvent事件，当所有的bean都初始化完成并被成功装载后会触发该事件，实现ApplicationListener<contextrefreshedevent>接口可以收到监听动作，然后可以写自己的逻辑。<br>使用时实现 ApplicationListener接口并传入ContextRefreshedEvent参数</contextrefreshedevent></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestApplicationListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent contextRefreshedEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(contextRefreshedEvent);</span><br><span class="line">        System.out.println(<span class="string">"TestApplicationListener............................"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，jdk中的诸多listener都是用的这种设计模式<br>java.util.EventListener<br>javax.servlet.http.HttpSessionBindingListener<br>javax.servlet.http.HttpSessionAttributeListener<br>javax.faces.event.PhaseListener </p><h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><h2 id="一、基本概念-2"><a href="#一、基本概念-2" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>装饰者模式是结构型设计模式。</p><p>装饰模式以<strong>对客户端透明的方式扩展对象的功能</strong>，是继承关系的一个替代方案。</p><p>允许向一个现有的对象添加新的功能。同时又不改变其结构，它是作为现有的类的一个包装。</p><p>主要解决的问题: 一般我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，<strong>子类会很膨胀</strong>。</p><h2 id="二、结构-2"><a href="#二、结构-2" class="headerlink" title="二、结构"></a>二、结构</h2><p>结构：</p><ul><li>装饰者（Decorator）和具体组件（ConcreteComponent）都继承自组件（Component）；</li><li>所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能；</li><li>装饰者的方法有一部分是自己的，这属于它的功能(<strong>半透明的装饰者模式</strong>)。然后调用被装饰者的方法实现，从而也保留了被装饰者的功能；</li></ul><p><img src="/images/03_decorator_02.png" alt="03_decorator_02.png"></p><h2 id="三、案例-2"><a href="#三、案例-2" class="headerlink" title="三、案例"></a>三、案例</h2><h3 id="1、装饰者模式案例"><a href="#1、装饰者模式案例" class="headerlink" title="1、装饰者模式案例"></a>1、装饰者模式案例</h3><blockquote><p>模拟在餐馆点饮料，我们可以点咖啡，而咖啡有<code>Decaf</code>咖啡和<code>Espresso</code>咖啡，而这两种咖啡都可以加牛奶和巧克力进去。</p></blockquote><p>具体的代码组织结构图:</p><p><img src="/images/03_decorator_01.png" alt="03_decorator_01.png"></p><p>具体代码:</p><p>先看最高的<code>component</code>包下的<code>Drink</code>类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Component的超类</span></span><br><span class="line"><span class="comment"> * 单品和装饰者都要继承自这个类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String description = <span class="string">""</span>; <span class="comment">//一开始没有描述</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price = <span class="number">0</span>; <span class="comment">//一开始价格为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽象方法</span></span><br><span class="line"><span class="comment">     *  1、如果是单品的话就直接是自己的价格</span></span><br><span class="line"><span class="comment">     *  2、如果是装饰者的话就还要加上装饰品自己的价格</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// setter getter</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDescription</span><span class="params">(String description)</span> </span>&#123; <span class="comment">//描述的时候顺便把价格描述一下</span></span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看两个具体的<code>Component</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** ConcreteComponent 1*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decaf</span> <span class="keyword">extends</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decaf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setDescription(<span class="string">"Decaf"</span>);</span><br><span class="line">        <span class="keyword">super</span>.setPrice(<span class="number">3</span>); <span class="comment">//3块钱</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice();<span class="comment">//super.getPrice()//这个就是父类的价格(自己什么也没加 (没有被装饰))</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写getter 后面加上自己的花费</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getDescription() + <span class="string">"-"</span> + cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** ConcreteComponent 2</span></span><br><span class="line"><span class="comment"> *  也可以在ConcreteComponent和Drink类有一个过渡的类)  (比如Coffee类)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Espresso</span> <span class="keyword">extends</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Espresso</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setDescription(<span class="string">"Espresso"</span>);</span><br><span class="line">        <span class="keyword">super</span>.setPrice(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice();<span class="comment">//super.getPrice()//这个就是父类的价格(自己什么也没加)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getDescription() + <span class="string">"-"</span> + cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看<code>decorator</code>下的三个类:</p><p>第一个是装饰者的超类，继承自<code>Drink</code>类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Drink</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个引用很重要，可以是单品，也可以是被包装过的类型，所以使用的是超类的对象</span></span><br><span class="line"><span class="comment">     * 这个就是要被包装的单品(被装饰的对象)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Drink drink; <span class="comment">//这里要拿到父类的引用，因为要控制另一个分支(具体的组件)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Drink drink)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.drink = drink;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果drink是已经被装包过的，那么就会产生递归调用　　最终到单品</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getPrice() + drink.cost(); <span class="comment">// 自己的价格和被包装单品的价格</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getDescription() + <span class="string">"-"</span> + <span class="keyword">super</span>.getPrice()</span><br><span class="line">                + <span class="string">" &amp;&amp; "</span> + drink.getDescription();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是两个装饰者:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个是具体的装饰者() --&gt; 继承自中间的装饰着Decorator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chocolate</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chocolate</span><span class="params">(Drink drink)</span> </span>&#123; <span class="comment">//如果父类搞了一个　带参数的构造函数，子类必须显示的使用super调用</span></span><br><span class="line">        <span class="keyword">super</span>(drink);</span><br><span class="line">        <span class="keyword">super</span>.setDescription(<span class="string">"Chocolate"</span>);</span><br><span class="line">        <span class="keyword">super</span>.setPrice(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Milk</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Milk</span><span class="params">(Drink drink)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(drink); <span class="comment">//调用父类的构造函数</span></span><br><span class="line">        <span class="keyword">super</span>.setDescription(<span class="string">"Milk"</span>);</span><br><span class="line">        <span class="keyword">super</span>.setPrice(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//只点一个单品 (Decaf 咖啡)</span></span><br><span class="line">        Drink order = <span class="keyword">new</span> Decaf();</span><br><span class="line">        System.out.println(<span class="string">"order description : "</span> + order.getDescription());</span><br><span class="line">        System.out.println(<span class="string">"order price : "</span> + order.cost());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"---------------加了调料的----------------"</span>);</span><br><span class="line"></span><br><span class="line">        order = <span class="keyword">new</span> Milk(order);<span class="comment">// 加了牛奶</span></span><br><span class="line">        order = <span class="keyword">new</span> Chocolate(order);</span><br><span class="line">        order = <span class="keyword">new</span> Chocolate(order); <span class="comment">// 加了两个巧克力</span></span><br><span class="line">        System.out.println(<span class="string">"order description : "</span> + order.getDescription());</span><br><span class="line">        System.out.println(<span class="string">"order price : "</span> + order.cost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">order description : Decaf-<span class="number">3.0</span></span><br><span class="line">order price : <span class="number">3.0</span></span><br><span class="line">---------------加了调料的----------------</span><br><span class="line">order description : Chocolate-<span class="number">1.0</span> &amp;&amp; Chocolate-<span class="number">1.0</span> &amp;&amp; Milk-<span class="number">3.0</span> &amp;&amp; Decaf-<span class="number">3.0</span></span><br><span class="line">order price : <span class="number">8.0</span></span><br></pre></td></tr></table></figure><h3 id="2、JavaIO中使用装饰者模式"><a href="#2、JavaIO中使用装饰者模式" class="headerlink" title="2、JavaIO中使用装饰者模式"></a>2、JavaIO中使用装饰者模式</h3><p>由于Java I/O库需要很多性能的各种组合，如果这些性能都是用继承的方法实现的，那么每一种组合都需要一个类，这样就会造成大量性能重复的类出现，所以Java IO使用的是装饰者设计模式。</p><p><img src="/images/03_decorator_03.png" alt></p><p>所以我们可以定义自己的装饰者。</p><blockquote><p> 这里我们定义一个流，这个流将读入的小写字母转换成大写字母。</p></blockquote><p><code>UpperCaseInputStream</code>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自己定义的输入流　　</span></span><br><span class="line"><span class="comment"> * 扩展FilterInputStream(这个类就是我们的Decorator) 中间装饰者　　</span></span><br><span class="line"><span class="comment"> * 所以我们只要继承这个就可以扩展自己的输入流装饰者　</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UpperCaseInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">UpperCaseInputStream</span><span class="params">(InputStream in)</span> </span>&#123;  <span class="comment">//这个InputStream就是我们的Drink 类(超类)</span></span><br><span class="line">        <span class="keyword">super</span>(in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现两个read()方法，将大写转化成小写的读入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写　相当于cost和description</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="keyword">super</span>.read(); <span class="comment">//读取一个字节</span></span><br><span class="line">        <span class="keyword">return</span> index == -<span class="number">1</span> ? index : Character.toUpperCase((<span class="keyword">char</span>)(index));  <span class="comment">//小写转换成大写</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字节数组</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="keyword">super</span>.read(b, off, len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            b[i] = (<span class="keyword">byte</span>)Character.toUpperCase((<span class="keyword">char</span>)(b[i]));</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下使用这个类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InputStream in = <span class="keyword">new</span> UpperCaseInputStream(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"/home/zxzxin/Java_Maven/DesignPatterns/src/main/java/decorator/java/in.txt"</span>)));<span class="comment">// 将这个in.txt文件读入的内容转换成大写</span></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = in.read()) &gt;= <span class="number">0</span>)</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)(len));</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果演示:</p><p><img src="/images/03_decorator_04.png" alt="03_decorator_04.png"></p><h2 id="四、总结-2"><a href="#四、总结-2" class="headerlink" title="四、总结"></a>四、总结</h2><p>优缺点:</p><ul><li><strong>优点</strong> : 装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</li><li><strong>缺点</strong> : 多层装饰比较复杂。</li></ul><p>实际应用: 　<strong>大多数情况下，装饰模式的实现都要比上面给出的示意性例子要简单。</strong></p><ul><li>如果只有一个ConcreteComponent类，那么可以考虑去掉抽象的Component类（接口），把Decorator作为一个ConcreteComponent子类；</li><li>　如果只有一个ConcreteDecorator类，那么就没有必要建立一个单独的Decorator类，而可以把Decorator和ConcreteDecorator的责任合并成一个类。</li></ul><p>可以把装饰模式理解为不需要实现接口就可以扩展某些实例的功能<br>更加详细的解释具体可以看<a href="http://www.cnblogs.com/java-my-life/archive/2012/04/20/2455726.html" target="_blank" rel="noopener"><strong>这篇博客</strong></a>。</p><h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><h2 id="一、基本概念-3"><a href="#一、基本概念-3" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。</p><p>可以将适配器理解为我们日常用的电脑充电器: 家庭电压为<code>220V</code>，而电脑充电频率是<code>20V</code>左右，所以需要适配。</p><h2 id="二、结构-3"><a href="#二、结构-3" class="headerlink" title="二、结构"></a>二、结构</h2><p>适配器可以分为两种: 对象适配器和类适配器。</p><p><strong>对象适配器</strong>:</p><p><img src="/images/07_adapter_01.png" alt="07_adapter_01.png"></p><p>从用户的角度看不到<strong>被适配者</strong>。</p><p>用户调用适配器转换出来的目标接口方法。适配器再调用被适配者的相关接口方法。</p><p>用户收到反馈结果，感觉只是和目标接口交互。</p><p><strong>类适配器</strong>:</p><p><img src="/images/07_adapter_05.png" alt="07_adapter_05.png"></p><p>通过多重继承目标接口和被适配者类方式来实现适配。</p><h2 id="三、案例-3"><a href="#三、案例-3" class="headerlink" title="三、案例"></a>三、案例</h2><blockquote><p>案例: 将火鸡冒充成鸭子。</p></blockquote><h3 id="1、对象适配器模式"><a href="#1、对象适配器模式" class="headerlink" title="1、对象适配器模式"></a>1、对象适配器模式</h3><p>逻辑图:</p><p><img src="/images/07_adapter_03.png" alt="07_adapter_03.png"></p><p>代码组织结构图:</p><p><img src="/images/07_adapter_02.png" alt="07_adapter_02.png"></p><p>被适配者火鸡<code>Turkey</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Turkey</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">gobble</span><span class="params">()</span></span>; <span class="comment">// 火鸡叫声</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 野火鸡 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildTurkey</span> <span class="keyword">implements</span> <span class="title">Turkey</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gobble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Go Go!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I am Flying a short distance!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目标对象<code>Duck</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 鸭子的接口 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>;<span class="comment">//鸭子叫声</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>适配器<code>TurkeyAdapter</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在外面表现是 鸭子(目标)，但是实质是火鸡(被适配者)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TurkeyAdapter</span> <span class="keyword">implements</span> <span class="title">Duck</span> </span>&#123; <span class="comment">//实现目标的接口</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Turkey turkey; <span class="comment">//这种对象型适配器必须要组合  被适配者，也就是要有适配者的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TurkeyAdapter</span><span class="params">(Turkey turkey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.turkey = turkey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际是火鸡在叫</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        turkey.gobble();<span class="comment">//外面表现是quack,但是内部是turkey.gobble()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//由于火鸡飞的短，所以多飞几次，让火鸡更像鸭子</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">            turkey.fly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WildTurkey turkey = <span class="keyword">new</span> WildTurkey();</span><br><span class="line">        Duck duck = <span class="keyword">new</span> TurkeyAdapter(turkey);</span><br><span class="line">        duck.quack(); <span class="comment">//看似是鸭子，其实内置是火鸡</span></span><br><span class="line">        duck.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Go Go!</span><br><span class="line">I am Flying a <span class="keyword">short</span> distance!</span><br><span class="line">I am Flying a <span class="keyword">short</span> distance!</span><br><span class="line">I am Flying a <span class="keyword">short</span> distance!</span><br><span class="line">I am Flying a <span class="keyword">short</span> distance!</span><br><span class="line">I am Flying a <span class="keyword">short</span> distance!</span><br><span class="line">I am Flying a <span class="keyword">short</span> distance!</span><br></pre></td></tr></table></figure><h3 id="2、类适配器模式"><a href="#2、类适配器模式" class="headerlink" title="2、类适配器模式"></a>2、类适配器模式</h3><p>基本结构图:</p><p><img src="/images/07_adapter_04.png" alt="07_adapter_04.png"></p><p>虽然Java不支持多继承，但是可以实现的同时继承。</p><p>只有<code>TurkeyAdapter</code>有一些代码变动，其他不变:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 和 对象适配器模式唯一的不同就是  : 适配器直接继承 被适配者 (而不是组合)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TurkeyAdapter</span> <span class="keyword">extends</span> <span class="title">WildTurkey</span> <span class="keyword">implements</span>  <span class="title">Duck</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.gobble(); <span class="comment">//直接继承 被适配者</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//让火鸡飞6次，飞的像鸭子</span></span><br><span class="line">        <span class="keyword">super</span>.fly();</span><br><span class="line">        <span class="keyword">super</span>.fly();</span><br><span class="line">        <span class="keyword">super</span>.fly();</span><br><span class="line">        <span class="keyword">super</span>.fly();</span><br><span class="line">        <span class="keyword">super</span>.fly();</span><br><span class="line">        <span class="keyword">super</span>.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TurkeyAdapter duck = <span class="keyword">new</span> TurkeyAdapter();<span class="comment">//直接new即可</span></span><br><span class="line">        duck.quack();</span><br><span class="line">        duck.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出和上面对象适配器一样。</p><h3 id="3、Java中从以前枚举器Enumeration到迭代器Iterator的适配"><a href="#3、Java中从以前枚举器Enumeration到迭代器Iterator的适配" class="headerlink" title="3、Java中从以前枚举器Enumeration到迭代器Iterator的适配"></a>3、Java中从以前枚举器Enumeration到迭代器Iterator的适配</h3><p>从<code>Enumeration</code>到<code>Iterator</code>适配的结构图:</p><p><img src="/images/07_adapter_06.png" alt="07_adapter_06.png"></p><p>一个实例代码:(下面<code>EnumerationIterator</code>就是一个适配器)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 对象适配器的举例 java中的枚举到迭代器 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumerationIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Enumeration enumeration; <span class="comment">//枚举 : 被适配者</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EnumerationIterator</span><span class="params">(Enumeration enumeration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.enumeration = enumeration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> enumeration.hasMoreElements(); <span class="comment">//实际调用的是 被适配者 的方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> enumeration.nextElement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个可以说是适配器的缺点， 有些不能适配，比如两个插孔的插头不能适配为三个插孔的插头</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、总结-3"><a href="#四、总结-3" class="headerlink" title="四、总结"></a>四、总结</h2><p>对象适配器和类适配器使用了不同的方法实现适配，<strong>对象适配器使用组合，类适配器使用继承</strong>。<br>总的来说，这种模式的思想就是把不能使用在特定环境的对象或类，通过适配器类，转换为可以用在该环境下的类或对象。</p><h2 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h2><p>除了上面提到的使用外，在springmvc中，这种模式也有使用<br>Spring MVC中的Controller种类众多，不同类型的Controller通过不同的方法来对请求进行处理。如果不利用适配器模式的话，DispatcherServlet直接获取对应类型的Controller，需要的自行来判断，每增加一个controller，就会多一层判断<br>为了实现适配器模式，首先定义一个接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span></span>;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function">ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>supports()方法传入处理器（宽泛的概念Controller，以及HttpRequestHandler，Servlet，等等）判断是否与当前适配器支持如果支持则从DispatcherServlet中的HandlerAdapter实现类中返回支持的适配器实现类。handler方法就是代理Controller来执行请求的方法并返回结果。</p><p>在DispatchServlert中的doDispatch方法中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br></pre></td></tr></table></figure></p><p>此代码通过调用DispatchServlert 中getHandlerAdapter传入Controller（宽泛的概念Controller，以及HttpRequestHandler，Servlet，等等），来获取对应的HandlerAdapter 的实现子类，从而做到使得每一种Controller有一种对应的适配器实现类</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.3dmgame.com/uploads/images/thumbpicfirst/20190219/1550567116_731464.jpg&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式总结（1）【单例模式，三种工厂模式】</title>
    <link href="https://www.junglezero.top/2019/07/25/sign-pattern/"/>
    <id>https://www.junglezero.top/2019/07/25/sign-pattern/</id>
    <published>2019-07-25T14:21:02.000Z</published>
    <updated>2019-07-25T14:50:01.202Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/upload/pasted-433.png" width="70%"></p><a id="more"></a><hr><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>单例模式属于创建型设计模式。</p><p>确保一个类只有一个实例，并提供该实例的全局访问点。</p><p>实现: <strong>使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现</strong>。</p><h2 id="二、结构"><a href="#二、结构" class="headerlink" title="二、结构"></a>二、结构</h2><p>类图:</p><p><img src="/upload/14_singleton.png" alt="14_singleton.png"></p><p><strong>私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量</strong>。</p><h2 id="三、几类经典单例模式实现"><a href="#三、几类经典单例模式实现" class="headerlink" title="三、几类经典单例模式实现"></a>三、几类经典单例模式实现</h2><h3 id="1、懒汉式-线程不安全"><a href="#1、懒汉式-线程不安全" class="headerlink" title="1、懒汉式-线程不安全"></a>1、懒汉式-线程不安全</h3><p>所谓懒汉式，就是说等到用的时候再进行创建</p><p>这种实现方法线程不安全，如果多个线程能够同时进入 <code>if (uniqueInstance == null)</code> ，并且此时 <code>uniqueInstance == null</code>，那么会有多个线程执行 <code>uniqueInstance = new Singleton();</code> 语句，这将导致实例化多次 <code>uniqueInstance</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式: 线程不安全</span></span><br><span class="line"><span class="comment">// 有延迟加载: 不是在类加载的时候就创建了，而是在调用newStance()的时候才会创建</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有静态实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、懒汉式-线程安全-性能不好"><a href="#2、懒汉式-线程安全-性能不好" class="headerlink" title="2、懒汉式-线程安全-性能不好"></a>2、懒汉式-线程安全-性能不好</h3><p>解决上面线程不安全的最直接方法就是上锁</p><p>但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待，即使 <code>uniqueInstance</code> 已经被实例化了。这会让线程阻塞时间过长，因此该方法有性能问题<br><strong>不推荐使用</strong>。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">newInstance</span><span class="params">()</span></span>&#123;<span class="comment">//在上面的基础上加了synchronized</span></span><br><span class="line">    <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)</span><br><span class="line">        uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、饿汉式-线程安全-无延迟加载"><a href="#3、饿汉式-线程安全-无延迟加载" class="headerlink" title="3、饿汉式-线程安全-无延迟加载"></a>3、饿汉式-线程安全-无延迟加载</h3><p>饿汉式：类一初始化就进行实例的创建（等不及了）</p><p>这种方式比较常用，但容易产生垃圾对象(丢失了延迟实例化(<code>lazy loading</code>)带来的节约资源的好处)。</p><p>它基于 <strong>classloader机制</strong>避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， <strong>但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazyloading 的效果</strong>。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、双重校验锁-线程安全"><a href="#4、双重校验锁-线程安全" class="headerlink" title="4、双重校验锁-线程安全"></a>4、双重校验锁-线程安全</h3><p><code>uniqueInstance</code> 只需要被实例化一次，之后就可以直接使用了。这种线程安全的优化方式就是缩小加锁的范围，只有当<code>uniqueInstance</code> 没有被实例化时，才需要进行加锁。</p><p>双重校锁：<br><strong>第一次校验：</strong>由于单例模式只需要创建一次实例，如果后面再次调用getInstance方法时，则直接返回之前创建的实例，因此大部分时间不需要执行同步方法里面的代码，大大提高了性能。如果不加第一次校验的话，那跟上面的懒汉模式没什么区别，每次都要去竞争锁。<br><strong>第二次校验：</strong>如果没有第二次校验，假设线程t1执行了第一次校验后，判断为null，这时t2也获取了CPU执行权，也执行了第一次校验，判断也为null。接下来t2获得锁，创建实例。这时t1又获得CPU执行权，由于之前已经进行了第一次校验，结果为null（不会再次判断），获得锁后，直接创建实例。结果就会导致创建多个实例。所以需要在同步代码里面进行第二次校验，如果实例为空，则进行创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双重加锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不需要先实例化</span></span><br><span class="line">    <span class="comment">// 使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一次校验</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// //第二次校验</span></span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p><ul><li>1)、为 <code>uniqueInstance</code> 分配内存空间；</li><li>2)、初始化 <code>uniqueInstance</code>；</li><li>3)、将 <code>uniqueInstance</code> 指向分配的内存地址；</li></ul><p>但是由于 JVM 具有<strong>指令重排</strong>的特性，执行顺序有可能变成 <code>1&gt;3&gt;2</code>。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 <code>T1</code> 执行了 1 和 3，此时 <code>T2</code>调用 <code>newInstance()</code> 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code>，但此时 <code>uniqueInstance</code> 还未被初始化。</p><p><strong>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行</strong>。</p><h3 id="5、静态内部类实现"><a href="#5、静态内部类实现" class="headerlink" title="5、静态内部类实现"></a>5、静态内部类实现</h3><p>当 <code>Singleton</code> 类加载时，<strong>静态内部类 Holder 没有被加载进内存</strong>。只有当调用 <code>newInstance()</code> 方法从而触发 <code>Holder.uniqueInstance</code> 时 <code>Holder</code>才会被加载，此时初始化<code>uniqueInstance</code> 实例，并且 JVM 能确保 <code>uniqueInstance</code> 只被实例化一次。</p><p>这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。</p><blockquote><p>这种方式是 Singleton 类被装载了，<code>uniqueInstance</code> 不一定被初始化。因为 <code>Holder</code>s 类没有被主动使用，只有通过显式调用 <code>newInstance()</code>方法时，才会显式装载 Holder 类，从而实例化<code>uniqueInstance</code>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、枚举实现"><a href="#6、枚举实现" class="headerlink" title="6、枚举实现"></a>6、枚举实现</h3><p>这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。</p><p>该实现在多次序列化再进行反序列化之后，不会得到多个实例。而其它实现需要使用 <code>transient</code> 修饰所有字段，并且实现序列化和反序列化的方法。</p><p>枚举实现单例 (+测试):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Sing.INSTANCE.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> Sing &#123;</span><br><span class="line"></span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//jvm guarantee only run once</span></span><br><span class="line">        Sing() &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Singleton <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line"></span><br><span class="line">        Set&lt;Singleton&gt;set = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;&gt;());<span class="comment">//注意set也要加锁</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line"></span><br><span class="line">                    set.add(Singleton.newInstance());</span><br><span class="line"></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">        System.out.println(set.size());<span class="comment">//1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于序列化和反序列化:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 单例测试</span></span><br><span class="line">        Singleton s1 = Singleton.INSTANCE;</span><br><span class="line">        s1.setName(<span class="string">"firstName"</span>);</span><br><span class="line">        System.out.println(<span class="string">"s1.getName(): "</span> + s1.getName());</span><br><span class="line"></span><br><span class="line">        Singleton s2 = Singleton.INSTANCE;</span><br><span class="line">        s2.setName(<span class="string">"secondName"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意我这里输出s1 ，但是已经变成了 secondName</span></span><br><span class="line">        System.out.println(<span class="string">"s1.getName(): "</span> + s1.getName());</span><br><span class="line">        System.out.println(<span class="string">"s2.getName(): "</span> + s2.getName());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反射获取实例测试</span></span><br><span class="line">        Singleton[] enumConstants = Singleton.class.getEnumConstants();</span><br><span class="line">        <span class="keyword">for</span> (Singleton enumConstant : enumConstants)</span><br><span class="line">            System.out.println(enumConstant.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1.getName(): firstName</span><br><span class="line">s1.getName(): secondName</span><br><span class="line">s2.getName(): secondName</span><br><span class="line">-----------------</span><br><span class="line">secondName</span><br></pre></td></tr></table></figure><blockquote><p>该实现可以防止反射攻击。在其它实现中，通过 <code>setAccessible()</code>(反射中的强制访问私有属性方法) 方法可以将私有构造函数的访问级别设置为 public，然后调用构造函数从而实例化对象，如果要防止这种攻击，需要在构造函数中添加防止多次实例化的代码。该实现是由 JVM 保证只会实例化一次，因此不会出现上述的反射攻击。</p></blockquote><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>一般情况下，<strong>不建议使用懒汉方式</strong>，建议使用饿汉方式。</p><p>只有在要明确实现 <code>lazy loading</code> 效果时，才会使用<strong>静态内部类方式</strong>。</p><p>如果涉及到<strong>反序列化创建对象</strong>时，可以尝试使用枚举方式。</p><p>如果有其他特殊的需求，可以考虑使用双检锁方式。</p><h2 id="五、应用实例"><a href="#五、应用实例" class="headerlink" title="五、应用实例"></a>五、应用实例</h2><p>Spring下默认的bean均为singleton，可以通过singleton=“true|false” 或者 scope=“？”来指定<br>这样做可以减少cpu内存的浪费。可能有人觉得多用户走多线程只运行一个实例肯定会引发线程安全问题，但在这里应当理解线程安全问题的本质：全局变量，公共变量被多个线程同时操作。虽然spring对象是单例的，但类里面方法对每个线程来说都是独立运行的，不存在多线程问题，只有成员变量有多线程问题，所以方法里面如果有用到成员变量就要考虑用安全的数据结构。对于有着特殊状态值（一定意义上的全局变量）的单例对象，spring使用ThreadLocal维护线程安全，不过这是另一个问题了。<br><a href="https://blog.csdn.net/zengdeqing2012/article/details/77098994" target="_blank" rel="noopener">https://blog.csdn.net/zengdeqing2012/article/details/77098994</a><br>在java JDK中</p><p>java.lang.Runtime#getRuntime()<br>java.awt.Desktop#getDesktop()<br>java.lang.System#getSecurityManager()<br>使用的都是单例模式，为什么？因为只要一个就够了。</p><h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><h2 id="一、基本概念-1"><a href="#一、基本概念-1" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p><strong>简单工厂模式是类的创建模式，又叫做静态工厂方法（Static Factory Method）模式。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例</strong>。</p><p>在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。<br>这个模式严格来讲是下面工厂方法模式的一个特例</p><h2 id="二、结构-1"><a href="#二、结构-1" class="headerlink" title="二、结构"></a>二、结构</h2><p>简单工厂把实例化的操作单独放到一个类中，这个类就是简单工厂类(Simple Factory)，<strong>让简单工厂类来决定应该用哪个具体子类来实例化 (而不是在客户端中决定)</strong>。</p><p>这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。</p><p>客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。</p><p>结构:</p><p><img src="/upload/04_simple_01.png" alt="04_simple_01.png"></p><h2 id="三、案例"><a href="#三、案例" class="headerlink" title="三、案例"></a>三、案例</h2><blockquote><p>模拟在<code>type == 1</code>的时候创建<code>ConcreteProduct1</code>、在<code>type == 2</code>的时候创建<code>ConcreteProduct2</code>、其他时候创建<code>ConcreteProduct</code>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们按照下面的方式创建，则我们在客户端包含了这些需要判断条件的实例化代码，则可以将这些实例化代码放到简单工厂中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不好的设计</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> type = <span class="number">1</span>;</span><br><span class="line">        Product product;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">            product = <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">            product = <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            product = <span class="keyword">new</span> ConcreteProduct();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// do something with the product</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是我们可以增加一个简单工厂类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以将createProduct写成静态的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们的测试类可以写成下面的样子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleFactory simpleFactory = <span class="keyword">new</span> SimpleFactory();</span><br><span class="line">        Product product = simpleFactory.createProduct(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// do something with product</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样既让客户端和具体类解耦，而且在客户端也看不到具体的繁杂的实例化代码。</p><h2 id="四、总结-1"><a href="#四、总结-1" class="headerlink" title="四、总结"></a>四、总结</h2><p>缺点 : 这个工厂类集中了所有的创建逻辑，当有复杂的多层次等级结构时，所有的业务逻辑都在这个工厂类中实现。什么时候它不能工作了，整个系统都会受到影响。</p><p>我们强调<strong>职责单一</strong>原则，一个类只提供一种功能。</p><h2 id="五、应用实例-1"><a href="#五、应用实例-1" class="headerlink" title="五、应用实例"></a>五、应用实例</h2><p>spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。如下配置，就是在 HelloItxxz 类中创建一个 itxxzBean。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"singletonBean"</span> <span class="attr">class</span>=<span class="string">"com.itxxz.HelloItxxz"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>Hello! 这是singletonBean!value&gt;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/ <span class="attr">bean</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"itxxzBean"</span> <span class="attr">class</span>=<span class="string">"com.itxxz.HelloItxxz"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">singleton</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>Hello! 这是itxxzBean! value&gt;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在juc中，类Executors就是一个典型的简单工厂方法类，在这类下，提供了创建多种ExecutorService的静态方法，在使用时直接调用这个类的静态方法创建不同的ExecutorService即可，而不需要再在客户端创建不同的实例</p><h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><h2 id="一、基本概念-2"><a href="#一、基本概念-2" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p><strong>工厂方法模式是类的创建模式，又叫做虚拟构造子(Virtual Constructor)模式或者多态性工厂（Polymorphic Factory）模式</strong>。<br>工厂方法模式的用意是<strong>定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中</strong>。</p><p>或者说引入工厂模式的目的就是我们需要多个工厂，但是每个工厂内部又要划分情况，如果只用一个工厂的话，会产生多种复合的情况。</p><p>比如说我们有两个工厂，每个工厂有3种情况，如果用简单工厂模式，要分为 <code>3 * 2 = 6</code>种情况，所以可以用工厂方法模式解决。</p><h2 id="二、结构-2"><a href="#二、结构-2" class="headerlink" title="二、结构"></a>二、结构</h2><p>在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由大工厂的子类(或者实现类)来创建对象。</p><p>即上面有一个大工厂，下面是分类的工厂。</p><p><img src="/upload/05_method_03.png" alt="05_method_03.png"></p><h2 id="三、案例-1"><a href="#三、案例-1" class="headerlink" title="三、案例"></a>三、案例</h2><blockquote><p>案例，模拟需要生成中国食物A，中国食物B，美国食物A，美国食物B。</p></blockquote><p>代码逻辑结构图:</p><p><img src="/upload/05_method_01.png" alt="05_method_01.png"></p><p>基本结构图:</p><p><img src="/upload/04_method_02.png" alt="04_method_02.png"></p><p>先给出这些食物(<code>Product</code>):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmericanFoodA</span> <span class="keyword">implements</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmericanFoodB</span> <span class="keyword">implements</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChineseFoodA</span> <span class="keyword">implements</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChineseFoodB</span> <span class="keyword">implements</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是抽象工厂:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FoodFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Food <span class="title">makeFood</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是两个子工厂:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChineseFoodFactory</span> <span class="keyword">implements</span> <span class="title">FoodFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">makeFood</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">"A"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ChineseFoodA();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">"B"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ChineseFoodB();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmericanFoodFactory</span> <span class="keyword">implements</span> <span class="title">FoodFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">makeFood</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">"A"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AmericanFoodA();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">"B"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AmericanFoodB();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先选择一个具体的工厂</span></span><br><span class="line">        FoodFactory factory = <span class="keyword">new</span> ChineseFoodFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由第一步的工厂产生具体的对象，不同的工厂造出不一样的对象</span></span><br><span class="line">        Food food = factory.makeFood(<span class="string">"A"</span>); <span class="comment">//  chineseFood * A</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、总结-2"><a href="#四、总结-2" class="headerlink" title="四、总结"></a>四、总结</h2><p>工厂方法模式和简单工厂模式在结构上的不同很明显。</p><p><strong>工厂方法模式的核心是一个抽象工厂类，而简单工厂模式把核心放在一个具体类上</strong>。</p><p>工厂方法模式退化后可以变得很像简单工厂模式。设想如果非常确定一个系统只需要一个具体工厂类，那么不妨把抽象工厂类合并到具体工厂类中去。由于只有一个具体工厂类，所以不妨将工厂方法改为静态方法，这时候就得到了简单工厂模式。</p><h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><h2 id="一、基本概念-3"><a href="#一、基本概念-3" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>当涉及到<strong>产品族</strong>的时候，就需要引入抽象工厂模式了。</p><p>每一个模式都是针对一定问题的解决方案。抽象工厂模式与工厂方法模式的最大区别就在于，<strong>工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则需要面对多个产品等级结构</strong>。</p><p>在学习抽象工厂具体实例之前，应该明白两个重要的概念：产品族和产品等级。</p><p>所谓产品族，是指位于不同产品等级结构中，功能相关联的产品组成的家族。比如AMD的主板、芯片组、CPU组成一个家族，Intel的主板、芯片组、CPU组成一个家族。而这两个家族都来自于三个产品等级：主板、芯片组、CPU。一个等级结构是由相同的结构的产品组成，示意图如下：</p><p><img src="/upload/06_abstract_06.png" alt="06_abstract_06.png"></p><h2 id="二、案例"><a href="#二、案例" class="headerlink" title="二、案例"></a>二、案例</h2><p>一个经典的例子是造一台电脑。我们先不引入抽象工厂模式，看看怎么实现。</p><p>因为电脑是由许多的构件组成的，我们将 CPU 和主板进行抽象，然后 CPU 由 CPUFactory 生产，主板由 MainBoardFactory 生产，然后，我们再将 CPU 和主板搭配起来组合在一起，如下:</p><p><img src="/upload/06_abstract_01.png" alt="06_abstract_01.png"></p><p>代码组织结构:</p><p><img src="/upload/06_abstract_02.png" alt="06_abstract_02.png"></p><p>这个时候的客户端调用是这样的（测试类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 得到 Intel 的 CPU</span></span><br><span class="line">        CPUFactory intelCPUFactory = <span class="keyword">new</span> IntelCPUFactory();</span><br><span class="line">        CPU cpu = intelCPUFactory.makeCPU();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到 AMD 的主板</span></span><br><span class="line">        MainBoardFactory mainBoardFactory = <span class="keyword">new</span> AmdMainBoardFactory();</span><br><span class="line">        MainBoard mainBoard = mainBoardFactory.makeMB();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 组装 CPU 和主板</span></span><br><span class="line">        Computer computer = <span class="keyword">new</span> Computer(cpu, mainBoard);</span><br><span class="line">        System.out.println(computer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体的完整代码可以看<a href="https://github.com/ZXZxin/ZXNotes/tree/master/%E6%9D%82%E9%A1%B9/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/factory" target="_blank" rel="noopener">这里</a></strong></p><p>单独看 CPU 工厂和主板工厂，它们分别是前面我们说的<strong>工厂模式</strong>。</p><p>这种方式也容易扩展，因为要给电脑加硬盘的话，只需要加一个 HardDiskFactory 和相应的实现即可，不需要修改现有的工厂。</p><p>但是，这种方式有一个问题，那就是如果 <strong>Intel 家产的 CPU 和 AMD 产的主板不能兼容使用</strong>，那么这代码就容易出错，因为客户端并不知道它们不兼容，也就会错误地出现随意组合。</p><p>下面就是我们要说的<strong>产品族</strong>的概念，它代表了组成某个产品的一系列附件的集合：</p><p><img src="/upload/06_abstract_03.png" alt="06_abstract_03.png"></p><p>当涉及到这种产品族的问题的时候，就需要抽象工厂模式来支持了。我们不再定义 CPU 工厂、主板工厂、硬盘工厂、显示屏工厂等等，<strong>我们直接定义电脑工厂，每个电脑工厂负责生产所有的设备，这样能保证肯定不存在兼容问题</strong>。</p><p><img src="/upload/06_abstract_04.png" alt="06_abstract_04.png"></p><p>这个时候，对于客户端来说，不再需要单独挑选 CPU厂商、主板厂商、硬盘厂商等，直接选择一家品牌工厂，品牌工厂会负责生产所有的东西，而且能保证肯定是兼容可用的。</p><p>改装的抽象工厂模式代码组织结构如下:</p><p><img src="/upload/06_abstract_05.png" alt="06_abstract_05.png"></p><p>主要的代码:</p><p>三个工厂:(一个超类工厂<code>PCFactory</code>，两个大厂工厂<code>AmdFactory</code>、<code>InterFactory</code>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PCFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">CPU <span class="title">makeCPU</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">MainBoard <span class="title">makeMB</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// HardDisk makeHD();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmdFactory</span> <span class="keyword">implements</span> <span class="title">PCFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CPU <span class="title">makeCPU</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AmdCPU();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MainBoard <span class="title">makeMB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AmdMainBoard();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntelFactory</span> <span class="keyword">implements</span> <span class="title">PCFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CPU <span class="title">makeCPU</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IntelCPU();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MainBoard <span class="title">makeMB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IntelMainBoard();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的测试类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 第一步就要选定一个“大厂”</span></span><br><span class="line">        PCFactory cf = <span class="keyword">new</span> AmdFactory();</span><br><span class="line">        <span class="comment">// 从这个大厂造 CPU</span></span><br><span class="line">        CPU cpu = cf.makeCPU();</span><br><span class="line">        <span class="comment">// 从这个大厂造主板</span></span><br><span class="line">        MainBoard board = cf.makeMB();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//... 从这个大厂造硬盘。等等</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将同一个厂子出来的 CPU、主板、硬盘组装在一起</span></span><br><span class="line">        Computer computer = <span class="keyword">new</span> Computer(cpu, board);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>当然，抽象工厂的问题也是显而易见的，比如我们要加个显示器，就需要修改所有的工厂，给所有的工厂都加上制造显示器的方法。这有点违反了<strong>对修改关闭，对扩展开放</strong>这个设计原则。</p><h1 id="三种工厂方法对比"><a href="#三种工厂方法对比" class="headerlink" title="三种工厂方法对比"></a>三种工厂方法对比</h1><p><img src="/upload/pasted-470.png" alt="06_abstract_03.png"><br><img src="/upload/pasted-472.png" alt="06_abstract_03.png"><br><img src="/upload/pasted-473.png" alt="06_abstract_03.png"><br><img src="/upload/pasted-474.png" alt="06_abstract_03.png"><br><img src="/upload/pasted-475.png" alt="06_abstract_03.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/upload/pasted-433.png&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL深入学习（3）【ID策略，横向扩展】</title>
    <link href="https://www.junglezero.top/2019/07/23/SQLDeepLearn3/"/>
    <id>https://www.junglezero.top/2019/07/23/SQLDeepLearn3/</id>
    <published>2019-07-23T00:58:56.000Z</published>
    <updated>2019-07-23T07:47:07.490Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img2.ali213.net/picfile/News/2015/05/14/2015051494057329.jpg" width="70%"><br><a id="more"></a></p><h1 id="ID策略"><a href="#ID策略" class="headerlink" title="ID策略"></a>ID策略</h1><ol><li><p>利用数据库自增ID<br>优点：最简单。 缺点：单点风险、单机性能瓶颈。</p></li><li><p>利用数据库集群并设置相应的步长（Flickr方案）<br>优点：高可用、ID较简洁。 缺点：需要单独的数据库集群。</p></li><li><p>Twitter Snowflake<br>优点：高性能高可用、易拓展。 缺点：需要独立的集群以及ZK。</p></li><li><p>一大波GUID、Random算法<br>优点：简单。 缺点：生成ID较长，有重复几率。</p></li></ol><h1 id="横向扩展MySQL服务器"><a href="#横向扩展MySQL服务器" class="headerlink" title="横向扩展MySQL服务器"></a>横向扩展MySQL服务器</h1><p>由多台MySQL服务器，提供数据存储服务器。<br>横向扩展是根本提升数据库服务器性能的手段！受限于单台计算机的硬件处理能力，去使用多台计算机完成同一个服务的支持。<br>比较典型的概念：<br>读写分离，负载均衡。<br>需要用到的技术，MySQL复制技术，负载均衡中间件。</p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。</p><ul><li>binlog 线程 ：负责将主服务器上的数据更改写入二进制文件（binlog）中。</li><li>I/O 线程 ：负责从主服务器上读取二进制日志文件，并写入从服务器的中继日志中。</li><li>SQL 线程 ：负责读取中继日志并重放其中的 SQL 语句。</li></ul><p><img src="/upload/pasted-453.png" alt="upload successful"></p><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>主服务器用来处理写操作以及实时性要求比较高的读操作，而从服务器用来处理读操作。<br>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个<br>服务器。<br>MySQL 读写分离能提高性能的原因在于：<br>主从服务器负责各自的读和写，极大程度缓解了锁的争用；<br>从服务器可以配置 MyISAM 引擎，提升查询性能以及节约系统开销；<br>增加冗余，提高可用性。</p><p><img src="/upload/pasted-452.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img2.ali213.net/picfile/News/2015/05/14/2015051494057329.jpg&quot; width=&quot;70%&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL深入研究（2）【查询优化，分区，分表】</title>
    <link href="https://www.junglezero.top/2019/07/21/QLDeepLearn/"/>
    <id>https://www.junglezero.top/2019/07/21/QLDeepLearn/</id>
    <published>2019-07-21T09:24:00.000Z</published>
    <updated>2019-07-23T07:10:10.234Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://images.ali213.net/picfile/pic/2017/10/27/927_2017102712122202.jpg" width="70%"><br><a id="more"></a></p><h1 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h1><h2 id="减少请求的数据量"><a href="#减少请求的数据量" class="headerlink" title="减少请求的数据量"></a>减少请求的数据量</h2><p>（一）只返回必要的列<br>最好不要使用 SELECT * 语句。<br>（二）只返回必要的行<br>使用 WHERE 语句进行查询过滤，有时候也需要使用 LIMIT 语句来限制返回的数据。<br>（三）缓存重复查询的数据<br>使用缓存可以避免在数据库中进行查询，特别要查询的数据经常被重复查询，缓存可以带来的查询性能提升将会是非常明显的。<br>若想要应用缓存，首先在my.ini或者my.cnf中配置query_cache_type，1表示默认缓存，需要sql_no_cache提示为不缓存，2表示默认不缓存，需要sql_cache主动缓存，0表示不缓存 。query_cache_size配置缓存大小<br>对于配置为2选项，若要进行缓存<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">SQL_CACHE</span> *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student</span><br></pre></td></tr></table></figure></p><p>调用reset query cache 可以清空缓存<br>当数据表改动时，基于整个表的缓存就会被删除<br>动态数据无法缓存</p><h2 id="重构查询方式"><a href="#重构查询方式" class="headerlink" title="重构查询方式"></a>重构查询方式</h2><h3 id="切分大查询"><a href="#切分大查询" class="headerlink" title="切分大查询"></a>切分大查询</h3><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。因此，可以把一个大范围操作切分为一个小范围操作<br>一个全范围的删除操作，可以切分为多个小段删除操作<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">messages</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">CREATE</span> &lt; <span class="keyword">DATE_SUB</span>(<span class="keyword">NOW</span>(), <span class="built_in">INTERVAL</span> <span class="number">3</span> <span class="keyword">MONTH</span>);</span><br></pre></td></tr></table></figure></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rows_affected = 0</span><br><span class="line"><span class="keyword">DO</span></span><br><span class="line">&#123; rows_affected = do_query (</span><br><span class="line"><span class="string">"DELETE FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 M</span></span><br><span class="line"><span class="string">ONTH) LIMIT 10000"</span></span><br><span class="line">) &#125;</span><br><span class="line"><span class="keyword">WHILE</span> rows_affected &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="分解大的连接查询"><a href="#分解大的连接查询" class="headerlink" title="分解大的连接查询"></a>分解大的连接查询</h3><ol start="2"><li>分解大连接查询<br>将一个大连接查询（JOIN）分解成对每一个表进行一次单表查询，然后将结果在应用程序中<br>进行关联，这样做的好处有：</li></ol><ul><li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li><li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li><li>减少锁竞争；</li><li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可扩展。</li><li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">tab</span><br><span class="line"><span class="keyword">JOIN</span> tag_post <span class="keyword">ON</span> tag_post.tag_id = tag.id</span><br><span class="line"><span class="keyword">JOIN</span> post <span class="keyword">ON</span> tag_post.post_id = post.id</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">tag.tag = <span class="string">'mysql'</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag <span class="keyword">WHERE</span> tag=<span class="string">'mysql'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag_post <span class="keyword">WHERE</span> tag_id=<span class="number">1234</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> post <span class="keyword">WHERE</span> post.id <span class="keyword">IN</span> (<span class="number">123</span>,<span class="number">456</span>,<span class="number">567</span>,<span class="number">9098</span>,<span class="number">8904</span>);</span><br></pre></td></tr></table></figure><h1 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>将一个表中的数据和索引，分散到不同的文件中进行存储，称之为分区操作，划分出来到文件就是不同的分区<br>分区的意义是将一个具有大量数据的表，将其分散到不同的数据和索引文件中进行储存<br>对于Innodb来说，相当于一个表对应对个ibd文件<br>分散之后，每个文件对应的数据量显著减少，保证单个文件的执行速度<br>一般情况就是根据id主键字段进行分区，或者为主键，唯一键的一个子集，在创建表时，利用partition进行设定<br>例如下面，就是利用id字段，使用hash算法，将数据分布在10个分区中<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t2 (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> auto_increment promary <span class="keyword">key</span>,</span><br><span class="line">col2 <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">col3 <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">col4 <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (col1),</span><br><span class="line"><span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> (col3)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">HASH</span>(<span class="keyword">id</span>)</span><br><span class="line"><span class="keyword">PARTITIONS</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure></p><p>分区完成后，客户端看上去还是一张表。</p><h2 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h2><p>range分区：基于一个给定的连续区间范围(区间要求连续并且不能重叠)，把数据分配到不同的分区<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t2 (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> auto_increment promary <span class="keyword">key</span>,</span><br><span class="line">col2 <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">col3 <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">pubtime <span class="built_in">INT</span> ,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>,pubtime),</span><br><span class="line"><span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> (col3)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>(pubtime)(</span><br><span class="line"><span class="keyword">PARTITION</span> p201907 <span class="keyword">VALUES</span> <span class="keyword">less</span> <span class="keyword">than</span> (<span class="number">1509665599</span>) <span class="comment">-- 某个时间的时间戳</span></span><br><span class="line"><span class="keyword">PARTITION</span> p201907 <span class="keyword">VALUES</span> <span class="keyword">less</span> <span class="keyword">than</span> (<span class="number">1512355599</span>) <span class="comment">-- 某个时间的时间戳</span></span><br><span class="line"><span class="keyword">PARTITION</span> p201907 <span class="keyword">VALUES</span> <span class="keyword">less</span> <span class="keyword">than</span> (<span class="number">1540765599</span>) <span class="comment">-- 某个时间的时间戳</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>条件只能用小于，更小的时间戳要放在前面<br>list分区：类似于range分区，区别在于list分区是居于枚举出的值列表分区，range是基于给定的连续区间范围分区，使用 in(值列表)<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t2 (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> auto_increment promary <span class="keyword">key</span>,</span><br><span class="line">col2 <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">col3 <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">status</span> <span class="built_in">INT</span> ,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>,pubtime),</span><br><span class="line"><span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> (col3)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>(<span class="keyword">status</span>)(</span><br><span class="line"><span class="keyword">PARTITION</span> p1 <span class="keyword">VALUES</span> <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>),</span><br><span class="line"><span class="keyword">PARTITION</span> p2 <span class="keyword">VALUES</span> <span class="keyword">in</span> (<span class="number">3</span>,<span class="number">4</span>),</span><br><span class="line"><span class="keyword">PARTITION</span> p3 <span class="keyword">VALUES</span> <span class="keyword">in</span> (<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>hash分区：基于给定的分区个数，把数据分配到不同的分区，采取的是求余方案，所谓hash算法，就是对于输入，得到某个特定的输出，要求如果输入相同的值应当得到相同的输出。这种算法在业务逻辑上表现为均匀分配<br>key分区：类似于hash分区，在hash中，只能对整数进行分区，但是key可以使用非整数类型进行分区（如字符串）</p><h2 id="分区管理"><a href="#分区管理" class="headerlink" title="分区管理"></a>分区管理</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除list或者range分区(同时删除分区对应的数据)</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> &lt;<span class="keyword">table</span>&gt; <span class="keyword">drop</span> <span class="keyword">partition</span> &lt;分区名称&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 新增分区</span></span><br><span class="line"><span class="comment">-- range添加新分区</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> &lt;<span class="keyword">table</span>&gt; <span class="keyword">add</span> <span class="keyword">partition</span>(<span class="keyword">partition</span> p4 <span class="keyword">values</span> <span class="keyword">less</span> <span class="keyword">than</span> MAXVALUE);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- list添加新分区</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> &lt;<span class="keyword">table</span>&gt; <span class="keyword">add</span> <span class="keyword">partition</span>(<span class="keyword">partition</span> p4 <span class="keyword">values</span> <span class="keyword">in</span> (<span class="number">25</span>,<span class="number">26</span>,<span class="number">28</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- hash重新分区</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> &lt;<span class="keyword">table</span>&gt; <span class="keyword">add</span> <span class="keyword">partition</span> <span class="keyword">partitions</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- key重新分区</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> &lt;<span class="keyword">table</span>&gt; <span class="keyword">add</span> <span class="keyword">partition</span> <span class="keyword">partitions</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 子分区添加新分区，虽然我没有指定子分区，但是系统会给子分区命名的</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> &lt;<span class="keyword">table</span>&gt; <span class="keyword">add</span> <span class="keyword">partition</span>(<span class="keyword">partition</span> p3 <span class="keyword">values</span> <span class="keyword">less</span> <span class="keyword">than</span> MAXVALUE);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- range重新分区</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> REORGANIZE <span class="keyword">PARTITION</span> p0,p1,p2,p3,p4 <span class="keyword">INTO</span> (<span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> MAXVALUE);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- list重新分区</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;<span class="keyword">table</span>&gt; REORGANIZE <span class="keyword">PARTITION</span> p0,p1,p2,p3,p4 <span class="keyword">INTO</span> (<span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在客户端程序不变的情况下，将服务器端的数据分布到不同的物理文件中，进而提供数据表的处理能力<br>当数据量比较大时，分区可以提升效率<br>且只有检索字段为分区字段时，分区效率才会明显提高</p><h1 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h1><p>如果一个表的每条记录的内容很大，那么就需要更多的IO操作，如果字段值比较大，而使用频率相对比较低，可以将大字段移到另一张表中，当查询不查大字段的时候，这样就减少了I/O操作<br>如果一个表的数据量很少，那么查询就很快；如果表的数据量非常非常大，那么查询就变的比较慢；也就是表的数据量影响这查询的性能。<br>表中的数据本来就有独立性，例如分别记录各个地区的数据或者不同时期的数据，特别是有些数据常用，而另外一些数据不常用。</p><p>通过应用程序，把数据划分到不同的表中存储，分表的操作会在客户端出现多张表<br>水平切分：<br><img src="/upload/pasted-450.png" alt="upload successful"><br>水平切分类似于分区，但是它是实实在在的把一个大表分成两个小表，可以根据某个查询值分块来把表水平切分</p><p>垂直切分：<br><img src="/upload/pasted-451.png" alt="upload successful"><br>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。 垂直分割一般用于拆分大字段和访问频率低的字段，分离冷热数据。</p><p>垂直分割适用于记录不是非常多的，但是字段却很多，这样占用空间比较大，检索时需要执行大量的I/O，严重降低了性能，这个时候需要把大的自读那拆分到另一个表中，并且该表与源表时一对一关系。<br>垂直拆分的优点： 可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。<br>垂直拆分的缺点： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://images.ali213.net/picfile/pic/2017/10/27/927_2017102712122202.jpg&quot; width=&quot;70%&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL深入研究（1）【字段设计，存储引擎介绍，锁机制，索引】</title>
    <link href="https://www.junglezero.top/2019/07/20/MySQLDeepLearn/"/>
    <id>https://www.junglezero.top/2019/07/20/MySQLDeepLearn/</id>
    <published>2019-07-19T23:24:42.000Z</published>
    <updated>2019-07-22T04:15:11.574Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.3dmgame.com/uploads/images/thumbpicfirst/20180830/1535616414_320863.jpg" width="70%"><br><a id="more"></a></p><h1 id="字段的设计"><a href="#字段的设计" class="headerlink" title="字段的设计"></a>字段的设计</h1><h2 id="优先使用符合业务需要的最小的数据类型"><a href="#优先使用符合业务需要的最小的数据类型" class="headerlink" title="优先使用符合业务需要的最小的数据类型"></a>优先使用符合业务需要的最小的数据类型</h2><p>1.比如ip地址，可以用无符号整型数直接储存（MySQL内置函数INET_ATON(字符串)和INTE_NTOA(整数)分别是把ip地址转换为整型和把整型转换为字符串）<br>2.对于非负数的存储，就没必要用一般的int形，用无符号就可以解决<br>3.不要用TEXT，BLOB，或者把他们都分离到单独的扩展表中<br>4.对于一些选择项，可以用数字代替原来的字符串</p><h2 id="用关联表替代枚举"><a href="#用关联表替代枚举" class="headerlink" title="用关联表替代枚举"></a>用关联表替代枚举</h2><p>枚举若发生改变，可能会对整张表造成影响，修改的思路是把性别抽离出来单独成一张关联表</p><h2 id="金额类型的存储"><a href="#金额类型的存储" class="headerlink" title="金额类型的存储"></a>金额类型的存储</h2><p>涉及到对精度的要求，应当用Decimal，另外的思路就是小金额大数据，用一个bigint存，这个思路就是消除小数点，消除关于精度的问题</p><h2 id="not-null"><a href="#not-null" class="headerlink" title="not null"></a>not null</h2><p>对于任何字段，应当尽量使其存储内容不为null，应当用数据域不会出现的某个值来替代。</p><h2 id="表中字段数量不宜过多"><a href="#表中字段数量不宜过多" class="headerlink" title="表中字段数量不宜过多"></a>表中字段数量不宜过多</h2><p>利用第三范式将表细化，减少表中字段数量</p><h2 id="表间关系设计"><a href="#表间关系设计" class="headerlink" title="表间关系设计"></a>表间关系设计</h2><p>利用合理的外键将表串联</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>只有很大内容上的需求采用text<br>字符串列的最大长度比平均长度大很多;列的更新很少（所以碎片不是问题）;使用了像UTF8这样的字符集（每个字符都使用不同的字节数进行存储）这个时候用varchar<br>很短，或者所有值都接近同一个长度（如MD5）;列经常变更，这个时候用char</p><h2 id="日期时间注意"><a href="#日期时间注意" class="headerlink" title="日期时间注意"></a>日期时间注意</h2><p>不要用字符串存储日期型数据，浪费空间<br>DATE能保存从1001到9999年，精度为秒，他把日期和时间封装到格式为YYYYMMDDHHMMSS的整数中，使用8字节<br>TIMESTAMP保存了从1970年以来的秒数，和Unix时间戳相同，只能保存1970到2038,使用4字节<br>FROM_UNIXTIME()和UNIX_TIMESTAMP()两个函数转换日期和Unix时间戳<br>通常用TIMESTAMP，空间效率高<br>MYSQL没有提供比秒更小粒度的日期和时间值，如果需要，可以用BIGINT存储微妙级别的时间戳，或用DOUBLE存储秒之后的小数部分</p><h1 id="数据引擎"><a href="#数据引擎" class="headerlink" title="数据引擎"></a>数据引擎</h1><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>MyISAM 设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操<br>作，则依然可以使用 MyISAM。<br>MyISAM 提供了大量的特性，包括压缩表、空间数据索引等。<br>不支持事务。<br>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加<br>排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入<br>（CONCURRENT INSERT）。<br>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数<br>据丢失，而且修复操作是非常慢的。<br>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据<br>写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应<br>的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成<br>索引损坏，需要执行修复操作</p><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>InnoDB 是 MySQL 默认的事务型存储引擎，只有在需要 InnoDB 不支持的特性时，才考虑使<br>用其它存储引擎。<br>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离<br>级别下，通过多版本并发控制（MVCC）+ 间隙锁（next-key locking）防止幻影读。<br>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的<br>提升。<br>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建<br>的自适应哈希索引、能够加速插入操作的插入缓冲区等。支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有<br>表的写入，而在读写混合场景中，停止写入可能也意味着停止读取</p><h1 id="MySQL的锁"><a href="#MySQL的锁" class="headerlink" title="MySQL的锁"></a>MySQL的锁</h1><p>MySQL的锁的初衷和java中的锁出发点是一样的，是计算机协调多个进程或线程并发访问某一资源的机制<br>在数据库中，除传统的 计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一 个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。</p><h2 id="一般描述"><a href="#一般描述" class="headerlink" title="一般描述"></a>一般描述</h2><p>MySQL不同的存储引擎所使用的锁的情况不太一样，但是大体分为三类：</p><ul><li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。 </li><li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。 </li><li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般<h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3>MyISAM主要采用的就是表锁，有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）。<br>对于这种读写锁分离设计，可以结合java的读写锁来进行理解<br>举例：当一个上了写锁时,其他读和写都会被阻塞<br><img src="/upload/pasted-431.png" alt="upload successful"></li></ul><p>当一个上了读锁时，和java中的有些区别：一个session使用LOCK TABLE命令给表film_text加了读锁，这个session可以查询锁定表中的记录，但更新或访问其他表都会提示错误；同时，另外一个session可以查询表中的记录，但更新就会出现锁等待。 </p><p><img src="/upload/pasted-436.png" alt="upload successful"></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作 （UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁</p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>MyISAM存储引擎有一个系统变量concurrent_insert，专门用以控制其并发插入的行为，其值分别可以为0、1或2。<br>当concurrent_insert设置为0时，不允许并发插入。<br>当concurrent_insert设置为1时，如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录。这也是MySQL的默认设置。<br>当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录。</p><p><img src="/upload/pasted-440.png" alt="upload successful"></p><h2 id="InnoDB锁"><a href="#InnoDB锁" class="headerlink" title="InnoDB锁"></a>InnoDB锁</h2><p>众所周知，Innodb支持事务<br>因此先了解下事务</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务是由一组sql语句组成的逻辑处理单元，具有ACID属性</p><p><img src="/upload/pasted-437.png" alt="upload successful"></p><ul><li>原子性（Actomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。</li><li>一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以操持完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。</li><li>隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。</li><li>持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。<br>实际上，这些特性并不是一种同级关系</li><li>只有满足一致性，事务的执行结果才是正确的。</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时要只要能满足原子性，就</li><li>一定能满足一致性。</li><li>在并发的情况下，多个事务并发执行，事务不仅要满足原子性，还需要满足隔离性，才能</li><li>满足一致性。事务满足持久化是为了能应对数据库奔溃的情况</li></ul><p><img src="/upload/pasted-438.png" alt="upload successful"></p><h3 id="事务并发的问题"><a href="#事务并发的问题" class="headerlink" title="事务并发的问题"></a>事务并发的问题</h3><p>和java中的并发一样，事务的并发也会带来读写的问题</p><ul><li>丢失更新(Lost Update)<br>由于事务之间是不知道彼此的存在的，因此当两个事务同时对同一个数据进行修改时，可能会发生先修改的数据被后修改的所覆盖的问题<br><img src="/upload/pasted-441.png" alt="upload successful"></li><li>脏读（Dirty Reads）：<br>一个事务正在对一条记录做修改，在这个事务并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做“脏读”。<br><img src="/upload/pasted-442.png" alt="upload successful"></li><li>不可重复读（Non-Repeatable Reads）：<br>一个事务在读取某些数据已经发生了改变、或某些记录已经被删除了！这种现象叫做“不可重复读”。<br><img src="/upload/pasted-443.png" alt="upload successful"></li><li>幻读（Phantom Reads）：<br>一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”</li></ul><p><img src="/upload/pasted-444.png" alt="upload successful"></p><h3 id="问题的解决"><a href="#问题的解决" class="headerlink" title="问题的解决"></a>问题的解决</h3><p>在并发事务处理带来的问题中，“更新丢失”通常应该是完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。</p><p>“脏读”、“不可重复读”和“幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。数据库实现事务隔离的方式，基本可以分为以下两种。</p><p>一种是在读取数据前，对其加锁，阻止其他事务对数据进行修改。<br>另一种是不用加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot），并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户的角度，好像是数据库可以提供同一数据的多个版本，因此，这种技术叫做数据多版本并发控制（ＭultiVersion Concurrency Control，简称MVCC或MCC），也经常称为多版本数据库。</p><p>在MVCC并发控制中，读操作可以分成两类：快照读 (snapshot read)与当前读 (current read)。快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。<br>在一个支持MVCC并发控制的系统中，哪些读操作是快照读？哪些操作又是当前读呢？以MySQL InnoDB为例：</p><ul><li><p>快照读：<br>简单的select操作，属于快照读，不加锁。(当然，也有例外)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ?;</span><br></pre></td></tr></table></figure></li><li><p>当前读：<br>特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。<br>下面语句都属于当前读，读取记录的最新版本。并且，读取之后，还需要保证其他并发事务不能修改当前记录，对读取记录加锁。其中，除了第一条语句，对读取记录加S锁 (共享锁)外，其他的操作，都加的是X锁 (排它锁)。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="keyword">values</span> (…);</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> <span class="keyword">set</span> ? <span class="keyword">where</span> ?;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ?;</span><br></pre></td></tr></table></figure></li></ul><p>为了解决“隔离”与“并发”的矛盾，ISO/ANSI SQL92定义了4个事务隔离级别，每个级别的隔离程度不同，允许出现的副作用也不同，应用可以根据自己的业务逻辑要求，通过选择不同的隔离级别来平衡 “隔离”与“并发”的矛盾。下表很好地概括了这4个隔离级别的特性</p><p><img src="/upload/pasted-445.png" alt="upload successful"></p><h3 id="InnoDB的行级锁"><a href="#InnoDB的行级锁" class="headerlink" title="InnoDB的行级锁"></a>InnoDB的行级锁</h3><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><ul><li>排它锁（Exclusive），简写为 X 锁，又称写锁。<br>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li><li>共享锁（Shared），简写为 S 锁，又称读锁。<br>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁</li></ul><h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p><ul><li>意向共享锁（IS）：事务打算给数据行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</li><li>意向排他锁（IX）：事务打算给数据行加排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</li></ul><p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务<br>对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。<br>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的<br>某个数据行上加 X 锁或 S 锁。有以下两个规定：</p><ul><li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li><li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。<br>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了<br>X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T<br>加 X 锁失败。<h4 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h4>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的 索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁 （Next-Key锁）。<br>利用这种锁可以解决幻读的问题，但是对于频繁插入的业务会造成严重的阻塞<br>比如以下例子</li></ul><p><img src="/upload/pasted-449.png" alt="upload successful"></p><h4 id="锁的使用"><a href="#锁的使用" class="headerlink" title="锁的使用"></a>锁的使用</h4><p>意向锁是InnoDB自动加的，不需用户干预。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁。<br>事务可以通过以下语句显式给记录集加共享锁或排他锁：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ... <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br></pre></td></tr></table></figure></p><h4 id="具体情况"><a href="#具体情况" class="headerlink" title="具体情况"></a>具体情况</h4><p>只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！<br>对一个没有创建索引的表进行查询</p><p><img src="/upload/pasted-446.png" alt="upload successful"><br>在上面的例子中，看起来session_1只给一行加了排他锁，但session_2在请求其他行的排他锁时，却出现了锁等待！原因就是在没有索引的情况下，InnoDB只能使用表锁</p><p>创建索引后<br><img src="/upload/pasted-447.png" alt="upload successful"></p><p>访问相同的索引并加锁就会阻塞</p><p><img src="/upload/pasted-448.png" alt="upload successful"></p><h1 id="MySQL的索引"><a href="#MySQL的索引" class="headerlink" title="MySQL的索引"></a>MySQL的索引</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>索引是一种可以加快数据查询速度的一种数据结构<br>虽然索引可以加快查询速度，提高 MySQL 的处理性能，但是过多地使用索引也会造成以下弊端：</p><ul><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li><li>除了数据表占数据空间之外，每一个索引还要占一定的物理空间。如果要建立聚簇索引，那么需要的空间就会更大。</li><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。<br>因此，索引的不能随便创建，应当结合具体情况具体分析</li></ul><p>根据数据结构划分，可以把索引划分为B树索引以及哈希索引</p><h2 id="B树索引"><a href="#B树索引" class="headerlink" title="B树索引"></a>B树索引</h2><p>这是比较常见的索引形式，是基于B树的数据结构，需要注意的就是这种索引遵循左边前缀原则，即索引的查找要从被选定为索引的最左边一列查询。<br>可以根据索引选择性判断是否需要创建索引<br>所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值：<br>Index Selectivity = Cardinality / #T<br>显然选择性的取值范围为(0, 1]，选择性越高的索引价值越大，这是由B+Tree的性质决定的。<br>有一种与索引选择性有关的索引优化策略叫做前缀索引，就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。<br>在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。(基于Innodb的聚集索引)</p><p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a><br>这篇文章讲的非常好</p><h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h2><p>哈希索引也称为散列索引或 HASH 索引。MySQL 目前仅有 MEMORY 存储引擎和 HEAP 存储引擎支持这类索引。其中，MEMORY 存储引擎可以支持 B- 树索引和 HASH 索引，且将 HASH 当成默认索引。<br>HASH 索引不是基于树形的数据结构查找数据，而是根据索引列对应的哈希值的方法获取表的记录行。哈希索引的最大特点是访问速度快，但也存在下面的一些缺点：</p><ul><li>MySQL 需要读取表中索引列的值来参与散列计算，散列计算是一个比较耗时的操作。也就是说，相对于 B- 树索引来说，建立哈希索引会耗费更多的时间。</li><li>不能使用 HASH 索引排序。</li><li>HASH 索引只支持等值比较，如“=”“IN()”或“&lt;=&gt;”。</li><li>HASH 索引不支持键的部分匹配，因为在计算 HASH 值的时候是通过整个索引值来计算的。</li></ul><h2 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h2><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查<br>找条件使用 MATCH AGAINST，而不是普通的 WHERE。<br>全文索引一般使用倒排索引实现，它记录着关键词到其所在文档的映射。<br>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p><h2 id="空间数据索引（R-tree）"><a href="#空间数据索引（R-tree）" class="headerlink" title="空间数据索引（R-tree）"></a>空间数据索引（R-tree）</h2><p>MyISAM 存储引擎支持空间数据索引，可以用于地理数据存储。空间数据索引会从所有维度<br>来索引数据，可以有效地使用任意维度来进行组合查询。<br>必须使用 GIS 相关的函数来维护数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.3dmgame.com/uploads/images/thumbpicfirst/20180830/1535616414_320863.jpg&quot; width=&quot;70%&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库SQL部分复习（4）【自定义函数，存储过程，触发器，依赖和三范式】</title>
    <link href="https://www.junglezero.top/2019/07/18/tabasereview4/"/>
    <id>https://www.junglezero.top/2019/07/18/tabasereview4/</id>
    <published>2019-07-18T14:13:28.000Z</published>
    <updated>2019-07-19T06:45:56.565Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/upload/pasted-279.png" width="70%"><br><a id="more"></a></p><h1 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>函数由一系列sql语句组成，调用函数就是一次性执行这些语句。所以函数可以降低语句重复。【但注意的是函数注重返回值，不注重执行过程，所以一些语句无法执行。所以函数并不是单纯的sql语句集合。】<br>函数只能返回单个值而不能返回一整个结果集。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> selectMAXgrade (sub <span class="built_in">VARCHAR</span>(<span class="number">10</span>)) <span class="keyword">RETURNS</span> <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DECLARE</span> c <span class="built_in">INT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">MAX</span>(grade)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">sc</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">cno = sub <span class="keyword">INTO</span> c;</span><br><span class="line"></span><br><span class="line">RETURN c;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">selectMAXgrade (<span class="string">'1001'</span>);</span><br></pre></td></tr></table></figure><h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p>存储过程是一组为了完成特定功能的 SQL 语句集合。使用存储过程的目的是将常用或复杂的工作预先用 SQL 语句写好并用一个指定名称存储起来，这个过程经编译和优化后存储在数据库服务器中，因此称为存储过程。当以后需要数据库提供与已定义好的存储过程的功能相同的服务时，只需调用“CALL存储过程名字”即可自动完成<br>存储过程有如下优点：<br>1) 封装性<br>存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的 SQL 语句，并且数据库专业人员可以随时对存储过程进行修改，而不会影响到调用它的应用程序源代码。<br>2) 可增强 SQL 语句的功能和灵活性<br>存储过程可以用流程控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。<br>3) 可减少网络流量<br>由于存储过程是在服务器端运行的，且执行速度快，因此当客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而可降低网络负载。<br>4) 高性能<br>存储过程执行一次后，产生的二进制代码就驻留在缓冲区，在以后的调用中，只需要从缓冲区中执行二进制代码即可，从而提高了系统的效率和性能。<br>5) 提高数据库的安全性和数据的完整性<br>使用存储过程可以完成所有数据库操作，并且可以通过编程的方式控制数据库信息访问的权限。</p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>找出给定的学科编号的考的90分以上的学生姓名<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">delimiter //</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> showOver90Stu (sub <span class="built_in">VARCHAR</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sno <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sno</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">sc</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">cno = sub</span><br><span class="line"><span class="keyword">AND</span> grade &gt; <span class="number">90</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">END</span> //</span><br><span class="line">    </span><br><span class="line"><span class="keyword">call</span> showOver90Stu(<span class="string">'1001'</span>)</span><br></pre></td></tr></table></figure></p><p>需要注意的是，在begin和end之间定义的sql结尾要加；，但是为了让语句不会提前运行，需要自定义终止字符，调用delimiter //，//表示希望作为终止符的符号。</p><h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><h2 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h2><p>MySQL 数据库中触发器是一个特殊的存储过程，不同的是执行存储过程要使用 CALL 语句来调用，而触发器的执行不需要使用 CALL 语句来调用，也不需要手工启动，只要一个预定义的事件发生就会被 MySQL自动调用</p><p>在实际使用中，MySQL 所支持的触发器有三种：INSERT 触发器、UPDATE 触发器和 DELETE 触发器。<br>1) INSERT 触发器<br>在 INSERT 语句执行之前或之后响应的触发器。<br>使用 INSERT 触发器需要注意以下几点：</p><ul><li>在 INSERT 触发器代码内，可引用一个名为 NEW（不区分大小写）的虚拟表来访问被插入的行。</li><li>在 BEFORE INSERT 触发器中，NEW 中的值也可以被更新，即允许更改被插入的值（只要具有对应的操作权限）。</li><li>对于 AUTO_INCREMENT 列，NEW 在 INSERT 执行之前包含的值是 0，在 INSERT 执行之后将包含新的自动生成值。</li></ul><p>2) UPDATE 触发器<br>在 UPDATE 语句执行之前或之后响应的触发器。<br>使用 UPDATE 触发器需要注意以下几点：</p><ul><li>在 UPDATE 触发器代码内，可引用一个名为 NEW（不区分大小写）的虚拟表来访问更新的值。</li><li>在 UPDATE 触发器代码内，可引用一个名为 OLD（不区分大小写）的虚拟表来访问 UPDATE 语句执行前的值。</li><li>在 BEFORE UPDATE 触发器中，NEW 中的值可能也被更新，即允许更改将要用于 UPDATE 语句中的值（只要具有对应的操作权限）。</li><li>OLD 中的值全部是只读的，不能被更新。</li></ul><p>3) DELETE 触发器<br>在 DELETE 语句执行之前或之后响应的触发器。<br>使用 DELETE 触发器需要注意以下几点：</p><ul><li>在 DELETE 触发器代码内，可以引用一个名为 OLD（不区分大小写）的虚拟表来访问被删除的行。</li><li>OLD 中的值全部是只读的，不能被更新。</li></ul><h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><p>当删除某个学生时，同时删除他的成绩等<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> deleteSc <span class="keyword">AFTER</span> <span class="keyword">DELETE</span> <span class="keyword">ON</span> student <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">sc</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sno = old.sno ;</span><br><span class="line"><span class="keyword">END</span> $$</span><br></pre></td></tr></table></figure></p><h1 id="依赖和三范式"><a href="#依赖和三范式" class="headerlink" title="依赖和三范式"></a>依赖和三范式</h1><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>设R(U)是一个属性集U上的关系模式，X和Y是U的子集。<br>若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等， 而在Y上的属性值不等， 则称 “X函数确定Y” 或  “Y函数依赖于X”。记作X→Y。<br>对于这个概念，可以这么理解：要是学号定了，确定了某个人，那么性别，姓名就都确定了</p><ul><li><p>平凡依赖和非平凡依赖<br><img src="/upload/pasted-432.png" alt="upload successful"><br>例如在sc中，<br>平凡函数依赖：(Sno, Cno) → Sno<br>非平凡依赖：(Sno, Cno) → Grade</p></li><li><p>完全依赖和部分依赖：<br><img src="/upload/pasted-434.png" alt="upload successful"><br>可以这么理解：只有全部的关系才能决定下一个属性，这就是完全依赖，如果其中一个就可以决定下一个属性，那么就是部分依赖<br>例如grade完全依赖于sno和cno，而由于sname依赖于sno，则sname部分依赖于sno和cno</p></li><li><p>传递依赖<br><img src="/upload/pasted-435.png" alt="upload successful"><br>比如对于关系，Std(Sno, Sdept, Mname)<br>sno决定sdept,sdept决定Mname,则相当于Mname传递依赖于sno</p></li></ul><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><h3 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h3><p>如果一个关系模式R的所有属性都是不可分的基本数据项，则R∈1NF。<br>意思是对于任意一个数据项，都能没有歧义存入数据库，比如说一个关系学生（学生信息），这就不满足第一范式</p><h3 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h3><p>若关系模式R∈1NF，并且每一个非主属性都完全函数依赖于R的码，则R∈2NF。<br>就是说只要主键确定了，别的数据项就都能确定了<br>对于关系scn(sno,cno,sname,grade)<br>grade对于主键(sno,cno)是完全依赖的，而sname对于（sno,cno）是部分依赖的，因此若要满足第二范式，则需要将原表拆成sc(sno,cno,grade),s(sno,sname)</p><h3 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h3><p><img src="/upload/pasted-439.png" alt="upload successful"><br>如S1（SNO，SNAME，DNO，DNAME，LOCATION） 各属性分别代表学号，姓名，所在系，系名称，系地址。<br>关系中存在传递依赖。即SNO -&gt; DNO。 而DNO -&gt; SNO却不存在，DNO -&gt; LOCATION, 因此关键字 SNO 对 LOCATION 函数决定是通过传递依赖 DNO -&gt; LOCATION 实现的。也就是说，SNO不直接决定非主属性LOCATION。<br>因此需要拆成两个关系<br>S（SNO，SNAME，DNO），D（DNO，DNAME，LOCATION）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/upload/pasted-279.png&quot; width=&quot;70%&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库SQL部分复习（3）【数据更新，视图，查询练习】</title>
    <link href="https://www.junglezero.top/2019/07/17/tabasereview/"/>
    <id>https://www.junglezero.top/2019/07/17/tabasereview/</id>
    <published>2019-07-17T11:29:36.000Z</published>
    <updated>2019-07-18T08:45:46.198Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/upload/pasted-430.png" width="70%"></p><a id="more"></a><h1 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h1><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>一般的插入<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SC (Sno,Cno)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">' 200215128 '</span> , <span class="string">' 1 '</span>)</span><br></pre></td></tr></table></figure></p><p>插入查询结果<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Deptage (Sdept, Avgage) <span class="keyword">SELECT</span></span><br><span class="line">Sdept,</span><br><span class="line"><span class="keyword">AVG</span>(Sage)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">Student</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">Sdept</span><br></pre></td></tr></table></figure></p><p>插入多条结果<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSERTINTO table_name (col_one, col_two)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">'c1'</span>, <span class="string">'c2'</span>),</span><br><span class="line">(<span class="string">'c3'</span>, <span class="string">'c4'</span>)</span><br></pre></td></tr></table></figure></p><p>这种方式只能在mysql里面写</p><h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><p>一般修改<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Student</span><br><span class="line"><span class="keyword">SET</span> Sage = <span class="number">22</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">Sno = <span class="string">' 200215121 '</span></span><br></pre></td></tr></table></figure></p><p>批量修改<br>若不设置条件，则是针对全部<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> sc</span><br><span class="line"><span class="keyword">SET</span> grade = grade + <span class="number">1</span></span><br></pre></td></tr></table></figure></p><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">S</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">Sno = <span class="string">'200215125'</span></span><br></pre></td></tr></table></figure><h1 id="视图（View）"><a href="#视图（View）" class="headerlink" title="视图（View）"></a>视图（View）</h1><p>视图是一个虚拟表，其内容由查询定义。同真实表一样，视图包含一系列带有名称的列和行数据，但视图并不是数据库真实存储的数据表。<br>视图是从一个、多个表或者视图中导出的表，包含一系列带有名称的数据列和若干条数据行。<br>视图并不同于数据表，它们的区别在于以下几点：</p><ul><li>视图不是数据库中真实的表，而是一张虚拟表，其结构和数据是建立在对数据中真实表的查询基础上的。</li><li>存储在数据库中的查询操作 SQL 语句定义了视图的内容，列数据和行数据来自于视图查询所引用的实际表，引用视图时动态生成这些数据。</li><li>视图没有实际的物理记录，不是以数据集的形式存储在数据库中的，它所对应的数据实际上是存储在视图所引用的真实表中的。</li><li>视图是数据的窗口，而表是内容。表是实际数据的存放单位，而视图只是以不同的显示方式展示数据，其数据来源还是实际表。</li><li>视图是查看数据表的一种方法，可以查询数据表中某些字段构成的数据，只是一些 SQL 语句的集合。从安全的角度来看，视图的数据安全性更高，使用视图的用户不接触数据表，不知道表结构。</li><li>视图的建立和删除只影响视图本身，不影响对应的基本表。</li></ul><h1 id="查询题目练习"><a href="#查询题目练习" class="headerlink" title="查询题目练习"></a>查询题目练习</h1><p>设有三个关系：<br>S(sno,sname,sex,age)<br>SC(sno,cno,grade)<br>C(cno,cname,teacher)</p><ol><li><p>查询LIU老师所授课程的课程号和课程名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">cno,</span><br><span class="line">cname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">C</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">teacher = <span class="string">'LIU'</span></span><br></pre></td></tr></table></figure></li><li><p>查询年龄大于23岁的男学生的学号和姓名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sno,</span><br><span class="line">sname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">S</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">age &gt; <span class="number">23</span></span><br><span class="line"><span class="keyword">AND</span> sex = <span class="string">'M'</span></span><br></pre></td></tr></table></figure></li><li><p>查询学号为S3学生所学课程的课程名与任课教师名<br>连接查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">cname,</span><br><span class="line">teacher</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">SC,</span><br><span class="line">C</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">SC.cno = C.cno</span><br><span class="line"><span class="keyword">AND</span> sno = <span class="string">'S3'</span></span><br></pre></td></tr></table></figure></li></ol><p>嵌套查询<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">cname,</span><br><span class="line">teacher</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">C</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">cno <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">cno</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">SC</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sno = <span class="string">'S3'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><ol start="4"><li>查询至少选修LIU老师所授课程中一门课程的女学生姓名<br>连接查询<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">S,</span><br><span class="line">SC,</span><br><span class="line">C</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">S.sno = SC.sno</span><br><span class="line"><span class="keyword">AND</span> SC.cno = C.cno</span><br><span class="line"><span class="keyword">AND</span> sex = <span class="string">'F'</span></span><br><span class="line"><span class="keyword">AND</span> teacher = <span class="string">'LIU'</span></span><br></pre></td></tr></table></figure></li></ol><p>嵌套查询<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">S</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sex = ‘F’</span><br><span class="line"><span class="keyword">AND</span> sno <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sno</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">SC</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">cno <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">cno</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">C</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">teacher = ‘LIU’</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><ol start="5"><li><p>查询WANG同学不学的课程的课程号<br>NOT EXISTS嵌套查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">cno</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">C</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">S,</span><br><span class="line">SC</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">S.sno = SC.sno</span><br><span class="line"><span class="keyword">AND</span> SC.cno = C.cno</span><br><span class="line"><span class="keyword">AND</span> sname = ‘WANG’</span><br><span class="line">)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>查询至少选修两门课的学生学号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sno</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">sno</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line"><span class="keyword">count</span>(*) &gt;= <span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>统计每门课程的学生选修人数（超过10人的课程才统计）。要求显示课程号和人数，查询结果按人数降序排列，若人数相同，按课程号升序排列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">cno,</span><br><span class="line"><span class="keyword">count</span>(sno)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">cno</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line"><span class="keyword">count</span>(*) &gt; <span class="number">10</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line"><span class="keyword">count</span>(sno) <span class="keyword">DESC</span>,</span><br><span class="line">cno</span><br></pre></td></tr></table></figure></li><li><p>求LIU老师所授课程的每门课程的平均成绩</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> C.cno,<span class="keyword">avg</span>(grade) </span><br><span class="line"><span class="keyword">from</span> SC,C</span><br><span class="line"><span class="keyword">where</span> SC.cno=C.cno </span><br><span class="line">    <span class="keyword">and</span> teacher=‘LIU’ </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> C.cno</span><br></pre></td></tr></table></figure></li><li><p>检索姓名以L打头的所有学生的姓名和年龄</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sname,</span><br><span class="line">age</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">S</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sname <span class="keyword">LIKE</span> <span class="string">'L%'</span></span><br></pre></td></tr></table></figure></li><li><p>求年龄大于所有女同学年龄的男学生姓名和年龄</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sname,</span><br><span class="line">age</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">S</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sex = ‘M’</span><br><span class="line"><span class="keyword">AND</span> age &gt; <span class="keyword">ALL</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">age</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">S</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sex = ‘F’</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/upload/pasted-430.png&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库SQL部分复习(2)【约束，数据类型，查询，连接查询，嵌套查询】</title>
    <link href="https://www.junglezero.top/2019/07/16/tabaseSQLReview-2/"/>
    <id>https://www.junglezero.top/2019/07/16/tabaseSQLReview-2/</id>
    <published>2019-07-16T08:22:35.000Z</published>
    <updated>2019-07-19T06:49:49.922Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/upload/pasted-427.png" width="70%"></p><a id="more"></a><hr><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><h2 id="模式（SCHEMA）-数据库（DATABASE）相关"><a href="#模式（SCHEMA）-数据库（DATABASE）相关" class="headerlink" title="模式（SCHEMA）,数据库（DATABASE）相关"></a>模式（SCHEMA）,数据库（DATABASE）相关</h2><p>MySQL官方文档指出，从概念上讲，模式是一组相互关联的数据库对象，如表，表列，列的数据类型，索引，外键等等。但是从物理层面上来说，模式与数据库是同义的。你可以在MySQL的SQL语法中用关键字SCHEMA替代DATABASE，例如使用CREATE SCHEMA来代替CREATE DATABASE。<br>也就是说，一个SCHEMA就是一套关系<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">SCHEMA</span> <span class="number">123</span></span><br></pre></td></tr></table></figure></p><p>就可以创建出一个新的数据库（DATABASE）</p><h2 id="表（TABLE）相关"><a href="#表（TABLE）相关" class="headerlink" title="表（TABLE）相关"></a>表（TABLE）相关</h2><h3 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h3><ul><li>主键约束（PRIMARY KEY)<br>主键约束是用来保证表中记录唯一可区分的列。一个表可以通过一列或列组合的数据来唯一标识表中的每一条记录。</li><li>唯一约束（UNIQUE)<br>规定一条记录的一个字段值或几个字段的组合值不得与其他记录的相同字段或字段组合的值重复，将这种限制成为“唯一约束”。</li><li>外键约束 (FOREIGN KEY)<br>1）外键列可以由是一个列或多个列组成。<br>2）外键列的取值可以为空，可以有重复值，但必须是它所引用列的列值之一。引用列必须是创建了主键约束或唯一约束的列。</li><li><p>检查约束 （CHECK)<br>检查约束是用来检查一个字段或多个字段的输入值是否满足指定的约束条件。</p></li><li><p>默认值约束（DEFAULT)<br>在用户定义数据类型的情况下，如果使用默认值约束，则默认值被插入到使用这个自定义数据的所有字段中。</p></li><li><p>空值约束（NULL)<br>空值约束就是指尚不知道或不确定的数据值，它不等同于0或空格。</p></li></ul><h3 id="数据库的基本数据类型（以MySQL为标准）"><a href="#数据库的基本数据类型（以MySQL为标准）" class="headerlink" title="数据库的基本数据类型（以MySQL为标准）"></a>数据库的基本数据类型（以MySQL为标准）</h3><h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><p>MySQL中提供了以下几种整数类型，可以设置自增约束</p><p><img src="/upload/pasted-414.png" alt="upload successful"><br>各个整数类型范围如下<br><img src="/upload/pasted-415.png" alt="upload successful"></p><h4 id="小数类型"><a href="#小数类型" class="headerlink" title="小数类型"></a>小数类型</h4><p>MySQL 中使用浮点数和定点数来表示小数。<br>浮点类型有两种，分别是单精度浮点数（FLOAT）和双精度浮点数（DOUBLE）；定点类型只有一种，就是 DECIMAL<br>两种类型都可以用（M,D）表示，其中M称为精度，表示总共的位数；D称为标度，表示小数的位数。<br>浮点数类型的取值范围为 M（1～255）和 D（1～30，且不能大于 M-2）DECIMAL 的默认 D 值为 0、M 值为 10<br> FLOAT 和 DOUBLE 在不指定精度时，默认会按照实际的精度（由计算机硬件和操作系统决定），DECIMAL 如果不指定精度，默认为（10，0）。<br> 不论是定点还是浮点类型，如果用户指定的精度超出精度范围，则会四舍五入进行处理。</p><p><img src="/upload/pasted-416.png" alt="upload successful"><br> 在 MySQL 中，定点数以字符串形式存储，在对精度要求比较高的时候（如货币、科学数据），使用 DECIMAL 的类型比较好，另外两个浮点数进行减法和比较运算时也容易出问题，所以在使用浮点数时需要注意，并尽量避免做浮点数比较。</p><h4 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h4><p>MySQL 中表示日期的数据类型：YEAR、TIME、DATE、DTAETIME、TIMESTAMP。当只记录年信息的时候，可以只使用 YEAR 类型。<br>当指定确定不合法的值时，系统将“零”值插入数据库中</p><p><img src="/upload/pasted-417.png" alt="upload successful"><br>对于YEAR,除了整数外也可以匹配形如YYYY的四位字符串或者两位字符串，对于两位的数字和字符串，0-69回转化为2001-2069，而70-99会转化为1970-1999<br>对于TIME,小时部分之所以会大出一部分的原因是可以用TIME表示某件事发展的时长，除了给定的格式外，可以用HHMMSS表示，但是对于这种输入，MySQL是从秒开始处理的。对于非法的输入，则储存0时间<br>对于DATE基本和上面有相似的规则，可以调用CURRENT_DATE 或者 NOW()，插入当前系统日期</p><p>DATETIME 在存储日期数据时，按实际输入的格式存储，即输入什么就存储什么，与时区无关；<br>TIMESTAMP 值的存储是以 UTC（世界标准时间）格式保存的，存储时对当前时区进行转换，检索时再转换回当前时区。即查询时，根据当前时区的不同，显示的时间值是不同的。</p><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p>MySQL 中的字符串类型有 CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、ENUM、SET 等。</p><p><img src="/upload/pasted-418.png" alt="upload successful"><br>char是定长字符串类型，即不管要储存的字符串多长，它只储存规定的长度，不管多短，会用空格补齐剩下的，而varchar是变长的，只能规定最大长度，其实际的储存空间为字符串占的空间+1（字符串结束标识）</p><p><img src="/upload/pasted-419.png" alt="upload successful"><br>ENUM是MySQL内的枚举类型，每个具体字符串对应一个索引值，ENUM 类型的字段在取值时，能在指定的枚举列表中获取，而且一次只能取一个。如果创建的成员中有空格，尾部的空格将自动被删除。ENUM 列总有一个默认值。如果将 ENUM 列声明为 NULL，NULL 值则为该列的一个有效值，并且默认值为 NULL。如果 ENUM 列被声明为 NOT NULL，其默认值为允许的值列表的第 1 个元素。<br>SET是一个加强版的枚举，可以选择多个值加入</p><h4 id="二进制类型"><a href="#二进制类型" class="headerlink" title="二进制类型"></a>二进制类型</h4><p>MySQL 中的二进制字符串有 BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。</p><p><img src="/upload/pasted-420.png" alt="upload successful"></p><h3 id="表的创建"><a href="#表的创建" class="headerlink" title="表的创建"></a>表的创建</h3><p>建立一个“学生选课”表SC，它由学号Sno、课程号Cno，修课成绩Grade组成，其中(Sno, Cno)为主码。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">(    Sno <span class="built_in">CHAR</span>(<span class="number">5</span>) ,</span><br><span class="line">     Cno <span class="built_in">CHAR</span>(<span class="number">3</span>) , </span><br><span class="line">     Grade   <span class="built_in">int</span>,</span><br><span class="line">     Primary <span class="keyword">key</span> (Sno, Cno),</span><br><span class="line">     <span class="keyword">Foreign</span> <span class="keyword">key</span> (sno) <span class="keyword">References</span> student (sno),</span><br><span class="line">     <span class="keyword">Foreign</span> <span class="keyword">key</span> (cno) <span class="keyword">References</span> course (cno)  );</span><br></pre></td></tr></table></figure><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="查询全部"><a href="#查询全部" class="headerlink" title="查询全部"></a>查询全部</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> STUDENT</span><br></pre></td></tr></table></figure><h3 id="查询某一列"><a href="#查询某一列" class="headerlink" title="查询某一列"></a>查询某一列</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sno <span class="keyword">FROM</span> STUDENT</span><br></pre></td></tr></table></figure><h3 id="查询经过计算结果"><a href="#查询经过计算结果" class="headerlink" title="查询经过计算结果"></a>查询经过计算结果</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title,</span><br><span class="line">price * <span class="number">50</span> <span class="keyword">AS</span> <span class="number">50</span>price</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film_list</span><br></pre></td></tr></table></figure><h3 id="利用case-when替换查询结果"><a href="#利用case-when替换查询结果" class="headerlink" title="利用case when替换查询结果"></a>利用case when替换查询结果</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title,</span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> price &gt; <span class="number">0.99</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="string">'ex'</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line"><span class="string">'chep'</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">AS</span> price</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film_list</span><br></pre></td></tr></table></figure><h3 id="利用CONCAT连接查询结果，利用cast转化结果"><a href="#利用CONCAT连接查询结果，利用cast转化结果" class="headerlink" title="利用CONCAT连接查询结果，利用cast转化结果"></a>利用CONCAT连接查询结果，利用cast转化结果</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">CONCAT</span>(title,<span class="string">'的票价是'</span>,<span class="keyword">CAST</span>(price <span class="keyword">AS</span> <span class="built_in">char</span>)) <span class="keyword">as</span> 价格说明</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film_list</span><br></pre></td></tr></table></figure><h3 id="查询结果返回大小写，字符串长度"><a href="#查询结果返回大小写，字符串长度" class="headerlink" title="查询结果返回大小写，字符串长度"></a>查询结果返回大小写，字符串长度</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">LOWER</span>(title),</span><br><span class="line"><span class="keyword">UPPER</span>(title),</span><br><span class="line"><span class="keyword">LENGTH</span>(title)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film_list</span><br></pre></td></tr></table></figure><h3 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h3><p>1、left(str,length) 从左边截取length<br>2、right(str,length)从右边截取length<br>3、substring(str,index)当index&gt;0从左边开始截取直到结束  当index&lt;0从右边开始截取直到结束  当index=0返回空<br>4、substring(str,index,len) 截取str,从index开始，截取len长度<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">left</span>(title,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film_list</span><br></pre></td></tr></table></figure></p><h3 id="日期相关函数"><a href="#日期相关函数" class="headerlink" title="日期相关函数"></a>日期相关函数</h3><p>now()获取当前的日期和时间<br>current_timestamp() 获取当前时间戳<br>date_format(date,format), time_format(time,format) 转换时间形式<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">DATE_FORMAT</span>(last_update, <span class="string">'%y%m%d%h%i%s'</span>) <span class="keyword">AS</span> <span class="string">'时间序列'</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br></pre></td></tr></table></figure></p><p>（日期、天数）转换函数：to_days(date), from_days(days)<br>（时间、秒）转换函数：time_to_sec(time), sec_to_time(seconds)<br>拼凑日期、时间函数：makdedate(year,dayofyear), maketime(hour,minute,second)<br>（Unix 时间戳、日期）转换函数</p><h3 id="集合，范围查询"><a href="#集合，范围查询" class="headerlink" title="集合，范围查询"></a>集合，范围查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> rating <span class="keyword">in</span> (<span class="string">'PG'</span>,<span class="string">'R'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">customer_id </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">payment</span><br><span class="line"><span class="keyword">where</span> payment_date <span class="keyword">BETWEEN</span> <span class="string">'2005-06-17 09:19:45'</span> <span class="keyword">and</span> <span class="string">'2005-08-02 18:55:15'</span></span><br></pre></td></tr></table></figure><p>注意 between是左闭右开的</p><h3 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h3><h4 id="Like-匹配"><a href="#Like-匹配" class="headerlink" title="Like 匹配"></a>Like 匹配</h4><p>1.%：表示任意0个或多个字符。可匹配任意类型和长度的字符，有些情况下若是中文，请使用两个百分号（%%）表示<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title <span class="keyword">LIKE</span> <span class="string">'%W%'</span></span><br></pre></td></tr></table></figure></p><p>若是要搜索包含某两个字的<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title <span class="keyword">LIKE</span> <span class="string">'%W%'</span> <span class="keyword">and</span> title <span class="keyword">LIKE</span> <span class="string">'%O%'</span></span><br></pre></td></tr></table></figure></p><p>2._： 表示任意单个字符。匹配单个任意字符<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title <span class="keyword">LIKE</span> <span class="string">'_O%'</span></span><br></pre></td></tr></table></figure></p><h4 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h4><p>^ 匹配字符开始的部分<br>查询以W开头的<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title REGEXP <span class="string">'^W'</span></span><br></pre></td></tr></table></figure></p><p>$ 匹配字符结束的部分<br>查询以S为结尾的部分<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title REGEXP <span class="string">'S$'</span></span><br></pre></td></tr></table></figure></p><p>. 匹配字符串中的任意一个字符，包括回车和换行<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title REGEXP <span class="string">'^W................S$'</span></span><br></pre></td></tr></table></figure></p><p>[字符集合]匹配字符集合中的任意字符<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title REGEXP <span class="string">'^W[OE]'</span></span><br></pre></td></tr></table></figure></p><p>[^字符集合]匹配除了字符集合外的任意字符<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title REGEXP <span class="string">'^W[^B-Z]'</span></span><br></pre></td></tr></table></figure></p><p>s1|s2|s3 匹配s1s2s3中的任意一个<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title REGEXP  <span class="string">'^WA|^WE|^WH'</span></span><br></pre></td></tr></table></figure></p><p>*代表多个该字符前的字符，包括0个或1个<br>+代表多个该字符前的字符，包括1个<br>字符串{N} 字符串出现N次<br>字符串{M，N}字符串最少出现M次，最多出现N次<br>若是查找的就是转义字符本身，最后要加上ESCAPE</p><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>使用GROUP BY 进行分组<br>将查询的结果按某一列或多列的值分组，值相等的<br>为一组<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">rating,<span class="keyword">COUNT</span>(rating)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> rating</span><br></pre></td></tr></table></figure></p><p>使用GROUP BY子句后，SELECT子句的列名列表中只能出现分组属性和集函数<br>若要想要对分完的组做条件筛选，则需要用Having而不是where<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">rating,<span class="keyword">COUNT</span>(rating)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> rating</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(rating)&gt;<span class="number">195</span><span class="string">`sql</span></span><br></pre></td></tr></table></figure></p><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>可以基于关系运算的连接来理解连接查询</p><ul><li><p>广义笛卡尔积（交叉连接）<br>又称非限制连接，它将两个表不加任何约束地组合在一起，也就是将第一个表中的所有记录分别与第二个表的所有记录组成新的记录。（进行广义笛卡尔乘积）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="string">`language`</span>.*,staff.*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line"><span class="string">`language`</span>,staff</span><br></pre></td></tr></table></figure></li><li><p>等值连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  student.Sno,Sname,sex,Cno,Grade</span><br><span class="line"><span class="keyword">FROM</span>     student,sc</span><br><span class="line"><span class="keyword">WHERE</span>  student.sno = sc.sno</span><br></pre></td></tr></table></figure></li></ul><p>任何子句中引用表1和表2中同名属性时，都必须加表名前缀。引用唯一属性名时可以加也可以省略表名前缀<br>也可以用内连接表示等值连接<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">student.Sno,</span><br><span class="line">Sname,</span><br><span class="line">sex,</span><br><span class="line">Cno,</span><br><span class="line">Grade</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> sc <span class="keyword">ON</span> student.sno = sc.sno</span><br></pre></td></tr></table></figure></p><ul><li><p>自然连接<br>是一种特殊的等值链接，在等值连接的基础上，去掉相同的属性</p></li><li><p>自然连接<br>自表的某个属性进行对比<br>例：查一门课的先修课</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  FIRST.Cno，SECOND.Cpno</span><br><span class="line"><span class="keyword">FROM</span>  Course  <span class="keyword">FIRST</span>，Course  <span class="keyword">SECOND</span></span><br><span class="line"><span class="keyword">WHERE</span> FIRST.Cpno = SECOND.Cno；</span><br></pre></td></tr></table></figure></li></ul><p><img src="/upload/pasted-424.png" alt="upload successful"></p><ul><li><p>外连接<br>外连接就是一种不等值连接，相比于等值连接只输出相等部分的连接情况，这种方式会输出所有的情况两边的所有情况，没有的值则用空替代<br>MySQL并不支持</p></li><li><p>左外连接<br>以左边的为基础，除了相等的部分，还会输出左边不符合条件的，空的地方用null装</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">student.Sno,</span><br><span class="line">Sname,</span><br><span class="line">sex,</span><br><span class="line">Cno,</span><br><span class="line">Grade</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student</span><br><span class="line"><span class="keyword">LEFT</span>  <span class="keyword">JOIN</span> sc <span class="keyword">ON</span> student.sno=sc.sno</span><br></pre></td></tr></table></figure></li></ul><p><img src="/upload/pasted-425.png" alt="upload successful"></p><ul><li>右外连接<br>则是以右边的为基础<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">student.Sno,</span><br><span class="line">Sname,</span><br><span class="line">sex,</span><br><span class="line">Cno,</span><br><span class="line">Grade</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student</span><br><span class="line"><span class="keyword">RIGHT</span>  <span class="keyword">JOIN</span> sc <span class="keyword">ON</span> student.sno=sc.sno</span><br></pre></td></tr></table></figure></li></ul><p><img src="/upload/pasted-426.png" alt="upload successful"></p><h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><p>嵌套查询就是把一些“出处”变成查询结果<br>对于MySQL，嵌套的查询结果要有别名<br>例如 查询与刘晨在一个系学习的学生<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sno,</span><br><span class="line">sname,</span><br><span class="line">sdept</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">s</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sdept <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sdept</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">s</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sname = <span class="string">'刘晨'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">s1.sno,</span><br><span class="line">s1.sname,</span><br><span class="line">s1.sdept</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">s s1,</span><br><span class="line">s s2</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">s1.sdept = s2.sdept</span><br><span class="line"><span class="keyword">AND</span> s2.sname = <span class="string">' 刘晨 '</span></span><br></pre></td></tr></table></figure><p>ANY和ALL<br>any是某一个值，all是所有值，可以大于小于不等于<br>例选择编号01同学的成绩中大于04同学所有科目的成绩的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">sname,</span><br><span class="line">cno,</span><br><span class="line">grade</span><br><span class="line">FROM</span><br><span class="line">(</span><br><span class="line">SELECT</span><br><span class="line">student.Sno,</span><br><span class="line">Sname,</span><br><span class="line">sex,</span><br><span class="line">Cno,</span><br><span class="line">Grade</span><br><span class="line">FROM</span><br><span class="line">student</span><br><span class="line">INNER JOIN sc ON student.sno = sc.sno</span><br><span class="line">) AS a</span><br><span class="line">WHERE</span><br><span class="line">grade &gt; ALL (</span><br><span class="line">SELECT</span><br><span class="line">grade</span><br><span class="line">FROM</span><br><span class="line">sc</span><br><span class="line">WHERE</span><br><span class="line">sno = &apos;01&apos;</span><br><span class="line">) </span><br><span class="line">AND sno = &apos;04&apos;</span><br></pre></td></tr></table></figure></p><p>EXISTS<br>首先要理解这个关键词的运行机制<br>例子：选出选了课程1001的人<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student <span class="keyword">as</span> a</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">EXISTS</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">sc</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sno = a.sno</span><br><span class="line"><span class="keyword">AND</span> cno = <span class="string">'1001'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>使用exist，会对where前面的主查询语句进行逐一校验，对于前面的某一条记录，如果能使exist后的查询语句有返回值（不是空），那么此时exist判定就是true，对于主查询，当前这一条就会作为结果，如果不符合，就不会被作为结果</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/upload/pasted-427.png&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库SQL部分复习（1）【关系模型，关系运算】</title>
    <link href="https://www.junglezero.top/2019/07/16/%E5%BA%93SQL%E9%83%A8%E5%88%86%E5%A4%8D%E4%B9%A0/"/>
    <id>https://www.junglezero.top/2019/07/16/库SQL部分复习/</id>
    <published>2019-07-16T01:47:14.000Z</published>
    <updated>2019-07-17T13:56:27.284Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/upload/pasted-429.png" width="70%"></p><a id="more"></a><hr><h1 id="实体联系模型（E-R）"><a href="#实体联系模型（E-R）" class="headerlink" title="实体联系模型（E-R）"></a>实体联系模型（E-R）</h1><p>实体型之间的联系：一对一联系（１：１）、一对多联系（１：N）、   多对多联系（Ｍ：Ｎ）<br>  例： 假设一个学生可选多门课程，而一门课程又有多个学生选修，每个学生每选一门课只有一个成绩， 一个教师只能讲一门课程，一门课程也可有多个教师讲授，一门课使用多本参考书。画出E－R图。</p><p><img src="/upload/pasted-393.png" alt="upload successful"></p><h1 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h1><p>在用户观点下，关系模型中数据的逻辑结构是一张二维表，它由行和列组成。</p><p><img src="/upload/pasted-392.png" alt="upload successful"><br>关系数据模型的数据结构</p><ul><li>关系（Relation）<br>通常指的是一张表</li><li>元组（Tuple）<br>表中的一行即为一个元组</li><li>属性(attribute)<br>一列即为一个属性</li><li>主码（key）<br>表中的某一个属性组，可以唯一确定一个元组</li><li>域（Domain）<br>属性的取值范围</li><li>分量<br>元组中的一个属性值<h1 id="数据库的三级模式结构"><a href="#数据库的三级模式结构" class="headerlink" title="数据库的三级模式结构"></a>数据库的三级模式结构</h1><h2 id="模式（Schema）"><a href="#模式（Schema）" class="headerlink" title="模式（Schema）"></a>模式（Schema）</h2></li></ul><p><img src="/upload/pasted-394.png" alt="upload successful"><br>模式（也称逻辑模式）<br>数据库中全体数据的逻辑结构和特征的描述<br>所有用户的公共数据视图，综合了所有用户的需求<br>一个数据库只有一个模式<br>模式的地位：是数据库系统模式结构的中间层<br>与数据的物理存储细节和硬件环境无关<br>与具体的应用程序、开发工具及高级程序设计语言无关<br>模式的定义：<br>数据的逻辑结构（数据项的名字、类型、取值范围等）<br>数据之间的联系<br>数据有关的安全性、完整性要求</p><h3 id="外模式-External-Schema"><a href="#外模式-External-Schema" class="headerlink" title="外模式(External Schema)"></a>外模式(External Schema)</h3><p>外模式（也称子模式或用户模式）<br>数据库用户（包括应用程序员和最终用户）使用的局部数据的逻辑结构和特征的描述<br>数据库用户的数据视图，是与某一应用有关的数据的逻辑表示<br>模式与外模式的关系：一对多<br>通常是模式的子集；一个数据库可以有多个外模式<br>外模式与应用的关系：一对多<br>同一外模式可以为某一用户的多个应用系统所使用，<br>但一个应用程序只能使用一个外模式<br>外模式是保证数据库安全性的一个有力措施<br>每个用户只能看见和访问所对应的外模式中的数据</p><h3 id="内模式（Internal-Schema）"><a href="#内模式（Internal-Schema）" class="headerlink" title="内模式（Internal Schema）"></a>内模式（Internal Schema）</h3><p>是数据物理结构和存储方式的描述<br>是数据在数据库内部的表示方式<br>记录的存储方式（顺序存储，按照B树结构存储，按hash方法存储）/ 索引的组织方式 / 数据是否压缩存储 / 数据是否加密 / 数据存储记录结构的规定<br>一个数据库只有一个内模式</p><h1 id="关系模型和关系"><a href="#关系模型和关系" class="headerlink" title="关系模型和关系"></a>关系模型和关系</h1><p>关系模型的数据结构非常简单，只包含单一的数据结构—-关系。在关系模型中，实体和实体间的各种联系都用关系表示。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>域（Domain）<br>一组具有相同数据类型的值的集合</li><li>笛卡尔积（Cartesian Product）<br><img src="/upload/pasted-395.png" alt="upload successful"></li></ul><p><img src="/upload/pasted-396.png" alt="upload successful"><br>笛卡尔积的每一个结果(d1,d2,d3,d4)被称为元组（Tuple）;<br>笛卡尔积的每一个结果中的具体的值di叫做一个分量（Component）<br>笛卡尔积做出的结果的元组数是基数（Cardinal number）</p><ul><li>关系<br><img src="/upload/pasted-397.png" alt="upload successful"></li><li>属性<br>每列的名字</li><li>码<ul><li>候选码（Candidate key）<br>若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选码<br>在最简单的情况下，候选码只包含一个属性。<br>在最极端的情况下，关系模式的所有属性组是这个关系模式的候选码，称为全码（All-key）</li><li>主码<br>若一个关系有多个候选码，则选定其中一个为主码（Primary key）<br>侯选码的诸属性称为主属性（Prime attribute）。<br>不包含在任何侯选码中的属性称为非码属性（Non-key attribute） </li></ul></li></ul><h2 id="三类关系"><a href="#三类关系" class="headerlink" title="三类关系"></a>三类关系</h2><p><img src="/upload/pasted-398.png" alt="upload successful"></p><h2 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h2><p><img src="/upload/pasted-399.png" alt="upload successful"></p><p><img src="/upload/pasted-400.png" alt="upload successful"></p><h2 id="关系的基本运算"><a href="#关系的基本运算" class="headerlink" title="关系的基本运算"></a>关系的基本运算</h2><p>设两个关系R,S：有相同的目n，相应的属性取自同一个域</p><ul><li>选择</li></ul><p><img src="/upload/pasted-406.png" alt="upload successful"></p><p><img src="/upload/pasted-407.png" alt="upload successful"></p><ul><li>投影</li></ul><p><img src="/upload/pasted-408.png" alt="upload successful"></p><ul><li>并<br>R∪S = { t|t Î R∨t ÎS }</li></ul><p><img src="/upload/pasted-402.png" alt="upload successful"></p><ul><li>差<br>R -S = { t|tÎR∧tÏS }<br><img src="/upload/pasted-403.png" alt="upload successful"></li><li>笛卡尔积</li></ul><p><img src="/upload/pasted-404.png" alt="upload successful"></p><p><img src="/upload/pasted-405.png" alt="upload successful"></p><ul><li>交<br>R∩S = { t|t Î R∧t ÎS }<br>R∩S = R –(R-S）</li><li>连接<br><img src="/upload/pasted-409.png" alt="upload successful"><br><img src="/upload/pasted-410.png" alt="upload successful"><br>有两类连接，包括等值连接和自然连接<br>等值连接<br><img src="/upload/pasted-411.png" alt="upload successful"><br>自然连接<br><img src="/upload/pasted-412.png" alt="upload successful"><br>相当于是一种合并<br><img src="/upload/pasted-413.png" alt="upload successful"></li></ul><h2 id="实体完整性（Entity-Integrity）"><a href="#实体完整性（Entity-Integrity）" class="headerlink" title="实体完整性（Entity Integrity）"></a>实体完整性（Entity Integrity）</h2><p>若属性A是基本关系R的主属性，则属性A不能取空值</p><h2 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h2><p>设F是基本关系R的一个或一组属性，但不是关系R的码。如果F与基本关系S的主码Ks相对应，则称F是基本关系R的外码，基本关系R称为参照关系（Referencing Relation）<br>基本关系S称为被参照关系（Reference Relation）或目标关系（Target  Relation）<br>若属性（或属性组）F是基本关系R的外码<br>它与基本关系S的主码Ks相对应（基本关<br>系R和S不一定是不同的关系），则对<br>于R中每个元组在F上的值必须为：<br>· 或者取空值（F的每个属性值均为空值）<br>· 或者等于S中某个元组的主码值。</p><p><img src="/upload/pasted-401.png" alt="upload successful"><br>用人话来说，就是外键不能是自己造出来的</p><h2 id="关系代数运算题目实例"><a href="#关系代数运算题目实例" class="headerlink" title="关系代数运算题目实例"></a>关系代数运算题目实例</h2><p>设教学数据库有3个关系<br>学生关系 S（Sno，Sname，age，sex）<br>成绩关系 SC（Sno，Cno，grade）<br>课程关系 C（Cno，Cname，teacher）</p><ol><li>LIU老师所教授课程的课程号，课程名<br>∏CNO,CNAME(σTNAME=‘LIU’ （C））</li><li>检索年龄大于23岁的男学生的学号和姓名<br>∏SNO,SNAME（ σ AGE&gt;23 ∧ SEX=‘M’（S））</li><li>检索学号为S3学生所学课程的课程名与任课老师名<br> ∏CNAME,TNAME（ σ SNO=‘S3’（SC）∞(C)）</li><li>检索至少选修LIU老师所教授课程中一门课的女学生姓名<br>  ∏SNAME(σSEX=‘F’(S)∞SC∞σTNAME=‘LIU’(C))</li><li>检索wang同学不学课程的课程号<br> ∏CNO(C)-∏CNO(σSNAME=‘WANG’(S)∞SC)</li><li>检索至少选修两门课的学生学号<br>∏1(σ1=4 ∧ 2!=5(SC × SC))</li><li>检索全部学生都选修的课程的课程号和课程名<br> ∏CNO,CNAME,SNO(C ∞SC) ÷ ∏SNO(S)</li><li>检索选修课程包含LIU老师所教授课程的学生学号<br>∏CNO,SNO(SC) ÷ ∏CNO(σTNAME=‘LIU’(C))</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/upload/pasted-429.png&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java多线程学习8（线程池，阻塞队列（BlockingQueue）FutureTask,Callable）</title>
    <link href="https://www.junglezero.top/2019/07/12/va-mitple-thread8/"/>
    <id>https://www.junglezero.top/2019/07/12/va-mitple-thread8/</id>
    <published>2019-07-12T12:21:40.000Z</published>
    <updated>2019-07-17T13:54:47.374Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/upload/pasted-428.png" width="70%"></p><a id="more"></a><hr><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2><h3 id="框架简介"><a href="#框架简介" class="headerlink" title="框架简介"></a>框架简介</h3><p><img src="/upload/pasted-367.png" alt="upload successful"><br>而具体说来，Executor是一个接口，对于这个接口，API文档是这样描述的。</p><blockquote><p>An object that executes submitted Runnable tasks. This interface provides a way of decoupling task submission from the mechanics of how each task will be run, including details of thread use, scheduling, etc. An Executor is normally used instead of explicitly creating threads.</p></blockquote><p>第一句话强调了这个的用法就是提交任务，并通过Executor来运行，可以用Executor来替代显示的调用Thread，把实现任务的细节封装。<br>对于该接口，可以直接在调用线程运行任务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirectExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    r.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一般则是另起线程运行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以构造一个组件化的Executor,把任务的执行序列化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前类继承一个Executor</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Queue&lt;Runnable&gt; tasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</span><br><span class="line">   <span class="keyword">final</span> Executor executor;</span><br><span class="line">   Runnable active;</span><br><span class="line"></span><br><span class="line">   SerialExecutor(Executor executor) &#123;</span><br><span class="line">     <span class="keyword">this</span>.executor = executor;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</span><br><span class="line">     tasks.offer(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">           r.run();</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           scheduleNext();</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="keyword">if</span> (active == <span class="keyword">null</span>) &#123;</span><br><span class="line">       scheduleNext();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> ((active = tasks.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">       executor.execute(active);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>说来说去，Executor不过是提供了一个接口，一种线程服务的思路，具体的线程复杂操作还是要看他的各个实现类<br>和继承接口</p><p><img src="/upload/pasted-368.png" alt="upload successful"><br>这才是整个Executor的体系框架</p><h2 id="BlockingQueue（阻塞队列）"><a href="#BlockingQueue（阻塞队列）" class="headerlink" title="BlockingQueue（阻塞队列）"></a>BlockingQueue（阻塞队列）</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>所谓阻塞队列，就是比一般队列多了两个操作的队列</p><p><img src="/upload/pasted-370.png" alt="upload successful"></p><p><img src="/upload/pasted-371.png" alt="upload successful"></p><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><h3 id="七个属性"><a href="#七个属性" class="headerlink" title="七个属性"></a>七个属性</h3><p> 结合自已以前实现的一个<a href="https://www.junglezero.top/2019/04/02/%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/">线程池</a>，对于其大概的属性已经有了初步了解。<br> 从ThreadPoolExecutor的构造函数开始看起，有四个重载的构造函数，找到其中参数最多的那个</p><p><img src="/upload/pasted-369.png" alt="upload successful"><br>和以前自己的实现的思路基本差不多：<br>核心线程数量、最大线程数量、多余线程存活时间（相比于核心线程多出来的线程在空闲时的存活时间）、时间单位、任务队列(阻塞队列)、线程工厂方法、拒绝策略</p><p>可以用以下的测试理解这几个属性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> TestMain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor= (ThreadPoolExecutor) buildThreadPool();</span><br><span class="line">        <span class="keyword">int</span> activeCount=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> queueSize=-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//线程池执行一个任务（Runable）</span></span><br><span class="line">        threadPoolExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                DoingJobs(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程池执行两个任务（Runable）</span></span><br><span class="line">        threadPoolExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                DoingJobs(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//。。。</span></span><br><span class="line">        <span class="comment">//当活跃线程数量发生改变时输出</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (activeCount!=threadPoolExecutor.getActiveCount()||queueSize!=threadPoolExecutor.getQueue().size())&#123;</span><br><span class="line">                System.out.println(<span class="string">"线程池中活跃线程数量："</span>+threadPoolExecutor.getActiveCount());</span><br><span class="line">                System.out.println(<span class="string">"核心线程数量（固定的）："</span>+threadPoolExecutor.getCorePoolSize());</span><br><span class="line">                System.out.println(<span class="string">"任务队列中等待执行的任务数量："</span>+threadPoolExecutor.getQueue().size());</span><br><span class="line">                activeCount=threadPoolExecutor.getActiveCount();</span><br><span class="line">                queueSize=threadPoolExecutor.getQueue().size();</span><br><span class="line">                System.out.println(<span class="string">"================================"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">buildThreadPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//核心线程数为1，最大线程池为2，存活时间为10s，阻塞队列（任务队列）的大小为1</span></span><br><span class="line">        ExecutorService executorService=<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                Thread t=<span class="keyword">new</span> Thread(r);</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">        System.out.println(<span class="string">"线程池创建成功！"</span>);</span><br><span class="line">        <span class="keyword">return</span> executorService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用Sleep来模拟线程运行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoingJobs</span><span class="params">(<span class="keyword">long</span> seconds)</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"正在执行任务"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(seconds);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当任务为1个时</p><p><img src="/upload/pasted-373.png" alt="upload successful"></p><p>当任务为2时</p><p><img src="/upload/pasted-372.png" alt="upload successful"><br>可以发现，当任务为2时，线程池并没有创建新的线程，因为任务可以在队列中等待</p><p>当任务为3时，此时把测试方法中的活跃线程数量改为线程池大小（线程中线程的数量）</p><p><img src="/upload/pasted-374.png" alt="upload successful"><br>可以发现，当任务队列慢的时候，再有新的任务加入，线程池就会根据最大线程数量创建新的线程共同执行任务，当任务队列中没有任务时，过了存回时间，多创建出的线程就会被销毁。</p><p>当任务有4个时</p><p><img src="/upload/pasted-375.png" alt="upload successful"><br>此时多出一个任务，无法进入阻塞队列，也无法执行，拒绝策略生效。</p><h2 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h2><p>线程池的关闭涉及到三个方法</p><p><img src="/upload/pasted-376.png" alt="upload successful"></p><p><img src="/upload/pasted-377.png" alt="upload successful"></p><p><img src="/upload/pasted-378.png" alt="upload successful"><br>通过测试可以发现<br>shutdown方法：平滑的关闭ExecutorService，当此方法被调用时，ExecutorService停止接收新的任务并且等待已经提交的任务（包含提交正在执行和提交未执行）执行完成。<br>当所有已提交任务执行完毕，线程池即被关闭。<br>awaitTermination方法：接收timeout和unit两个参数，用于设定超时时间及单位。当等待超过设定时间时，会监测ExecutorService是否已经关闭，<br>若关闭则返回true，否则返回false。一般情况下会和shutdown方法组合使用。<br>shutdown调用后，不可以再submit新的task，已经submit的将继续执行。<br>shutdownNow试图停止当前正执行的task，并返回尚未执行的task的list</p><p>因此最好的关闭线程池的方式是shutdown+awaitTermination</p><h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><p>Executors是一个工厂类<br>其中包括了许多关于线程池及Executors框架相关的创建方法<br>毕竟拿七个参数创建一个线程池太复杂了<br><img src="/upload/pasted-379.png" alt="upload successful"></p><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><blockquote><p>Creates a thread pool that creates new threads as needed, but will reuse previously constructed threads when they are available. These pools will typically improve the performance of programs that execute many short-lived asynchronous tasks. Calls to execute will reuse previously constructed threads if available. If no existing thread is available, a new thread will be created and added to the pool. Threads that have not been used for sixty seconds are terminated and removed from the cache. Thus, a pool that remains idle for long enough will not consume any resources. Note that pools with similar properties but different details (for example, timeout parameters) may be created using ThreadPoolExecutor constructors.</p></blockquote><p>这种线程池的特点就是按照需求创建线程以处理更多的耗时短的异步任务<br>看其具体实现就可以知道<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，这个线程池一开始核心线程就是0，最大线程数量却相当于没有限制，存活时间为1分钟，这就很好的印证了按需分配创建线程的思路。而关键还是在这个阻塞队列上<br>SynchronousQueue是一种很特殊的阻塞队列，其中每个 put 必须等待一个 take，否则会进入wait状态反之亦然。同步队列没有任何内部容量，甚至连一个队列的容量都没有。<br>使用完成后不需要显示的调用shotdown<br>注意：仅适合周期短的多任务，因为创建线程的数量是没用限制的</p><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顾名思义，这是一种固定线程数量的线程池，不会额外去创建，阻塞队列采用LinkedBlockingQueue,是以链表为内核实现的阻塞队列，默认大小为Integar.Max<br>使用完成后需要shutdown</p><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">    (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                            <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br></pre></td></tr></table></figure><p>这个实际上就是newFixedThreadPool线程数量设置为1的时候</p><h3 id="newWorkStealingPool"><a href="#newWorkStealingPool" class="headerlink" title="newWorkStealingPool"></a>newWorkStealingPool</h3><p>这是在1.8新出的一种线程池服务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">        (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种服务是根据cpu个数创建的ForkJoinPool,根据前面讲的，ForkJoinPool中执行的是ForkJoinTask，Runable是不行的<br>看源码可以知道，传入Runable以后，会执行一个内部的转换</p><p>这种线程数量的确定和创建时是根据电脑根据cpu个数创建的（等于）<br>工作窃取概念：所谓工作窃取，指的是闲置的线程去处理本不属于它的任务。<br>每个处理器核，都有一个队列存储着需要完成的任务。对于多核的机器来说，当一个核对应的任务处理完毕后，就可以去帮助其他的核处理任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    ForkJoinTask&lt;?&gt; job;</span><br><span class="line">    <span class="keyword">if</span> (task <span class="keyword">instanceof</span> ForkJoinTask&lt;?&gt;) <span class="comment">// avoid re-wrap</span></span><br><span class="line">        job = (ForkJoinTask&lt;?&gt;) task;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        job = <span class="keyword">new</span> ForkJoinTask.RunnableExecuteAction(task);</span><br><span class="line">    externalSubmit(job);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在用Callable来执行（线程的第三种实现方法）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorsTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService =Executors.newWorkStealingPool();</span><br><span class="line">        System.out.println(executorService.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">         <span class="comment">//这里可以先把Callable当成是有返回值的Runable</span></span><br><span class="line">        List&lt;Callable&lt;String&gt;&gt; callables=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> ( ;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">            Callable&lt;String&gt; callable=<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="comment">//call方法就相当于Run方法</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                    sleep(<span class="number">2</span>);</span><br><span class="line">                    <span class="comment">//可以有返回值</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"任务被"</span>+Thread.currentThread().getName();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">             callables.add(callable);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//批量运行，且将返回运行结果Future</span></span><br><span class="line">            List&lt;Future&lt;String&gt;&gt; futures=executorService.invokeAll(callables);</span><br><span class="line">            <span class="comment">//若是没有执行完，这里会是堵塞的</span></span><br><span class="line">            <span class="keyword">for</span> (Future f:futures)&#123;</span><br><span class="line">                System.out.println(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> seconds)</span></span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           TimeUnit.SECONDS.sleep(seconds);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><p><img src="/upload/pasted-381.png" alt="upload successful"><br>可以发现，这种线程池服务也是自动退出的</p><h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor。它主要用来在给定的延迟之后运行任务，或者定期执行任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolExecutorDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个实现了Runable的时间任务类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String id;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TimerTask</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        ScheduledExecutorService ses = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//调用scheduleAtFixedRate来进行周期执行，拿第一个来说，开始时延是200ms，周期为1000ms</span></span><br><span class="line">        ScheduledFuture sfa = ses.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask(<span class="string">"a"</span>), <span class="number">200</span>,</span><br><span class="line">                                                    <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        ScheduledFuture sfb = ses.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask(<span class="string">"b"</span>), <span class="number">400</span>, </span><br><span class="line">                                                    <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        ScheduledFuture sfc = ses.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask(<span class="string">"c"</span>), <span class="number">600</span>,</span><br><span class="line">                                                    <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        ScheduledFuture sfd = ses.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask(<span class="string">"d"</span>), <span class="number">800</span>, </span><br><span class="line">                                                    <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        sfa.cancel(<span class="keyword">true</span>);</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        ses.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程运行时发生错误的处理"><a href="#线程运行时发生错误的处理" class="headerlink" title="线程运行时发生错误的处理"></a>线程运行时发生错误的处理</h2><p>一般情况下，可以<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread t=<span class="keyword">new</span> Thread();</span><br><span class="line">t.setUncaughtExceptionHandler(<span class="keyword">new</span> Thread.UncaughtExceptionHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(t.getName()+<span class="string">"运行时发生错误~！"</span>);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>如果线程的实现不是自己定义的<br>如果是=自己定义的，则可以定义内部方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Error</span><span class="params">(Throwable e)</span></span>&#123;</span><br><span class="line">     System.out.println(<span class="string">"当前线程发生错误"</span>);</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="拒绝策略细节"><a href="#拒绝策略细节" class="headerlink" title="拒绝策略细节"></a>拒绝策略细节</h2><h3 id="ThreadPoolExecutor-AbortPolicy"><a href="#ThreadPoolExecutor-AbortPolicy" class="headerlink" title="ThreadPoolExecutor.AbortPolicy()"></a>ThreadPoolExecutor.AbortPolicy()</h3><p>这个策略中，不能执行且不能进入阻塞队列的任务会直接被抛出异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p><img src="/upload/pasted-382.png" alt="upload successful"></p><h3 id="new-ThreadPoolExecutor-DiscardPolicy"><a href="#new-ThreadPoolExecutor-DiscardPolicy" class="headerlink" title="new ThreadPoolExecutor.DiscardPolicy()"></a>new ThreadPoolExecutor.DiscardPolicy()</h3><p>这个拒绝策略则不会做出任何事</p><h3 id="ThreadPoolExecutor-CallerRunsPolicy"><a href="#ThreadPoolExecutor-CallerRunsPolicy" class="headerlink" title="ThreadPoolExecutor.CallerRunsPolicy()"></a>ThreadPoolExecutor.CallerRunsPolicy()</h3><p>这个策略会在execute 方法的调用线程中运行被拒绝的任务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line"></span><br><span class="line">               r.run();</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><p><img src="/upload/pasted-383.png" alt="upload successful"></p><h3 id="ThreadPoolExecutor-DiscardOldestPolicy"><a href="#ThreadPoolExecutor-DiscardOldestPolicy" class="headerlink" title="ThreadPoolExecutor.DiscardOldestPolicy()"></a>ThreadPoolExecutor.DiscardOldestPolicy()</h3><p>这个方法会把阻塞队列的队尾元素去除，然后执行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line"></span><br><span class="line">        e.getQueue().poll();</span><br><span class="line"></span><br><span class="line">        e.execute(r);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="ExecutorService-几个其他方法"><a href="#ExecutorService-几个其他方法" class="headerlink" title="ExecutorService 几个其他方法"></a>ExecutorService 几个其他方法</h2><h3 id="invokeAny"><a href="#invokeAny" class="headerlink" title="invokeAny"></a>invokeAny</h3><p>测试方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">testInvokeAny</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ExecutorService executorService= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    List&lt;Callable&lt;Integer&gt;&gt; callables=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//创建5个Callable</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        Callable&lt;Integer&gt; callable= <span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">//先进入随机的sleep</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>));</span><br><span class="line">                <span class="comment">//输出语句</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//放入集合中</span></span><br><span class="line">        callables.add(callable);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//输出invokeany的结果</span></span><br><span class="line">        System.out.println(executorService.invokeAny(callables));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><p><img src="/upload/pasted-384.png" alt="upload successful"><br>也就是说，运行invokeany，当运行的那一个任务运行完毕后，会取消掉其他正在运行的任务<br>注意：这个方法是一个阻塞方法，也就是说只有选定的某个任务执行完成，才会有返回值，否则会一直陷入阻塞状态<br>另外，该方法的重载方法还可以添加TimeOut,超过TimeOut时间，其他任务取消运行。抛出Timeout异常。</p><h3 id="invokeAll"><a href="#invokeAll" class="headerlink" title="invokeAll"></a>invokeAll</h3><p><img src="/upload/pasted-385.png" alt="upload successful"><br>这个方法也是一个阻塞方法</p><h3 id="submit-Runable"><a href="#submit-Runable" class="headerlink" title="submit(Runable)"></a>submit(Runable)</h3><p><img src="/upload/pasted-386.png" alt="upload successful"><br>这个方法可以返回一个结果值，但是由于Runable没有返回值所以可以手动传入一个值作为返回值（Future）</p><h1 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h1><p>Future是一个接口</p><blockquote><p>A Future represents the result of an asynchronous computation. Methods are provided to check if the computation is complete, to wait for its completion, and to retrieve the result of the computation. The result can only be retrieved using method get when the computation has completed, blocking if necessary until it is ready. Cancellation is performed by the cancel method. Additional methods are provided to determine if the task completed normally or was cancelled. Once a computation has completed, the computation cannot be cancelled. If you would like to use a Future for the sake of cancellability but not provide a usable result, you can declare types of the form Future&lt;?&gt; and return null as a result of the underlying task. </p></blockquote><p>future可以理解为一个票据，表示一个某个任务的结果，我们不是非要等到这个任务执行完毕才能进行别的任务，我们，我们可以在这个任务执行时，先去执行别的任务，等到这个任务执行完毕，再通过future获得任务的结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        Callable&lt;String&gt; longTimeJob=<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"长时工作完成"</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Callable&lt;String&gt; shotTimeJob=<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"短时工作完成"</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Future&lt;String&gt; res1=executorService.submit(longTimeJob);</span><br><span class="line">        Future&lt;String&gt; res2=executorService.submit(shotTimeJob);</span><br><span class="line">        System.out.println(res1);</span><br><span class="line">        System.out.println(res2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Future的方法"><a href="#Future的方法" class="headerlink" title="Future的方法"></a>Future的方法</h2><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p>Waits if necessary for the computation to complete, and then retrieves its result.<br>也就是说，通过票据Future获得线程的运行结果（Callable），会使线程陷入阻塞（会使调用get方法的线程进入阻塞,和线程池执行任务的线程无关）<br>比如(res1是长时任务的结果)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"主线程！！！！"</span>);</span><br><span class="line">    System.out.println(res1.get());</span><br><span class="line">    System.out.println(<span class="string">"&gt;?&gt;&gt;?&gt;&gt;&gt;?&gt;"</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果输出:</p><p><img src="/upload/pasted-387.png" alt="upload successful"><br>重载方法中，有一个TimeOut的参数，若调用get超时，则调用get方法的线程会抛timeout异常，但是未完成的任务仍然会继续进行。</p><h3 id="isDone"><a href="#isDone" class="headerlink" title="isDone"></a>isDone</h3><p><img src="/upload/pasted-389.png" alt="upload successful"><br>任务完成了，返回true；任务没完成，出现了异常，任务不能再继续做了，返回true，任务在做了，返回false</p><h3 id="cancle"><a href="#cancle" class="headerlink" title="cancle"></a>cancle</h3><p><img src="/upload/pasted-390.png" alt="upload successful"><br>如果取消任务成功则返回true，如果取消任务失败则返回false。参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。</p><h1 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h1><p>FutureTask是Runable和Future的实现类（是Future的唯一实现）<br>所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    ExecutorService executorService= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    Thread doingLong=<span class="keyword">null</span>;</span><br><span class="line">    FutureTask&lt;String&gt; futureTask=<span class="keyword">new</span> FutureTask&lt;String&gt;(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"任务任务任务"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    executorService.submit(futureTask);</span><br><span class="line">    System.out.println(futureTask.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h1><p>铺垫了这么多，Callable也就很好理解了，</p><p><img src="/upload/pasted-391.png" alt="upload successful"><br>Callable和Runable类似，但是它却可以有返回值</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/upload/pasted-428.png&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java多线程学习7（Exchanger,StampedLock,Fork/join,Phaser）</title>
    <link href="https://www.junglezero.top/2019/07/09/java-mutiple-threading-7/"/>
    <id>https://www.junglezero.top/2019/07/09/java-mutiple-threading-7/</id>
    <published>2019-07-09T03:36:52.000Z</published>
    <updated>2019-07-12T04:37:33.974Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/upload/pasted-356.png" width="70%"></p><a id="more"></a><hr><h1 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>A synchronization point at which threads can pair and swap elements within pairs. Each thread presents some object on entry to the exchange method, matches with a partner thread, and receives its partner’s object on return. An Exchanger may be viewed as a bidirectional form of a SynchronousQueue. Exchangers may be useful in applications such as genetic algorithms and pipeline designs. </p></blockquote><p>主要内容：提供一个同步点，使一对线程交换数据，可以使用在遗传算法和管道设计上</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><img src="/upload/pasted-351.png" alt="upload successful"><br>简要来说就是调用该方法的线程会进入等待状态，等待其他线程调用，若有其他线程调用，则交换两者数据（把参数中的object传过去，返回传回来的object），注意一个及时性，即使调用该方法后休眠，也不会影响交换，若非特殊情况下的阻断，则调用该方法会一直等下去，<br>若有超过两个线程都调用exchange方法，则先到交换点（先调用方法）的两个线程会交换数据，若第三个线程调用，则会等待第四个线程调用来交换数据</p><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Exchanger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置交换器</span></span><br><span class="line">        <span class="keyword">final</span> Exchanger&lt;String&gt; exchanger=<span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"开始运行。"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//模拟为该线程有的数据</span></span><br><span class="line">                    String myData=<span class="string">"123456789"</span>;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"交换之前的数据:"</span>+myData);</span><br><span class="line">                    <span class="comment">//调用交换器的exchange方法，并返回交换的结果（进入交换点等待另一个线程调用该方法）</span></span><br><span class="line">                    String exchangeResult=exchanger.exchange(myData);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"交换之后的数据:"</span>+exchangeResult);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"结束。"</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"开始运行。"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String myData=<span class="string">"987654321"</span>;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"交换之前的数据:"</span>+myData);</span><br><span class="line">                    String exchangeResult=exchanger.exchange(myData);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"交换之后的数据:"</span>+exchangeResult);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"结束。"</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="/upload/pasted-352.png" alt="upload successful"></p><h1 id="StamperdLock"><a href="#StamperdLock" class="headerlink" title="StamperdLock"></a>StamperdLock</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>这是java1.8新增加的锁（在JUC中），是对ReentrantReadWriteLock锁的一种改进:基于读的乐观锁<br>在Optimistic reading中，即使读线程获取到了读锁，写线程尝试获取写锁也不会阻塞，这相当于对读模式的优化，但是可能会导致数据不一致的问题。所以，当使用Optimistic reading获取到读锁时，必须对获取结果进行校验。<br>注意：StampededLock不支持重入</p><p><img src="/upload/pasted-353.png" alt="upload successful"></p><p>这里有一篇<a href="https://blog.overops.com/java-8-stampedlocks-vs-readwritelocks-and-synchronized/" target="_blank" rel="noopener">文章</a>,在这片文章中，作者讨论了synchronized,StampedLocks,和RWlock的效率对比，可以发现当读线程远多于写线程时，乐观锁的效率是最高的。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>可以使用StampededLock直接替代reentrantreadwritelock<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.StampedLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLockTest</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> StampedLock lock=<span class="keyword">new</span> StampedLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> List&lt;Long&gt; DATA=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ExecutorService executorService= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        Runnable readTask=<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (;;)</span><br><span class="line">                    read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable writeTask =<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (;;)</span><br><span class="line">                    write();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(writeTask);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//悲观式读取</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamped=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamped=lock.readLock();</span><br><span class="line">            <span class="comment">//模拟读取数据</span></span><br><span class="line">            System.out.println(DATA.toString());</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlockRead(stamped);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamp=lock.writeLock();</span><br><span class="line">            DATA.add(System.currentTimeMillis());</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而这个锁的改进就是对读加上乐观锁<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> stamped = lock.tryOptimisticRead();</span><br><span class="line">    <span class="keyword">if</span> (lock.validate(stamped)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamped = lock.readLock();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Fork-join"><a href="#Fork-join" class="headerlink" title="Fork/join"></a>Fork/join</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>Fork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。<br>Fork就是把一个大任务切分为若干子任务并行的执行，Join就是合并这些子任务的执行结果，最后得到这个大任务的结果<br>ForkJoinTask是轻量级的线程形式<br><img src="/upload/pasted-354.png" alt="upload successful"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>一般是使用ForkJoinTask 的继承类RecursiveAction（无返回值）和RecursiveTask（有返回值），并且依附在ForkJoinPool上进行使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分割任务的最大阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_THRSHOLD=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ForkJoinPool forkJoinPool=<span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        <span class="comment">//把ForkJoinTask提交ForkJoinPool进行运行</span></span><br><span class="line">        <span class="comment">//计算范围为0到10</span></span><br><span class="line">        ForkJoinTask&lt;Integer&gt; future=forkJoinPool.submit(<span class="keyword">new</span> ComputeRecursiveTask(<span class="number">0</span>,<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer result=<span class="number">0</span>;</span><br><span class="line">            result=future.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算的Fork/join线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputeRecursiveTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算的起始和终点</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> start;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">ComputeRecursiveTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//当发现起始和终点的相差的小于阈值时</span></span><br><span class="line">            <span class="keyword">if</span> (end-start&lt;=MAX_THRSHOLD)&#123;</span><br><span class="line">                <span class="comment">//直接计算返回结果，这里模拟的的是累加</span></span><br><span class="line">                <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">                    result+=i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//将起始到终点二分，分成两个子部分</span></span><br><span class="line">                <span class="keyword">int</span> middle=(start-end);</span><br><span class="line">                ComputeRecursiveTask leftRecursiveTask=<span class="keyword">new</span> ComputeRecursiveTask(start,middle);</span><br><span class="line">                ComputeRecursiveTask rightRecursiveTask=<span class="keyword">new</span> ComputeRecursiveTask(middle,end);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//调用fork进行执行</span></span><br><span class="line">                leftRecursiveTask.fork();</span><br><span class="line">                rightRecursiveTask.fork();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//最终的结果就是两个join</span></span><br><span class="line">                <span class="keyword">return</span> leftRecursiveTask.join()+rightRecursiveTask.join();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>文档讲到，这是一个可复用的同步器栅栏，可以理解为时CyclicBarrier和CountDownLatch的一个升级版<br>Phaser类机制是在每一步结束的位置对线程进行同步，当所有的线程都完成了这一步，才能进行下一步。<br>用来解决控制多个线程分阶段共同完成任务的情景问题。<br>当有并发任务并且需要分解成几步执行的时候，这种机制就非常适合。<br>CyclicBarrier CountDownLatch 只能在构造时指定参与量，而phaser可以动态的增减参与量<br>且Phaser支持父子结构，可以用在fork/join框架中</p><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><p><img src="/upload/pasted-358.png" alt="upload successful"></p><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>API中给到的几个使用例子<br>可以替代CountDownLatch来执行只需运行一次的线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runTasks</span><span class="params">(List&lt;Runnable&gt; tasks)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Phaser phaser = <span class="keyword">new</span> Phaser(<span class="number">1</span>); <span class="comment">// 参数为1，表示phaser计数为1</span></span><br><span class="line">   <span class="comment">// 创建并开始线程</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">final</span> Runnable task : tasks) &#123;</span><br><span class="line">   <span class="comment">//phaser添加一个新的运行部分</span></span><br><span class="line">     phaser.register();</span><br><span class="line">     <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         phaser.arriveAndAwaitAdvance(); <span class="comment">// await all creation</span></span><br><span class="line">         task.run();</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;.start();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//允许线程开始执行并在运行结束后注销（一次执行），不等着其他线程</span></span><br><span class="line">   phaser.arriveAndDeregister();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>重复执行一系列线程：重写onAdvance方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startTasks</span><span class="params">(List&lt;Runnable&gt; tasks, <span class="keyword">final</span> <span class="keyword">int</span> iterations)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Phaser phaser = <span class="keyword">new</span> Phaser() &#123;</span><br><span class="line">   <span class="comment">//重写该方法，来确定phaser的终止条件（返回true 表示终止）</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> phase &gt;= iterations || registeredParties == <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   phaser.register();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">final</span> Runnable task : tasks) &#123;</span><br><span class="line">     phaser.register();</span><br><span class="line">     <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">do</span> &#123;</span><br><span class="line">           task.run();</span><br><span class="line">           phaser.arriveAndAwaitAdvance();</span><br><span class="line">         &#125; <span class="keyword">while</span> (!phaser.isTerminated());</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;.start();</span><br><span class="line">   &#125;</span><br><span class="line">   phaser.arriveAndDeregister(); <span class="comment">// deregister self, don't wait</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>自己写的例子：模仿CyclicBarrier<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Phaser;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhaserTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Phaser phaser=<span class="keyword">new</span> Phaser();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            Task a=<span class="keyword">new</span> Task(phaser);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将主线程运行块加入phaser</span></span><br><span class="line">        phaser.register();</span><br><span class="line">        phaser.arriveAndAwaitAdvance();</span><br><span class="line">        System.out.println(<span class="string">"全部线程全部完成"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Phaser taskPhaser;</span><br><span class="line">        Task(Phaser phaser)&#123;</span><br><span class="line">            taskPhaser=phaser;</span><br><span class="line">            <span class="comment">//新添加一个运行块</span></span><br><span class="line">            phaser.register();</span><br><span class="line">            <span class="comment">//直接运行</span></span><br><span class="line">            start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"正在工作中》》》》》"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//线程到达并等待运行</span></span><br><span class="line">            taskPhaser.arriveAndAwaitAdvance();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><img src="/upload/pasted-359.png" alt="upload successful"></p><p>多个线程分阶段共同完成任务:完成铁人三项<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Phaser;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhaserTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Phaser phaser=<span class="keyword">new</span> Phaser(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Athletes(i,phaser).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Athletes</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Phaser phaser;</span><br><span class="line"></span><br><span class="line">        Athletes(<span class="keyword">int</span> num,Phaser phaser)&#123;</span><br><span class="line">            <span class="keyword">this</span>.num=num;</span><br><span class="line">            <span class="keyword">this</span>.phaser=phaser;</span><br><span class="line">            <span class="comment">//phaser.register();</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"No."</span>+num+<span class="string">"开始跑了"</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>));</span><br><span class="line">                System.out.println(<span class="string">"No."</span>+num+<span class="string">"跑到头了"</span>);</span><br><span class="line"></span><br><span class="line">                phaser.arriveAndAwaitAdvance();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"No."</span>+num+<span class="string">"开始游泳了"</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>));</span><br><span class="line">                System.out.println(<span class="string">"No."</span>+num+<span class="string">"游泳到头了"</span>);</span><br><span class="line"></span><br><span class="line">                phaser.arriveAndAwaitAdvance();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"No."</span>+num+<span class="string">"开始骑自行车了"</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>));</span><br><span class="line">                System.out.println(<span class="string">"No."</span>+num+<span class="string">"骑自行车到头了"</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><img src="/upload/pasted-360.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/upload/pasted-356.png&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java语言基础知识和其他应该知道的东西</title>
    <link href="https://www.junglezero.top/2019/07/06/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://www.junglezero.top/2019/07/06/Java语言基础知识/</id>
    <published>2019-07-06T02:53:05.000Z</published>
    <updated>2019-07-14T01:19:13.048Z</updated>
    
    <content type="html"><![CDATA[<p># </p><h2 id="ArrayList和Linkedlist区别"><a href="#ArrayList和Linkedlist区别" class="headerlink" title="ArrayList和Linkedlist区别"></a>ArrayList和Linkedlist区别</h2><p>1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。<br>2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。<br>3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。<br>4．对ArrayList和LinkedList而言，在列表末尾增加一个元素所花的开销都是固定的。对ArrayList而言，主要是在内部数组中增加一项，指向所添加的元素，偶尔可能会导致对数组重新进行分配；而对LinkedList而言，这个开销是统一的，分配一个内部Entry对象。<br>5．在ArrayList的中间插入或删除一个元素意味着这个列表中剩余的元素都会被移动；而在LinkedList的中间插入或删除一个元素的开销是固定的。<br>6．LinkedList不支持高效的随机元素访问。<br>7．ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间 </p><h2 id="java方法“值传递”的理解"><a href="#java方法“值传递”的理解" class="headerlink" title="java方法“值传递”的理解"></a>java方法“值传递”的理解</h2><p>java中的数据类型有基本类型和引用类型，他们都是值传递方式。基本类型传递的是它的值，因此方法中的改变参数的值，不会影响方法外。引用类型传递的是一个地址，因为引用类型在生成对象实例时，里面的值是一个地址，指向了对象实例。在传值的时候实际上传的是一个地址，他们指向了同一块地址，所以在方法内的改变会影响方法外的参数。 这里比较乱人心的是包装类型，因为包装类型也是引用类型，这里应该就是和包装类型的实现有关了，在包装类型中，比如Integer a=1，有一个自动装箱的操作。其实a=1，如果现在令a=2，不会令2覆盖1（即1本身是不会变的），真正改变的是a被赋给了一个新地址，这个地址指向了2。因此方法内的改变包装类型的值就相当于改变了形参里面的地址，相当于重新new了一遍。而方法外面的实参仍旧指向含1的那个地址，一次方法内的改变不会影响方法外的实参。 </p><p><img src="/upload/pasted-320.png" alt="upload successful"></p><h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><p>Volatile：与锁相比，Volatile 变量是一种非常简单但同时又非常脆弱的同步机制，它在某些情况下将提供优于锁的性能和伸缩性。如果严格遵循 volatile 的使用条件 —— 即变量真正独立于其他变量和自己以前的值 —— 在某些情况下可以使用 volatile 代替 synchronized 来简化代码。然而，使用 volatile 的代码往往比使用锁的代码更加容易出错。<br>只能在有限的一些情形下使用 volatile 变量替代锁。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：</p><ul><li>（1）对变量的写操作不依赖于当前值。</li><li>（2）该变量没有包含在具有其他变量的不变式中。<br>实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。<br>第一个条件的限制使 volatile 变量不能用作线程安全计数器。虽然增量操作（x++）看上去类似一个单独操作，实际上它是一个由读取－修改－写入操作序列组成的组合操作，必须以原子方式执行，而 volatile 不能提供必须的原子特性。实现正确的操作需要使 x 的值在操作期间保持不变，而 volatile 变量无法实现这点。 </li></ul><h2 id="数组复制"><a href="#数组复制" class="headerlink" title="数组复制"></a>数组复制</h2><p>1.for循环<br>2.System.arraycopy<br>3.Arrays.copyOf<br>4.clone</p><h2 id="类的加载顺序"><a href="#类的加载顺序" class="headerlink" title="类的加载顺序"></a>类的加载顺序</h2><p>(1) 父类静态代码块(包括静态初始化块，静态属性，但不包括静态方法)<br>(2) 子类静态代码块(包括静态初始化块，静态属性，但不包括静态方法 )<br>(3) 父类非静态代码块( 包括非静态初始化块，非静态属性 )<br>(4) 父类构造函数<br>(5) 子类非静态代码块 ( 包括非静态初始化块，非静态属性 )<br>(6) 子类构造函数</p><h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p>1、不管有没有出现异常，finally块中代码都会执行；<br>2、当try和catch中有return时，finally仍然会执行；<br>3、finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，不管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值），所以函数返回值是在finally执行前确定的；<br>4、finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。</p><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="registerNatives"><a href="#registerNatives" class="headerlink" title="registerNatives()"></a>registerNatives()</h3><p>向JVM注册native方法<br>在类初始化的时候，会依次从父类到本类的类变量及类初始化块中的类变量及方法按照定义顺序放到 &lt; clinit&gt;方法中，这样可以保证父类的类变量及方法的初始化一定先于子类。所以当子类调用相应 native方法，比如计算 hashCode时，一定可以保证能够调用到 JVM的 native方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">       registerNatives();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h3 id="getClass"><a href="#getClass" class="headerlink" title="getClass()"></a>getClass()</h3><p>类加载的第一阶段类的加载就是将 .class文件加载到内存，并生成一个 java.lang.Class对象的过程。 getClass()方法就是获取这个对象，这是当前类的对象在运行时类的所有信息的集合。这个方法是反射三种方式之一。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure></p><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><p>这个方法返回一个int类型的hash值<br>在 Java应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改；<br>如果两个对象 x.equals(y) 方法返回 true，则 x、 y这两个对象的 hashCode必须相等。<br>如果两个对象 x.equals(y) 方法返回 false，则 x、 y这两个对象的 hashCode可以相等也可以不等。但是，为不相等的对象生成不同整数结果可以提高哈希表的性能。<br>默认的 hashCode是将内存地址转换为的 hash值，重写过后就是自定义的计算方式；也可以通过 System.identityHashCode(Object)来返回原本的 hashCode。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>计算 hashCode使用了31作为基础乘数，为什么使用31呢？result *31=(result&lt;&lt;5)-result。 JVM底层可以自动做优化为位运算，效率很高；还有因为 31计算的 hashCode冲突较少，利于 hash桶位的分布。</p><h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><p>用于比较当前对象与目标对象是否相等，默认是比较引用是否指向同一对象。为 public方法，子类可重写。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>重写equals的意义：<br>因为如果不重写equals方法，当将自定义对象放到 map或者 set中时；如果这时两个对象的 hashCode相同，就会调用 equals方法进行比较，这个时候会调用 Object中默认的 equals方法，而默认的 equals方法只是比较了两个对象的引用是否指向了同一个对象，显然大多数时候都不会指向，这样就会将重复对象存入 map或者 set中。这就破坏了 map与 set不能存储重复对象的特性，会造成内存溢出。</p><h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><p>这是一个 protected方法，提供给子类重写。但需要实现 Cloneable接口，这是一个标记接口，如果没有实现，当调用 object.clone()方法，会抛出 CloneNotSupportedException<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure></p><p>两个概念——<br>浅拷贝：创建一个新对象，然后将当前对象的非静态字段复制到该对象，如果字段类型是值类型（基本类型）的，那么对该字段进行复制；如果字段是引用类型的，则只复制该字段的引用而不复制引用指向的对象。此时新对象里面的引用类型字段相当于是原始对象里面引用类型字段的一个副本，原始对象与新对象里面的引用字段指向的是同一个对象。<br>说白了就是clone一个对象，将会创建一个新的对象，而对于其内部属性，比如一个String的引用类型，克隆对象和被克隆对象指向的是一个引用。换言之，如果克隆对象的属性发生了改变，则原对象也会发生改变<br>而深拷贝则是一个完全不同的拷贝的方式<br>深拷贝通过序列化(Serializable)实现</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="wait-相关方法"><a href="#wait-相关方法" class="headerlink" title="wait()相关方法"></a>wait()相关方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        timeout++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多线程情况下使用作用是阻塞进程</p><ul><li>此方法只能在当前线程获取到对象的锁监视器之后才能调用，否则会抛出 IllegalMonitorStateException异常。</li><li>调用 wait方法，线程会将锁监视器进行释放；而 Thread.sleep，Thread.yield()并不会释放锁。</li><li>wait方法会一直阻塞，直到其他线程调用当前对象的 notify()/notifyAll()方法将其唤醒；而 wait(long)是等待给定超时时间内（单位毫秒），如果还没有调用 notify()/nofiyAll()会自动唤醒； wait(long,int)如果第二个参数大于 0并且小于 999999，则第一个参数 +1作为超时时间；</li></ul><h3 id="notify-notifyAll"><a href="#notify-notifyAll" class="headerlink" title="notify()/notifyAll()"></a>notify()/notifyAll()</h3><p>如果当前线程获得了当前对象锁，调用 wait方法，将锁释放并阻塞；这时另一个线程获取到了此对象锁，并调用此对象的 notify()/notifyAll()方法将之前的线程唤醒。这些方法都是 publicfinal的，不可被重写。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>要点：<br>调用 notify()后，阻塞线程被唤醒，可以参与锁的竞争，但可能调用 notify()方法的线程还要继续做其他事，锁并未释放，所以我们看到的结果是，无论 notify()是在方法一开始调用，还是最后调用，阻塞线程都要等待当前线程结束才能开始。</p><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h3><p>jvm垃圾回收时进行调用</p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p><img src="/upload/pasted-321.png" alt="upload successful"></p><p><img src="/upload/pasted-380.png" alt="upload successful"></p><h2 id="和equals"><a href="#和equals" class="headerlink" title="==和equals"></a>==和equals</h2><p>==用来判断两个变量是否相等时，如果两个变量是基本类型变量，且都是数值类型(不要求数据类型严格相同)，则只要两个变量的值相等，就返回true；对于两个引用类型变量，必须指向同一个对象，==才会返回true。<br>equals方法用于比较两个独立对象的内容是否相同</p><h2 id="实例变量，局部变量，类变量，final变量"><a href="#实例变量，局部变量，类变量，final变量" class="headerlink" title="实例变量，局部变量，类变量，final变量"></a>实例变量，局部变量，类变量，final变量</h2><ul><li>实例变量：是定义在是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。分配了内存空间后会给所有的成员变量一次初始化，没有赋值的会给成员变量对应类型的值，数据类型不同则默认值不同。</li><li>局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。用的时候是直接入栈的，如果没有赋值，这个变量就没有初始值，也就无法操作，所以局部变量要初始化。</li><li>类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。</li><li>final变量，final 修饰的变量。如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li></ul><h2 id="Integer的赋值问题"><a href="#Integer的赋值问题" class="headerlink" title="Integer的赋值问题"></a>Integer的赋值问题</h2><p>在为Integer赋值的时候，java编译器会将其翻译成调用valueOf()方法。比如Integer i=127翻译为Integer i=Integer.valueOf(127)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//high为127</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= -<span class="number">128</span> &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + <span class="number">128</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，对于-128到127之间的数，Java会对其进行缓存。而超出这个范围则新建一个对象。</p><h2 id="throws和throw"><a href="#throws和throw" class="headerlink" title="throws和throw"></a>throws和throw</h2><p>1、throws出现在方法头，throw出现在方法体 2、throws表示出现异常的一种可能性，并不一定会发生异常；throw则是抛出了异常，执行throw则一定抛出了某种异常。 3、两者都是消极的异常处理方式，只是抛出或者可能抛出异常，是不会由函数处理，真正的处理异常由它的上层调用处理</p><h2 id="接口（Interface）"><a href="#接口（Interface）" class="headerlink" title="接口（Interface）"></a>接口（Interface）</h2><p>接口，比抽象类还要抽象的类。</p><ul><li>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract （只能是 public abstract，其他修饰符都会报错）。</li><li>接口中可以含有变量，但是接口中的变量会被隐式的指定为  public static final   变量（并且只能是 public，用 private 修饰会报编译错误。）</li><li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。 </li></ul><p>注：<br>接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。<br>接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字。<br>接口中的方法都是公有的。public</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>Reflection（反射）是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的內部信息，并能直接操作任意对象的内部属性及方法。</p><p>Java反射机制主要提供了以下功能：</p><ul><li>在运行时构造任意一个类的对象</li><li>在运行时获取任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的方法（属性）</li><li>生成动态代理</li></ul><ol><li><p>Class: 是一个类; 一个描述类的类.<br>　　封装了描述方法的 Method,描述字段的 Filed,描述构造器的 Constructor 等属性.</p><ol start="2"><li><p>如何得到 Class 对象:<br>　　2.1 Person.class<br>　　2.2 person.getClass()<br>　　2.3 Class.forName(“com.atguigu.javase.Person”)</p></li><li><p>关于 Method:<br>　　3.1 如何获取 Method:<br>　　　　1). getDeclaredMethods: 得到 Method 的数组.<br>　　　　2). getDeclaredMethod(String methondName, Class … parameterTypes)</p></li></ol><p>　　3.2 如何调用 Method<br>　　　　1). 如果方法时 private 修饰的, 需要先调用 Method 的　setAccessible(true), 使其变为可访问<br>　　　　2). method.invoke(obj, Object … args);</p><ol start="4"><li><p>关于 Field:<br>　　4.1 如何获取 Field: getField(String fieldName)<br>　　4.2 如何获取 Field 的值:<br>　　　　1). setAccessible(true)<br>　　　　2). field.get(Object obj)<br>　　4.3 如何设置 Field 的值:<br>　　　　field.set(Obejct obj, Object val)</p></li><li><p>了解 Constructor 和 Annotation </p></li><li><p>反射和泛型.<br>　　6.1 getGenericSuperClass: 获取带泛型参数的父类, 返回值为: BaseDao&lt;Employee, String&gt;<br>　　6.2 Type 的子接口: ParameterizedType<br>　　6.3 可以调用 ParameterizedType 的 Type[] getActualTypeArguments() 获取泛型参数的数组.<br><a href="https://www.cnblogs.com/tech-bird/p/3525336.html" target="_blank" rel="noopener">https://www.cnblogs.com/tech-bird/p/3525336.html</a></p></li></ol></li></ol><h2 id="AQS和CAS"><a href="#AQS和CAS" class="headerlink" title="AQS和CAS"></a>AQS和CAS</h2><p>抽象队列同步器AQS ( AbstractQueuedSychronizer ) , 如果说java.util.concurrent的基础是CAS的话,那么AQS就是整个Java并发包的核心了, ReentrantLock、CountDownLatch、Semaphore等都用到了它。AQS实际上以双向队列的形式连接所有的Entry ,比方说ReentrantLock ,所有等待的线程都被放在一个Entry中并连成双向队列,前面一个线程使用 ReentrantLock好了, 则双向队列实际上的第一个Entry开始运行。 AQS定 义了对双向队列所有的操作,而只开放了tryLock和tryRelease方法给开发者使用,开发者可以根据自己的实现重写tryLock和tryRelease方法,以实现自己的并发功能。</p><p>比较并替换CAS(Compare and Swap) ,假设有三个操作数:内存值V、旧的预期值A、要修改的值B ,当且仅当预期值A和内存值V相同时,才桧将内存值修改为B并返回true ,否则什么都不做并返回false ,整个比较并替换的操作是一个原子操作。CAS一定要volatile变量配合,这样才能保证每次拿到的变量是主内中最新的相应值,否则旧的预期值A对某条线程来说,永远是一个不会变的值A,只要某次CAS操作失败，下面永远都不可能成功。</p><p>CAS虽然比较高效的解决了原子操作问题,但仍存在三大问题。</p><ul><li>循环时间开销大</li><li>只能保证一个共享变量的原子操作</li><li>ABA问题</li></ul><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p> Condition是在java 1.5中才出现的，它用来替代传统的Object的wait()、notify()实现线程间的协作，相比使用Object的wait()、notify()，使用Condition1的await()、signal()这种方式实现线程间协作更加安全和高效。因此通常来说比较推荐使用Condition，在阻塞队列那一篇博文中就讲述到了，阻塞队列实际上是使用了Condition来模拟线程间协作。</p><ul><li>Condition是个接口，基本的方法就是await()和signal()方法；</li><li>Condition依赖于Lock接口，生成一个Condition的基本代码是lock.newCondition()</li><li>调用Condition的await()和signal()方法，都必须在lock保护之内，就是说必须在lock.lock()和lock.unlock之间才可以使用Conditon中的await()对应Object的wait()； Condition中的signal()对应Object的notify()； Condition中的signalAll()对应Object的notifyAll() </li></ul><h2 id="Spring-mvc执行流程"><a href="#Spring-mvc执行流程" class="headerlink" title="Spring mvc执行流程"></a>Spring mvc执行流程</h2><p><img src="/upload/pasted-323.png" alt="upload successful"><br><a href="https://www.cnblogs.com/jay36/p/7527039.html" target="_blank" rel="noopener">https://www.cnblogs.com/jay36/p/7527039.html</a></p><h2 id="AOP-IOC"><a href="#AOP-IOC" class="headerlink" title="AOP IOC"></a>AOP IOC</h2><p>AOP和IOC是Spring精华部分, AOP可以看做是对OOP的补充,对代码进行横向的扩展,通过代理模式实现,代理模式有静态代理,动态代理, Spring利用的是动态代理,在程序运行过程中将增强代码织入原代码中。IOC是 控制反转,将对象的控制权交给Spring框架,用户需要使用对象无需创建,直接使用即呵。AOP和IOC最可贵的是它们的思想。</p><h2 id="Hibernate-POJO"><a href="#Hibernate-POJO" class="headerlink" title="Hibernate POJO"></a>Hibernate POJO</h2><p>Hibernate Pojo的三态分别为transient（瞬时态）,persistent（持久态）,detached（游离态）</p><p>1、官方给出的三态与Session的关系如下：</p><p>transient: never persistent, not associated with any Session<br>persistent: associated with a unique Session<br>detached: previously persistent, not associated with any Session</p><p>2、三种状态间相互转换关系，及他们在数据库、session中的状态如下：<br>a.当我们new一个pojo时，它处于瞬时态，此时与session、数据库均无任何关联。<br>b.此后，我们获得session并开启hibernate事务，调用save(),persist(),saveOrUpdate()方法，将pojo转变为持久态，此时session中存有这个pojo，但直到transaction.commit()被调用时，sql语句才会执行，此后数据库中也才有此条数据。<br>c.但当commit()并且session.close()执行过后，pojo就变为了游离态，也就是说，数据库中有该记录，但session中不再有。<br>d.持久化状态的实例，也可以重新变成瞬时态，那就是调用delete()方法。<br>e.通过get()或load()方法得到的pojo是持久态的。<br>f.游离态的pojo可以通过update(),saveOrUpdate(),lock()和replicate()方法重新成为持久态。<br>g.调用merge()方法后，pojo维持原态，但内容会被更新到数据库</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>Java通过Executors提供四个静态方法创建四种线程池，分别为：</p><p>newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p><p>newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p><p>newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</p><p>newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</p><p>作用：<br>限定线程的个数，不会导致由于线程过多导致系统运行缓慢或崩溃</p><p>线程池不需要每次都去创建或销毁，节约了资源、</p><p>线程池不需要每次都去创建，响应时间更快。</p><h2 id="javaWeb"><a href="#javaWeb" class="headerlink" title="javaWeb"></a>javaWeb</h2><h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p><img src="/upload/pasted-324.png" alt="upload successful"><br>servlet是运行在服务器端的小应用程序，是接收网络服务的请求和产生响应的一种方式。<br>servlet的功能：接受http请求，产生动态http响应。<br>HttpServlet是GenericServlet的子类。<br>GenericServlet是个抽象类，必须给出子类才能实例化。它给 出了设计servlet的一些骨架，定义了servlet生命周期，还有一些得到名字、配置、初始化参数的方法，其设计的是和应用层协议无关的，也就是说 你有可能用非http协议实现它。<br>HttpServlet是子类，当然就具有GenericServlet的一切特性，还添加了doGet, doPost, doDelete, doPut, doTrace等方法对应处理http协议里的命令的请求响应过程。</p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>servlet有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。这个生存期由javax.servlet.Servlet接口的init,service和destroy方法表达。<br>加载Servlet的class—-&gt;实例化Servlet—–&gt;调用Servlet的init完成初始化—-&gt;响应请求（Servlet的service方法）—–&gt;Servlet容器关闭时(Servlet的destory方法)<br>Servlet启动时，开始加载servlet生命周期开始。Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候(服务器关闭)调用其destroy方法。</p><h4 id="forward-与redirect-的区别"><a href="#forward-与redirect-的区别" class="headerlink" title="forward() 与redirect()的区别"></a>forward() 与redirect()的区别</h4><p>forward是服务器端的转向而redirect是客户端的跳转。</p><p>使用forward浏览器的地址不会发生改变。而redirect会发生改变。</p><p>Forward是一次请求中完成。而redirect是重新发起请求。</p><p>Forward是在服务器端完成，而不用客户端重新发起请求，效率较高<br>一般没有特殊需要，自己写的Servlet都扩展HttpServlet 。</p><h4 id="JSP和Servlet有哪些相同点和不同点"><a href="#JSP和Servlet有哪些相同点和不同点" class="headerlink" title="JSP和Servlet有哪些相同点和不同点"></a>JSP和Servlet有哪些相同点和不同点</h4><p>JSP是Servlet技术的扩展，所有的jsp文件都会被翻译为一个继承HttpServlet的类。也就是jsp最终也是一个Servlet.这个Servlet对外提供服务。</p><p><img src="/upload/pasted-347.png" alt="upload successful"><br>Servlet和JSP最主要的不同点在于JSP侧重于视图，Servlet主要用于控制逻辑。<br>Servlet如果要实现html的功能，必须使用Writer输出对应的html,比较麻烦。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件,做界面展示比较方便而嵌入逻辑比较复杂</p><h4 id="jsp内置对象"><a href="#jsp内置对象" class="headerlink" title="jsp内置对象"></a>jsp内置对象</h4><p>request 用户端请求，此请求会包含来自GET/POST请求的参数</p><p>response 网页传回用户端的回应</p><p>pageContext 网页的属性是在这里管理</p><p>session 与请求有关的会话期</p><p>application servlet正在执行的内容</p><p>out 用来传送回应的输出</p><p>config servlet的构架部件</p><p>page JSP网页本身</p><p>exception 针对错误网页，未捕捉的例外</p><p>四大作用域：pageContext request session application 可以通过jstl从四大作用域中取值.</p><p>Jsp传递值request session application cookie也能传值</p><h3 id="http-get和post请求的区别"><a href="#http-get和post请求的区别" class="headerlink" title="http get和post请求的区别"></a>http get和post请求的区别</h3><p>GET和POST请求都是http的请求方式，用户通过不同的http的请求方式完成对资源（url）的不同操作。GET，POST，PUT，DELETE就对应着对这个资源的查 ，改 ，增 ，删 4个操作,具体点来讲GET一般用于获取/查询资源信息，而POST一般用于更新资源信息<br>1、Get请求提交的数据会在地址栏显示出来，而post请求不会再地址栏显示出来.</p><p>GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&amp;连接；POST提交：把提交的数据放置在是HTTP包的包体中。因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变</p><p>2、传输数据的大小</p><p>http Get请求由于浏览器对地址长度的限制而导致传输的数据有限制。而POST请求不会因为地址长度限制而导致传输数据限制。</p><p>3、安全性,POST的安全性要比GET的安全性高。由于数据是会在地址中呈现，所以可以通过历史记录找到密码等关键信息。</p><h3 id="Session-和-Cookie"><a href="#Session-和-Cookie" class="headerlink" title="Session 和 Cookie"></a>Session 和 Cookie</h3><p>Session和cookie都是会话(Seesion)跟踪技术。Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。但是Session的实现依赖于Cookie,sessionId(session的唯一标识需要存放在客户端).</p><p>cookie 和session 的区别：</p><p>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</p><p>2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗</p><p>   考虑到安全应当使用session。</p><p>3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用COOKIE。</p><p>4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p><p>5、所以个人建议：</p><p>   将登陆信息等重要信息存放为SESSION</p><p>   其他信息如果需要保留，可以放在COOKIE中，比如购物车</p><p>购物车最好使用cookie，但是cookie是可以在客户端禁用的，这时候我们要使用cookie+数据库的方式实现，当从cookie中不能取出数据时，就从数据库获取。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;# &lt;/p&gt;
&lt;h2 id=&quot;ArrayList和Linkedlist区别&quot;&gt;&lt;a href=&quot;#ArrayList和Linkedlist区别&quot; class=&quot;headerlink&quot; title=&quot;ArrayList和Linkedlist区别&quot;&gt;&lt;/a&gt;ArrayList和
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>结束是另一个开始</title>
    <link href="https://www.junglezero.top/2019/07/05/mething-Ends-Something-Begins-translate-cn/"/>
    <id>https://www.junglezero.top/2019/07/05/mething-Ends-Something-Begins-translate-cn/</id>
    <published>2019-07-05T15:05:25.000Z</published>
    <updated>2019-07-19T00:56:51.306Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/upload/pasted-357.png"><br>《猎魔人》原著作者送给其朋友的结婚礼物，和正传发生的故事有些矛盾，但问题不大<br>高甜预警！！！<br><a id="more"></a></p><hr><p>翻译自外国的某个热心粉丝Something Ends, Something Begins <a href="https://witcher.fandom.com/wiki/Something_Ends,_Something_Begins_(unofficial_translation)" target="_blank" rel="noopener">https://witcher.fandom.com/wiki/Something_Ends,_Something_Begins_(unofficial_translation)</a><br>意思跑偏太正常了，这哥们把波兰语翻译成英语要跑偏一部分，我再把英语翻译成汉语又会跑偏一部分。对于这里面出现的一些人物，已经在第一次出现的地方链接到了猎魔人的wiki,有兴趣的朋友可以看一看。</p><hr><h1 id="I"><a href="#I" class="headerlink" title="I"></a>I</h1><p>   太阳炽热的触须透过百叶窗的缝隙伸展开来，倾斜的阳光把房间横断开来，飞悬的尘埃在光线中跃动着，落在地板的熊皮上，在叶妮芙皮带扣炫目的闪光中渐渐消散。叶妮芙的腰带挂在高跟鞋上，高跟鞋在白色蕾丝内衣上，而内衣在黑色的裙子上。一只黑色长筒袜挂在雕刻成烟囱状的扶手椅上，另一只袜子和另一只高跟鞋却四处不见，杰洛特叹了口气。叶妮芙喜欢利索优雅的脱掉衣服，他必须开始习惯起来，他没别的选择。<br>他站起身来，打开窗子向外看去，湖面光滑如镜，迷迷蒙蒙中，岸边的桦树和赤杨的叶子上闪着露珠，远处的草地上覆盖着厚重的雾，沉默的压下来，犹如蛛网一般悬在草地之上</p><p>   叶妮芙在毯子下嘟囔着什么，含糊不清。杰洛特叹了口气<br>   “今天天气真好，叶。”<br>   “嗯？你说什么？”<br>   “今天天气很好，尤为的好”<br>   她还是让他吃了一惊，女术士并没有像往常一样讽刺挖苦，也没有把头压在枕头下，而是坐起身来。用手梳理着头发，然后在床上找睡衣，杰洛特知道睡衣就在床头下面，就在她昨晚脱掉的地方，但是他一句话也没说，因为他知道，叶妮芙讨厌这种话。<br>   女术士突然咒骂起来，她踢了踢毯子，举起手咬住手指，睡袍就从床前飞来，摆动着荷叶边，犹如一个可怕的幽灵，然后落在她的手上。杰洛特叹了口气。叶妮芙站起身来走到他跟前，抱住了他，咬了他的胳膊，杰洛特叹了口气，他不得不习惯的事似乎多的数不清。<br>   “你没什么想说的吗？”，女术士眯着眼睛，问道<br>   “并没有。”<br>   “很好，今天的确很好，干的不错。”<br>   “什么意思？”<br>   叶妮芙还没来得及回答，就听见远处传来一声又高又长的叫喊声和喘息声。湖边，希瑞骑着一匹黑色的母马溅起一阵水花，这是一匹纯种马，长得很漂亮。杰洛特还记得它的上一个主人是个半精灵，这个半精灵轻率的凭第一印象错误的判断了这个白发的猎魔女，最终犯下大错。希瑞将这匹母马命名为“卡尔比”，在史凯利杰岛民的口中，这个意思是一种可怕的，胆大妄为的海的神灵，有时也会化身为马。这名字非常适合这匹母马。不久之前，有个半身人就因为某种艰难的方式了解到了，当他尝试偷走这匹马时，被这匹马猛地给了一脚，正中脸上，这半身人以前叫桑迪·弗洛莫顿，但自此以后人们就叫他“花椰菜”了。<br>   “总有一天她会摔断脖子的”，叶妮芙叫喊道，看着希瑞在溅起的水花中飞奔，弯腰，牢牢的踩着马镫。“总有一天你这疯女儿会摔断脖子的。”<br>   杰洛特转过头来，也不说话，就这么静静的看着女术士那双紫罗兰色的眼眸。<br>   “好吧好吧，”叶妮芙目不转睛的微笑着，“对不起，我们的女儿。”<br>   她又抱住他，紧紧地靠在他身上，又咬了下他的胳膊，然后亲吻她，接着又咬了下，杰洛特嘴唇触碰着她的头发，小心翼翼的把睡袍来到她的肩上。<br>   然后最终他们还是又上了床，散乱的毯子，尚有余温，仍旧沉浸在梦中。他们开始互相寻找彼此，寻找的时间很长，也很耐心，他们都深知最终会找到彼此，充满欢喜的彼此，他们所做的一切都是欢愉的，尽管他们之间尚有很大的差异，他们也和往常一样想着，这种差异并不是将他们分割开来，而是紧紧的绑在一起的差异，就犹如房梁和屋脊，那才是房屋的诞生所在。这也犹如第一次，当他被她赤裸而强烈的欲望所迷住，而她被他的巧妙和感性所迷住，就像她第一次本想告诉他，但是他却只用了一个吻和一个安抚让她安宁下来，消除了其他的所有感觉，后来，当他想要告诉她时，他却一点声音也发不出来，再后来，欢愉被一块巨石压倒，他们的眼中只有那一刻的闪光，听到的只是无声的呼喊，世界犹如静止一般，结束了，开始了，然后是沉默，宁静的沉默【本段见小说第一本《白狼崛起》的“最后的愿望”】<br>   还有无限的魅力。<br>   世界又重新回到它的轨道上，这里还是一张充满梦幻和光亮的床，然后是一天，那样的一天……<br>   “叶…”<br>   “嗯？”<br>   “当你说今天天气不错时，还说了句‘干得不错’，该不是……”<br>   “是的”她承认道，伸展着双臂握紧毯子的边，使她的胸部在那一刻以这种方式展现出来，这使得猎魔人的下半身一阵颤动<br>   “看啊，杰洛特，是我们打造出这样的天气，昨晚，我，<a href="http://witcher.huijiwiki.com/wiki/%E5%8D%97%E5%B0%BC%E5%85%8B" target="_blank" rel="noopener">南尼克</a>,特莉丝和<a href="http://witcher.huijiwiki.com/wiki/%E5%A4%9A%E7%91%9E%E5%8A%A0%E9%9B%B7" target="_blank" rel="noopener">多瑞加雷</a>,我不能冒险，今天必须是美好的一天……”<br>她一声不吭的用膝盖猛击了杰洛特一下。<br>   “为什么？因为这是你生命中最重要的一天，傻东西。”【叶妮芙设定上会读心术，专读杰洛特的】</p><hr><h1 id="II"><a href="#II" class="headerlink" title="II"></a>II</h1><p>   洛史洛格城堡矗立在湖中凸起的地带，亟需进行全面的修缮工作，绝对不仅仅是现在。说的好听一点，洛史洛格就是一片废墟，一个不规整的石头堆，铺满了常青藤，野葡萄，地衣和苔藓，说来说去也不过是这片烂沼泽地中的一个遗迹，四处满是蛤蟆，蝾螈和乌龟，当年这片土地给赫维格国王时，这已经就是一片废墟了，这个城堡以及周边的沼泽，更像是一份毕生的礼物，一份送给赫维格告别礼物。赫维格于12年前退位，以支持他的侄子“友善者”布伦南，杰洛特曾通过丹德里恩结识了这位前国王，因为赫维格国王为人和蔼，也喜好招待宾客，所以这位吟游诗人经常出入城堡。<br>   当女术士排除了猎魔人所提供的所有地点参考时，丹德里恩就把赫维格国王的洛史洛格城堡提了上来，诡异的是，女术士马上就同意了这个提议，甚至连鼻子也没抽一下。<br>于是，杰洛特和叶妮芙的婚礼将在洛史洛格城堡举行</p><hr><h1 id="III"><a href="#III" class="headerlink" title="III"></a>III</h1><p>   一开始，这场婚礼设定上是小型的，不那么引人注目的婚礼，可是因为各种原因，这是不可能实现的，所以很有必要找一个擅长组织的人。自然，叶妮芙是拒绝的，她不想张罗她自己的婚礼，杰洛特和希瑞，还有丹德里恩，那就不用说了，他们就没组织这个概念，于是他们向艾尔兰德的梅里泰莉神庙的大祭司南尼克求助，南尼克二话不说就来了，带着两个年轻的女祭司小爱若拉和尤妮德。<br>   于是各种问题开始接踵而至。</p><hr><h1 id="IV"><a href="#IV" class="headerlink" title="IV"></a>IV</h1><p>   “这可不行，杰洛特，”南尼克怒吼道，跺了跺脚，“婚礼和宴会要是出了什么岔子我可不负责。那片废墟，有些傻瓜竟然称之为一座城堡，那可是一点用也没有，那里的厨房都要塌了，舞厅也就能用来做个马厩，那个礼拜堂……那就不是个礼拜堂，至少你能告诉我那个瘸子赫维格信奉哪位神灵吗？”<br>“据我所知，他谁也不信奉，他还声称宗教不过是大众的精神毒品”<br>“哼，我就知道，”女祭司说道，丝毫没有掩饰自己的轻蔑，“那个礼拜堂里没有一座雕像，除了老鼠粪以外，就没有别的东西了，最重要的是，那个地方不过是一摊死水，杰洛特，你怎么不想在一个文明的国家举行婚礼呢，比如温格堡？”<br>   “你知道的，叶是一个混血儿，你们的那些文明国家可不准许这种混合的婚姻”<br>“梅里泰莉女神在上！不过是四分之一的精灵血统，有什么问题吗？谁都或多或少的带点上古民族的血统，这只是个愚蠢的偏见！”<br>   “那也不是我编出来的。”</p><hr><h1 id="V"><a href="#V" class="headerlink" title="V"></a>V</h1><p>   邀请的客人名单实际上并不长，夫妇两人把名单汇总交给了丹德里恩，让他去发放邀请函，结果是这个吟游诗人还没来得及读完就给弄丢了，因为他羞于承认，于是他就耍了些花招：尽可能的邀请他所能邀请的任何人，当然，他对叶妮芙和杰洛特都很了解，所以没有落下任何一个重要的人，但是要是没有趁机邀请到更多的乱七八糟的形形色色的人的话，那他也就不是丹德里恩了。<br>   于是，杰洛特的导师，来自凯尔莫罕的老维瑟米尔和杰洛特的童年伙伴，猎魔人艾斯卡尔就过来了<br>   德鲁伊<a href="http://witcher.huijiwiki.com/wiki/%E8%8E%AB%E6%96%AF%E8%90%A8%E5%85%8B" target="_blank" rel="noopener">莫斯萨克</a>带着一个名叫芙蕾雅的金发女郎来了，芙蕾雅比他高一头，但是可比他年轻上百岁。来的还有<a href="http://witcher.huijiwiki.com/wiki/%E5%85%8B%E6%8B%89%E8%8C%A8%C2%B7%E5%AE%89%C2%B7%E5%85%8B%E8%8E%B1%E7%89%B9" target="_blank" rel="noopener">克拉茨·安·克莱特</a>,史凯利杰群岛的伯爵，带着他的两个儿子拉格纳和洛基，拉格纳骑马时，脚都快碰到地了，而洛基则像个精灵，也难怪他们兄弟两个，但是他们有着不同的母亲<br>   来自布拉维坎的里夫·凯尔迪米恩和他女儿阿妮卡到了【出自《白狼崛起》的“勿以恶小”，布拉维坎屠夫的称号就是从这个地方得来的】，阿妮卡很有魅力但生性害羞。矮人<a href="http://witcher.huijiwiki.com/wiki/%E4%BA%9A%E5%B0%94%E6%BD%98%C2%B7%E9%BD%90%E6%A0%BC%E6%9E%97" target="_blank" rel="noopener">亚尔潘·齐格林</a>出现了，没有带着其他人，这很有意思，他一般都是带着他的长胡子同伙的。他是在半路上碰上了精灵<a href="http://witcher.huijiwiki.com/wiki/%E5%87%AF%E7%91%9E%E5%B0%94%E4%B8%B9" target="_blank" rel="noopener">凯瑞尔丹</a>一起来的，可见凯瑞尔丹在精灵中还是有些地位的，身边有几个默默无闻的精灵，无人知晓。<br>又来了一队吵吵嚷嚷的半身人，这群人里杰洛特只认识<a href="http://witcher.huijiwiki.com/wiki/%E4%B8%B9%E8%BF%AA%C2%B7%E6%AF%94%E4%BC%AF%E5%A8%81%E7%89%B9" target="_blank" rel="noopener">丹迪·比伯威特</a>，蓼草牧场的商人和牧马人,还有只是有所耳闻的，因好斗而出名的老婆加德尼娅·比伯威特，领头的还有一个不是半身人的半身人——著名的商人特里科·朗格瑞文克·勒托特，一个异形怪，伪装成名为“<a href="http://witcher.huijiwiki.com/wiki/%E5%98%9F%E5%98%9F" target="_blank" rel="noopener">嘟嘟</a>”的半身人。【见《宿命之剑》的“永恒之火”】<br>   来自布洛克莱昂的<a href="http://witcher.huijiwiki.com/wiki/%E8%8F%B2%E6%96%AF%E5%A5%88%E7%89%B9" target="_blank" rel="noopener">菲斯奈特</a>男爵到了，带着他的妻子，高贵的树精布蕾恩，以及他们的五个女儿莫丽恩、希瑞菈、莫娜、艾思娜和卡什卡，莫丽恩15岁的样子，而卡什卡看上去只有五岁。她们都是一头红发，尽管菲斯奈特是黑发，布蕾恩是金发、布蕾恩明显怀有身孕。他的一群红发树精女儿彼此咯咯的笑着，菲斯奈特信誓旦旦的说，这次一定是个儿子【小说中说树精X非树精=女树精】而布蕾恩则笑着补充道，这个“儿子”就叫梅丽莎。【这两个人的故事见《宿命之剑》的“宿命之剑”】<br>   独臂的<a href="http://witcher.huijiwiki.com/wiki/%E9%9B%85%E5%B0%94" target="_blank" rel="noopener">雅尔</a>也来了，这是一位年轻的牧师，编年史家，来自艾尔兰德，是南尼克的一个学徒，他来这里主要是因为他暗恋的希瑞，心疼的南尼克觉得，希瑞对于这个残疾青年的隐晦的调情似乎太过冷淡。<br>   打头的不速之客是布利姆巫德的<a href="http://witcher.huijiwiki.com/wiki/%E8%89%BE%E6%A0%BC%E7%BD%97%E7%93%A6%E5%B0%94" target="_blank" rel="noopener">艾格罗瓦尔</a>王子，他的到来被视作为一个奇迹，因为他和杰洛特曾经毫不留情的公开鄙视对方，更奇怪的是，他是和他的妻子美人鱼<a href="http://witcher.huijiwiki.com/wiki/%E5%B8%8C%E6%81%A9%E5%A8%9C%E5%85%B9" target="_blank" rel="noopener">希恩娜兹</a>一起来的，尽管她为了一双异常漂亮的腿牺牲了自己的鱼尾，但人们都知道她从未离开过海岸，因为她对陆地充满恐惧【这段故事见《宿命之剑》的“一点牺牲”】<br>   没人料到还会有其他的国王会对于此事比较上心——说来说去也没人邀请他们。尽管如此，还是有很多国王派发贺信，礼物，使者——或者以上的一并送出。他们应该是事先商量好了，因为他们的使者是组团来的，彼此都相互认识了。伊夫骑士代表埃塞因国王，领主苏力沃伊代表文斯拉夫国王，玛索尔姆爵士代表西吉斯蒙德国王，德弗卢爵士代表<a href="http://witcher.huijiwiki.com/wiki/%E9%9B%85%E5%A6%B2" target="_blank" rel="noopener">雅坦</a>王后，他们这几个人的旅行一定很愉快，因为伊夫的嘴唇被割破了，苏力沃伊的胳膊绑在板子上，玛索尔姆一瘸一拐的，而德弗卢醉的很厉害，几乎要从马上摔下来了。<br>   没人能邀请金龙<a href="http://witcher.huijiwiki.com/wiki/%E5%8D%9A%E5%B0%94%E5%A5%87" target="_blank" rel="noopener">维纶特瑞坦梅斯</a>,因为没人知道怎么邀请他以及他到底在哪，令众人吃惊的是，他还是来了，自然是隐藏了真实的形态，是以骑士博尔奇“三只寒鸦”的身份来的，当然，有丹德里恩在的地方，就没有什么隐私可言，但是当吟游诗人指着这位卷发骑士声称他其实是一条金龙时，还是没什么人相信。<br>   没人会料到还有一群各式各样的流浪人的到来，当然，也没人邀请他们。他们被登记为“丹德里恩的朋友和熟人”，主要是诗人，歌手和剧场演员，还有杂耍演员，职业骰子手，鳄鱼训练师以及四个浓妆艳抹的女人，其中三个毫无疑问就是妓女，而第四个虽然看上去不像，但毫无疑问也是，有两个算命的，其中一个还是个骗子，还有一个雕塑家，一个金发女郎，和一个醉酒的灵媒师，还有个麻子脸的侏儒，自称是舒滕巴赫<br>   在一艘外形犹如一只天鹅背着一个巨大的枕头的魔法船上，术士团到了，他们比邀请的要少上4倍，但是比预期来的要多上三倍，正如传言所说的那样，叶妮芙的同行并不认同她会嫁给一个外人，还是个猎魔人，他们中的一部分人直接无视邀请，另一部分人则以没时间为由，说是要去参见一年一度的世界修道院集会，因此，在那艘被丹德里恩唤做“枕头鸟”的船上只有沃尔的多瑞加雷，牛堡的<a href="http://witcher.huijiwiki.com/wiki/%E8%8E%B1%E5%BE%B7%E5%85%8B%E9%87%8C%E5%A4%AB" target="_blank" rel="noopener">莱德克里夫</a>,以及一头栗色头发的特莉丝·梅利葛德</p><hr><h1 id="VI"><a href="#VI" class="headerlink" title="VI"></a>VI</h1><p>   “是你邀请的特莉丝·梅利葛德？”<br>   “没有的事，”猎魔人急忙摇了摇头，暗自庆幸自己的血液循环系统不会让自己脸红。“不是我，估计是丹德里恩，尽管他们都说他们是通过水晶占卜知道的。”<br>   “我不希望特莉丝·梅利葛德出现在我的婚礼上！”<br>   “为什么呀，她可是你的朋友。”<br>   “不要把我当傻子，猎魔人！是个人就知道你跟她有一腿。”<br>   “扯淡！”<br>   叶妮芙的紫罗兰色眼睛危险的眯着。<br>   “是真的”<br>   “真不是”<br>   “就是真的”<br>   “够了，”他生气的把头扭向一边，“就是真的了，你想怎么样？”<br>   女术士沉默了，摆弄着脖子上的黑曜石星星。<br>   “也没什么，”女术士最终开了口，“我就是想让你承认罢了，不要冲我撒谎，杰洛特，永远也不要”</p><hr><h1 id="VII"><a href="#VII" class="headerlink" title="VII"></a>VII</h1><p>   城堡的石墙散发出一股潮湿的气息，外加一股子药草的酸味。阳光照在褐色的泥水上，竟然拽出了沼泽地里某种植物的暖绿色和海狸百合闪闪发光的黄色<br>城堡也慢慢苏醒过来，渐渐有了生机。城堡西翼，有人打开百叶窗，放声大笑。有人用一种微弱的声音请求来一些泡菜卤水，丹德里恩的一位同事，一个盲诗人，一边刮着胡子，一边放声唱到：</p><p>干草仓后的栅栏上，<br>有只公鸡高声唱，<br>姑娘我会赶到你身旁，<br>来上一炮也无妨……</p><p>   门吱扭一声开了，丹德里恩来到院子中，他伸了伸懒腰，揉了揉眼睛<br>   “你好啊，新郎官，”他疲惫的说道。“如果你想要溜走，就只有现在了。”<br>   “丹德里恩，你竟然成了早起的鸟儿。”<br>   “我压根就没上床”，诗人嘟囔着，坐在猎魔人旁的石凳上，靠着长满藤蔓的石墙。“神啊，多么每美妙的夜晚，但不管怎么说，可不是每天都有好朋友要结婚，自然是要好好的庆祝一下。”<br>   “婚礼的宴会是在今天，”杰洛特提醒道，“你能撑得过去吗？”<br>   “你瞧不起我吗？”</p><p>   艳阳高照，鸟儿在灌木丛中啾啾的叫着，湖上传来溅水声和咯咯的笑声，那是菲斯奈特的红发树精女儿们莫丽恩、希瑞菈、莫娜、艾思娜和卡什卡正和往常一样光着身子在湖中玩耍，特莉丝·梅利葛德和莫斯萨克的朋友芙蕾雅正看着她们。而城垛上，皇家的使者们，伊夫骑士，苏力沃伊领主，玛索尔姆爵士和德弗卢爵士却为了争抢一个望远镜而大打出手。</p><p>   “玩得还好吗，丹德里恩？”<br>   “别提了。”<br>   “又出什么乱子了？”<br>   “可是有那么几个。”</p><p>   正如诗人所说，第一个争端是关于种族的。宴会开到一半时，特里科·朗格瑞文克·勒托特突然发作，说他已经忍受够了半身人的伪装，勒托特指着在坐的树精，精灵，半身人，美人鱼，人类和一个声称自己是舒滕巴赫的侏儒，说他们每个人都能做他们自己而只有他，特里科必须得伪装成别人的样子，这就是种歧视，然后他突然变回了自己自然模样，看到这一幕，加德尼娅·比伯威特当场晕了过去，艾格罗瓦尔王子差点被龙虾给噎着，而里夫·卡尔迪米恩的女儿阿妮卡则歇斯底里的叫了起来，这混乱场面最终还是靠着金龙维纶特瑞坦梅斯得以拯救，当然，是以骑士博尔奇“三只寒鸦”的形态。他淡淡的向勒托特解释道，说异形是一种天赐的恩惠，然而这种恩惠也要求他保持一种社会能够接受的形态，而且也是出于对东道主的礼仪。<br>   可是勒托特指责维纶特瑞坦梅斯，说他的这番话完全就是种族主义，沙文主义以及站着说话不腰疼。因此受辱的维纶特瑞坦梅斯猛地变成了龙形，毁坏了几件家具，引得众人一阵恐慌，待局势稍微缓和下来时，一场激烈的争端就开始了，人类和非人种族在互相指责对方的不宽容，对方的种族歧视，这场争论意想不到的转折来自脸上长着雀斑的媚儿，就是那个不像妓女的妓女，她说这场争辩就是扯淡，对于“专业人士”来说，是不是人根本就没有关系，还说愿意当场证明（当然，钱要到位。）甚至包括处在自然形态下的维纶特瑞坦梅斯，在那片刻间的寂静中，众人听到那个灵媒师说她也愿意做同样的事，而且不收钱。维纶特瑞坦梅斯赶忙转换话题，开始讨论一些相对安全的话题，比如经济，政治，狩猎，钓鱼以及冒险。<br>   其他的事情可能相对来说不那么暴力。莫斯萨克，莱德克里夫和多瑞加雷比他们谁能用意念控制更多的东西浮空。最终是多瑞加雷赢了，他成功的将两把椅子，一个水果盘，一碗汤，一个地球仪，一只猫，两只狗以及菲斯奈特和布蕾恩的女儿卡什卡悬在空中。<br>   然后是菲斯奈特和布蕾恩的两个女儿，希瑞拉和莫娜扭打在一起，于是她们被要求返回自己的房间，不一会拉格纳和玛索尔姆爵士为菲斯奈特的大女儿莫林又打了起来。生气的菲斯奈特赶忙把自己的红发女儿们都关在了屋子里，然后自己兴冲冲的跑去参加由莫斯萨克的女友芙蕾雅组织的斗酒。很快，丹德里恩的朋友们，那些诗人和歌手，纷纷喝倒在桌子下，很明显芙蕾雅对于酒精有难以想象的抑制能力，近乎于免疫。但是菲斯奈特，克拉茨·安·克莱特，里夫·卡尔迪米恩仍然勇敢的战斗着，然后他们也败下阵来。术士莱德克里夫此时却还坚定的举着酒杯，直到人们发现他带着一个独角兽的角，拿掉之后，他一下子就不行了。有那么一段时间，桌子上都没人，然后就来了一个穿着老式服装的卡夫坦人，他脸色苍白，没人认识他。他和芙蕾雅喝了几个来回，过了一会，站了起来，晕晕乎乎的，礼貌的鞠了一躬，穿过一堵墙，就好像一阵雾，通过对大厅中的挂画的彻底搜查，人们认定他可能是几百年前在黑暗时代被谋杀的罗兹罗格的继承人“魔鬼”威廉姆。<br>   这座古堡藏着各种各样的秘密，早些年，它以它的阴森可怕而闻名，但是人们都比较怀疑，毕竟并没有发生什么超自然的事。午夜时分，一只吸血鬼从开着的窗子飞来进来，一进来，就被矮人亚尔潘·齐格林扔了头大蒜，然后被他追着打。整个晚上，总能听见货真价实的鬼哭狼嚎，但没人在意，人们都觉得是丹德里恩和他的朋友在搞鬼。然而，楼梯上大量的外质表明，这的确就是货真价实的鬼魂，还有几个人滑到在上面。</p><p>   有个影子跨过门槛，他眨着火一般的眼睛，淘气的捏了希恩娜兹的屁股一把，看来要想解决这些误会可能要有些难度了，因为希恩娜兹认定就是丹德里恩干的，这个鬼影立刻借着这个误会，四处捣乱，直到他被南尼克抓住并用驱魔术驱逐出去。<br>   几个人声称自己看见了苍白夫人，传说中，她被活埋在洛史洛格城堡的地下墓穴中。而别的人则觉得这个不是苍白夫人，而是那个女灵媒师在画廊中走动着找酒喝<br>   然后就开始有人失踪了，最开始失踪的是伊夫骑士和鳄鱼杀手，不一会人，人们发现拉格纳和年轻的女祭司尤妮德也没了。然后是加德尼娅·比伯威特，但后来才知道她去睡觉了。接着是独臂的雅尔和第二个年轻女祭司小爱若拉。虽然希瑞对雅尔没什么感情可言，但还是有些担心，但很显然，这个年轻人不小心摔在了阴沟里，在里面睡着了。而小爱若拉则是在楼梯口被发现了，旁边还有精灵凯瑞尔丹。特莉丝·梅利葛德和来自凯尔莫罕的猎魔人艾斯卡尔被发现了消失在花园的凉亭附近。早上，有人声称看见了在凉亭那里看见了变形怪特里科，人们就在议论纷纷，琢磨着这个异形怪到底变成了谁的模样，甚至有人觉得这里有两个异形怪。他们想向金龙维纶特瑞坦梅斯征求下意见，毕竟他也是个变形专家，结果这条龙也不见了，妓女媚儿和他在一起。<br>   第二个妓女也没了，同时消失的还有一个算命的，剩下的一个算命的说他才是真的那个，但是没人能证明。同时，那个自称是舒滕巴赫的侏儒也不见了。</p><p>   “你大概已经后悔了，”吟游诗人打了个大大的哈欠，“你不在真的是太遗憾了，那可是相当的精彩。”<br>   “我的确挺后悔的，”猎魔人感叹道，“但是你懂得……我不能,因为叶妮芙……总之你应该是最了解的。”<br>   “那是肯定的，”丹德里恩赞成到，“所以我才不会傻到去结婚。”</p><hr><h1 id="VIII"><a href="#VIII" class="headerlink" title="VIII"></a>VIII</h1><p>   城堡的厨房中传来了平底锅的叮当声，快乐的笑声以及哼哼的小调声。要为这么多客人提供盛宴是个问题，因为赫维格国王平日几乎就没什么客人。术士的到来并没有解决任何问题，出于对于食品安全的考量，食物都得是自然的东西，不掺杂一点魔法，所以南尼克到处助抓人打下手。一开始并不简单，因为被拉过来的人一点厨房的常识也没有，而那些会做饭的早就跑掉了。然而还是加德尼娅·比伯威特带着一群半身人过来帮忙。令人吃惊的是，丹德里恩招来的那四个妓女都是出乎意料的厨房能手。<br>   供给方面也没有问题菲斯奈特和艾格罗瓦尔组织了一场狩猎，打来了不少鹿肉，布蕾恩和他的女儿们只用了两个小时就打来了足够多的野味，众所周知树精大多箭术惊人，就连小女儿卡什卡弯弓搭箭也很流畅。热衷钓鱼的老国王赫维格一早就到湖上打鱼去了。带回了梭子鱼，狭鳕鱼还有好大只的贝斯鱼。ke的小儿子洛基跟他一同去的，岛民出身的他驾船打鱼样样精通，并且他也是早上为数不多能派上用场的，因为他和赫维格国王一样不沾酒。<br>   在变形怪特里科的驱使下，丹迪·比伯威特和他的亲戚们开始打扫大厅和各个房间，他们又赶着两个算命的，鳄鱼杀手，雕塑家还有喝的烂醉的灵媒师一同打扫清理。<br>   看管地下室的酒水的工作一开始交给了丹德里恩和他的朋友们，后来被证明这是一个灾难性的决定，于是这些诗人们就被赶了出去，钥匙交到莫斯萨克的女朋友芙蕾雅手中。但是丹德里恩和他的朋友们还赖着不走了，试图用抒情诗打动芙蕾雅，可这位岛民却像抵制酒精那样抵制他们的诗歌。<br>   杰洛特猛地抬起头来，他被从石子路上传来的马蹄声惊醒了，卡尔比从墙边的灌木丛中冲出，是希瑞来了，她穿着她的黑色皮革护甲，背上背着把剑，正是名剑格维尔，是她从科洛奇沙漠的地下墓穴中得到的。<br>   有那么一会他们就要彼此对视，也不说话。女孩驾着马向前，卡尔比向着杰洛特咬了过去，却被希瑞猛地拉了回来。<br>   “就是今天了，”猎魔女说道，“是今天，杰洛特。”<br>   “是今天，”猎魔人背靠着墙，确认到。<br>   “我很高兴”，她的声音中有种不确定，“我想……我不太肯定你们两个会不会幸福，但我还是很高兴。”<br>   “希瑞，下马，我们得谈谈。”<br>   女孩甩了下头，把头发甩到了后面。杰洛特看见了一道又宽又丑的伤疤——这是一段不堪回首的往事，希瑞就是为了遮住伤疤才将头发蓄长，但是她总是忘了挡住伤疤。<br>   “我要走了，杰洛特”她告诉猎魔人，“宴会之后，立马上路。”<br>   “下马，希瑞。”<br>   猎魔女跳下马来，坐在他身旁，杰洛特抱住了她，希瑞靠在他的肩上。<br>   “我要离开了，”她又说了一遍。<br>   他什么也没说，话到嘴边，但是他觉得不合适，或者说不必要。他什么也没说。<br>   “我知道你在想什么，”她慢慢的说道，“你觉得我是要逃跑，的确是这样。”<br>   他还是沉默着，他确实明白。<br>   “毕竟，在经历了这么多风风雨雨，你终于和叶结婚了，你理应幸福，理应有一个安定的家，但是这一切却令我感到害怕，杰洛特，所以……我要逃离这一切。”<br>   他还是沉默着，他想起了自己的逃跑。<br>   “宴会结束马上就走，”希瑞又说了一遍。“我想……我想要再次感受策马急行的风，我想眺望地平线上的星星，我想要晚上吹丹德里恩歌谣的调调，我渴求战斗，渴求用剑一决胜负，渴求冒险，渴求胜利带给我的喜悦，并且我渴求孤孤单单的一个人，你能明白我的意思吗？”<br>   “明白，”杰洛特悲伤的笑了笑，“我当然明白，你是我的宿命，你是个猎魔人，你要去做你必须要做的，但我必须要告诉你一件事，你不能一走了之，尽管你在不停的尝试。”<br>   “我知道，”她回应到，紧紧的抱住他，“我也希望有一天，如果我不停的等待，如果我有足够的耐心，我大概也有像你这样的一天……如此好的一天……即使……”<br>   “即使什么，希瑞？”<br>   “我很丑，而且还有那样一道难看的伤疤……”<br>   “希瑞！”他打断她，“你是世上最漂亮的女孩……当然只是在叶之后。”<br>   “杰洛特……”<br>   “你不信的话，去问丹德里恩。”<br>   “杰洛特，我……”<br>   “说起来，他死哪里去了……”<br>   “我要去南方，”她打断了他，不敢直视他。“战后仍然不安定，那里的人们需要保护，我会派上用场的，还要去科洛奇……还有尼弗迦德，我和格威尔在那里还有未了结的事。”<br>   她突然沉默了，脸变得冷漠起来。绿色的眼睛眯了起来，嘴角挂满了仇恨。我记得，杰洛特，我还记得，就像现在一样。上一次他们并肩在吕思勋城堡作战。楼梯上已经血流成河，他们就站在血泊当中。狼和猫，两个冷血的杀人机器，非人的速度和非人的冷漠，围上来的尼弗迦德人慢慢的后退。一只出奇冷静的狼和一只出奇疯狂的猫，闪烁的刀锋，哭喊声，四处迸溅的鲜血，以及遍地凋零的生命……就像那样，就像上一次那样。<br>   希瑞将头发向后甩去，灰白的头发在太阳穴处一阵震荡。<br>   “我还用未竟之事，”她冷冷的说道，“为了<a href="http://witcher.huijiwiki.com/wiki/%E7%B1%B3%E5%B8%8C%E5%B0%94" target="_blank" rel="noopener">米希尔</a>,为了我的米希尔，我已经为她报了仇，但是只杀一个人是不够的。”<br>   <a href="http://witcher.huijiwiki.com/wiki/%E7%B1%B3%E5%B8%8C%E5%B0%94" target="_blank" rel="noopener">雷欧·邦纳特</a>，她杀了他，为她报了仇。希瑞啊希瑞，你现在已经处在深渊边缘，女儿，即使杀了上千人也换不回你的米希尔，要提防仇恨啊，那种堪比癌症的情感。<br>   “你要当心你自己啊。”他低沉的说。<br>   “我宁愿让别人当心，”她讽刺的笑了笑，“这样回报更多，也更加有意义。”<br>   我再也见不到她了，他想，如果她走了，我不会再见到她了。<br>   “还会再见的，”她出乎意料的回答道，脸上挂着一个女术士而非猎魔人的微笑。“还会再见的，杰洛特。”<br>   她如一个男孩般跑开了，敏捷的跳上马鞍。<br>   “架，卡尔比！！”<br>【以上对话涉及的人的确是后面小说中的人物，但是故事的发展稍微不太一样】<br>马蹄铁踏在路上，迸溅出火花。丹德里恩不知从哪里冒出来了，他把鲁特琴挂在肩上，腾出手来，一手拿着一大罐啤酒。</p><p>   “来，喝一杯”他说着，坐在他身边，“这对你有好处。”<br>   “我不太确定，叶妮芙警告我，如果他在我身上闻到酒味”<br>   “嚼些欧芹就行了，喝吧，你这妻管严。”</p><p>   他们静静的坐了好长时间，慢悠悠的喝着啤酒，丹德里恩叹了口气。<br>   “希瑞要走了，是吗？”<br>   “嗯。”<br>   “我觉得也是，杰洛特，听我说两句……”<br>   “丹德里恩，你还是闭嘴吧。”<br>   “哦。好吧。”<br>   他们又沉默了。厨房传来了一股烤鹿肉的香味，刺柏的味道很浓。<br>   “……结束了（Something ends），”杰洛特艰难的说，“都结束了。”<br>   “可不是这样，”诗人严肃的反驳道，“是开始了（Something begins）”</p><hr><h1 id="IX"><a href="#IX" class="headerlink" title="IX"></a>IX</h1><p>   下午是在一片哭声中度过的，一切都是从美之灵药开始的，这种灵药，更准确的说是一种软膏，在古老的习俗中，也被称作“格拉玛耶”，据说可以使女性变得更加漂亮，更加引人注目。在各个主妇的要求下，te准备了大量的药膏。于是在场的女士们开始按照习俗涂抹。但是，在锁死的门后传来了希瑞菈、莫娜、艾思娜和卡什卡的哭声，她们不允许使用格拉玛耶，只有大女儿莫丽恩才能享受这一殊荣。哭的最响的是卡什卡，在她的上一层，莉莉正在哇哇的哭，她是dan的女儿，因为她发现和大多数魔法物品一样，格拉玛耶对半身人不起作用，在花园中瞎逛的灵媒师只是嗅了嗅，可她不知道的是嗅上一口就提神醒脑的后果，酒醒之后她陷入了无尽的忧郁当中。城堡的西翼，里夫·卡尔迪米恩的女儿阿妮卡也哭了起来，她不知道格拉玛耶是要涂在眼睛下面的，却吃了那药膏，现在正在腹泻。希瑞也拿了她那一份，涂在了卡尔比的眼下。<br>   女祭司小爱若拉和尤妮德也哭了，因为叶妮芙拒绝穿她们为她精心制作的白色婚纱，甚至南尼克在一旁劝也没用，叶妮芙骂骂咧咧，还把盘子给摔了，大声喊着她穿上这玩意就像一个他妈的白衣处女，南尼克也生气了，大声骂着她的行为比三个该死处女还糟糕。叶妮芙也没有回骂回去，直接放了一道闪电，打穿了塔楼的屋顶。这一举措还是有好的一面的，突如其来的巨响让卡尔迪米恩的女儿一惊，竟然吓好了她的腹泻。<br>   又有人看见特莉丝和猎魔人艾斯卡尔溜进了花园的小亭子，两人还手牵着手，毫无疑问，这次两人都是本人，因为变形怪特里科正在和丹迪·比伯威特和金龙维纶特瑞坦梅斯喝酒。<br>   人们又仔仔细细的找了一遍，还是没找到那个自称是舒滕巴赫的侏儒。</p><hr><h1 id="X"><a href="#X" class="headerlink" title="X"></a>X</h1><p>   “叶……”<br>   她看上去心情激动，金色的宝冠下，她那黑色的波浪般的卷发，垂在肩头，乌黑亮丽。立起的衣领是白色棉织，而袖口却镶着黑色条纹，两者通过紫罗兰色的紧身上衣连在一起。<br>   “花，别忘了花”，特莉丝在一旁提醒道，她一身深蓝色的装扮，递给新娘一束白玫瑰，“哦，叶。我太开心了……”<br>   “特莉丝，亲爱的……”叶妮芙突然抽泣起来，两个女术士紧紧地拥抱在一起，轻吻着彼此的钻石耳环。<br>   “意思意思就行了”南尼克在一旁不耐烦的提醒道，抚平洁白的祭祀服上的褶皱。“走，我们去教堂，爱若拉，尤妮德，托着她的裙摆，否则她会在楼梯口摔死自己的。”<br>   叶妮芙走向杰洛特伸出，伸出戴着白色蕾丝手套的手，整理了杰洛特嵌着银边的黑色斗篷的衣领，杰洛特伸出胳膊挽住她。<br>   “杰洛特，”他在她耳边轻轻的说道，“我还是不敢相信。”<br>   “叶，”杰洛特低声的回答道，“我爱你。”<br>   “我知道。”叶妮芙喃喃道。</p><hr><h1 id="XI"><a href="#XI" class="headerlink" title="XI"></a>XI</h1><p>   “赫维格死哪里去了？”<br>   “不知道，”丹德里恩一边轻抚着他那身时髦上衣的扣子，一边回答道。<br>   “说起来，希瑞去哪了？”<br>   “不知道。”叶妮芙皱起眉头，吸了吸鼻子。“你那股欧芹味的道不错啊，丹德里恩，你改吃素了吗？”<br>   宾客们开始陆续入场，小小的礼拜堂变得拥挤起来，一身黑礼服的艾格罗瓦尔坐在闪着白光的美人鱼希恩娜兹身边。他们的身边是一群穿着米黄色，棕色衣服的半身人，亚尔潘和金龙维纶特瑞坦梅斯则浑身上下金光闪闪，菲斯奈特和多瑞格雷则是一身紫色装扮，皇家使团的各位使者则和他们各自的纹章保持着一致的色调，精灵和树精是一身绿色。而丹德里恩和他的朋友们则穿的花里胡哨，五颜六色的的衣服。<br>   “有人看见洛基了吗？”莫斯萨克问道。<br>   “洛基？”艾斯卡尔走了过来，顺着装饰着野鸡毛的帽子看向德鲁伊。“洛基和赫维格一起湖上捕鱼去了，我看见他们的船还在湖上，希瑞则是去叫他们回来。”<br>   “这是什么时候的事?”<br>   “有一会了”。<br>   “诅咒你们得瘟疫，这群该死的渔夫，”克拉茨·安·克莱特咒骂道，“他们这是钓鱼钓上头了，把正事给忘了，雷格纳，去吧他们叫回来。”<br>   “等一下，”布蕾恩一把推开想要吃她豆腐的丹德里恩，“我们需要跑的快的人，莫娜，卡什卡， Raenn’ess aen laeke, va!”<br>   “早就说了，”南尼克气得不行，“赫维格根本就不靠谱，不敬畏神灵的白痴还要让他负责？谁还赞成他继续做主婚人？”<br>   “他好歹是个国王，”杰洛特不确定的说道，“可能叫前国王更确切，但好歹是个国王”<br>   “万岁……”一个算命的听到国王两个字后职业本能的开始唱起歌来，幸好，旁边的鳄鱼杀手及时放倒了他。半身人们开始骚动起来，有人骂骂咧咧，还有人被别人锤了鼻子，变形怪特里科踩到了加德尼娅·比伯威特的裙子，她开始尖叫起来，灵媒师则无缘无故的抽泣了起来<br>   “要是在这么等下去，”叶妮芙紧紧地抓住花束，努力保持着微笑，“再等一会我就要吐血了，马上给我开始。”<br>   “不要乱动，叶，”特莉丝悄声说道，“紧身衣要裂开了。”<br>   “那个侏儒舒滕巴赫跑到哪里去了，”一个歌手叫喊道。<br>   “我们也不知道啊。”四个妓女异口同声的喊道。<br>   “狗娘养的，马上派个人去找他，”丹德里恩大喊到，“他是负责带花过来的，现在可怎么办，舒滕巴赫和花都不在这，这婚礼可怎么继续？”<br>   被派去寻找国王的树精姐妹尖叫着冲进婚礼大厅，洛基则紧随其后，身上又脏又湿，前额上破了一个大口子。<br>   “洛基，”克拉奇喊了起来，“什么情况？”<br>   “妈妈！！！！！！”卡什卡哭喊道。<br>   “Que’ss aen!，”布蕾恩抓住她的两个女儿，抚慰她们，用精灵语问道，”Que’ss aen que suecc’ss feal, caer me?”<br>   “我们的船翻了……”洛基上气不接下气的说道，“就在岸边，来了只大怪物！，我用船桨揍他，但是他就直接吞了…….吞了我的船桨！”<br>   “谁？什么东西？”<br>   “杰洛特，”布蕾恩喊道，“杰洛特，莫娜说那是一只cinarea”<br>   “一只巨水蝽!”猎魔人惊叫道，“艾斯卡尔，快把我的剑拿来！”<br>   【怪物出自《精灵之血》，按照时间上来看，这是后来作者才安排的。】<br>   “我的法杖呢，”多瑞格雷也喊了一声，“雷德克里夫，我的法杖在哪？”<br>   “希瑞！”洛基喊了一声，擦了擦额头的鲜血，“希瑞正在和那怪兽战斗！”<br>   “操蛋了，希瑞根本打不过一只巨水蝽！艾斯卡尔，把我的马也牵来”<br>   “等一下，”叶妮芙甩掉头上的宝冠，“我们用传送门，那样更快，多瑞格雷，特莉丝，雷德克里夫，把你们的手给我……”<br>   一阵沉默过后，又响起了尖叫声，赫维格国王出现在门口，浑身又湿又脏，但是全身完好。他身边则站着一个光头的年轻人，身上穿着一套闪闪发光奇怪的盔甲。希瑞则紧随他们之后，手上提着格维尔，浑身泥泞，衣服滴着水，头发蓬乱，一道恐怖的伤疤横在脸上，从太阳穴直到下巴，袖口下的衣服被撕烂了，鲜血直流。<br>   “希瑞！！”<br>   “我杀了它，”猎魔人女孩弱弱的说道，“我劈开了它的头。”<br>   希瑞几乎要倒下了，杰洛特，艾斯卡尔和丹德里恩簇拥上前把住她，但就是这样她也没放开她的剑。<br>   “又受伤了……”吟游诗人悲叹到，“又是伤到了脸，为什么她的命运就这么不堪……”<br>   叶妮芙高声尖叫，一把推开雅尔，这个独臂的年轻人正好站在叶妮芙和希瑞之间，希瑞身上的泥巴和鲜血弄脏了女术士的婚纱，但是她一点也不在意。叶妮芙用手指按住猎魔人女孩的脸，吟诵了了一个魔法咒语，在杰洛特看来，整个城堡都因为这个法术晃了一下，甚至太阳也暗淡了一秒。叶妮芙缓慢的把手指从希瑞脸上移开，众人惊叹起来，巨大，丑陋的伤口变成一条细细的红线，只有几滴血而已，希瑞倒在杰洛特怀中。<br>   “厉害！”多瑞格雷感叹道，“这可是大师的手笔。”<br>   “干得好，叶，”特莉丝静静的说道，而一旁的南尼克则哭了起来。<br>   叶妮芙笑了笑，眼睛向上一翻，晕了过去，杰洛特还是在她如丝带般倒下之前抱住了她。</p><hr><h1 id="XII"><a href="#XII" class="headerlink" title="XII"></a>XII</h1><p>   “杰洛特，冷静，”南尼克说，“别太激动，过一会就好了，她只是用力过猛，别那么紧张了……你知道她有多爱希瑞。”<br>   “我知道。”杰洛特抬起头，看着门口站着的那个穿着一身闪闪发光的奇怪盔甲的年轻人。<br>   “听着，孩子，现在回到礼堂，这里没你事了，只是告诉我，你是谁？”<br>   “我，我是加拉哈德。”年轻的骑士回答道，“我想……我想问下那位美丽勇敢的少女怎么样了？”<br>   “哪一个？”猎魔人笑道，“这里有两个，两个都是漂亮，勇敢的少女，尽管其中一个只是偶然才是的，你说的是哪一个？”<br>   年轻人的脸，明显红了，“年轻的那一位……”他回答道，“就是那个义无反顾跑去帮助渔王的那位。”<br>   “谁？”<br>   “他说的是赫维格，”南尼克插嘴道，“巨水蝽在赫维格和洛基捕鱼时攻击了他们的船，希瑞则冲向了巨水蝽，而这个小伙子正好在近旁，过去帮了希瑞。”<br>   “你帮了希瑞，”猎魔人满怀感激的看着这个年轻的骑士，“你叫什么来着……”<br>   “加拉哈德，请问这里是阿瓦隆，渔王的城堡吗？”<br>   【阿瓦隆：亚瑟王传说中的极乐世界】<br>   门开了，叶妮芙在特莉丝的搀扶下出现在门口，她的脸色苍白。<br>   “叶！”<br>   “我们去礼堂。”女术士平静的要求到。“客人们都等着呢。”<br>   “叶……我们不急，可以再迟些。”<br>   “即使是恶魔要带走我，我也要嫁给你，而且是现在！”<br>   “希瑞怎么样了？”<br>   “哪个希瑞？”，猎魔人女孩从叶妮芙身后冒出，她正在往脸上涂抹着格拉玛耶。<br>   “一切都好，杰洛特，不过是一道擦伤，我都没什么感觉。”<br>   加拉哈德单膝跪地，铠甲发出金属碰撞的咯吱声。<br>   “女神……”<br>   希瑞漂亮的绿眼睛睁圆了。<br>   “希瑞，请允许我……”猎魔人说道，“这个骑士，嗯，加拉哈德，你们应当彼此见过了，他当时帮了你一把。”<br>   希瑞脸红了，格拉玛耶开始生效了，细小的伤疤在红润的脸蛋上几乎看不见了。<br>   “女神，”加拉哈德喃喃的说道，“您是如此亲切，如此美丽，请允许我留下,我想……”<br>   “毫无疑问，他想成为你的骑士，希瑞，”特莉丝说道。<br>   希瑞优雅的欠身行礼，但始终一句话也没说。<br>   “客人还等着呢，”叶妮芙打断他们。“加拉哈德，我在我看来，你不仅是个勇敢的战士，而且还是有礼貌的小伙子，你和我的……我的女儿并肩作战，所以，在婚礼上你可以挽住她，希瑞，快去换一身裙子，杰洛特，整理整理的你的头发，把你的内衬塞回袖子里去，都出来了，十分钟之内我要在礼堂看见你们。”</p><hr><h1 id="XIII"><a href="#XIII" class="headerlink" title="XIII"></a>XIII</h1><p>  婚礼仪式无比的辉煌，夫人和女孩们感动的哭成一片，赫维格——是前国王，但仍然是个国王——主持的婚礼，来自凯尔莫罕的维瑟米尔和南尼克作为这对新婚夫妻的父母方，特莉丝和艾斯卡尔是证婚人，加拉哈德陪着希瑞，后者脸红的像一枝娇艳的牡丹。<br>  佩剑的人们把剑搭在了一起，支起一个架子。丹德里恩和他的朋友们则演奏者鲁特琴，唱着特意为这个时刻谱写的曲子，在菲斯奈特的红发女儿们和美人鱼希恩娜兹的优美的歌声的伴奏下，丹德里恩开始即兴的祝愿这对新婚夫妻幸福，好运，以及一个成功的新婚之夜，听到这话，叶妮芙娇嗔的给了他一脚。【这里和原著有冲突，美人鱼献祭了尾巴换了腿以后，就失去了声音】<br>  人们聚集在王座大厅，各就各位，叶妮芙和杰洛特坐在主席上，手上绑着婚礼纱带，他们微笑着回应各位嘉宾的祝福和祝酒词。<br>  昨晚还乱搞一气的客人们，今晚则彻底变了样，都在以一种文明的方式尽情享乐，在相当长的一段时间里竟然没有人喝醉，当然只有一个人例外，那就是可怜的独臂小伙子雅尔，他无法忍受在加拉哈德甜甜的注视下满脸通红的希瑞，不停的喝闷酒 。今晚也没人意外失踪，除了卡什卡，不久之后，在桌子底下看见了她，她趴在一直狗身上，睡得正香呢。<br>  吸取了前一晚的教训，洛史洛格的鬼魂们也没有再来捣乱，只有一个例外，那就是只剩下骨架和裹尸布的马洪，突然出现在艾格罗瓦尔,莫斯萨克和菲斯奈特身后，然而王子，男爵和德鲁伊正非常专注的讨论政治，甚至都没有注意到他，由于没有一个人鸟他，这个骨架非常的沮丧。他在桌子旁四处走动，冷不丁的用他的牙齿咬了特莉丝一口，而女术士正温柔的依偎在艾斯卡尔的手臂上，她优雅的举起了手，掰断了他的手指头，狗处理了掰断的指骨。<br>  “愿伟大的梅里特利女神保佑你们夫妻俩，”南尼克亲吻了叶妮芙，和杰洛特碰了碰杯。“但是你们可没少走弯路，不过可算是结了婚。我真的很高兴，希望希瑞也能跟你们一样，找到命中注定的那个人后，能痛快的定下终生。”<br>  “我觉得，”杰洛特看向被猎魔人女孩迷住的加拉哈德，“她已经找到一个了。”<br>  “你说的是那个不知从哪里来的怪人？”女祭司惊讶道，“他们之间是没有结果的，你有没有仔细观察过那个人？没有？那你现在看看他在干嘛，他现在正在向希瑞求爱，但是手却不停的摸索着桌子上的酒杯，这可不太正常，我实在想不明白希瑞看他就像看一张照片那样仔细，雅尔，他可不一样，这孩子有理性，懂礼貌……”<br>  “您那有理性，懂礼貌的加尔已经摔到桌子下面去了，”叶妮芙打断了女祭司，“南尼克，别说了，希瑞过来了。”<br>  灰发的猎魔人女孩坐在赫维格让出的椅子上，搂住女术士。<br>  “我要离开了。”她平静地说。<br>  “我知道，孩子。”<br>  “加拉哈德……加拉哈德打算跟着我，也不知道为什么，我大概不能阻止他吧，对吗？”<br>  “当然阻止不了，杰洛特！”叶妮芙的眼睛，在温暖的紫罗兰色调中闪闪发光，看着她的丈夫，“到桌边去，陪客人们说说话，你也可以稍微喝上一小杯，但是只能是一小杯，我想和我的女儿谈谈，这是女人之间的谈话。”<br>  杰洛特叹了口气。<br>  聚会的氛围上来了。丹德里恩的朋友们唱的小黄歌让卡尔迪米恩的女儿安尼卡满脸通红。醉醺醺的龙v紧紧的抱着喝的更醉的变形怪特里科，试图说服他，变成a王子然后和美人鱼上床可不是个太友好的行为。<br>  菲斯奈特的红发女儿们则为了取悦那些皇家的使者们尽情的展现她们美妙的身姿，而皇家的使者们也在尽他们的全力打动树精们，看他们表演，总有种在游乐场的错觉。亚尔潘齐格林，用带有浓重鼻音的嗓子向精灵凯瑞尔丹说他打小就想当个精灵。莫斯萨克大喊着政府药丸，而艾格罗瓦尔则极力反对，当然也没人知道他们说的是哪个政府，赫维格国王则对加德尼娅说他用马鬃绳钓上了条大鲤鱼，半身人只是梦游般的点了点头，并且时不时的拍打下旁边的丈夫叫他不要喝的太多。<br>  画廊里，两个算命的和鳄鱼杀手则在四处走动，想找到那个名字叫舒滕巴赫的侏儒，但是仍旧找不到【未见侏儒——我们仍未找到那天前来赴宴的那个名字叫做舒滕巴赫的侏儒】，芙蕾雅显然讨厌酒量不行的男人，于是就在这和那个女灵媒师喝赫尔特·斯凯尔特，两人都保持着一种高尚和严肃的静默，因为这是一场无声的战斗。<br>  杰洛特绕着桌子走了一圈，挨个和客人们碰了杯，客人们也拍着他的背，祝他幸福。最后他来到了加拉哈德和丹德里恩附近，加拉哈德盯着诗人的酒杯，嘟嘟囔囔的说着什么，而吟游诗人则眯着眼睛仔细听着。杰洛特打算一探究竟。<br>  “……于是我就上了船，”加拉哈德说，“船驶向那片薄雾，我得向您承认，丹德里恩大师，我那时候怕的不行……我承认我有时候会失去希望，就像这次，我觉得我的末日到了，我会死在那片无法穿透的薄雾中，然后太阳就出来了…..在湖面上闪烁，就好像…金子一般。然后在我前方就是…阿瓦隆，这里是阿瓦隆，对吗？”<br>  “不是，”丹德里恩一边给两人满上，一边回答道，“这是Schwemmland，可以翻译成沼泽地……先喝一杯吧，加拉哈德。”<br>  “这个城堡……一定是蒙萨尔瓦特，不是吗？”<br>  “可不是，这个城堡叫洛史洛格，我就从来没听说过什么蒙萨尔瓦特，孩子，如果我都没听说过的话，那就是没有的事了，年轻人，为新婚夫妇干一杯吧。”<br>  “干杯，丹德里恩大师，但是那位国王，他不是渔王吗？”<br>  “赫维格？哦，他是挺喜欢钓鱼的，这倒是真的，他以前喜欢打猎，但是在奥斯战役中伤了腿，然后就再也不能骑马了，但你也不能叫人家渔王，首先，这个名字太蠢了，其次，你这样会冒犯到赫维格的。”<br>  加拉哈德半晌没说话，只是晃动着杯子中剩下一半的酒，然后他深深地叹了口气，环顾四周。<br>  “他们是对的，”他低声说道，“这只是个传说，一个童话，一段幻象，简而言之，这就是个谎言，这就是一片普通的沼泽地而不是阿瓦隆，没有希望了。”【阿瓦隆跟这个地方外表差不多】<br>  “喂，喂，”诗人用手戳了戳他，“不要伤心，孩子，你忧郁个什么劲？你正在参加一场婚礼派对，所以要做到就是高兴点，喝喝酒，唱唱歌。你还年轻，还有大把时光。还有一辈子的路要走。”<br>  “一辈子？”骑士若有所思的重复道，“那又如何，丹德里恩大师，有什么开始了，还是说有什么结束了？”<br>  丹德里恩好奇的看了他一眼。<br>  “不，我可不知道，如果连我都不知道的话，那就没人知道了，所以结论就是吗，没什么要结束，也没什么要开始。”<br>  “我不明白。”<br>  “你明白也没什么用。”</p><p>  加拉哈德想了想，皱起眉。<br>  “那圣杯呢？”他最后问道，“圣杯到哪里去了？”<br>  “圣杯又是什么东西？”<br>  “是我们追寻的东西，”他解释道，悲伤的看着吟游诗人，“那是最重要的，没有它，我们的生命就没什么意义，没有它，我们的生命永远不完整。”<br>  吟游诗人紧闭双唇，以他那著名的神色看向骑士，眼神中充满睿智和诚恳。<br>  “你个傻蛋，”他回答道，“你一整晚都坐在你的‘圣杯’旁边。”<br>  【这段亚瑟王的圆桌骑士异世界穿越是真的秀】</p><hr><h1 id="XIV"><a href="#XIV" class="headerlink" title="XIV"></a>XIV</h1><p>  午夜时分的，当客人已经玩的上头时，杰洛特和叶妮芙从宴会中脱离出来，他们终于可以平和的看看对方。突然，门开了，强盗维辛来了，人们都称他作“抢劫柏”，维辛身长两米开外，留着及腰长的大胡子，鼻子的颜色和形状都像萝卜，一直肩膀上扛着他那根著名的大棍子“牙签”，另一只肩膀上则扛着个大袋子。<br>  杰洛特和叶妮芙都认识这位“抢劫柏”。他俩谁也没想着要邀请他来。毫无疑问，这又是丹德里恩干的好事。<br>  “维辛，欢迎你，”女术士微笑道，“能记住我们真的是太好了，来，请坐”<br>  强盗倚着牙签，恭敬的鞠了一躬<br>  “祝你们快快乐乐，早生贵子”，他大声说道，“祝你们夫妻俩百年好合……我在说什么？两百年，该死的，应该是两百年。啊，我很高兴，杰洛特，还有叶妮芙夫人，我就知道你们会结婚的，尽管你们总是像,像狗一样打来打去。他妈的，我在说什么鸟话……”<br>  “欢迎，欢迎，维辛。”猎魔人说着，向着他能找到的最大的杯子倒酒，“为我们的健康干杯，你是打哪来的？有谣言说你进了监狱。”<br>  “他们把我给放了。”“抢劫柏”喝了一大口，叹了口气，“你们怎么说的，他妈的，保释？然后我就到这里来了，亲爱的，我给你们带了礼物，打开看看。”<br>  “这什么玩意，”女术士高声叫道，看着那个大口袋，里面的东西还在不停的动。<br>  “我是在路上看见的，”，抢劫柏回答道，“我是在花坛那里找见的，那有个光着屁股的石头女人，你知道的，就是有鸽子在上面……”<br>  “这袋子里到底是什么？”<br>  “哦，是一个，嗯，怎么说呢，一个小恶魔。这就当做新婚礼物了。你们这有放养动物的地方吗，没有？好吧，你们可以把他做成标本，然后挂着走廊上，人们看见了会惊叹的。但是我得告诉你，这他妈的是个骗子，他一直说自己叫舒滕巴赫。”</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/upload/pasted-357.png&quot;&gt;&lt;br&gt;《猎魔人》原著作者送给其朋友的结婚礼物，和正传发生的故事有些矛盾，但问题不大&lt;br&gt;高甜预警！！！&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
