<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>淋中之虹</title>
  
  <subtitle>向来不知道该说些什么</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.junglezero.top/"/>
  <updated>2019-07-17T14:08:28.089Z</updated>
  <id>https://www.junglezero.top/</id>
  
  <author>
    <name>JungleZero</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库SQL部分复习（3）【数据更新，视图】</title>
    <link href="https://www.junglezero.top/2019/07/17/tabasereview/"/>
    <id>https://www.junglezero.top/2019/07/17/tabasereview/</id>
    <published>2019-07-17T11:29:36.000Z</published>
    <updated>2019-07-17T14:08:28.089Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/upload/pasted-431.png" width="70%"></p><a id="more"></a><h1 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h1><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>一般的插入<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SC (Sno,Cno)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">' 200215128 '</span> , <span class="string">' 1 '</span>)</span><br></pre></td></tr></table></figure></p><p>插入查询结果<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Deptage (Sdept, Avgage) <span class="keyword">SELECT</span></span><br><span class="line">Sdept,</span><br><span class="line"><span class="keyword">AVG</span>(Sage)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">Student</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">Sdept</span><br></pre></td></tr></table></figure></p><p>插入多条结果<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSERTINTO table_name (col_one, col_two)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">'c1'</span>, <span class="string">'c2'</span>),</span><br><span class="line">(<span class="string">'c3'</span>, <span class="string">'c4'</span>)</span><br></pre></td></tr></table></figure></p><p>这种方式只能在mysql里面写</p><h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><p>一般修改<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Student</span><br><span class="line"><span class="keyword">SET</span> Sage = <span class="number">22</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">Sno = <span class="string">' 200215121 '</span></span><br></pre></td></tr></table></figure></p><p>批量修改<br>若不设置条件，则是针对全部<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> sc</span><br><span class="line"><span class="keyword">SET</span> grade = grade + <span class="number">1</span></span><br></pre></td></tr></table></figure></p><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">S</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">Sno = <span class="string">'200215125'</span></span><br></pre></td></tr></table></figure><h1 id="视图（View）"><a href="#视图（View）" class="headerlink" title="视图（View）"></a>视图（View）</h1><p>视图是一个虚拟表，其内容由查询定义。同真实表一样，视图包含一系列带有名称的列和行数据，但视图并不是数据库真实存储的数据表。<br>视图是从一个、多个表或者视图中导出的表，包含一系列带有名称的数据列和若干条数据行。<br>视图并不同于数据表，它们的区别在于以下几点：</p><ul><li>视图不是数据库中真实的表，而是一张虚拟表，其结构和数据是建立在对数据中真实表的查询基础上的。</li><li>存储在数据库中的查询操作 SQL 语句定义了视图的内容，列数据和行数据来自于视图查询所引用的实际表，引用视图时动态生成这些数据。</li><li>视图没有实际的物理记录，不是以数据集的形式存储在数据库中的，它所对应的数据实际上是存储在视图所引用的真实表中的。</li><li>视图是数据的窗口，而表是内容。表是实际数据的存放单位，而视图只是以不同的显示方式展示数据，其数据来源还是实际表。</li><li>视图是查看数据表的一种方法，可以查询数据表中某些字段构成的数据，只是一些 SQL 语句的集合。从安全的角度来看，视图的数据安全性更高，使用视图的用户不接触数据表，不知道表结构。</li><li>视图的建立和删除只影响视图本身，不影响对应的基本表。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/upload/pasted-431.png&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式总结</title>
    <link href="https://www.junglezero.top/2019/07/17/sign-pattern/"/>
    <id>https://www.junglezero.top/2019/07/17/sign-pattern/</id>
    <published>2019-07-17T11:16:41.000Z</published>
    <updated>2019-07-17T14:12:40.860Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/upload/pasted-430.png" width="70%"></p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/upload/pasted-430.png&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库SQL部分复习(2)【约束，数据类型，查询，连接查询，嵌套查询】</title>
    <link href="https://www.junglezero.top/2019/07/16/tabaseSQLReview-2/"/>
    <id>https://www.junglezero.top/2019/07/16/tabaseSQLReview-2/</id>
    <published>2019-07-16T08:22:35.000Z</published>
    <updated>2019-07-17T14:01:06.786Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/upload/pasted-427.png" width="70%"></p><a id="more"></a><hr><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><h2 id="模式（SCHEMA）-数据库（DATABASE）相关"><a href="#模式（SCHEMA）-数据库（DATABASE）相关" class="headerlink" title="模式（SCHEMA）,数据库（DATABASE）相关"></a>模式（SCHEMA）,数据库（DATABASE）相关</h2><p>MySQL官方文档指出，从概念上讲，模式是一组相互关联的数据库对象，如表，表列，列的数据类型，索引，外键等等。但是从物理层面上来说，模式与数据库是同义的。你可以在MySQL的SQL语法中用关键字SCHEMA替代DATABASE，例如使用CREATE SCHEMA来代替CREATE DATABASE。<br>也就是说，一个SCHEMA就是一套关系<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">SCHEMA</span> <span class="number">123</span></span><br></pre></td></tr></table></figure></p><p>就可以创建出一个新的数据库（DATABASE）</p><h2 id="表（TABLE）相关"><a href="#表（TABLE）相关" class="headerlink" title="表（TABLE）相关"></a>表（TABLE）相关</h2><h3 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h3><ul><li>主键约束（PRIMARY KEY)<br>主键约束是用来保证表中记录唯一可区分的列。一个表可以通过一列或列组合的数据来唯一标识表中的每一条记录。</li><li>唯一约束（UNIQUE)<br>规定一条记录的一个字段值或几个字段的组合值不得与其他记录的相同字段或字段组合的值重复，将这种限制成为“唯一约束”。</li><li>外键约束 (FOREIGN KEY)<br>1）外键列可以由是一个列或多个列组成。<br>2）外键列的取值可以为空，可以有重复值，但必须是它所引用列的列值之一。引用列必须是创建了主键约束或唯一约束的列。</li><li><p>检查约束 （CHECK)<br>检查约束是用来检查一个字段或多个字段的输入值是否满足指定的约束条件。</p></li><li><p>默认值约束（DEFAULT)<br>在用户定义数据类型的情况下，如果使用默认值约束，则默认值被插入到使用这个自定义数据的所有字段中。</p></li><li><p>空值约束（NULL)<br>空值约束就是指尚不知道或不确定的数据值，它不等同于0或空格。</p></li></ul><h3 id="数据库的基本数据类型（以MySQL为标准）"><a href="#数据库的基本数据类型（以MySQL为标准）" class="headerlink" title="数据库的基本数据类型（以MySQL为标准）"></a>数据库的基本数据类型（以MySQL为标准）</h3><h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><p>MySQL中提供了以下几种整数类型，可以设置自增约束</p><p><img src="\\upload\pasted-414.png\" alt="upload successful"><br>各个整数类型范围如下<br><img src="\\upload\pasted-415.png\" alt="upload successful"></p><h4 id="小数类型"><a href="#小数类型" class="headerlink" title="小数类型"></a>小数类型</h4><p>MySQL 中使用浮点数和定点数来表示小数。<br>浮点类型有两种，分别是单精度浮点数（FLOAT）和双精度浮点数（DOUBLE）；定点类型只有一种，就是 DECIMAL<br>两种类型都可以用（M,D）表示，其中M称为精度，表示总共的位数；D称为标度，表示小数的位数。<br>浮点数类型的取值范围为 M（1～255）和 D（1～30，且不能大于 M-2）DECIMAL 的默认 D 值为 0、M 值为 10<br> FLOAT 和 DOUBLE 在不指定精度时，默认会按照实际的精度（由计算机硬件和操作系统决定），DECIMAL 如果不指定精度，默认为（10，0）。<br> 不论是定点还是浮点类型，如果用户指定的精度超出精度范围，则会四舍五入进行处理。</p><p><img src="/upload/pasted-416.png" alt="upload successful"><br> 在 MySQL 中，定点数以字符串形式存储，在对精度要求比较高的时候（如货币、科学数据），使用 DECIMAL 的类型比较好，另外两个浮点数进行减法和比较运算时也容易出问题，所以在使用浮点数时需要注意，并尽量避免做浮点数比较。</p><h4 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h4><p>MySQL 中表示日期的数据类型：YEAR、TIME、DATE、DTAETIME、TIMESTAMP。当只记录年信息的时候，可以只使用 YEAR 类型。<br>当指定确定不合法的值时，系统将“零”值插入数据库中</p><p><img src="\\upload\pasted-417.png\" alt="upload successful"><br>对于YEAR,除了整数外也可以匹配形如YYYY的四位字符串或者两位字符串，对于两位的数字和字符串，0-69回转化为2001-2069，而70-99会转化为1970-1999<br>对于TIME,小时部分之所以会大出一部分的原因是可以用TIME表示某件事发展的时长，除了给定的格式外，可以用HHMMSS表示，但是对于这种输入，MySQL是从秒开始处理的。对于非法的输入，则储存0时间<br>对于DATE基本和上面有相似的规则，可以调用CURRENT_DATE 或者 NOW()，插入当前系统日期</p><p>DATETIME 在存储日期数据时，按实际输入的格式存储，即输入什么就存储什么，与时区无关；<br>TIMESTAMP 值的存储是以 UTC（世界标准时间）格式保存的，存储时对当前时区进行转换，检索时再转换回当前时区。即查询时，根据当前时区的不同，显示的时间值是不同的。</p><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p>MySQL 中的字符串类型有 CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、ENUM、SET 等。</p><p><img src="\\upload\pasted-418.png\" alt="upload successful"><br>char是定长字符串类型，即不管要储存的字符串多长，它只储存规定的长度，不管多短，会用空格补齐剩下的，而varchar是变长的，只能规定最大长度，其实际的储存空间为字符串占的空间+1（字符串结束标识）</p><p><img src="/upload/pasted-419.png" alt="upload successful"><br>ENUM是MySQL内的枚举类型，每个具体字符串对应一个索引值，ENUM 类型的字段在取值时，能在指定的枚举列表中获取，而且一次只能取一个。如果创建的成员中有空格，尾部的空格将自动被删除。ENUM 列总有一个默认值。如果将 ENUM 列声明为 NULL，NULL 值则为该列的一个有效值，并且默认值为 NULL。如果 ENUM 列被声明为 NOT NULL，其默认值为允许的值列表的第 1 个元素。<br>SET是一个加强版的枚举，可以选择多个值加入</p><h4 id="二进制类型"><a href="#二进制类型" class="headerlink" title="二进制类型"></a>二进制类型</h4><p>MySQL 中的二进制字符串有 BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。</p><p><img src="\\upload\pasted-420.png\" alt="upload successful"></p><h3 id="表的创建"><a href="#表的创建" class="headerlink" title="表的创建"></a>表的创建</h3><p>建立一个“学生选课”表SC，它由学号Sno、课程号Cno，修课成绩Grade组成，其中(Sno, Cno)为主码。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">(    Sno <span class="built_in">CHAR</span>(<span class="number">5</span>) ,</span><br><span class="line">     Cno <span class="built_in">CHAR</span>(<span class="number">3</span>) , </span><br><span class="line">     Grade   <span class="built_in">int</span>,</span><br><span class="line">     Primary <span class="keyword">key</span> (Sno, Cno),</span><br><span class="line">     <span class="keyword">Foreign</span> <span class="keyword">key</span> (sno) <span class="keyword">References</span> student (sno),</span><br><span class="line">     <span class="keyword">Foreign</span> <span class="keyword">key</span> (cno) <span class="keyword">References</span> course (cno)  );</span><br></pre></td></tr></table></figure><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="查询全部"><a href="#查询全部" class="headerlink" title="查询全部"></a>查询全部</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> STUDENT</span><br></pre></td></tr></table></figure><h3 id="查询某一列"><a href="#查询某一列" class="headerlink" title="查询某一列"></a>查询某一列</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sno <span class="keyword">FROM</span> STUDENT</span><br></pre></td></tr></table></figure><h3 id="查询经过计算结果"><a href="#查询经过计算结果" class="headerlink" title="查询经过计算结果"></a>查询经过计算结果</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title,</span><br><span class="line">price * <span class="number">50</span> <span class="keyword">AS</span> <span class="number">50</span>price</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film_list</span><br></pre></td></tr></table></figure><h3 id="利用case-when替换查询结果"><a href="#利用case-when替换查询结果" class="headerlink" title="利用case when替换查询结果"></a>利用case when替换查询结果</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title,</span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> price &gt; <span class="number">0.99</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="string">'ex'</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line"><span class="string">'chep'</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">AS</span> price</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film_list</span><br></pre></td></tr></table></figure><h3 id="利用CONCAT连接查询结果，利用cast转化结果"><a href="#利用CONCAT连接查询结果，利用cast转化结果" class="headerlink" title="利用CONCAT连接查询结果，利用cast转化结果"></a>利用CONCAT连接查询结果，利用cast转化结果</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">CONCAT</span>(title,<span class="string">'的票价是'</span>,<span class="keyword">CAST</span>(price <span class="keyword">AS</span> <span class="built_in">char</span>)) <span class="keyword">as</span> 价格说明</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film_list</span><br></pre></td></tr></table></figure><h3 id="查询结果返回大小写，字符串长度"><a href="#查询结果返回大小写，字符串长度" class="headerlink" title="查询结果返回大小写，字符串长度"></a>查询结果返回大小写，字符串长度</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">LOWER</span>(title),</span><br><span class="line"><span class="keyword">UPPER</span>(title),</span><br><span class="line"><span class="keyword">LENGTH</span>(title)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film_list</span><br></pre></td></tr></table></figure><h3 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h3><p>1、left(str,length) 从左边截取length<br>2、right(str,length)从右边截取length<br>3、substring(str,index)当index&gt;0从左边开始截取直到结束  当index&lt;0从右边开始截取直到结束  当index=0返回空<br>4、substring(str,index,len) 截取str,从index开始，截取len长度<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">left</span>(title,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film_list</span><br></pre></td></tr></table></figure></p><h3 id="日期相关函数"><a href="#日期相关函数" class="headerlink" title="日期相关函数"></a>日期相关函数</h3><p>now()获取当前的日期和时间<br>current_timestamp() 获取当前时间戳<br>date_format(date,format), time_format(time,format) 转换时间形式<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">DATE_FORMAT</span>(last_update, <span class="string">'%y%m%d%h%i%s'</span>) <span class="keyword">AS</span> <span class="string">'时间序列'</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br></pre></td></tr></table></figure></p><p>（日期、天数）转换函数：to_days(date), from_days(days)<br>（时间、秒）转换函数：time_to_sec(time), sec_to_time(seconds)<br>拼凑日期、时间函数：makdedate(year,dayofyear), maketime(hour,minute,second)<br>（Unix 时间戳、日期）转换函数</p><h3 id="集合，范围查询"><a href="#集合，范围查询" class="headerlink" title="集合，范围查询"></a>集合，范围查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> rating <span class="keyword">in</span> (<span class="string">'PG'</span>,<span class="string">'R'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">customer_id </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">payment</span><br><span class="line"><span class="keyword">where</span> payment_date <span class="keyword">BETWEEN</span> <span class="string">'2005-06-17 09:19:45'</span> <span class="keyword">and</span> <span class="string">'2005-08-02 18:55:15'</span></span><br></pre></td></tr></table></figure><p>注意 between是左闭右开的</p><h3 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h3><h4 id="Like-匹配"><a href="#Like-匹配" class="headerlink" title="Like 匹配"></a>Like 匹配</h4><p>1.%：表示任意0个或多个字符。可匹配任意类型和长度的字符，有些情况下若是中文，请使用两个百分号（%%）表示<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title <span class="keyword">LIKE</span> <span class="string">'%W%'</span></span><br></pre></td></tr></table></figure></p><p>若是要搜索包含某两个字的<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title <span class="keyword">LIKE</span> <span class="string">'%W%'</span> <span class="keyword">and</span> title <span class="keyword">LIKE</span> <span class="string">'%O%'</span></span><br></pre></td></tr></table></figure></p><p>2._： 表示任意单个字符。匹配单个任意字符<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title <span class="keyword">LIKE</span> <span class="string">'_O%'</span></span><br></pre></td></tr></table></figure></p><h4 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h4><p>^ 匹配字符开始的部分<br>查询以W开头的<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title REGEXP <span class="string">'^W'</span></span><br></pre></td></tr></table></figure></p><p>$ 匹配字符结束的部分<br>查询以S为结尾的部分<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title REGEXP <span class="string">'S$'</span></span><br></pre></td></tr></table></figure></p><p>. 匹配字符串中的任意一个字符，包括回车和换行<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title REGEXP <span class="string">'^W................S$'</span></span><br></pre></td></tr></table></figure></p><p>[字符集合]匹配字符集合中的任意字符<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title REGEXP <span class="string">'^W[OE]'</span></span><br></pre></td></tr></table></figure></p><p>[^字符集合]匹配除了字符集合外的任意字符<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title REGEXP <span class="string">'^W[^B-Z]'</span></span><br></pre></td></tr></table></figure></p><p>s1|s2|s3 匹配s1s2s3中的任意一个<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title REGEXP  <span class="string">'^WA|^WE|^WH'</span></span><br></pre></td></tr></table></figure></p><p>*代表多个该字符前的字符，包括0个或1个<br>+代表多个该字符前的字符，包括1个<br>字符串{N} 字符串出现N次<br>字符串{M，N}字符串最少出现M次，最多出现N次<br>若是查找的就是转义字符本身，最后要加上ESCAPE</p><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>使用GROUP BY 进行分组<br>将查询的结果按某一列或多列的值分组，值相等的<br>为一组<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">rating,<span class="keyword">COUNT</span>(rating)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> rating</span><br></pre></td></tr></table></figure></p><p>使用GROUP BY子句后，SELECT子句的列名列表中只能出现分组属性和集函数<br>若要想要对分完的组做条件筛选，则需要用Having而不是where<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">rating,<span class="keyword">COUNT</span>(rating)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> rating</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(rating)&gt;<span class="number">195</span><span class="string">`sql</span></span><br></pre></td></tr></table></figure></p><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>可以基于关系运算的连接来理解连接查询</p><ul><li><p>广义笛卡尔积（交叉连接）<br>又称非限制连接，它将两个表不加任何约束地组合在一起，也就是将第一个表中的所有记录分别与第二个表的所有记录组成新的记录。（进行广义笛卡尔乘积）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="string">`language`</span>.*,staff.*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line"><span class="string">`language`</span>,staff</span><br></pre></td></tr></table></figure></li><li><p>等值连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  student.Sno,Sname,sex,Cno,Grade</span><br><span class="line"><span class="keyword">FROM</span>     student,sc</span><br><span class="line"><span class="keyword">WHERE</span>  student.sno = sc.sno</span><br></pre></td></tr></table></figure></li></ul><p>任何子句中引用表1和表2中同名属性时，都必须加表名前缀。引用唯一属性名时可以加也可以省略表名前缀<br>也可以用内连接表示等值连接<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">student.Sno,</span><br><span class="line">Sname,</span><br><span class="line">sex,</span><br><span class="line">Cno,</span><br><span class="line">Grade</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> sc <span class="keyword">ON</span> student.sno = sc.sno</span><br></pre></td></tr></table></figure></p><ul><li><p>自然连接<br>是一种特殊的等值链接，在等值连接的基础上，去掉相同的属性</p></li><li><p>自然连接<br>自表的某个属性进行对比<br>例：查一门课的先修课</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  FIRST.Cno，SECOND.Cpno</span><br><span class="line"><span class="keyword">FROM</span>  Course  <span class="keyword">FIRST</span>，Course  <span class="keyword">SECOND</span></span><br><span class="line"><span class="keyword">WHERE</span> FIRST.Cpno = SECOND.Cno；</span><br></pre></td></tr></table></figure></li></ul><p><img src="\\upload\pasted-424.png\" alt="upload successful"></p><ul><li><p>外连接<br>外连接就是一种不等值连接，相比于等值连接只输出相等部分的连接情况，这种方式会输出所有的情况两边的所有情况，没有的值则用空替代<br>MySQL并不支持</p></li><li><p>左外连接<br>以左边的为基础，除了相等的部分，还会输出左边不符合条件的，空的地方用null装</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">student.Sno,</span><br><span class="line">Sname,</span><br><span class="line">sex,</span><br><span class="line">Cno,</span><br><span class="line">Grade</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student</span><br><span class="line"><span class="keyword">LEFT</span>  <span class="keyword">JOIN</span> sc <span class="keyword">ON</span> student.sno=sc.sno</span><br></pre></td></tr></table></figure></li></ul><p><img src="/upload/pasted-425.png" alt="upload successful"></p><ul><li>右外连接<br>则是以右边的为基础<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">student.Sno,</span><br><span class="line">Sname,</span><br><span class="line">sex,</span><br><span class="line">Cno,</span><br><span class="line">Grade</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student</span><br><span class="line"><span class="keyword">RIGHT</span>  <span class="keyword">JOIN</span> sc <span class="keyword">ON</span> student.sno=sc.sno</span><br></pre></td></tr></table></figure></li></ul><p><img src="\\upload\pasted-426.png\" alt="upload successful"></p><h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><p>嵌套查询就是把一些“出处”变成查询结果<br>对于MySQL，嵌套的查询结果要有别名<br>例如 查询与刘晨在一个系学习的学生<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sno,</span><br><span class="line">sname,</span><br><span class="line">sdept</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">s</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sdept <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sdept</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">s</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sname = <span class="string">'刘晨'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">s1.sno,</span><br><span class="line">s1.sname,</span><br><span class="line">s1.sdept</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">s s1,</span><br><span class="line">s s2</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">s1.sdept = s2.sdept</span><br><span class="line"><span class="keyword">AND</span> s2.sname = <span class="string">' 刘晨 '</span></span><br></pre></td></tr></table></figure><p>ANY和ALL<br>any是某一个值，all是所有值，可以大于小于不等于<br>例选择编号01同学的成绩中大于04同学所有科目的成绩的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">sname,</span><br><span class="line">cno,</span><br><span class="line">grade</span><br><span class="line">FROM</span><br><span class="line">(</span><br><span class="line">SELECT</span><br><span class="line">student.Sno,</span><br><span class="line">Sname,</span><br><span class="line">sex,</span><br><span class="line">Cno,</span><br><span class="line">Grade</span><br><span class="line">FROM</span><br><span class="line">student</span><br><span class="line">INNER JOIN sc ON student.sno = sc.sno</span><br><span class="line">) AS a</span><br><span class="line">WHERE</span><br><span class="line">grade &gt; ALL (</span><br><span class="line">SELECT</span><br><span class="line">grade</span><br><span class="line">FROM</span><br><span class="line">sc</span><br><span class="line">WHERE</span><br><span class="line">sno = &apos;01&apos;</span><br><span class="line">) </span><br><span class="line">AND sno = &apos;04&apos;</span><br></pre></td></tr></table></figure></p><p>EXISTS<br>首先要理解这个关键词的运行机制<br>例子：选出选了课程1001的人<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student <span class="keyword">as</span> a</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">EXISTS</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">sc</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sno = a.sno</span><br><span class="line"><span class="keyword">AND</span> cno = <span class="string">'1001'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>使用exist，会对where前面的主查询语句进行逐一校验，对于前面的某一条记录，如果能使exist后的查询语句有返回值（不是空），那么此时exist判定就是true，对于主查询，当前这一条就会作为结果，如果不符合，就不会被作为结果</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/upload/pasted-427.png&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库SQL部分复习（1）【关系模型，关系运算】</title>
    <link href="https://www.junglezero.top/2019/07/16/%E5%BA%93SQL%E9%83%A8%E5%88%86%E5%A4%8D%E4%B9%A0/"/>
    <id>https://www.junglezero.top/2019/07/16/库SQL部分复习/</id>
    <published>2019-07-16T01:47:14.000Z</published>
    <updated>2019-07-17T13:56:27.284Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/upload/pasted-429.png" width="70%"></p><a id="more"></a><hr><h1 id="实体联系模型（E-R）"><a href="#实体联系模型（E-R）" class="headerlink" title="实体联系模型（E-R）"></a>实体联系模型（E-R）</h1><p>实体型之间的联系：一对一联系（１：１）、一对多联系（１：N）、   多对多联系（Ｍ：Ｎ）<br>  例： 假设一个学生可选多门课程，而一门课程又有多个学生选修，每个学生每选一门课只有一个成绩， 一个教师只能讲一门课程，一门课程也可有多个教师讲授，一门课使用多本参考书。画出E－R图。</p><p><img src="/upload/pasted-393.png" alt="upload successful"></p><h1 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h1><p>在用户观点下，关系模型中数据的逻辑结构是一张二维表，它由行和列组成。</p><p><img src="/upload/pasted-392.png" alt="upload successful"><br>关系数据模型的数据结构</p><ul><li>关系（Relation）<br>通常指的是一张表</li><li>元组（Tuple）<br>表中的一行即为一个元组</li><li>属性(attribute)<br>一列即为一个属性</li><li>主码（key）<br>表中的某一个属性组，可以唯一确定一个元组</li><li>域（Domain）<br>属性的取值范围</li><li>分量<br>元组中的一个属性值<h1 id="数据库的三级模式结构"><a href="#数据库的三级模式结构" class="headerlink" title="数据库的三级模式结构"></a>数据库的三级模式结构</h1><h2 id="模式（Schema）"><a href="#模式（Schema）" class="headerlink" title="模式（Schema）"></a>模式（Schema）</h2></li></ul><p><img src="/upload/pasted-394.png" alt="upload successful"><br>模式（也称逻辑模式）<br>数据库中全体数据的逻辑结构和特征的描述<br>所有用户的公共数据视图，综合了所有用户的需求<br>一个数据库只有一个模式<br>模式的地位：是数据库系统模式结构的中间层<br>与数据的物理存储细节和硬件环境无关<br>与具体的应用程序、开发工具及高级程序设计语言无关<br>模式的定义：<br>数据的逻辑结构（数据项的名字、类型、取值范围等）<br>数据之间的联系<br>数据有关的安全性、完整性要求</p><h3 id="外模式-External-Schema"><a href="#外模式-External-Schema" class="headerlink" title="外模式(External Schema)"></a>外模式(External Schema)</h3><p>外模式（也称子模式或用户模式）<br>数据库用户（包括应用程序员和最终用户）使用的局部数据的逻辑结构和特征的描述<br>数据库用户的数据视图，是与某一应用有关的数据的逻辑表示<br>模式与外模式的关系：一对多<br>通常是模式的子集；一个数据库可以有多个外模式<br>外模式与应用的关系：一对多<br>同一外模式可以为某一用户的多个应用系统所使用，<br>但一个应用程序只能使用一个外模式<br>外模式是保证数据库安全性的一个有力措施<br>每个用户只能看见和访问所对应的外模式中的数据</p><h3 id="内模式（Internal-Schema）"><a href="#内模式（Internal-Schema）" class="headerlink" title="内模式（Internal Schema）"></a>内模式（Internal Schema）</h3><p>是数据物理结构和存储方式的描述<br>是数据在数据库内部的表示方式<br>记录的存储方式（顺序存储，按照B树结构存储，按hash方法存储）/ 索引的组织方式 / 数据是否压缩存储 / 数据是否加密 / 数据存储记录结构的规定<br>一个数据库只有一个内模式</p><h1 id="关系模型和关系"><a href="#关系模型和关系" class="headerlink" title="关系模型和关系"></a>关系模型和关系</h1><p>关系模型的数据结构非常简单，只包含单一的数据结构—-关系。在关系模型中，实体和实体间的各种联系都用关系表示。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>域（Domain）<br>一组具有相同数据类型的值的集合</li><li>笛卡尔积（Cartesian Product）<br><img src="/upload/pasted-395.png" alt="upload successful"></li></ul><p><img src="/upload/pasted-396.png" alt="upload successful"><br>笛卡尔积的每一个结果(d1,d2,d3,d4)被称为元组（Tuple）;<br>笛卡尔积的每一个结果中的具体的值di叫做一个分量（Component）<br>笛卡尔积做出的结果的元组数是基数（Cardinal number）</p><ul><li>关系<br><img src="/upload/pasted-397.png" alt="upload successful"></li><li>属性<br>每列的名字</li><li>码<ul><li>候选码（Candidate key）<br>若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选码<br>在最简单的情况下，候选码只包含一个属性。<br>在最极端的情况下，关系模式的所有属性组是这个关系模式的候选码，称为全码（All-key）</li><li>主码<br>若一个关系有多个候选码，则选定其中一个为主码（Primary key）<br>侯选码的诸属性称为主属性（Prime attribute）。<br>不包含在任何侯选码中的属性称为非码属性（Non-key attribute） </li></ul></li></ul><h2 id="三类关系"><a href="#三类关系" class="headerlink" title="三类关系"></a>三类关系</h2><p><img src="/upload/pasted-398.png" alt="upload successful"></p><h2 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h2><p><img src="/upload/pasted-399.png" alt="upload successful"></p><p><img src="/upload/pasted-400.png" alt="upload successful"></p><h2 id="关系的基本运算"><a href="#关系的基本运算" class="headerlink" title="关系的基本运算"></a>关系的基本运算</h2><p>设两个关系R,S：有相同的目n，相应的属性取自同一个域</p><ul><li>选择</li></ul><p><img src="/upload/pasted-406.png" alt="upload successful"></p><p><img src="/upload/pasted-407.png" alt="upload successful"></p><ul><li>投影</li></ul><p><img src="/upload/pasted-408.png" alt="upload successful"></p><ul><li>并<br>R∪S = { t|t Î R∨t ÎS }</li></ul><p><img src="/upload/pasted-402.png" alt="upload successful"></p><ul><li>差<br>R -S = { t|tÎR∧tÏS }<br><img src="/upload/pasted-403.png" alt="upload successful"></li><li>笛卡尔积</li></ul><p><img src="/upload/pasted-404.png" alt="upload successful"></p><p><img src="/upload/pasted-405.png" alt="upload successful"></p><ul><li>交<br>R∩S = { t|t Î R∧t ÎS }<br>R∩S = R –(R-S）</li><li>连接<br><img src="/upload/pasted-409.png" alt="upload successful"><br><img src="/upload/pasted-410.png" alt="upload successful"><br>有两类连接，包括等值连接和自然连接<br>等值连接<br><img src="/upload/pasted-411.png" alt="upload successful"><br>自然连接<br><img src="/upload/pasted-412.png" alt="upload successful"><br>相当于是一种合并<br><img src="/upload/pasted-413.png" alt="upload successful"></li></ul><h2 id="实体完整性（Entity-Integrity）"><a href="#实体完整性（Entity-Integrity）" class="headerlink" title="实体完整性（Entity Integrity）"></a>实体完整性（Entity Integrity）</h2><p>若属性A是基本关系R的主属性，则属性A不能取空值</p><h2 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h2><p>设F是基本关系R的一个或一组属性，但不是关系R的码。如果F与基本关系S的主码Ks相对应，则称F是基本关系R的外码，基本关系R称为参照关系（Referencing Relation）<br>基本关系S称为被参照关系（Reference Relation）或目标关系（Target  Relation）<br>若属性（或属性组）F是基本关系R的外码<br>它与基本关系S的主码Ks相对应（基本关<br>系R和S不一定是不同的关系），则对<br>于R中每个元组在F上的值必须为：<br>· 或者取空值（F的每个属性值均为空值）<br>· 或者等于S中某个元组的主码值。</p><p><img src="/upload/pasted-401.png" alt="upload successful"><br>用人话来说，就是外键不能是自己造出来的</p><h2 id="关系代数运算题目实例"><a href="#关系代数运算题目实例" class="headerlink" title="关系代数运算题目实例"></a>关系代数运算题目实例</h2><p>设教学数据库有3个关系<br>学生关系 S（Sno，Sname，age，sex）<br>成绩关系 SC（Sno，Cno，grade）<br>课程关系 C（Cno，Cname，teacher）</p><ol><li>LIU老师所教授课程的课程号，课程名<br>∏CNO,CNAME(σTNAME=‘LIU’ （C））</li><li>检索年龄大于23岁的男学生的学号和姓名<br>∏SNO,SNAME（ σ AGE&gt;23 ∧ SEX=‘M’（S））</li><li>检索学号为S3学生所学课程的课程名与任课老师名<br> ∏CNAME,TNAME（ σ SNO=‘S3’（SC）∞(C)）</li><li>检索至少选修LIU老师所教授课程中一门课的女学生姓名<br>  ∏SNAME(σSEX=‘F’(S)∞SC∞σTNAME=‘LIU’(C))</li><li>检索wang同学不学课程的课程号<br> ∏CNO(C)-∏CNO(σSNAME=‘WANG’(S)∞SC)</li><li>检索至少选修两门课的学生学号<br>∏1(σ1=4 ∧ 2!=5(SC × SC))</li><li>检索全部学生都选修的课程的课程号和课程名<br> ∏CNO,CNAME,SNO(C ∞SC) ÷ ∏SNO(S)</li><li>检索选修课程包含LIU老师所教授课程的学生学号<br>∏CNO,SNO(SC) ÷ ∏CNO(σTNAME=‘LIU’(C))</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/upload/pasted-429.png&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java多线程学习8（线程池，阻塞队列（BlockingQueue）FutureTask,Callable）</title>
    <link href="https://www.junglezero.top/2019/07/12/va-mitple-thread8/"/>
    <id>https://www.junglezero.top/2019/07/12/va-mitple-thread8/</id>
    <published>2019-07-12T12:21:40.000Z</published>
    <updated>2019-07-17T13:54:47.374Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/upload/pasted-428.png" width="70%"></p><a id="more"></a><hr><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2><h3 id="框架简介"><a href="#框架简介" class="headerlink" title="框架简介"></a>框架简介</h3><p><img src="/upload/pasted-367.png" alt="upload successful"><br>而具体说来，Executor是一个接口，对于这个接口，API文档是这样描述的。</p><blockquote><p>An object that executes submitted Runnable tasks. This interface provides a way of decoupling task submission from the mechanics of how each task will be run, including details of thread use, scheduling, etc. An Executor is normally used instead of explicitly creating threads.</p></blockquote><p>第一句话强调了这个的用法就是提交任务，并通过Executor来运行，可以用Executor来替代显示的调用Thread，把实现任务的细节封装。<br>对于该接口，可以直接在调用线程运行任务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirectExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    r.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一般则是另起线程运行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以构造一个组件化的Executor,把任务的执行序列化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前类继承一个Executor</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Queue&lt;Runnable&gt; tasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</span><br><span class="line">   <span class="keyword">final</span> Executor executor;</span><br><span class="line">   Runnable active;</span><br><span class="line"></span><br><span class="line">   SerialExecutor(Executor executor) &#123;</span><br><span class="line">     <span class="keyword">this</span>.executor = executor;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</span><br><span class="line">     tasks.offer(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">           r.run();</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           scheduleNext();</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="keyword">if</span> (active == <span class="keyword">null</span>) &#123;</span><br><span class="line">       scheduleNext();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> ((active = tasks.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">       executor.execute(active);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>说来说去，Executor不过是提供了一个接口，一种线程服务的思路，具体的线程复杂操作还是要看他的各个实现类<br>和继承接口</p><p><img src="/upload/pasted-368.png" alt="upload successful"><br>这才是整个Executor的体系框架</p><h2 id="BlockingQueue（阻塞队列）"><a href="#BlockingQueue（阻塞队列）" class="headerlink" title="BlockingQueue（阻塞队列）"></a>BlockingQueue（阻塞队列）</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>所谓阻塞队列，就是比一般队列多了两个操作的队列</p><p><img src="/upload/pasted-370.png" alt="upload successful"></p><p><img src="/upload/pasted-371.png" alt="upload successful"></p><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><h3 id="七个属性"><a href="#七个属性" class="headerlink" title="七个属性"></a>七个属性</h3><p> 结合自已以前实现的一个<a href="https://www.junglezero.top/2019/04/02/%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/">线程池</a>，对于其大概的属性已经有了初步了解。<br> 从ThreadPoolExecutor的构造函数开始看起，有四个重载的构造函数，找到其中参数最多的那个</p><p><img src="/upload/pasted-369.png" alt="upload successful"><br>和以前自己的实现的思路基本差不多：<br>核心线程数量、最大线程数量、多余线程存活时间（相比于核心线程多出来的线程在空闲时的存活时间）、时间单位、任务队列(阻塞队列)、线程工厂方法、拒绝策略</p><p>可以用以下的测试理解这几个属性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> TestMain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor= (ThreadPoolExecutor) buildThreadPool();</span><br><span class="line">        <span class="keyword">int</span> activeCount=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> queueSize=-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//线程池执行一个任务（Runable）</span></span><br><span class="line">        threadPoolExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                DoingJobs(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程池执行两个任务（Runable）</span></span><br><span class="line">        threadPoolExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                DoingJobs(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//。。。</span></span><br><span class="line">        <span class="comment">//当活跃线程数量发生改变时输出</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (activeCount!=threadPoolExecutor.getActiveCount()||queueSize!=threadPoolExecutor.getQueue().size())&#123;</span><br><span class="line">                System.out.println(<span class="string">"线程池中活跃线程数量："</span>+threadPoolExecutor.getActiveCount());</span><br><span class="line">                System.out.println(<span class="string">"核心线程数量（固定的）："</span>+threadPoolExecutor.getCorePoolSize());</span><br><span class="line">                System.out.println(<span class="string">"任务队列中等待执行的任务数量："</span>+threadPoolExecutor.getQueue().size());</span><br><span class="line">                activeCount=threadPoolExecutor.getActiveCount();</span><br><span class="line">                queueSize=threadPoolExecutor.getQueue().size();</span><br><span class="line">                System.out.println(<span class="string">"================================"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">buildThreadPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//核心线程数为1，最大线程池为2，存活时间为10s，阻塞队列（任务队列）的大小为1</span></span><br><span class="line">        ExecutorService executorService=<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                Thread t=<span class="keyword">new</span> Thread(r);</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">        System.out.println(<span class="string">"线程池创建成功！"</span>);</span><br><span class="line">        <span class="keyword">return</span> executorService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用Sleep来模拟线程运行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoingJobs</span><span class="params">(<span class="keyword">long</span> seconds)</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"正在执行任务"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(seconds);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当任务为1个时</p><p><img src="/upload/pasted-373.png" alt="upload successful"></p><p>当任务为2时</p><p><img src="/upload/pasted-372.png" alt="upload successful"><br>可以发现，当任务为2时，线程池并没有创建新的线程，因为任务可以在队列中等待</p><p>当任务为3时，此时把测试方法中的活跃线程数量改为线程池大小（线程中线程的数量）</p><p><img src="/upload/pasted-374.png" alt="upload successful"><br>可以发现，当任务队列慢的时候，再有新的任务加入，线程池就会根据最大线程数量创建新的线程共同执行任务，当任务队列中没有任务时，过了存回时间，多创建出的线程就会被销毁。</p><p>当任务有4个时</p><p><img src="/upload/pasted-375.png" alt="upload successful"><br>此时多出一个任务，无法进入阻塞队列，也无法执行，拒绝策略生效。</p><h2 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h2><p>线程池的关闭涉及到三个方法</p><p><img src="/upload/pasted-376.png" alt="upload successful"></p><p><img src="/upload/pasted-377.png" alt="upload successful"></p><p><img src="/upload/pasted-378.png" alt="upload successful"><br>通过测试可以发现<br>shutdown方法：平滑的关闭ExecutorService，当此方法被调用时，ExecutorService停止接收新的任务并且等待已经提交的任务（包含提交正在执行和提交未执行）执行完成。<br>当所有已提交任务执行完毕，线程池即被关闭。<br>awaitTermination方法：接收timeout和unit两个参数，用于设定超时时间及单位。当等待超过设定时间时，会监测ExecutorService是否已经关闭，<br>若关闭则返回true，否则返回false。一般情况下会和shutdown方法组合使用。<br>shutdown调用后，不可以再submit新的task，已经submit的将继续执行。<br>shutdownNow试图停止当前正执行的task，并返回尚未执行的task的list</p><p>因此最好的关闭线程池的方式是shutdown+awaitTermination</p><h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><p>Executors是一个工厂类<br>其中包括了许多关于线程池及Executors框架相关的创建方法<br>毕竟拿七个参数创建一个线程池太复杂了<br><img src="/upload/pasted-379.png" alt="upload successful"></p><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><blockquote><p>Creates a thread pool that creates new threads as needed, but will reuse previously constructed threads when they are available. These pools will typically improve the performance of programs that execute many short-lived asynchronous tasks. Calls to execute will reuse previously constructed threads if available. If no existing thread is available, a new thread will be created and added to the pool. Threads that have not been used for sixty seconds are terminated and removed from the cache. Thus, a pool that remains idle for long enough will not consume any resources. Note that pools with similar properties but different details (for example, timeout parameters) may be created using ThreadPoolExecutor constructors.</p></blockquote><p>这种线程池的特点就是按照需求创建线程以处理更多的耗时短的异步任务<br>看其具体实现就可以知道<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，这个线程池一开始核心线程就是0，最大线程数量却相当于没有限制，存活时间为1分钟，这就很好的印证了按需分配创建线程的思路。而关键还是在这个阻塞队列上<br>SynchronousQueue是一种很特殊的阻塞队列，其中每个 put 必须等待一个 take，否则会进入wait状态反之亦然。同步队列没有任何内部容量，甚至连一个队列的容量都没有。<br>使用完成后不需要显示的调用shotdown<br>注意：仅适合周期短的多任务，因为创建线程的数量是没用限制的</p><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顾名思义，这是一种固定线程数量的线程池，不会额外去创建，阻塞队列采用LinkedBlockingQueue,是以链表为内核实现的阻塞队列，默认大小为Integar.Max<br>使用完成后需要shutdown</p><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">    (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                            <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br></pre></td></tr></table></figure><p>这个实际上就是newFixedThreadPool线程数量设置为1的时候</p><h3 id="newWorkStealingPool"><a href="#newWorkStealingPool" class="headerlink" title="newWorkStealingPool"></a>newWorkStealingPool</h3><p>这是在1.8新出的一种线程池服务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">        (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种服务是根据cpu个数创建的ForkJoinPool,根据前面讲的，ForkJoinPool中执行的是ForkJoinTask，Runable是不行的<br>看源码可以知道，传入Runable以后，会执行一个内部的转换</p><p>这种线程数量的确定和创建时是根据电脑根据cpu个数创建的（等于）<br>工作窃取概念：所谓工作窃取，指的是闲置的线程去处理本不属于它的任务。<br>每个处理器核，都有一个队列存储着需要完成的任务。对于多核的机器来说，当一个核对应的任务处理完毕后，就可以去帮助其他的核处理任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    ForkJoinTask&lt;?&gt; job;</span><br><span class="line">    <span class="keyword">if</span> (task <span class="keyword">instanceof</span> ForkJoinTask&lt;?&gt;) <span class="comment">// avoid re-wrap</span></span><br><span class="line">        job = (ForkJoinTask&lt;?&gt;) task;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        job = <span class="keyword">new</span> ForkJoinTask.RunnableExecuteAction(task);</span><br><span class="line">    externalSubmit(job);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在用Callable来执行（线程的第三种实现方法）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorsTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService =Executors.newWorkStealingPool();</span><br><span class="line">        System.out.println(executorService.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">         <span class="comment">//这里可以先把Callable当成是有返回值的Runable</span></span><br><span class="line">        List&lt;Callable&lt;String&gt;&gt; callables=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> ( ;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">            Callable&lt;String&gt; callable=<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="comment">//call方法就相当于Run方法</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                    sleep(<span class="number">2</span>);</span><br><span class="line">                    <span class="comment">//可以有返回值</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"任务被"</span>+Thread.currentThread().getName();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">             callables.add(callable);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//批量运行，且将返回运行结果Future</span></span><br><span class="line">            List&lt;Future&lt;String&gt;&gt; futures=executorService.invokeAll(callables);</span><br><span class="line">            <span class="comment">//若是没有执行完，这里会是堵塞的</span></span><br><span class="line">            <span class="keyword">for</span> (Future f:futures)&#123;</span><br><span class="line">                System.out.println(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> seconds)</span></span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           TimeUnit.SECONDS.sleep(seconds);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><p><img src="/upload/pasted-381.png" alt="upload successful"><br>可以发现，这种线程池服务也是自动退出的</p><h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor。它主要用来在给定的延迟之后运行任务，或者定期执行任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolExecutorDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个实现了Runable的时间任务类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String id;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TimerTask</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        ScheduledExecutorService ses = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//调用scheduleAtFixedRate来进行周期执行，拿第一个来说，开始时延是200ms，周期为1000ms</span></span><br><span class="line">        ScheduledFuture sfa = ses.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask(<span class="string">"a"</span>), <span class="number">200</span>,</span><br><span class="line">                                                    <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        ScheduledFuture sfb = ses.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask(<span class="string">"b"</span>), <span class="number">400</span>, </span><br><span class="line">                                                    <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        ScheduledFuture sfc = ses.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask(<span class="string">"c"</span>), <span class="number">600</span>,</span><br><span class="line">                                                    <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        ScheduledFuture sfd = ses.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask(<span class="string">"d"</span>), <span class="number">800</span>, </span><br><span class="line">                                                    <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        sfa.cancel(<span class="keyword">true</span>);</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        ses.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程运行时发生错误的处理"><a href="#线程运行时发生错误的处理" class="headerlink" title="线程运行时发生错误的处理"></a>线程运行时发生错误的处理</h2><p>一般情况下，可以<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread t=<span class="keyword">new</span> Thread();</span><br><span class="line">t.setUncaughtExceptionHandler(<span class="keyword">new</span> Thread.UncaughtExceptionHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(t.getName()+<span class="string">"运行时发生错误~！"</span>);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>如果线程的实现不是自己定义的<br>如果是=自己定义的，则可以定义内部方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Error</span><span class="params">(Throwable e)</span></span>&#123;</span><br><span class="line">     System.out.println(<span class="string">"当前线程发生错误"</span>);</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="拒绝策略细节"><a href="#拒绝策略细节" class="headerlink" title="拒绝策略细节"></a>拒绝策略细节</h2><h3 id="ThreadPoolExecutor-AbortPolicy"><a href="#ThreadPoolExecutor-AbortPolicy" class="headerlink" title="ThreadPoolExecutor.AbortPolicy()"></a>ThreadPoolExecutor.AbortPolicy()</h3><p>这个策略中，不能执行且不能进入阻塞队列的任务会直接被抛出异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p><img src="/upload/pasted-382.png" alt="upload successful"></p><h3 id="new-ThreadPoolExecutor-DiscardPolicy"><a href="#new-ThreadPoolExecutor-DiscardPolicy" class="headerlink" title="new ThreadPoolExecutor.DiscardPolicy()"></a>new ThreadPoolExecutor.DiscardPolicy()</h3><p>这个拒绝策略则不会做出任何事</p><h3 id="ThreadPoolExecutor-CallerRunsPolicy"><a href="#ThreadPoolExecutor-CallerRunsPolicy" class="headerlink" title="ThreadPoolExecutor.CallerRunsPolicy()"></a>ThreadPoolExecutor.CallerRunsPolicy()</h3><p>这个策略会在execute 方法的调用线程中运行被拒绝的任务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line"></span><br><span class="line">               r.run();</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><p><img src="/upload/pasted-383.png" alt="upload successful"></p><h3 id="ThreadPoolExecutor-DiscardOldestPolicy"><a href="#ThreadPoolExecutor-DiscardOldestPolicy" class="headerlink" title="ThreadPoolExecutor.DiscardOldestPolicy()"></a>ThreadPoolExecutor.DiscardOldestPolicy()</h3><p>这个方法会把阻塞队列的队尾元素去除，然后执行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line"></span><br><span class="line">        e.getQueue().poll();</span><br><span class="line"></span><br><span class="line">        e.execute(r);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="ExecutorService-几个其他方法"><a href="#ExecutorService-几个其他方法" class="headerlink" title="ExecutorService 几个其他方法"></a>ExecutorService 几个其他方法</h2><h3 id="invokeAny"><a href="#invokeAny" class="headerlink" title="invokeAny"></a>invokeAny</h3><p>测试方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">testInvokeAny</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ExecutorService executorService= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    List&lt;Callable&lt;Integer&gt;&gt; callables=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//创建5个Callable</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        Callable&lt;Integer&gt; callable= <span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">//先进入随机的sleep</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>));</span><br><span class="line">                <span class="comment">//输出语句</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//放入集合中</span></span><br><span class="line">        callables.add(callable);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//输出invokeany的结果</span></span><br><span class="line">        System.out.println(executorService.invokeAny(callables));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><p><img src="/upload/pasted-384.png" alt="upload successful"><br>也就是说，运行invokeany，当运行的那一个任务运行完毕后，会取消掉其他正在运行的任务<br>注意：这个方法是一个阻塞方法，也就是说只有选定的某个任务执行完成，才会有返回值，否则会一直陷入阻塞状态<br>另外，该方法的重载方法还可以添加TimeOut,超过TimeOut时间，其他任务取消运行。抛出Timeout异常。</p><h3 id="invokeAll"><a href="#invokeAll" class="headerlink" title="invokeAll"></a>invokeAll</h3><p><img src="/upload/pasted-385.png" alt="upload successful"><br>这个方法也是一个阻塞方法</p><h3 id="submit-Runable"><a href="#submit-Runable" class="headerlink" title="submit(Runable)"></a>submit(Runable)</h3><p><img src="/upload/pasted-386.png" alt="upload successful"><br>这个方法可以返回一个结果值，但是由于Runable没有返回值所以可以手动传入一个值作为返回值（Future）</p><h1 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h1><p>Future是一个接口</p><blockquote><p>A Future represents the result of an asynchronous computation. Methods are provided to check if the computation is complete, to wait for its completion, and to retrieve the result of the computation. The result can only be retrieved using method get when the computation has completed, blocking if necessary until it is ready. Cancellation is performed by the cancel method. Additional methods are provided to determine if the task completed normally or was cancelled. Once a computation has completed, the computation cannot be cancelled. If you would like to use a Future for the sake of cancellability but not provide a usable result, you can declare types of the form Future&lt;?&gt; and return null as a result of the underlying task. </p></blockquote><p>future可以理解为一个票据，表示一个某个任务的结果，我们不是非要等到这个任务执行完毕才能进行别的任务，我们，我们可以在这个任务执行时，先去执行别的任务，等到这个任务执行完毕，再通过future获得任务的结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        Callable&lt;String&gt; longTimeJob=<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"长时工作完成"</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Callable&lt;String&gt; shotTimeJob=<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"短时工作完成"</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Future&lt;String&gt; res1=executorService.submit(longTimeJob);</span><br><span class="line">        Future&lt;String&gt; res2=executorService.submit(shotTimeJob);</span><br><span class="line">        System.out.println(res1);</span><br><span class="line">        System.out.println(res2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Future的方法"><a href="#Future的方法" class="headerlink" title="Future的方法"></a>Future的方法</h2><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p>Waits if necessary for the computation to complete, and then retrieves its result.<br>也就是说，通过票据Future获得线程的运行结果（Callable），会使线程陷入阻塞（会使调用get方法的线程进入阻塞,和线程池执行任务的线程无关）<br>比如(res1是长时任务的结果)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"主线程！！！！"</span>);</span><br><span class="line">    System.out.println(res1.get());</span><br><span class="line">    System.out.println(<span class="string">"&gt;?&gt;&gt;?&gt;&gt;&gt;?&gt;"</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果输出:</p><p><img src="/upload/pasted-387.png" alt="upload successful"><br>重载方法中，有一个TimeOut的参数，若调用get超时，则调用get方法的线程会抛timeout异常，但是未完成的任务仍然会继续进行。</p><h3 id="isDone"><a href="#isDone" class="headerlink" title="isDone"></a>isDone</h3><p><img src="/upload/pasted-389.png" alt="upload successful"><br>任务完成了，返回true；任务没完成，出现了异常，任务不能再继续做了，返回true，任务在做了，返回false</p><h3 id="cancle"><a href="#cancle" class="headerlink" title="cancle"></a>cancle</h3><p><img src="/upload/pasted-390.png" alt="upload successful"><br>如果取消任务成功则返回true，如果取消任务失败则返回false。参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。</p><h1 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h1><p>FutureTask是Runable和Future的实现类（是Future的唯一实现）<br>所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    ExecutorService executorService= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    Thread doingLong=<span class="keyword">null</span>;</span><br><span class="line">    FutureTask&lt;String&gt; futureTask=<span class="keyword">new</span> FutureTask&lt;String&gt;(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"任务任务任务"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    executorService.submit(futureTask);</span><br><span class="line">    System.out.println(futureTask.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h1><p>铺垫了这么多，Callable也就很好理解了，</p><p><img src="/upload/pasted-391.png" alt="upload successful"><br>Callable和Runable类似，但是它却可以有返回值</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/upload/pasted-428.png&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java多线程学习7（Exchanger,StampedLock,Fork/join,Phaser）</title>
    <link href="https://www.junglezero.top/2019/07/09/java-mutiple-threading-7/"/>
    <id>https://www.junglezero.top/2019/07/09/java-mutiple-threading-7/</id>
    <published>2019-07-09T03:36:52.000Z</published>
    <updated>2019-07-12T04:37:33.974Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/upload/pasted-356.png" width="70%"></p><a id="more"></a><hr><h1 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>A synchronization point at which threads can pair and swap elements within pairs. Each thread presents some object on entry to the exchange method, matches with a partner thread, and receives its partner’s object on return. An Exchanger may be viewed as a bidirectional form of a SynchronousQueue. Exchangers may be useful in applications such as genetic algorithms and pipeline designs. </p></blockquote><p>主要内容：提供一个同步点，使一对线程交换数据，可以使用在遗传算法和管道设计上</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><img src="/upload/pasted-351.png" alt="upload successful"><br>简要来说就是调用该方法的线程会进入等待状态，等待其他线程调用，若有其他线程调用，则交换两者数据（把参数中的object传过去，返回传回来的object），注意一个及时性，即使调用该方法后休眠，也不会影响交换，若非特殊情况下的阻断，则调用该方法会一直等下去，<br>若有超过两个线程都调用exchange方法，则先到交换点（先调用方法）的两个线程会交换数据，若第三个线程调用，则会等待第四个线程调用来交换数据</p><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Exchanger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置交换器</span></span><br><span class="line">        <span class="keyword">final</span> Exchanger&lt;String&gt; exchanger=<span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"开始运行。"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//模拟为该线程有的数据</span></span><br><span class="line">                    String myData=<span class="string">"123456789"</span>;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"交换之前的数据:"</span>+myData);</span><br><span class="line">                    <span class="comment">//调用交换器的exchange方法，并返回交换的结果（进入交换点等待另一个线程调用该方法）</span></span><br><span class="line">                    String exchangeResult=exchanger.exchange(myData);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"交换之后的数据:"</span>+exchangeResult);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"结束。"</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"开始运行。"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String myData=<span class="string">"987654321"</span>;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"交换之前的数据:"</span>+myData);</span><br><span class="line">                    String exchangeResult=exchanger.exchange(myData);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"交换之后的数据:"</span>+exchangeResult);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"结束。"</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="/upload/pasted-352.png" alt="upload successful"></p><h1 id="StamperdLock"><a href="#StamperdLock" class="headerlink" title="StamperdLock"></a>StamperdLock</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>这是java1.8新增加的锁（在JUC中），是对ReentrantReadWriteLock锁的一种改进:基于读的乐观锁<br>在Optimistic reading中，即使读线程获取到了读锁，写线程尝试获取写锁也不会阻塞，这相当于对读模式的优化，但是可能会导致数据不一致的问题。所以，当使用Optimistic reading获取到读锁时，必须对获取结果进行校验。<br>注意：StampededLock不支持重入</p><p><img src="/upload/pasted-353.png" alt="upload successful"></p><p>这里有一篇<a href="https://blog.overops.com/java-8-stampedlocks-vs-readwritelocks-and-synchronized/" target="_blank" rel="noopener">文章</a>,在这片文章中，作者讨论了synchronized,StampedLocks,和RWlock的效率对比，可以发现当读线程远多于写线程时，乐观锁的效率是最高的。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>可以使用StampededLock直接替代reentrantreadwritelock<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.StampedLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLockTest</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> StampedLock lock=<span class="keyword">new</span> StampedLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> List&lt;Long&gt; DATA=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ExecutorService executorService= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        Runnable readTask=<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (;;)</span><br><span class="line">                    read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable writeTask =<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (;;)</span><br><span class="line">                    write();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(writeTask);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//悲观式读取</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamped=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamped=lock.readLock();</span><br><span class="line">            <span class="comment">//模拟读取数据</span></span><br><span class="line">            System.out.println(DATA.toString());</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlockRead(stamped);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamp=lock.writeLock();</span><br><span class="line">            DATA.add(System.currentTimeMillis());</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而这个锁的改进就是对读加上乐观锁<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> stamped = lock.tryOptimisticRead();</span><br><span class="line">    <span class="keyword">if</span> (lock.validate(stamped)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamped = lock.readLock();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Fork-join"><a href="#Fork-join" class="headerlink" title="Fork/join"></a>Fork/join</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>Fork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。<br>Fork就是把一个大任务切分为若干子任务并行的执行，Join就是合并这些子任务的执行结果，最后得到这个大任务的结果<br>ForkJoinTask是轻量级的线程形式<br><img src="/upload/pasted-354.png" alt="upload successful"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>一般是使用ForkJoinTask 的继承类RecursiveAction（无返回值）和RecursiveTask（有返回值），并且依附在ForkJoinPool上进行使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分割任务的最大阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_THRSHOLD=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ForkJoinPool forkJoinPool=<span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        <span class="comment">//把ForkJoinTask提交ForkJoinPool进行运行</span></span><br><span class="line">        <span class="comment">//计算范围为0到10</span></span><br><span class="line">        ForkJoinTask&lt;Integer&gt; future=forkJoinPool.submit(<span class="keyword">new</span> ComputeRecursiveTask(<span class="number">0</span>,<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer result=<span class="number">0</span>;</span><br><span class="line">            result=future.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算的Fork/join线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputeRecursiveTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算的起始和终点</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> start;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">ComputeRecursiveTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//当发现起始和终点的相差的小于阈值时</span></span><br><span class="line">            <span class="keyword">if</span> (end-start&lt;=MAX_THRSHOLD)&#123;</span><br><span class="line">                <span class="comment">//直接计算返回结果，这里模拟的的是累加</span></span><br><span class="line">                <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">                    result+=i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//将起始到终点二分，分成两个子部分</span></span><br><span class="line">                <span class="keyword">int</span> middle=(start-end);</span><br><span class="line">                ComputeRecursiveTask leftRecursiveTask=<span class="keyword">new</span> ComputeRecursiveTask(start,middle);</span><br><span class="line">                ComputeRecursiveTask rightRecursiveTask=<span class="keyword">new</span> ComputeRecursiveTask(middle,end);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//调用fork进行执行</span></span><br><span class="line">                leftRecursiveTask.fork();</span><br><span class="line">                rightRecursiveTask.fork();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//最终的结果就是两个join</span></span><br><span class="line">                <span class="keyword">return</span> leftRecursiveTask.join()+rightRecursiveTask.join();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>文档讲到，这是一个可复用的同步器栅栏，可以理解为时CyclicBarrier和CountDownLatch的一个升级版<br>Phaser类机制是在每一步结束的位置对线程进行同步，当所有的线程都完成了这一步，才能进行下一步。<br>用来解决控制多个线程分阶段共同完成任务的情景问题。<br>当有并发任务并且需要分解成几步执行的时候，这种机制就非常适合。<br>CyclicBarrier CountDownLatch 只能在构造时指定参与量，而phaser可以动态的增减参与量<br>且Phaser支持父子结构，可以用在fork/join框架中</p><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><p><img src="/upload/pasted-358.png" alt="upload successful"></p><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>API中给到的几个使用例子<br>可以替代CountDownLatch来执行只需运行一次的线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runTasks</span><span class="params">(List&lt;Runnable&gt; tasks)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Phaser phaser = <span class="keyword">new</span> Phaser(<span class="number">1</span>); <span class="comment">// 参数为1，表示phaser计数为1</span></span><br><span class="line">   <span class="comment">// 创建并开始线程</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">final</span> Runnable task : tasks) &#123;</span><br><span class="line">   <span class="comment">//phaser添加一个新的运行部分</span></span><br><span class="line">     phaser.register();</span><br><span class="line">     <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         phaser.arriveAndAwaitAdvance(); <span class="comment">// await all creation</span></span><br><span class="line">         task.run();</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;.start();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//允许线程开始执行并在运行结束后注销（一次执行），不等着其他线程</span></span><br><span class="line">   phaser.arriveAndDeregister();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>重复执行一系列线程：重写onAdvance方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startTasks</span><span class="params">(List&lt;Runnable&gt; tasks, <span class="keyword">final</span> <span class="keyword">int</span> iterations)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Phaser phaser = <span class="keyword">new</span> Phaser() &#123;</span><br><span class="line">   <span class="comment">//重写该方法，来确定phaser的终止条件（返回true 表示终止）</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> phase &gt;= iterations || registeredParties == <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   phaser.register();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">final</span> Runnable task : tasks) &#123;</span><br><span class="line">     phaser.register();</span><br><span class="line">     <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">do</span> &#123;</span><br><span class="line">           task.run();</span><br><span class="line">           phaser.arriveAndAwaitAdvance();</span><br><span class="line">         &#125; <span class="keyword">while</span> (!phaser.isTerminated());</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;.start();</span><br><span class="line">   &#125;</span><br><span class="line">   phaser.arriveAndDeregister(); <span class="comment">// deregister self, don't wait</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>自己写的例子：模仿CyclicBarrier<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Phaser;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhaserTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Phaser phaser=<span class="keyword">new</span> Phaser();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            Task a=<span class="keyword">new</span> Task(phaser);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将主线程运行块加入phaser</span></span><br><span class="line">        phaser.register();</span><br><span class="line">        phaser.arriveAndAwaitAdvance();</span><br><span class="line">        System.out.println(<span class="string">"全部线程全部完成"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Phaser taskPhaser;</span><br><span class="line">        Task(Phaser phaser)&#123;</span><br><span class="line">            taskPhaser=phaser;</span><br><span class="line">            <span class="comment">//新添加一个运行块</span></span><br><span class="line">            phaser.register();</span><br><span class="line">            <span class="comment">//直接运行</span></span><br><span class="line">            start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"正在工作中》》》》》"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//线程到达并等待运行</span></span><br><span class="line">            taskPhaser.arriveAndAwaitAdvance();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><img src="/upload/pasted-359.png" alt="upload successful"></p><p>多个线程分阶段共同完成任务:完成铁人三项<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Phaser;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhaserTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Phaser phaser=<span class="keyword">new</span> Phaser(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Athletes(i,phaser).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Athletes</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Phaser phaser;</span><br><span class="line"></span><br><span class="line">        Athletes(<span class="keyword">int</span> num,Phaser phaser)&#123;</span><br><span class="line">            <span class="keyword">this</span>.num=num;</span><br><span class="line">            <span class="keyword">this</span>.phaser=phaser;</span><br><span class="line">            <span class="comment">//phaser.register();</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"No."</span>+num+<span class="string">"开始跑了"</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>));</span><br><span class="line">                System.out.println(<span class="string">"No."</span>+num+<span class="string">"跑到头了"</span>);</span><br><span class="line"></span><br><span class="line">                phaser.arriveAndAwaitAdvance();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"No."</span>+num+<span class="string">"开始游泳了"</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>));</span><br><span class="line">                System.out.println(<span class="string">"No."</span>+num+<span class="string">"游泳到头了"</span>);</span><br><span class="line"></span><br><span class="line">                phaser.arriveAndAwaitAdvance();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"No."</span>+num+<span class="string">"开始骑自行车了"</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>));</span><br><span class="line">                System.out.println(<span class="string">"No."</span>+num+<span class="string">"骑自行车到头了"</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><img src="/upload/pasted-360.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/upload/pasted-356.png&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java语言基础知识和其他应该知道的东西</title>
    <link href="https://www.junglezero.top/2019/07/06/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://www.junglezero.top/2019/07/06/Java语言基础知识/</id>
    <published>2019-07-06T02:53:05.000Z</published>
    <updated>2019-07-14T01:19:13.048Z</updated>
    
    <content type="html"><![CDATA[<p># </p><h2 id="ArrayList和Linkedlist区别"><a href="#ArrayList和Linkedlist区别" class="headerlink" title="ArrayList和Linkedlist区别"></a>ArrayList和Linkedlist区别</h2><p>1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。<br>2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。<br>3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。<br>4．对ArrayList和LinkedList而言，在列表末尾增加一个元素所花的开销都是固定的。对ArrayList而言，主要是在内部数组中增加一项，指向所添加的元素，偶尔可能会导致对数组重新进行分配；而对LinkedList而言，这个开销是统一的，分配一个内部Entry对象。<br>5．在ArrayList的中间插入或删除一个元素意味着这个列表中剩余的元素都会被移动；而在LinkedList的中间插入或删除一个元素的开销是固定的。<br>6．LinkedList不支持高效的随机元素访问。<br>7．ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间 </p><h2 id="java方法“值传递”的理解"><a href="#java方法“值传递”的理解" class="headerlink" title="java方法“值传递”的理解"></a>java方法“值传递”的理解</h2><p>java中的数据类型有基本类型和引用类型，他们都是值传递方式。基本类型传递的是它的值，因此方法中的改变参数的值，不会影响方法外。引用类型传递的是一个地址，因为引用类型在生成对象实例时，里面的值是一个地址，指向了对象实例。在传值的时候实际上传的是一个地址，他们指向了同一块地址，所以在方法内的改变会影响方法外的参数。 这里比较乱人心的是包装类型，因为包装类型也是引用类型，这里应该就是和包装类型的实现有关了，在包装类型中，比如Integer a=1，有一个自动装箱的操作。其实a=1，如果现在令a=2，不会令2覆盖1（即1本身是不会变的），真正改变的是a被赋给了一个新地址，这个地址指向了2。因此方法内的改变包装类型的值就相当于改变了形参里面的地址，相当于重新new了一遍。而方法外面的实参仍旧指向含1的那个地址，一次方法内的改变不会影响方法外的实参。 </p><p><img src="/upload/pasted-320.png" alt="upload successful"></p><h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><p>Volatile：与锁相比，Volatile 变量是一种非常简单但同时又非常脆弱的同步机制，它在某些情况下将提供优于锁的性能和伸缩性。如果严格遵循 volatile 的使用条件 —— 即变量真正独立于其他变量和自己以前的值 —— 在某些情况下可以使用 volatile 代替 synchronized 来简化代码。然而，使用 volatile 的代码往往比使用锁的代码更加容易出错。<br>只能在有限的一些情形下使用 volatile 变量替代锁。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：</p><ul><li>（1）对变量的写操作不依赖于当前值。</li><li>（2）该变量没有包含在具有其他变量的不变式中。<br>实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。<br>第一个条件的限制使 volatile 变量不能用作线程安全计数器。虽然增量操作（x++）看上去类似一个单独操作，实际上它是一个由读取－修改－写入操作序列组成的组合操作，必须以原子方式执行，而 volatile 不能提供必须的原子特性。实现正确的操作需要使 x 的值在操作期间保持不变，而 volatile 变量无法实现这点。 </li></ul><h2 id="数组复制"><a href="#数组复制" class="headerlink" title="数组复制"></a>数组复制</h2><p>1.for循环<br>2.System.arraycopy<br>3.Arrays.copyOf<br>4.clone</p><h2 id="类的加载顺序"><a href="#类的加载顺序" class="headerlink" title="类的加载顺序"></a>类的加载顺序</h2><p>(1) 父类静态代码块(包括静态初始化块，静态属性，但不包括静态方法)<br>(2) 子类静态代码块(包括静态初始化块，静态属性，但不包括静态方法 )<br>(3) 父类非静态代码块( 包括非静态初始化块，非静态属性 )<br>(4) 父类构造函数<br>(5) 子类非静态代码块 ( 包括非静态初始化块，非静态属性 )<br>(6) 子类构造函数</p><h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p>1、不管有没有出现异常，finally块中代码都会执行；<br>2、当try和catch中有return时，finally仍然会执行；<br>3、finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，不管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值），所以函数返回值是在finally执行前确定的；<br>4、finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。</p><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="registerNatives"><a href="#registerNatives" class="headerlink" title="registerNatives()"></a>registerNatives()</h3><p>向JVM注册native方法<br>在类初始化的时候，会依次从父类到本类的类变量及类初始化块中的类变量及方法按照定义顺序放到 &lt; clinit&gt;方法中，这样可以保证父类的类变量及方法的初始化一定先于子类。所以当子类调用相应 native方法，比如计算 hashCode时，一定可以保证能够调用到 JVM的 native方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">       registerNatives();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h3 id="getClass"><a href="#getClass" class="headerlink" title="getClass()"></a>getClass()</h3><p>类加载的第一阶段类的加载就是将 .class文件加载到内存，并生成一个 java.lang.Class对象的过程。 getClass()方法就是获取这个对象，这是当前类的对象在运行时类的所有信息的集合。这个方法是反射三种方式之一。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure></p><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><p>这个方法返回一个int类型的hash值<br>在 Java应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改；<br>如果两个对象 x.equals(y) 方法返回 true，则 x、 y这两个对象的 hashCode必须相等。<br>如果两个对象 x.equals(y) 方法返回 false，则 x、 y这两个对象的 hashCode可以相等也可以不等。但是，为不相等的对象生成不同整数结果可以提高哈希表的性能。<br>默认的 hashCode是将内存地址转换为的 hash值，重写过后就是自定义的计算方式；也可以通过 System.identityHashCode(Object)来返回原本的 hashCode。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>计算 hashCode使用了31作为基础乘数，为什么使用31呢？result *31=(result&lt;&lt;5)-result。 JVM底层可以自动做优化为位运算，效率很高；还有因为 31计算的 hashCode冲突较少，利于 hash桶位的分布。</p><h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><p>用于比较当前对象与目标对象是否相等，默认是比较引用是否指向同一对象。为 public方法，子类可重写。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>重写equals的意义：<br>因为如果不重写equals方法，当将自定义对象放到 map或者 set中时；如果这时两个对象的 hashCode相同，就会调用 equals方法进行比较，这个时候会调用 Object中默认的 equals方法，而默认的 equals方法只是比较了两个对象的引用是否指向了同一个对象，显然大多数时候都不会指向，这样就会将重复对象存入 map或者 set中。这就破坏了 map与 set不能存储重复对象的特性，会造成内存溢出。</p><h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><p>这是一个 protected方法，提供给子类重写。但需要实现 Cloneable接口，这是一个标记接口，如果没有实现，当调用 object.clone()方法，会抛出 CloneNotSupportedException<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure></p><p>两个概念——<br>浅拷贝：创建一个新对象，然后将当前对象的非静态字段复制到该对象，如果字段类型是值类型（基本类型）的，那么对该字段进行复制；如果字段是引用类型的，则只复制该字段的引用而不复制引用指向的对象。此时新对象里面的引用类型字段相当于是原始对象里面引用类型字段的一个副本，原始对象与新对象里面的引用字段指向的是同一个对象。<br>说白了就是clone一个对象，将会创建一个新的对象，而对于其内部属性，比如一个String的引用类型，克隆对象和被克隆对象指向的是一个引用。换言之，如果克隆对象的属性发生了改变，则原对象也会发生改变<br>而深拷贝则是一个完全不同的拷贝的方式<br>深拷贝通过序列化(Serializable)实现</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="wait-相关方法"><a href="#wait-相关方法" class="headerlink" title="wait()相关方法"></a>wait()相关方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        timeout++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多线程情况下使用作用是阻塞进程</p><ul><li>此方法只能在当前线程获取到对象的锁监视器之后才能调用，否则会抛出 IllegalMonitorStateException异常。</li><li>调用 wait方法，线程会将锁监视器进行释放；而 Thread.sleep，Thread.yield()并不会释放锁。</li><li>wait方法会一直阻塞，直到其他线程调用当前对象的 notify()/notifyAll()方法将其唤醒；而 wait(long)是等待给定超时时间内（单位毫秒），如果还没有调用 notify()/nofiyAll()会自动唤醒； wait(long,int)如果第二个参数大于 0并且小于 999999，则第一个参数 +1作为超时时间；</li></ul><h3 id="notify-notifyAll"><a href="#notify-notifyAll" class="headerlink" title="notify()/notifyAll()"></a>notify()/notifyAll()</h3><p>如果当前线程获得了当前对象锁，调用 wait方法，将锁释放并阻塞；这时另一个线程获取到了此对象锁，并调用此对象的 notify()/notifyAll()方法将之前的线程唤醒。这些方法都是 publicfinal的，不可被重写。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>要点：<br>调用 notify()后，阻塞线程被唤醒，可以参与锁的竞争，但可能调用 notify()方法的线程还要继续做其他事，锁并未释放，所以我们看到的结果是，无论 notify()是在方法一开始调用，还是最后调用，阻塞线程都要等待当前线程结束才能开始。</p><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h3><p>jvm垃圾回收时进行调用</p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p><img src="/upload/pasted-321.png" alt="upload successful"></p><p><img src="/upload/pasted-380.png" alt="upload successful"></p><h2 id="和equals"><a href="#和equals" class="headerlink" title="==和equals"></a>==和equals</h2><p>==用来判断两个变量是否相等时，如果两个变量是基本类型变量，且都是数值类型(不要求数据类型严格相同)，则只要两个变量的值相等，就返回true；对于两个引用类型变量，必须指向同一个对象，==才会返回true。<br>equals方法用于比较两个独立对象的内容是否相同</p><h2 id="实例变量，局部变量，类变量，final变量"><a href="#实例变量，局部变量，类变量，final变量" class="headerlink" title="实例变量，局部变量，类变量，final变量"></a>实例变量，局部变量，类变量，final变量</h2><ul><li>实例变量：是定义在是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。分配了内存空间后会给所有的成员变量一次初始化，没有赋值的会给成员变量对应类型的值，数据类型不同则默认值不同。</li><li>局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。用的时候是直接入栈的，如果没有赋值，这个变量就没有初始值，也就无法操作，所以局部变量要初始化。</li><li>类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。</li><li>final变量，final 修饰的变量。如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li></ul><h2 id="Integer的赋值问题"><a href="#Integer的赋值问题" class="headerlink" title="Integer的赋值问题"></a>Integer的赋值问题</h2><p>在为Integer赋值的时候，java编译器会将其翻译成调用valueOf()方法。比如Integer i=127翻译为Integer i=Integer.valueOf(127)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//high为127</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= -<span class="number">128</span> &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + <span class="number">128</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，对于-128到127之间的数，Java会对其进行缓存。而超出这个范围则新建一个对象。</p><h2 id="throws和throw"><a href="#throws和throw" class="headerlink" title="throws和throw"></a>throws和throw</h2><p>1、throws出现在方法头，throw出现在方法体 2、throws表示出现异常的一种可能性，并不一定会发生异常；throw则是抛出了异常，执行throw则一定抛出了某种异常。 3、两者都是消极的异常处理方式，只是抛出或者可能抛出异常，是不会由函数处理，真正的处理异常由它的上层调用处理</p><h2 id="接口（Interface）"><a href="#接口（Interface）" class="headerlink" title="接口（Interface）"></a>接口（Interface）</h2><p>接口，比抽象类还要抽象的类。</p><ul><li>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract （只能是 public abstract，其他修饰符都会报错）。</li><li>接口中可以含有变量，但是接口中的变量会被隐式的指定为  public static final   变量（并且只能是 public，用 private 修饰会报编译错误。）</li><li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。 </li></ul><p>注：<br>接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。<br>接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字。<br>接口中的方法都是公有的。public</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>Reflection（反射）是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的內部信息，并能直接操作任意对象的内部属性及方法。</p><p>Java反射机制主要提供了以下功能：</p><ul><li>在运行时构造任意一个类的对象</li><li>在运行时获取任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的方法（属性）</li><li>生成动态代理</li></ul><ol><li><p>Class: 是一个类; 一个描述类的类.<br>　　封装了描述方法的 Method,描述字段的 Filed,描述构造器的 Constructor 等属性.</p><ol start="2"><li><p>如何得到 Class 对象:<br>　　2.1 Person.class<br>　　2.2 person.getClass()<br>　　2.3 Class.forName(“com.atguigu.javase.Person”)</p></li><li><p>关于 Method:<br>　　3.1 如何获取 Method:<br>　　　　1). getDeclaredMethods: 得到 Method 的数组.<br>　　　　2). getDeclaredMethod(String methondName, Class … parameterTypes)</p></li></ol><p>　　3.2 如何调用 Method<br>　　　　1). 如果方法时 private 修饰的, 需要先调用 Method 的　setAccessible(true), 使其变为可访问<br>　　　　2). method.invoke(obj, Object … args);</p><ol start="4"><li><p>关于 Field:<br>　　4.1 如何获取 Field: getField(String fieldName)<br>　　4.2 如何获取 Field 的值:<br>　　　　1). setAccessible(true)<br>　　　　2). field.get(Object obj)<br>　　4.3 如何设置 Field 的值:<br>　　　　field.set(Obejct obj, Object val)</p></li><li><p>了解 Constructor 和 Annotation </p></li><li><p>反射和泛型.<br>　　6.1 getGenericSuperClass: 获取带泛型参数的父类, 返回值为: BaseDao&lt;Employee, String&gt;<br>　　6.2 Type 的子接口: ParameterizedType<br>　　6.3 可以调用 ParameterizedType 的 Type[] getActualTypeArguments() 获取泛型参数的数组.<br><a href="https://www.cnblogs.com/tech-bird/p/3525336.html" target="_blank" rel="noopener">https://www.cnblogs.com/tech-bird/p/3525336.html</a></p></li></ol></li></ol><h2 id="AQS和CAS"><a href="#AQS和CAS" class="headerlink" title="AQS和CAS"></a>AQS和CAS</h2><p>抽象队列同步器AQS ( AbstractQueuedSychronizer ) , 如果说java.util.concurrent的基础是CAS的话,那么AQS就是整个Java并发包的核心了, ReentrantLock、CountDownLatch、Semaphore等都用到了它。AQS实际上以双向队列的形式连接所有的Entry ,比方说ReentrantLock ,所有等待的线程都被放在一个Entry中并连成双向队列,前面一个线程使用 ReentrantLock好了, 则双向队列实际上的第一个Entry开始运行。 AQS定 义了对双向队列所有的操作,而只开放了tryLock和tryRelease方法给开发者使用,开发者可以根据自己的实现重写tryLock和tryRelease方法,以实现自己的并发功能。</p><p>比较并替换CAS(Compare and Swap) ,假设有三个操作数:内存值V、旧的预期值A、要修改的值B ,当且仅当预期值A和内存值V相同时,才桧将内存值修改为B并返回true ,否则什么都不做并返回false ,整个比较并替换的操作是一个原子操作。CAS一定要volatile变量配合,这样才能保证每次拿到的变量是主内中最新的相应值,否则旧的预期值A对某条线程来说,永远是一个不会变的值A,只要某次CAS操作失败，下面永远都不可能成功。</p><p>CAS虽然比较高效的解决了原子操作问题,但仍存在三大问题。</p><ul><li>循环时间开销大</li><li>只能保证一个共享变量的原子操作</li><li>ABA问题</li></ul><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p> Condition是在java 1.5中才出现的，它用来替代传统的Object的wait()、notify()实现线程间的协作，相比使用Object的wait()、notify()，使用Condition1的await()、signal()这种方式实现线程间协作更加安全和高效。因此通常来说比较推荐使用Condition，在阻塞队列那一篇博文中就讲述到了，阻塞队列实际上是使用了Condition来模拟线程间协作。</p><ul><li>Condition是个接口，基本的方法就是await()和signal()方法；</li><li>Condition依赖于Lock接口，生成一个Condition的基本代码是lock.newCondition()</li><li>调用Condition的await()和signal()方法，都必须在lock保护之内，就是说必须在lock.lock()和lock.unlock之间才可以使用Conditon中的await()对应Object的wait()； Condition中的signal()对应Object的notify()； Condition中的signalAll()对应Object的notifyAll() </li></ul><h2 id="Spring-mvc执行流程"><a href="#Spring-mvc执行流程" class="headerlink" title="Spring mvc执行流程"></a>Spring mvc执行流程</h2><p><img src="/upload/pasted-323.png" alt="upload successful"><br><a href="https://www.cnblogs.com/jay36/p/7527039.html" target="_blank" rel="noopener">https://www.cnblogs.com/jay36/p/7527039.html</a></p><h2 id="AOP-IOC"><a href="#AOP-IOC" class="headerlink" title="AOP IOC"></a>AOP IOC</h2><p>AOP和IOC是Spring精华部分, AOP可以看做是对OOP的补充,对代码进行横向的扩展,通过代理模式实现,代理模式有静态代理,动态代理, Spring利用的是动态代理,在程序运行过程中将增强代码织入原代码中。IOC是 控制反转,将对象的控制权交给Spring框架,用户需要使用对象无需创建,直接使用即呵。AOP和IOC最可贵的是它们的思想。</p><h2 id="Hibernate-POJO"><a href="#Hibernate-POJO" class="headerlink" title="Hibernate POJO"></a>Hibernate POJO</h2><p>Hibernate Pojo的三态分别为transient（瞬时态）,persistent（持久态）,detached（游离态）</p><p>1、官方给出的三态与Session的关系如下：</p><p>transient: never persistent, not associated with any Session<br>persistent: associated with a unique Session<br>detached: previously persistent, not associated with any Session</p><p>2、三种状态间相互转换关系，及他们在数据库、session中的状态如下：<br>a.当我们new一个pojo时，它处于瞬时态，此时与session、数据库均无任何关联。<br>b.此后，我们获得session并开启hibernate事务，调用save(),persist(),saveOrUpdate()方法，将pojo转变为持久态，此时session中存有这个pojo，但直到transaction.commit()被调用时，sql语句才会执行，此后数据库中也才有此条数据。<br>c.但当commit()并且session.close()执行过后，pojo就变为了游离态，也就是说，数据库中有该记录，但session中不再有。<br>d.持久化状态的实例，也可以重新变成瞬时态，那就是调用delete()方法。<br>e.通过get()或load()方法得到的pojo是持久态的。<br>f.游离态的pojo可以通过update(),saveOrUpdate(),lock()和replicate()方法重新成为持久态。<br>g.调用merge()方法后，pojo维持原态，但内容会被更新到数据库</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>Java通过Executors提供四个静态方法创建四种线程池，分别为：</p><p>newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p><p>newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p><p>newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</p><p>newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</p><p>作用：<br>限定线程的个数，不会导致由于线程过多导致系统运行缓慢或崩溃</p><p>线程池不需要每次都去创建或销毁，节约了资源、</p><p>线程池不需要每次都去创建，响应时间更快。</p><h2 id="javaWeb"><a href="#javaWeb" class="headerlink" title="javaWeb"></a>javaWeb</h2><h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p><img src="/upload/pasted-324.png" alt="upload successful"><br>servlet是运行在服务器端的小应用程序，是接收网络服务的请求和产生响应的一种方式。<br>servlet的功能：接受http请求，产生动态http响应。<br>HttpServlet是GenericServlet的子类。<br>GenericServlet是个抽象类，必须给出子类才能实例化。它给 出了设计servlet的一些骨架，定义了servlet生命周期，还有一些得到名字、配置、初始化参数的方法，其设计的是和应用层协议无关的，也就是说 你有可能用非http协议实现它。<br>HttpServlet是子类，当然就具有GenericServlet的一切特性，还添加了doGet, doPost, doDelete, doPut, doTrace等方法对应处理http协议里的命令的请求响应过程。</p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>servlet有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。这个生存期由javax.servlet.Servlet接口的init,service和destroy方法表达。<br>加载Servlet的class—-&gt;实例化Servlet—–&gt;调用Servlet的init完成初始化—-&gt;响应请求（Servlet的service方法）—–&gt;Servlet容器关闭时(Servlet的destory方法)<br>Servlet启动时，开始加载servlet生命周期开始。Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候(服务器关闭)调用其destroy方法。</p><h4 id="forward-与redirect-的区别"><a href="#forward-与redirect-的区别" class="headerlink" title="forward() 与redirect()的区别"></a>forward() 与redirect()的区别</h4><p>forward是服务器端的转向而redirect是客户端的跳转。</p><p>使用forward浏览器的地址不会发生改变。而redirect会发生改变。</p><p>Forward是一次请求中完成。而redirect是重新发起请求。</p><p>Forward是在服务器端完成，而不用客户端重新发起请求，效率较高<br>一般没有特殊需要，自己写的Servlet都扩展HttpServlet 。</p><h4 id="JSP和Servlet有哪些相同点和不同点"><a href="#JSP和Servlet有哪些相同点和不同点" class="headerlink" title="JSP和Servlet有哪些相同点和不同点"></a>JSP和Servlet有哪些相同点和不同点</h4><p>JSP是Servlet技术的扩展，所有的jsp文件都会被翻译为一个继承HttpServlet的类。也就是jsp最终也是一个Servlet.这个Servlet对外提供服务。</p><p><img src="/upload/pasted-347.png" alt="upload successful"><br>Servlet和JSP最主要的不同点在于JSP侧重于视图，Servlet主要用于控制逻辑。<br>Servlet如果要实现html的功能，必须使用Writer输出对应的html,比较麻烦。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件,做界面展示比较方便而嵌入逻辑比较复杂</p><h4 id="jsp内置对象"><a href="#jsp内置对象" class="headerlink" title="jsp内置对象"></a>jsp内置对象</h4><p>request 用户端请求，此请求会包含来自GET/POST请求的参数</p><p>response 网页传回用户端的回应</p><p>pageContext 网页的属性是在这里管理</p><p>session 与请求有关的会话期</p><p>application servlet正在执行的内容</p><p>out 用来传送回应的输出</p><p>config servlet的构架部件</p><p>page JSP网页本身</p><p>exception 针对错误网页，未捕捉的例外</p><p>四大作用域：pageContext request session application 可以通过jstl从四大作用域中取值.</p><p>Jsp传递值request session application cookie也能传值</p><h3 id="http-get和post请求的区别"><a href="#http-get和post请求的区别" class="headerlink" title="http get和post请求的区别"></a>http get和post请求的区别</h3><p>GET和POST请求都是http的请求方式，用户通过不同的http的请求方式完成对资源（url）的不同操作。GET，POST，PUT，DELETE就对应着对这个资源的查 ，改 ，增 ，删 4个操作,具体点来讲GET一般用于获取/查询资源信息，而POST一般用于更新资源信息<br>1、Get请求提交的数据会在地址栏显示出来，而post请求不会再地址栏显示出来.</p><p>GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&amp;连接；POST提交：把提交的数据放置在是HTTP包的包体中。因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变</p><p>2、传输数据的大小</p><p>http Get请求由于浏览器对地址长度的限制而导致传输的数据有限制。而POST请求不会因为地址长度限制而导致传输数据限制。</p><p>3、安全性,POST的安全性要比GET的安全性高。由于数据是会在地址中呈现，所以可以通过历史记录找到密码等关键信息。</p><h3 id="Session-和-Cookie"><a href="#Session-和-Cookie" class="headerlink" title="Session 和 Cookie"></a>Session 和 Cookie</h3><p>Session和cookie都是会话(Seesion)跟踪技术。Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。但是Session的实现依赖于Cookie,sessionId(session的唯一标识需要存放在客户端).</p><p>cookie 和session 的区别：</p><p>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</p><p>2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗</p><p>   考虑到安全应当使用session。</p><p>3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用COOKIE。</p><p>4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p><p>5、所以个人建议：</p><p>   将登陆信息等重要信息存放为SESSION</p><p>   其他信息如果需要保留，可以放在COOKIE中，比如购物车</p><p>购物车最好使用cookie，但是cookie是可以在客户端禁用的，这时候我们要使用cookie+数据库的方式实现，当从cookie中不能取出数据时，就从数据库获取。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;# &lt;/p&gt;
&lt;h2 id=&quot;ArrayList和Linkedlist区别&quot;&gt;&lt;a href=&quot;#ArrayList和Linkedlist区别&quot; class=&quot;headerlink&quot; title=&quot;ArrayList和Linkedlist区别&quot;&gt;&lt;/a&gt;ArrayList和
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>结束是另一个开始</title>
    <link href="https://www.junglezero.top/2019/07/05/mething-Ends-Something-Begins-translate-cn/"/>
    <id>https://www.junglezero.top/2019/07/05/mething-Ends-Something-Begins-translate-cn/</id>
    <published>2019-07-05T15:05:25.000Z</published>
    <updated>2019-07-18T02:59:28.705Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/upload/pasted-357.png"><br>《猎魔人》原著作者送给其朋友的结婚礼物，和正传发生的故事有些矛盾，但问题不大<br>高甜预警！！！<br><a id="more"></a></p><hr><p>翻译自外国的某个热心粉丝Something Ends, Something Begins <a href="https://witcher.fandom.com/wiki/Something_Ends,_Something_Begins_(unofficial_translation)" target="_blank" rel="noopener">https://witcher.fandom.com/wiki/Something_Ends,_Something_Begins_(unofficial_translation)</a><br>意思跑偏太正常了，这哥们把波兰语翻译成英语要跑偏一部分，我再把英语翻译成汉语又会跑偏一部分。对于这里面出现的一些人物，已经在第一次出现的地方链接到了猎魔人的wiki,有兴趣的朋友可以看一看。</p><hr><h1 id="I"><a href="#I" class="headerlink" title="I"></a>I</h1><p>   太阳炽热的触须透过百叶窗的缝隙伸展开来，倾斜的阳光把房间横断开来，飞悬的尘埃在光线中跃动着，落在地板的熊皮上，在叶妮芙皮带扣炫目的闪光中渐渐消散。叶妮芙的腰带挂在高跟鞋上，高跟鞋在白色蕾丝内衣上，而内衣在黑色的裙子上。一只黑色长筒袜挂在雕刻成烟囱状的扶手椅上，另一只袜子和另一只高跟鞋却四处不见，杰洛特叹了口气。叶妮芙喜欢利索优雅的脱掉衣服，他必须开始习惯起来，他没别的选择。<br>他站起身来，打开窗子向外看去，湖面光滑如镜，迷迷蒙蒙中，岸边的桦树和赤杨的叶子上闪着露珠，远处的草地上覆盖着厚重的雾，沉默的压下来，犹如蛛网一般悬在草地之上</p><p>   叶妮芙在毯子下嘟囔着什么，含糊不清。杰洛特叹了口气<br>   “今天天气真好，叶。”<br>   “嗯？你说什么？”<br>   “今天天气很好，尤为的好”<br>   她还是让他吃了一惊，女术士并没有像往常一样讽刺挖苦，也没有把头压在枕头下，而是坐起身来。用手梳理着头发，然后在床上找睡衣，杰洛特知道睡衣就在床头下面，就在她昨晚脱掉的地方，但是他一句话也没说，因为他知道，叶妮芙讨厌这种话。<br>   女术士突然咒骂起来，她踢了踢毯子，举起手咬住手指，睡袍就从床前飞来，摆动着荷叶边，犹如一个可怕的幽灵，然后落在她的手上。杰洛特叹了口气。叶妮芙站起身来走到他跟前，抱住了他，咬了他的胳膊，杰洛特叹了口气，他不得不习惯的事似乎多的数不清。<br>   “你没什么想说的吗？”，女术士眯着眼睛，问道<br>   “并没有。”<br>   “很好，今天的确很好，干的不错。”<br>   “什么意思？”<br>   叶妮芙还没来得及回答，就听见远处传来一声又高又长的叫喊声和喘息声。湖边，希瑞骑着一匹黑色的母马溅起一阵水花，这是一匹纯种马，长得很漂亮。杰洛特还记得它的上一个主人是个半精灵，这个半精灵轻率的凭第一印象错误的判断了这个白发的猎魔女，最终犯下大错。希瑞将这匹母马命名为“卡尔比”，在史凯利杰岛民的口中，这个意思是一种可怕的，胆大妄为的海的神灵，有时也会化身为马。这名字非常适合这匹母马。不久之前，有个半身人就因为某种艰难的方式了解到了，当他尝试偷走这匹马时，被这匹马猛地给了一脚，正中脸上，这半身人以前叫桑迪·弗洛莫顿，但自此以后人们就叫他“花椰菜”了。<br>   “总有一天她会摔断脖子的”，叶妮芙叫喊道，看着希瑞在溅起的水花中飞奔，弯腰，牢牢的踩着马镫。“总有一天你这疯女儿会摔断脖子的。”<br>   杰洛特转过头来，也不说话，就这么静静的看着女术士那双紫罗兰色的眼眸。<br>   “好吧好吧，”叶妮芙目不转睛的微笑着，“对不起，我们的女儿。”<br>   她又抱住他，紧紧地靠在他身上，又咬了下他的胳膊，然后亲吻她，接着又咬了下，杰洛特嘴唇触碰着她的头发，小心翼翼的把睡袍来到她的肩上。<br>   然后最终他们还是又上了床，散乱的毯子，尚有余温，仍旧沉浸在梦中。他们开始互相寻找彼此，寻找的时间很长，也很耐心，他们都深知最终会找到彼此，充满欢喜的彼此，他们所做的一切都是欢愉的，尽管他们之间尚有很大的差异，他们也和往常一样想着，这种差异并不是将他们分割开来，而是紧紧的绑在一起的差异，就犹如房梁和屋脊，那才是房屋的诞生所在。这也犹如第一次，当他被她赤裸而强烈的欲望所迷住，而她被他的巧妙和感性所迷住，就像她第一次本想告诉他，但是他却只用了一个吻和一个安抚让她安宁下来，消除了其他的所有感觉，后来，当他想要告诉她时，他却一点声音也发不出来，再后来，欢愉被一块巨石压倒，他们的眼中只有那一刻的闪光，听到的只是无声的呼喊，世界犹如静止一般，结束了，开始了，然后是沉默，宁静的沉默【本段见小说第一本《白狼崛起》的“最后的愿望”】<br>   还有无限的魅力。<br>   世界又重新回到它的轨道上，这里还是一张充满梦幻和光亮的床，然后是一天，那样的一天……<br>   “叶…”<br>   “嗯？”<br>   “当你说今天天气不错时，还说了句‘干得不错’，该不是……”<br>   “是的”她承认道，伸展着双臂握紧毯子的边，使她的胸部在那一刻以这种方式展现出来，这使得猎魔人的下半身一阵颤动<br>   “看啊，杰洛特，是我们打造出这样的天气，昨晚，我，<a href="http://witcher.huijiwiki.com/wiki/%E5%8D%97%E5%B0%BC%E5%85%8B" target="_blank" rel="noopener">南尼克</a>,特莉丝和<a href="http://witcher.huijiwiki.com/wiki/%E5%A4%9A%E7%91%9E%E5%8A%A0%E9%9B%B7" target="_blank" rel="noopener">多瑞加雷</a>,我不能冒险，今天必须是美好的一天……”<br>她一声不吭的用膝盖猛击了杰洛特一下。<br>   “为什么？因为这是你生命中最重要的一天，傻东西。”【叶妮芙设定上会读心术，专读杰洛特的】</p><hr><h1 id="II"><a href="#II" class="headerlink" title="II"></a>II</h1><p>   洛史洛格城堡矗立在湖中凸起的地带，亟需进行全面的修缮工作，绝对不仅仅是现在。说的好听一点，洛史洛格就是一片废墟，一个不规整的石头堆，铺满了常青藤，野葡萄，地衣和苔藓，说来说去也不过是这片烂沼泽地中的一个遗迹，四处满是蛤蟆，蝾螈和乌龟，当年这片土地给赫维格国王时，这已经就是一片废墟了，这个城堡以及周边的沼泽，更像是一份毕生的礼物，一份送给赫维格告别礼物。赫维格于12年前退位，以支持他的侄子“友善者”布伦南，杰洛特曾通过丹德里恩结识了这位前国王，因为赫维格国王为人和蔼，也喜好招待宾客，所以这位吟游诗人经常出入城堡。<br>   当女术士排除了猎魔人所提供的所有地点参考时，丹德里恩就把赫维格国王的洛史洛格城堡提了上来，诡异的是，女术士马上就同意了这个提议，甚至连鼻子也没抽一下。<br>于是，杰洛特和叶妮芙的婚礼将在洛史洛格城堡举行</p><hr><h1 id="III"><a href="#III" class="headerlink" title="III"></a>III</h1><p>   一开始，这场婚礼设定上是小型的，不那么引人注目的婚礼，可是因为各种原因，这是不可能实现的，所以很有必要找一个擅长组织的人。自然，叶妮芙是拒绝的，她不想张罗她自己的婚礼，杰洛特和希瑞，还有丹德里恩，那就不用说了，他们就没组织这个概念，于是他们向艾尔兰德的梅里泰莉神庙的大祭司南尼克求助，南尼克二话不说就来了，带着两个年轻的女祭司小爱若拉和尤妮德。<br>   于是各种问题开始接踵而至。</p><hr><h1 id="IV"><a href="#IV" class="headerlink" title="IV"></a>IV</h1><p>   “这可不行，杰洛特，”南尼克怒吼道，跺了跺脚，“婚礼和宴会要是出了什么岔子我可不负责。那片废墟，有些傻瓜竟然称之为一座城堡，那可是一点用也没有，那里的厨房都要塌了，舞厅也就能用来做个马厩，那个礼拜堂……那就不是个礼拜堂，至少你能告诉我那个瘸子赫维格信奉哪位神灵吗？”<br>“据我所知，他谁也不信奉，他还声称宗教不过是大众的精神毒品”<br>“哼，我就知道，”女祭司说道，丝毫没有掩饰自己的轻蔑，“那个礼拜堂里没有一座雕像，除了老鼠粪以外，就没有别的东西了，最重要的是，那个地方不过是一摊死水，杰洛特，你怎么不想在一个文明的国家举行婚礼呢，比如温格堡？”<br>   “你知道的，叶是一个混血儿，你们的那些文明国家可不准许这种混合的婚姻”<br>“梅里泰莉女神在上！不过是四分之一的精灵血统，有什么问题吗？谁都或多或少的带点上古民族的血统，这只是个愚蠢的偏见！”<br>   “那也不是我编出来的。”</p><hr><h1 id="V"><a href="#V" class="headerlink" title="V"></a>V</h1><p>   邀请的客人名单实际上并不长，夫妇两人把名单汇总交给了丹德里恩，让他去发放邀请函，结果是这个吟游诗人还没来得及读完就给弄丢了，因为他羞于承认，于是他就耍了些花招：尽可能的邀请他所能邀请的任何人，当然，他对叶妮芙和杰洛特都很了解，所以没有落下任何一个重要的人，但是要是没有趁机邀请到更多的乱七八糟的形形色色的人的话，那他也就不是丹德里恩了。<br>   于是，杰洛特的导师，来自凯尔莫罕的老维瑟米尔和杰洛特的童年伙伴，猎魔人艾斯卡尔就过来了<br>   德鲁伊<a href="http://witcher.huijiwiki.com/wiki/%E8%8E%AB%E6%96%AF%E8%90%A8%E5%85%8B" target="_blank" rel="noopener">莫斯萨克</a>带着一个名叫芙蕾雅的金发女郎来了，芙蕾雅比他高一头，但是可比他年轻上百岁。来的还有<a href="http://witcher.huijiwiki.com/wiki/%E5%85%8B%E6%8B%89%E8%8C%A8%C2%B7%E5%AE%89%C2%B7%E5%85%8B%E8%8E%B1%E7%89%B9" target="_blank" rel="noopener">克拉茨·安·克莱特</a>,史凯利杰群岛的伯爵，带着他的两个儿子拉格纳和洛基，拉格纳骑马时，脚都快碰到地了，而洛基则像个精灵，也难怪他们兄弟两个，但是他们有着不同的母亲<br>   来自布拉维坎的里夫·凯尔迪米恩和他女儿阿妮卡到了【出自《白狼崛起》的“勿以恶小”，布拉维坎屠夫的称号就是从这个地方得来的】，阿妮卡很有魅力但生性害羞。矮人<a href="http://witcher.huijiwiki.com/wiki/%E4%BA%9A%E5%B0%94%E6%BD%98%C2%B7%E9%BD%90%E6%A0%BC%E6%9E%97" target="_blank" rel="noopener">亚尔潘·齐格林</a>出现了，没有带着其他人，这很有意思，他一般都是带着他的长胡子同伙的。他是在半路上碰上了精灵<a href="http://witcher.huijiwiki.com/wiki/%E5%87%AF%E7%91%9E%E5%B0%94%E4%B8%B9" target="_blank" rel="noopener">凯瑞尔丹</a>一起来的，可见凯瑞尔丹在精灵中还是有些地位的，身边有几个默默无闻的精灵，无人知晓。<br>又来了一队吵吵嚷嚷的半身人，这群人里杰洛特只认识<a href="http://witcher.huijiwiki.com/wiki/%E4%B8%B9%E8%BF%AA%C2%B7%E6%AF%94%E4%BC%AF%E5%A8%81%E7%89%B9" target="_blank" rel="noopener">丹迪·比伯威特</a>，蓼草牧场的商人和牧马人,还有只是有所耳闻的，因好斗而出名的老婆加德尼娅·比伯威特，领头的还有一个不是半身人的半身人——著名的商人特里科·朗格瑞文克·勒托特，一个异形怪，伪装成名为“<a href="http://witcher.huijiwiki.com/wiki/%E5%98%9F%E5%98%9F" target="_blank" rel="noopener">嘟嘟</a>”的半身人。【见《宿命之剑》的“永恒之火”】<br>   来自布洛克莱昂的<a href="http://witcher.huijiwiki.com/wiki/%E8%8F%B2%E6%96%AF%E5%A5%88%E7%89%B9" target="_blank" rel="noopener">菲斯奈特</a>男爵到了，带着他的妻子，高贵的树精布蕾恩，以及他们的五个女儿莫丽恩、希瑞菈、莫娜、艾思娜和卡什卡，莫丽恩15岁的样子，而卡什卡看上去只有五岁。她们都是一头红发，尽管菲斯奈特是黑发，布蕾恩是金发、布蕾恩明显怀有身孕。他的一群红发树精女儿彼此咯咯的笑着，菲斯奈特信誓旦旦的说，这次一定是个儿子【小说中说树精X非树精=女树精】而布蕾恩则笑着补充道，这个“儿子”就叫梅丽莎。【这两个人的故事见《宿命之剑》的“宿命之剑”】<br>   独臂的<a href="http://witcher.huijiwiki.com/wiki/%E9%9B%85%E5%B0%94" target="_blank" rel="noopener">雅尔</a>也来了，这是一位年轻的牧师，编年史家，来自艾尔兰德，是南尼克的一个学徒，他来这里主要是因为他暗恋的希瑞，心疼的南尼克觉得，希瑞对于这个残疾青年的隐晦的调情似乎太过冷淡。<br>   打头的不速之客是布利姆巫德的<a href="http://witcher.huijiwiki.com/wiki/%E8%89%BE%E6%A0%BC%E7%BD%97%E7%93%A6%E5%B0%94" target="_blank" rel="noopener">艾格罗瓦尔</a>王子，他的到来被视作为一个奇迹，因为他和杰洛特曾经毫不留情的公开鄙视对方，更奇怪的是，他是和他的妻子美人鱼<a href="http://witcher.huijiwiki.com/wiki/%E5%B8%8C%E6%81%A9%E5%A8%9C%E5%85%B9" target="_blank" rel="noopener">希恩娜兹</a>一起来的，尽管她为了一双异常漂亮的腿牺牲了自己的鱼尾，但人们都知道她从未离开过海岸，因为她对陆地充满恐惧【这段故事见《宿命之剑》的“一点牺牲”】<br>   没人料到还会有其他的国王会对于此事比较上心——说来说去也没人邀请他们。尽管如此，还是有很多国王派发贺信，礼物，使者——或者以上的一并送出。他们应该是事先商量好了，因为他们的使者是组团来的，彼此都相互认识了。伊夫骑士代表埃塞因国王，领主苏力沃伊代表文斯拉夫国王，玛索尔姆爵士代表西吉斯蒙德国王，德弗卢爵士代表<a href="http://witcher.huijiwiki.com/wiki/%E9%9B%85%E5%A6%B2" target="_blank" rel="noopener">雅坦</a>王后，他们这几个人的旅行一定很愉快，因为伊夫的嘴唇被割破了，苏力沃伊的胳膊绑在板子上，玛索尔姆一瘸一拐的，而德弗卢醉的很厉害，几乎要从马上摔下来了。<br>   没人能邀请金龙<a href="http://witcher.huijiwiki.com/wiki/%E5%8D%9A%E5%B0%94%E5%A5%87" target="_blank" rel="noopener">维纶特瑞坦梅斯</a>,因为没人知道怎么邀请他以及他到底在哪，令众人吃惊的是，他还是来了，自然是隐藏了真实的形态，是以骑士博尔奇“三只寒鸦”的身份来的，当然，有丹德里恩在的地方，就没有什么隐私可言，但是当吟游诗人指着这位卷发骑士声称他其实是一条金龙时，还是没什么人相信。<br>   没人会料到还有一群各式各样的流浪人的到来，当然，也没人邀请他们。他们被登记为“丹德里恩的朋友和熟人”，主要是诗人，歌手和剧场演员，还有杂耍演员，职业骰子手，鳄鱼训练师以及四个浓妆艳抹的女人，其中三个毫无疑问就是妓女，而第四个虽然看上去不像，但毫无疑问也是，有两个算命的，其中一个还是个骗子，还有一个雕塑家，一个金发女郎，和一个醉酒的灵媒师，还有个麻子脸的侏儒，自称是舒滕巴赫<br>   在一艘外形犹如一只天鹅背着一个巨大的枕头的魔法船上，术士团到了，他们比邀请的要少上4倍，但是比预期来的要多上三倍，正如传言所说的那样，叶妮芙的同行并不认同她会嫁给一个外人，还是个猎魔人，他们中的一部分人直接无视邀请，另一部分人则以没时间为由，说是要去参见一年一度的世界修道院集会，因此，在那艘被丹德里恩唤做“枕头鸟”的船上只有沃尔的多瑞加雷，牛堡的<a href="http://witcher.huijiwiki.com/wiki/%E8%8E%B1%E5%BE%B7%E5%85%8B%E9%87%8C%E5%A4%AB" target="_blank" rel="noopener">莱德克里夫</a>,以及一头栗色头发的特莉丝·梅利葛德</p><hr><h1 id="VI"><a href="#VI" class="headerlink" title="VI"></a>VI</h1><p>   “是你邀请的特莉丝·梅利葛德？”<br>   “没有的事，”猎魔人急忙摇了摇头，暗自庆幸自己的血液循环系统不会让自己脸红。“不是我，估计是丹德里恩，尽管他们都说他们是通过水晶占卜知道的。”<br>   “我不希望特莉丝·梅利葛德出现在我的婚礼上！”<br>   “为什么呀，她可是你的朋友。”<br>   “不要把我当傻子，猎魔人！是个人就知道你跟她有一腿。”<br>   “扯淡！”<br>   叶妮芙的紫罗兰色眼睛危险的眯着。<br>   “是真的”<br>   “真不是”<br>   “就是真的”<br>   “够了，”他生气的把头扭向一边，“就是真的了，你想怎么样？”<br>   女术士沉默了，摆弄着脖子上的黑曜石星星。<br>   “也没什么，”女术士最终开了口，“我就是想让你承认罢了，不要冲我撒谎，杰洛特，永远也不要”</p><hr><h1 id="VII"><a href="#VII" class="headerlink" title="VII"></a>VII</h1><p>   城堡的石墙散发出一股潮湿的气息，外加一股子药草的酸味。阳光照在褐色的泥水上，竟然拽出了沼泽地里某种植物的暖绿色和海狸百合闪闪发光的黄色<br>城堡也慢慢苏醒过来，渐渐有了生机。城堡西翼，有人打开百叶窗，放声大笑。有人用一种微弱的声音请求来一些泡菜卤水，丹德里恩的一位同事，一个盲诗人，一边刮着胡子，一边放声唱到：</p><p>干草仓后的栅栏上，<br>有只公鸡高声唱，<br>姑娘我会赶到你身旁，<br>来上一炮也无妨……</p><p>   门吱扭一声开了，丹德里恩来到院子中，他伸了伸懒腰，揉了揉眼睛<br>   “你好啊，新郎官，”他疲惫的说道。“如果你想要溜走，就只有现在了。”<br>   “丹德里恩，你竟然成了早起的鸟儿。”<br>   “我压根就没上床”，诗人嘟囔着，坐在猎魔人旁的石凳上，靠着长满藤蔓的石墙。“神啊，多么每美妙的夜晚，但不管怎么说，可不是每天都有好朋友要结婚，自然是要好好的庆祝一下。”<br>   “婚礼的宴会是在今天，”杰洛特提醒道，“你能撑得过去吗？”<br>   “你瞧不起我吗？”</p><p>   艳阳高照，鸟儿在灌木丛中啾啾的叫着，湖上传来溅水声和咯咯的笑声，那是菲斯奈特的红发树精女儿们莫丽恩、希瑞菈、莫娜、艾思娜和卡什卡正和往常一样光着身子在湖中玩耍，特莉丝·梅利葛德和莫斯萨克的朋友芙蕾雅正看着她们。而城垛上，皇家的使者们，伊夫骑士，苏力沃伊领主，玛索尔姆爵士和德弗卢爵士却为了争抢一个望远镜而大打出手。</p><p>   “玩得还好吗，丹德里恩？”<br>   “别提了。”<br>   “又出什么乱子了？”<br>   “可是有那么几个。”</p><p>   正如诗人所说，第一个争端是关于种族的。宴会开到一半时，特里科·朗格瑞文克·勒托特突然发作，说他已经忍受够了半身人的伪装，勒托特指着在坐的树精，精灵，半身人，美人鱼，人类和一个声称自己是舒滕巴赫的侏儒，说他们每个人都能做他们自己而只有他，特里科必须得伪装成别人的样子，这就是种歧视，然后他突然变回了自己自然模样，看到这一幕，加德尼娅·比伯威特当场晕了过去，艾格罗瓦尔王子差点被龙虾给噎着，而里夫·卡尔迪米恩的女儿阿妮卡则歇斯底里的叫了起来，这混乱场面最终还是靠着金龙维纶特瑞坦梅斯得以拯救，当然，是以骑士博尔奇“三只寒鸦”的形态。他淡淡的向勒托特解释道，说异形是一种天赐的恩惠，然而这种恩惠也要求他保持一种社会能够接受的形态，而且也是出于对东道主的礼仪。<br>   可是勒托特指责维纶特瑞坦梅斯，说他的这番话完全就是种族主义，沙文主义以及站着说话不腰疼。因此受辱的维纶特瑞坦梅斯猛地变成了龙形，毁坏了几件家具，引得众人一阵恐慌，待局势稍微缓和下来时，一场激烈的争端就开始了，人类和非人种族在互相指责对方的不宽容，对方的种族歧视，这场争论意想不到的转折来自脸上长着雀斑的媚儿，就是那个不像妓女的妓女，她说这场争辩就是扯淡，对于“专业人士”来说，是不是人根本就没有关系，还说愿意当场证明（当然，钱要到位。）甚至包括处在自然形态下的维纶特瑞坦梅斯，在那片刻间的寂静中，众人听到那个灵媒师说她也愿意做同样的事，而且不收钱。维纶特瑞坦梅斯赶忙转换话题，开始讨论一些相对安全的话题，比如经济，政治，狩猎，钓鱼以及冒险。<br>   其他的事情可能相对来说不那么暴力。莫斯萨克，莱德克里夫和多瑞加雷比他们谁能用意念控制更多的东西浮空。最终是多瑞加雷赢了，他成功的将两把椅子，一个水果盘，一碗汤，一个地球仪，一只猫，两只狗以及菲斯奈特和布蕾恩的女儿卡什卡悬在空中。<br>   然后是菲斯奈特和布蕾恩的两个女儿，希瑞拉和莫娜扭打在一起，于是她们被要求返回自己的房间，不一会拉格纳和玛索尔姆爵士为菲斯奈特的大女儿莫林又打了起来。生气的菲斯奈特赶忙把自己的红发女儿们都关在了屋子里，然后自己兴冲冲的跑去参加由莫斯萨克的女友芙蕾雅组织的斗酒。很快，丹德里恩的朋友们，那些诗人和歌手，纷纷喝倒在桌子下，很明显芙蕾雅对于酒精有难以想象的抑制能力，近乎于免疫。但是菲斯奈特，克拉茨·安·克莱特，里夫·卡尔迪米恩仍然勇敢的战斗着，然后他们也败下阵来。术士莱德克里夫此时却还坚定的举着酒杯，直到人们发现他带着一个独角兽的角，拿掉之后，他一下子就不行了。有那么一段时间，桌子上都没人，然后就来了一个穿着老式服装的卡夫坦人，他脸色苍白，没人认识他。他和芙蕾雅喝了几个来回，过了一会，站了起来，晕晕乎乎的，礼貌的鞠了一躬，穿过一堵墙，就好像一阵雾，通过对大厅中的挂画的彻底搜查，人们认定他可能是几百年前在黑暗时代被谋杀的罗兹罗格的继承人“魔鬼”威廉姆。<br>   这座古堡藏着各种各样的秘密，早些年，它以它的阴森可怕而闻名，但是人们都比较怀疑，毕竟并没有发生什么超自然的事。午夜时分，一只吸血鬼从开着的窗子飞来进来，一进来，就被矮人亚尔潘·齐格林扔了头大蒜，然后被他追着打。整个晚上，总能听见货真价实的鬼哭狼嚎，但没人在意，人们都觉得是丹德里恩和他的朋友在搞鬼。然而，楼梯上大量的外质表明，这的确就是货真价实的鬼魂，还有几个人滑到在上面。</p><p>   有个影子跨过门槛，他眨着火一般的眼睛，淘气的捏了希恩娜兹的屁股一把，看来要想解决这些误会可能要有些难度了，因为希恩娜兹认定就是丹德里恩干的，这个鬼影立刻借着这个误会，四处捣乱，直到他被南尼克抓住并用驱魔术驱逐出去。<br>   几个人声称自己看见了苍白夫人，传说中，她被活埋在洛史洛格城堡的地下墓穴中。而别的人则觉得这个不是苍白夫人，而是那个女灵媒师在画廊中走动着找酒喝<br>   然后就开始有人失踪了，最开始失踪的是伊夫骑士和鳄鱼杀手，不一会人，人们发现拉格纳和年轻的女祭司尤妮德也没了。然后是加德尼娅·比伯威特，但后来才知道她去睡觉了。接着是独臂的雅尔和第二个年轻女祭司小爱若拉。虽然希瑞对雅尔没什么感情可言，但还是有些担心，但很显然，这个年轻人不小心摔在了阴沟里，在里面睡着了。而小爱若拉则是在楼梯口被发现了，旁边还有精灵凯瑞尔丹。特莉丝·梅利葛德和来自凯尔莫罕的猎魔人艾斯卡尔被发现了消失在花园的凉亭附近。早上，有人声称看见了在凉亭那里看见了变形怪特里科，人们就在议论纷纷，琢磨着这个异形怪到底变成了谁的模样，甚至有人觉得这里有两个异形怪。他们想向金龙维纶特瑞坦梅斯征求下意见，毕竟他也是个变形专家，结果这条龙也不见了，妓女媚儿和他在一起。<br>   第二个妓女也没了，同时消失的还有一个算命的，剩下的一个算命的说他才是真的那个，但是没人能证明。同时，那个自称是舒滕巴赫的侏儒也不见了。</p><p>   “你大概已经后悔了，”吟游诗人打了个大大的哈欠，“你不在真的是太遗憾了，那可是相当的精彩。”<br>   “我的确挺后悔的，”猎魔人感叹道，“但是你懂得……我不能,因为叶妮芙……总之你应该是最了解的。”<br>   “那是肯定的，”丹德里恩赞成到，“所以我才不会傻到去结婚。”</p><hr><h1 id="VIII"><a href="#VIII" class="headerlink" title="VIII"></a>VIII</h1><p>   城堡的厨房中传来了平底锅的叮当声，快乐的笑声以及哼哼的小调声。要为这么多客人提供盛宴是个问题，因为赫维格国王平日几乎就没什么客人。术士的到来并没有解决任何问题，出于对于食品安全的考量，食物都得是自然的东西，不掺杂一点魔法，所以南尼克到处助抓人打下手。一开始并不简单，因为被拉过来的人一点厨房的常识也没有，而那些会做饭的早就跑掉了。然而还是加德尼娅·比伯威特带着一群半身人过来帮忙。令人吃惊的是，丹德里恩招来的那四个妓女都是出乎意料的厨房能手。<br>   供给方面也没有问题菲斯奈特和艾格罗瓦尔组织了一场狩猎，打来了不少鹿肉，布蕾恩和他的女儿们只用了两个小时就打来了足够多的野味，众所周知树精大多箭术惊人，就连小女儿卡什卡弯弓搭箭也很流畅。热衷钓鱼的老国王赫维格一早就到湖上打鱼去了。带回了梭子鱼，狭鳕鱼还有好大只的贝斯鱼。ke的小儿子洛基跟他一同去的，岛民出身的他驾船打鱼样样精通，并且他也是早上为数不多能派上用场的，因为他和赫维格国王一样不沾酒。<br>   在变形怪特里科的驱使下，丹迪·比伯威特和他的亲戚们开始打扫大厅和各个房间，他们又赶着两个算命的，鳄鱼杀手，雕塑家还有喝的烂醉的灵媒师一同打扫清理。<br>   看管地下室的酒水的工作一开始交给了丹德里恩和他的朋友们，后来被证明这是一个灾难性的决定，于是这些诗人们就被赶了出去，钥匙交到莫斯萨克的女朋友芙蕾雅手中。但是丹德里恩和他的朋友们还赖着不走了，试图用抒情诗打动芙蕾雅，可这位岛民却像抵制酒精那样抵制他们的诗歌。<br>   杰洛特猛地抬起头来，他被从石子路上传来的马蹄声惊醒了，卡尔比从墙边的灌木丛中冲出，是希瑞来了，她穿着她的黑色皮革护甲，背上背着把剑，正是名剑格维尔，是她从科洛奇沙漠的地下墓穴中得到的。<br>   有那么一会他们就要彼此对视，也不说话。女孩驾着马向前，卡尔比向着杰洛特咬了过去，却被希瑞猛地拉了回来。<br>   “就是今天了，”猎魔女说道，“是今天，杰洛特。”<br>   “是今天，”猎魔人背靠着墙，确认到。<br>   “我很高兴”，她的声音中有种不确定，“我想……我不太肯定你们两个会不会幸福，但我还是很高兴。”<br>   “希瑞，下马，我们得谈谈。”<br>   女孩甩了下头，把头发甩到了后面。杰洛特看见了一道又宽又丑的伤疤——这是一段不堪回首的往事，希瑞就是为了遮住伤疤才将头发蓄长，但是她总是忘了挡住伤疤。<br>   “我要走了，杰洛特”她告诉猎魔人，“宴会之后，立马上路。”<br>   “下马，希瑞。”<br>   猎魔女跳下马来，坐在他身旁，杰洛特抱住了她，希瑞靠在他的肩上。<br>   “我要离开了，”她又说了一遍。<br>   他什么也没说，话到嘴边，但是他觉得不合适，或者说不必要。他什么也没说。<br>   “我知道你在想什么，”她慢慢的说道，“你觉得我是要逃跑，的确是这样。”<br>   他还是沉默着，他确实明白。<br>   “毕竟，在经历了这么多风风雨雨，你终于和叶结婚了，你理应幸福，理应有一个安定的家，但是这一切却令我感到害怕，杰洛特，所以……我要逃离这一切。”<br>   他还是沉默着，他想起了自己的逃跑。<br>   “宴会结束马上就走，”希瑞又说了一遍。“我想……我想要再次感受策马急行的风，我想眺望地平线上的星星，我想要晚上吹丹德里恩歌谣的调调，我渴求战斗，渴求用剑一决胜负，渴求冒险，渴求胜利带给我的喜悦，并且我渴求孤孤单单的一个人，你能明白我的意思吗？”<br>   “明白，”杰洛特悲伤的笑了笑，“我当然明白，你是我的宿命，你是个猎魔人，你要去做你必须要做的，但我必须要告诉你一件事，你不能一走了之，尽管你在不停的尝试。”<br>   “我知道，”她回应到，紧紧的抱住他，“我也希望有一天，如果我不停的等待，如果我有足够的耐心，我大概也有像你这样的一天……如此好的一天……即使……”<br>   “即使什么，希瑞？”<br>   “我很丑，而且还有那样一道难看的伤疤……”<br>   “希瑞！”他打断她，“你是世上最漂亮的女孩……当然只是在叶之后。”<br>   “杰洛特……”<br>   “你不信的话，去问丹德里恩。”<br>   “杰洛特，我……”<br>   “说起来，他死哪里去了……”<br>   “我要去南方，”她打断了他，不敢直视他。“战后仍然不安定，那里的人们需要保护，我会派上用场的，还要去科洛奇……还有尼弗迦德，我和格威尔在那里还有未了结的事。”<br>   她突然沉默了，脸变得冷漠起来。绿色的眼睛眯了起来，嘴角挂满了仇恨。我记得，杰洛特，我还记得，就像现在一样。上一次他们并肩在吕思勋城堡作战。楼梯上已经血流成河，他们就站在血泊当中。狼和猫，两个冷血的杀人机器，非人的速度和非人的冷漠，围上来的尼弗迦德人慢慢的后退。一只出奇冷静的狼和一只出奇疯狂的猫，闪烁的刀锋，哭喊声，四处迸溅的鲜血，以及遍地凋零的生命……就像那样，就像上一次那样。<br>   希瑞将头发向后甩去，灰白的头发在太阳穴处一阵震荡。<br>   “我还用未竟之事，”她冷冷的说道，“为了<a href="http://witcher.huijiwiki.com/wiki/%E7%B1%B3%E5%B8%8C%E5%B0%94" target="_blank" rel="noopener">米希尔</a>,为了我的米希尔，我已经为她报了仇，但是只杀一个人是不够的。”<br>   <a href="http://witcher.huijiwiki.com/wiki/%E7%B1%B3%E5%B8%8C%E5%B0%94" target="_blank" rel="noopener">雷欧·邦纳特</a>，她杀了他，为她报了仇。希瑞啊希瑞，你现在已经处在深渊边缘，女儿，即使杀了上千人也换不回你的米希尔，要提防仇恨啊，那种堪比癌症的情感。<br>   “你要当心你自己啊。”他低沉的说。<br>   “我宁愿让别人当心，”她讽刺的笑了笑，“这样回报更多，也更加有意义。”<br>   我再也见不到她了，他想，如果她走了，我不会再见到她了。<br>   “还会再见的，”她出乎意料的回答道，脸上挂着一个女术士而非猎魔人的微笑。“还会再见的，杰洛特。”<br>   她如一个男孩般跑开了，敏捷的跳上马鞍。<br>   “架，卡尔比！！”<br>【以上对话涉及的人的确是后面小说中的人物，但是故事的发展稍微不太一样】<br>马蹄铁踏在路上，迸溅出火花。丹德里恩不知从哪里冒出来了，他把鲁特琴挂在肩上，腾出手来，一手拿着一大罐啤酒。</p><p>   “来，喝一杯”他说着，坐在他身边，“这对你有好处。”<br>   “我不太确定，叶妮芙警告我，如果他在我身上闻到酒味”<br>   “嚼些欧芹就行了，喝吧，你这妻管严。”</p><p>   他们静静的坐了好长时间，慢悠悠的喝着啤酒，丹德里恩叹了口气。<br>   “希瑞要走了，是吗？”<br>   “嗯。”<br>   “我觉得也是，杰洛特，听我说两句……”<br>   “丹德里恩，你还是闭嘴吧。”<br>   “哦。好吧。”<br>   他们又沉默了。厨房传来了一股烤鹿肉的香味，刺柏的味道很浓。<br>   “……结束了（Something ends），”杰洛特艰难的说，“都结束了。”<br>   “可不是这样，”诗人严肃的反驳道，“是开始了（Something begins）”</p><hr><h1 id="IX"><a href="#IX" class="headerlink" title="IX"></a>IX</h1><p>   下午是在一片哭声中度过的，一切都是从美之灵药开始的，这种灵药，更准确的说是一种软膏，在古老的习俗中，也被称作“格拉玛耶”，据说可以使女性变得更加漂亮，更加引人注目。在各个主妇的要求下，te准备了大量的药膏。于是在场的女士们开始按照习俗涂抹。但是，在锁死的门后传来了希瑞菈、莫娜、艾思娜和卡什卡的哭声，她们不允许使用格拉玛耶，只有大女儿莫丽恩才能享受这一殊荣。哭的最响的是卡什卡，在她的上一层，莉莉正在哇哇的哭，她是dan的女儿，因为她发现和大多数魔法物品一样，格拉玛耶对半身人不起作用，在花园中瞎逛的灵媒师只是嗅了嗅，可她不知道的是嗅上一口就提神醒脑的后果，酒醒之后她陷入了无尽的忧郁当中。城堡的西翼，里夫·卡尔迪米恩的女儿阿妮卡也哭了起来，她不知道格拉玛耶是要涂在眼睛下面的，却吃了那药膏，现在正在腹泻。希瑞也拿了她那一份，涂在了卡尔比的眼下。<br>   女祭司小爱若拉和尤妮德也哭了，因为叶妮芙拒绝穿她们为她精心制作的白色婚纱，甚至南尼克在一旁劝也没用，叶妮芙骂骂咧咧，还把盘子给摔了，大声喊着她穿上这玩意就像一个他妈的白衣处女，南尼克也生气了，大声骂着她的行为比三个该死处女还糟糕。叶妮芙也没有回骂回去，直接放了一道闪电，打穿了塔楼的屋顶。这一举措还是有好的一面的，突如其来的巨响让卡尔迪米恩的女儿一惊，竟然吓好了她的腹泻。<br>   又有人看见特莉丝和猎魔人艾斯卡尔溜进了花园的小亭子，两人还手牵着手，毫无疑问，这次两人都是本人，因为变形怪特里科正在和丹迪·比伯威特和金龙维纶特瑞坦梅斯喝酒。<br>   人们又仔仔细细的找了一遍，还是没找到那个自称是舒滕巴赫的侏儒。</p><hr><h1 id="X"><a href="#X" class="headerlink" title="X"></a>X</h1><p>   “叶……”<br>   她看上去心情激动，金色的宝冠下，她那黑色的波浪般的卷发，垂在肩头，乌黑亮丽。立起的衣领是白色棉织，而袖口却镶着黑色条纹，两者通过紫罗兰色的紧身上衣连在一起。<br>   “花，别忘了花”，特莉丝在一旁提醒道，她一身深蓝色的装扮，递给新娘一束白玫瑰，“哦，叶。我太开心了……”<br>   “特莉丝，亲爱的……”叶妮芙突然抽泣起来，两个女术士紧紧地拥抱在一起，轻吻着彼此的钻石耳环。<br>   “意思意思就行了”南尼克在一旁不耐烦的提醒道，抚平洁白的祭祀服上的褶皱。“走，我们去教堂，爱若拉，尤妮德，托着她的裙摆，否则她会在楼梯口摔死自己的。”<br>   叶妮芙走向杰洛特伸出，伸出戴着白色蕾丝手套的手，整理了杰洛特嵌着银边的黑色斗篷的衣领，杰洛特伸出胳膊挽住她。<br>   “杰洛特，”他在她耳边轻轻的说道，“我还是不敢相信。”<br>   “叶，”杰洛特低声的回答道，“我爱你。”<br>   “我知道。”叶妮芙喃喃道。</p><hr><h1 id="XI"><a href="#XI" class="headerlink" title="XI"></a>XI</h1><p>   “赫维格死哪里去了？”<br>   “不知道，”丹德里恩一边轻抚着他那身时髦上衣的扣子，一边回答道。<br>   “说起来，希瑞去哪了？”<br>   “不知道。”叶妮芙皱起眉头，吸了吸鼻子。“你那股欧芹味的道不错啊，丹德里恩，你改吃素了吗？”<br>   宾客们开始陆续入场，小小的礼拜堂变得拥挤起来，一身黑礼服的ai坐在闪着白光的美人鱼si身边。他们的身边是一群穿着米黄色，棕色衣服的半身人，ya和金龙wei则浑身上下金光闪闪，fei和多瑞格雷则是一身紫色装扮，皇家使团的各位使者则和他们各自的纹章保持着一致的色调，精灵和树精是一身绿色。而丹德里恩和他的朋友们则穿的花里胡哨，五颜六色的的衣服。<br>   “有人看见洛基了吗？”莫斯萨克问道。<br>   “洛基？”艾斯卡尔走了过来，顺着装饰着野鸡毛的帽子看向德鲁伊。“洛基和赫维格一起湖上捕鱼去了，我看见他们的船还在湖上，希瑞则是去叫他们回来。”<br>   “这是什么时候的事?”<br>   “有一会了”。<br>   “诅咒你们得瘟疫，这群该死的渔夫，”克拉茨·安·克莱特咒骂道，“他们这是钓鱼钓上头了，把正事给忘了，雷格纳，去吧他们叫回来。”<br>   “等一下，”布蕾恩一把推开想要吃她豆腐的丹德里恩，“我们需要跑的快的人，莫娜，卡什卡， Raenn’ess aen laeke, va!”<br>   “早就说了，”南尼克气得不行，“赫维格根本就不靠谱，不敬畏神灵的白痴还要让他负责？谁还赞成他继续做主婚人？”<br>   “他好歹是个国王，”杰洛特不确定的说道，“可能叫前国王更确切，但好歹是个国王”<br>   “万岁……”一个算命的听到国王两个字后职业本能的开始唱起歌来，幸好，旁边的鳄鱼杀手及时放倒了他。半身人们开始骚动起来，有人骂骂咧咧，还有人被别人锤了鼻子，变形怪特里科踩到了加德尼娅·比伯威特的裙子，她开始尖叫起来，灵媒师则无缘无故的抽泣了起来<br>   “要是在这么等下去，”叶妮芙紧紧地抓住花束，努力保持着微笑，“再等一会我就要吐血了，马上给我开始。”<br>   “不要乱动，叶，”特莉丝悄声说道，“紧身衣要裂开了。”<br>   “那个侏儒舒滕巴赫跑到哪里去了，”一个歌手叫喊道。<br>   “我们也不知道啊。”四个妓女异口同声的喊道。<br>   “狗娘养的，马上派个人去找他，”丹德里恩大喊到，“他是负责带花过来的，现在可怎么办，舒滕巴赫和花都不在这，这婚礼可怎么继续？”<br>   被派去寻找国王的树精姐妹尖叫着冲进婚礼大厅，洛基则紧随其后，身上又脏又湿，前额上破了一个大口子。<br>   “洛基，”克拉奇喊了起来，“什么情况？”<br>   “妈妈！！！！！！”卡什卡哭喊道。<br>   “Que’ss aen!，”布蕾恩抓住她的两个女儿，抚慰她们，用精灵语问道，”Que’ss aen que suecc’ss feal, caer me?”<br>   “我们的船翻了……”洛基上气不接下气的说道，“就在岸边，来了只大怪物！，我用船桨揍他，但是他就直接吞了…….吞了我的船桨！”<br>   “谁？什么东西？”<br>   “杰洛特，”布蕾恩喊道，“杰洛特，莫娜说那是一只cinarea”<br>   “一个zhirritva!”猎魔人惊叫道，“艾斯卡尔，快把我的剑拿来！”<br>   【这怪物实在不知道是啥】<br>   “我的法杖呢，”多瑞格雷也喊了一声，“雷德克里夫，我的法杖在哪？”<br>   “希瑞！”洛基喊了一声，擦了擦额头的鲜血，“希瑞正在和那怪兽战斗！”<br>   “操蛋了，希瑞根本打不过一个zhirritva！艾斯卡尔，把我的马也牵来”<br>   “等一下，”叶妮芙甩掉头上的宝冠，“我们用传送门，那样更快，多瑞格雷，特莉丝，雷德克里夫，把你们的手给我……”<br>   一阵沉默过后，又响起了尖叫声，赫维格国王出现在门口，浑身又湿又脏，但是全身完好。他身边则站着一个光头的年轻人，身上穿着一套闪闪发光奇怪的盔甲。希瑞则紧随他们之后，手上提着格维尔，浑身泥泞，衣服滴着水，头发蓬乱，一道恐怖的伤疤横在脸上，从太阳穴直到下巴，袖口下的衣服被撕烂了，鲜血直流。<br>   “希瑞！！”<br>   “我杀了它，”猎魔人女孩弱弱的说道，“我劈开了它的头。”<br>   希瑞几乎要倒下了，杰洛特，艾斯卡尔和丹德里恩簇拥上前把住她，但就是这样她也没放开她的剑。<br>   “又受伤了……”吟游诗人悲叹到，“又是伤到了脸，为什么她的命运就这么不堪……”<br>   叶妮芙高声尖叫，一把推开雅尔，这个独臂的年轻人正好站在叶妮芙和希瑞之间，希瑞身上的泥巴和鲜血弄脏了女术士的婚纱，但是她一点也不在意。叶妮芙用手指按住猎魔人女孩的脸，吟诵了了一个魔法咒语，在杰洛特看来，整个城堡都因为这个法术晃了一下，甚至太阳也暗淡了一秒。叶妮芙缓慢的把手指从希瑞脸上移开，众人惊叹起来，巨大，丑陋的伤口变成一条细细的红线，只有几滴血而已，希瑞倒在杰洛特怀中。<br>   “厉害！”多瑞格雷感叹道，“这可是大师的手笔。”<br>   “干得好，叶，”特莉丝静静的说道，而一旁的南尼克则哭了起来。<br>   叶妮芙笑了笑，眼睛向上一翻，晕了过去，杰洛特还是在她如丝带般倒下之前抱住了她。</p><hr><h1 id="XII"><a href="#XII" class="headerlink" title="XII"></a>XII</h1><p>   “杰洛特，冷静，”南尼克说，“别太激动，过一会就好了，她只是用力过猛，别那么紧张了……你知道她有多爱希瑞。”<br>   “我知道。”杰洛特抬起头，看着门口站着的那个穿着一身闪闪发光的奇怪盔甲的年轻人。<br>   “听着，孩子，现在回到礼堂，这里没你事了，只是告诉我，你是谁？”<br>   “我，我是加拉哈德。”年轻的骑士回答道，“我想……我想问下那位美丽勇敢的少女怎么样了？”<br>   “哪一个？”猎魔人笑道，“这里有两个，两个都是漂亮，勇敢的少女，尽管其中一个只是偶然才是的，你说的是哪一个？”<br>   年轻人的脸，明显红了，“年轻的那一位……”他回答道，“就是那个义无反顾跑去帮助渔王的那位。”<br>   “谁？”<br>   “他说的是赫维格，”南尼克插嘴道，“zhirritva在赫维格和洛基捕鱼时攻击了他们的船，希瑞则冲向了zhirritva，而这个小伙子正好在近旁，过去帮了希瑞。”<br>   “你帮了希瑞，”猎魔人满怀感激的看着这个年轻的骑士，“你叫什么来着……”<br>   “加拉哈德，请问这里是阿瓦隆，渔王的城堡吗？”<br>   【阿瓦隆：亚瑟王传说中的极乐世界】<br>   门开了，叶妮芙在特莉丝的搀扶下出现在门口，她的脸色苍白。<br>   “叶！”<br>   “我们去礼堂。”女术士平静的要求到。“客人们都等着呢。”<br>   “叶……我们不急，可以再迟些。”<br>   “即使是恶魔要带走我，我也要嫁给你，而且是现在！”<br>   “希瑞怎么样了？”<br>   “哪个希瑞？”，猎魔人女孩从叶妮芙身后冒出，她正在往脸上涂抹着格拉玛耶。<br>   “一切都好，杰洛特，不过是一道擦伤，我都没什么感觉。”<br>   加拉哈德单膝跪地，铠甲发出金属碰撞的咯吱声。<br>   “女神……”<br>   希瑞漂亮的绿眼睛睁圆了。<br>   “希瑞，请允许我……”猎魔人说道，“这个骑士，嗯，加拉哈德，你们应当彼此见过了，他当时帮了你一把。”<br>   希瑞脸红了，格拉玛耶开始生效了，细小的伤疤在红润的脸蛋上几乎看不见了。<br>   “女神，”加拉哈德喃喃的说道，“您是如此亲切，如此美丽，请允许我留下,我想……”<br>   “毫无疑问，他想成为你的骑士，希瑞，”特莉丝说道。<br>   希瑞优雅的欠身行礼，但始终一句话也没说。<br>   “客人还等着呢，”叶妮芙打断他们。“加拉哈德，我在我看来，你不仅是个勇敢的战士，而且还是有礼貌的小伙子，你和我的……我的女儿并肩作战，所以，在婚礼上你可以挽住她，希瑞，快去换一身裙子，杰洛特，整理整理的你的头发，把你的内衬塞回袖子里去，都出来了，十分钟之内我要在礼堂看见你们。”</p><hr><h1 id="XIII"><a href="#XIII" class="headerlink" title="XIII"></a>XIII</h1><p>  婚礼仪式无比的辉煌，夫人和女孩们感动的哭成一片，赫维格——是前国王，但仍然是个国王——主持的婚礼，来自凯尔莫罕的维瑟米尔和南尼克作为这对新婚夫妻的父母方，特莉丝和艾斯卡尔是证婚人，加拉哈德陪着希瑞，后者脸红的像一枝娇艳的牡丹。<br>  佩剑的人们把剑搭在了一起，支起一个架子。丹德里恩和他的朋友们则演奏者鲁特琴，唱着特意为这个时刻谱写的曲子，在菲斯奈特的红发女儿们和美人鱼希恩娜兹的优美的歌声的伴奏下，丹德里恩开始即兴的祝愿这对新婚夫妻幸福，好运，以及一个成功的新婚之夜，听到这话，叶妮芙娇嗔的给了他一脚。【这里和原著有冲突，美人鱼献祭了尾巴换了腿以后，就失去了声音】<br>  人们聚集在王座大厅，各就各位，叶妮芙和杰洛特坐在主席上，手上绑着婚礼纱带，他们微笑着回应各位嘉宾的祝福和祝酒词。<br>  昨晚还乱搞一气的客人们，今晚则彻底变了样，都在以一种文明的方式尽情享乐，在相当长的一段时间里竟然没有人喝醉，当然只有一个人例外，那就是可怜的独臂小伙子雅尔，他无法忍受在加拉哈德甜甜的注视下满脸通红的希瑞，不停的喝闷酒 。今晚也没人意外失踪，除了卡什卡，不久之后，在桌子底下看见了她，她趴在一直狗身上，睡得正香呢。<br>  吸取了前一晚的教训，洛史洛格的鬼魂们也没有再来捣乱，只有一个例外，那就是只剩下骨架和裹尸布的马洪，突然出现在艾格罗瓦尔,莫斯萨克和菲斯奈特身后，然而王子，男爵和德鲁伊正非常专注的讨论政治，甚至都没有注意到他，由于没有一个人鸟他，这个骨架非常的沮丧。他在桌子旁四处走动，冷不丁的用他的牙齿咬了特莉丝一口，而女术士正温柔的依偎在艾斯卡尔的手臂上，她优雅的举起了手，掰断了他的手指头，狗处理了掰断的指骨。<br>  “愿伟大的梅里特利女神保佑你们夫妻俩，”南尼克亲吻了叶妮芙，和杰洛特碰了碰杯。“但是你们可没少走弯路，不过可算是结了婚。我真的很高兴，希望希瑞也能跟你们一样，找到命中注定的那个人后，能痛快的定下终生。”<br>  “我觉得，”杰洛特看向被猎魔人女孩迷住的加拉哈德，“她已经找到一个了。”<br>  “你说的是那个不知从哪里来的怪人？”女祭司惊讶道，“他们之间是没有结果的，你有没有仔细观察过那个人？没有？那你现在看看他在干嘛，他现在正在向希瑞求爱，但是手却不停的摸索着桌子上的酒杯，这可不太正常，我实在想不明白希瑞看他就像看一张照片那样仔细，雅尔，他可不一样，这孩子有理性，懂礼貌……”<br>  “您那有理性，懂礼貌的加尔已经摔到桌子下面去了，”叶妮芙打断了女祭司，“南尼克，别说了，希瑞过来了。”<br>  灰发的猎魔人女孩坐在赫维格让出的椅子上，搂住女术士。<br>  “我要离开了。”她平静地说。<br>  “我知道，孩子。”<br>  “加拉哈德……加拉哈德打算跟着我，也不知道为什么，我大概不能阻止他吧，对吗？”<br>  “当然阻止不了，杰洛特！”叶妮芙的眼睛，在温暖的紫罗兰色调中闪闪发光，看着她的丈夫，“到桌边去，陪客人们说说话，你也可以稍微喝上一小杯，但是只能是一小杯，我想和我的女儿谈谈，这是女人之间的谈话。”<br>  杰洛特叹了口气。<br>  聚会的氛围上来了。丹德里恩的朋友们唱的小黄歌让卡尔迪米恩的女儿安尼卡满脸通红。醉醺醺的龙v紧紧的抱着喝的更醉的变形怪特里科，试图说服他，变成a王子然后和美人鱼上床可不是个太友好的行为。<br>  菲斯奈特的红发女儿们则为了取悦那些皇家的使者们尽情的展现她们美妙的身姿，而皇家的使者们也在尽他们的全力打动树精们，看他们表演，总有种在游乐场的错觉。亚尔潘齐格林，用带有浓重鼻音的嗓子向精灵凯瑞尔丹说他打小就想当个精灵。莫斯萨克大喊着政府药丸，而艾格罗瓦尔则极力反对，当然也没人知道他们说的是哪个政府，赫维格国王则对加德尼娅说他用马鬃绳钓上了条大鲤鱼，半身人只是梦游般的点了点头，并且时不时的拍打下旁边的丈夫叫他不要喝的太多。<br>  画廊里，两个算命的和鳄鱼杀手则在四处走动，想找到那个名字叫舒滕巴赫的侏儒，但是仍旧找不到【未见侏儒——我们仍未找到那天前来赴宴的那个名字叫做舒滕巴赫的侏儒】，芙蕾雅显然讨厌酒量不行的男人，于是就在这和那个女灵媒师喝赫尔特·斯凯尔特，两人都保持着一种高尚和严肃的静默，因为这是一场无声的战斗。<br>  杰洛特绕着桌子走了一圈，挨个和客人们碰了杯，客人们也拍着他的背，祝他幸福。最后他来到了加拉哈德和丹德里恩附近，加拉哈德盯着诗人的酒杯，嘟嘟囔囔的说着什么，而吟游诗人则眯着眼睛仔细听着。杰洛特打算一探究竟。<br>  “……于是我就上了船，”加拉哈德说，“船驶向那片薄雾，我得向您承认，丹德里恩大师，我那时候怕的不行……我承认我有时候会失去希望，就像这次，我觉得我的末日到了，我会死在那片无法穿透的薄雾中，然后太阳就出来了…..在湖面上闪烁，就好像…金子一般。然后在我前方就是…阿瓦隆，这里是阿瓦隆，对吗？”<br>  “不是，”丹德里恩一边给两人满上，一边回答道，“这是Schwemmland，可以翻译成沼泽地……先喝一杯吧，加拉哈德。”<br>  “这个城堡……一定是蒙萨尔瓦特，不是吗？”<br>  “可不是，这个城堡叫洛史洛格，我就从来没听说过什么蒙萨尔瓦特，孩子，如果我都没听说过的话，那就是没有的事了，年轻人，为新婚夫妇干一杯吧。”<br>  “干杯，丹德里恩大师，但是那位国王，他不是渔王吗？”<br>  “赫维格？哦，他是挺喜欢钓鱼的，这倒是真的，他以前喜欢打猎，但是在奥斯战役中伤了腿，然后就再也不能骑马了，但你也不能叫人家渔王，首先，这个名字太蠢了，其次，你这样会冒犯到赫维格的。”<br>  加拉哈德半晌没说话，只是晃动着杯子中剩下一半的酒，然后他深深地叹了口气，环顾四周。<br>  “他们是对的，”他低声说道，“这只是个传说，一个童话，一段幻象，简而言之，这就是个谎言，这就是一片普通的沼泽地而不是阿瓦隆，没有希望了。”【阿瓦隆跟这个地方外表差不多】<br>  “喂，喂，”诗人用手戳了戳他，“不要伤心，孩子，你忧郁个什么劲？你正在参加一场婚礼派对，所以要做到就是高兴点，喝喝酒，唱唱歌。你还年轻，还有大把时光。还有一辈子的路要走。”<br>  “一辈子？”骑士若有所思的重复道，“那又如何，丹德里恩大师，有什么开始了，还是说有什么结束了？”<br>  丹德里恩好奇的看了他一眼。<br>  “不，我可不知道，如果连我都不知道的话，那就没人知道了，所以结论就是吗，没什么要结束，也没什么要开始。”<br>  “我不明白。”<br>  “你明白也没什么用。”</p><p>  加拉哈德想了想，皱起眉。<br>  “那圣杯呢？”他最后问道，“圣杯到哪里去了？”<br>  “圣杯又是什么东西？”<br>  “是我们追寻的东西，”他解释道，悲伤的看着吟游诗人，“那是最重要的，没有它，我们的生命就没什么意义，没有它，我们的生命永远不完整。”<br>  吟游诗人紧闭双唇，以他那著名的神色看向骑士，眼神中充满睿智和诚恳。<br>  “你个傻蛋，”他回答道，“你一整晚都坐在你的‘圣杯’旁边。”<br>  【这段亚瑟王的圆桌骑士异世界穿越是真的秀】</p><hr><h1 id="XIV"><a href="#XIV" class="headerlink" title="XIV"></a>XIV</h1><p>  午夜时分的，当客人已经玩的上头时，杰洛特和叶妮芙从宴会中脱离出来，他们终于可以平和的看看对方。突然，门开了，强盗维辛来了，人们都称他作“抢劫柏”，维辛身长两米开外，留着及腰长的大胡子，鼻子的颜色和形状都像萝卜，一直肩膀上扛着他那根著名的大棍子“牙签”，另一只肩膀上则扛着个大袋子。<br>  杰洛特和叶妮芙都认识这位“抢劫柏”。他俩谁也没想着要邀请他来。毫无疑问，这又是丹德里恩干的好事。<br>  “维辛，欢迎你，”女术士微笑道，“能记住我们真的是太好了，来，请坐”<br>  强盗倚着牙签，恭敬的鞠了一躬<br>  “祝你们快快乐乐，早生贵子”，他大声说道，“祝你们夫妻俩百年好合……我在说什么？两百年，该死的，应该是两百年。啊，我很高兴，杰洛特，还有叶妮芙夫人，我就知道你们会结婚的，尽管你们总是像,像狗一样打来打去。他妈的，我在说什么鸟话……”<br>  “欢迎，欢迎，维辛。”猎魔人说着，向着他能找到的最大的杯子倒酒，“为我们的健康干杯，你是打哪来的？有谣言说你进了监狱。”<br>  “他们把我给放了。”“抢劫柏”喝了一大口，叹了口气，“你们怎么说的，他妈的，保释？然后我就到这里来了，亲爱的，我给你们带了礼物，打开看看。”<br>  “这什么玩意，”女术士高声叫道，看着那个大口袋，里面的东西还在不停的动。<br>  “我是在路上看见的，”，抢劫柏回答道，“我是在花坛那里找见的，那有个光着屁股的石头女人，你知道的，就是有鸽子在上面……”<br>  “这袋子里到底是什么？”<br>  “哦，是一个，嗯，怎么说呢，一个小恶魔。这就当做新婚礼物了。你们这有放养动物的地方吗，没有？好吧，你们可以把他做成标本，然后挂着走廊上，人们看见了会惊叹的。但是我得告诉你，这他妈的是个骗子，他一直说自己叫舒滕巴赫。”</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/upload/pasted-357.png&quot;&gt;&lt;br&gt;《猎魔人》原著作者送给其朋友的结婚礼物，和正传发生的故事有些矛盾，但问题不大&lt;br&gt;高甜预警！！！&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java多线程学习6（CAS，原子类，CountDownLatch，CyclicBarrier，Semaphore）</title>
    <link href="https://www.junglezero.top/2019/07/02/ithreading-6/"/>
    <id>https://www.junglezero.top/2019/07/02/ithreading-6/</id>
    <published>2019-07-02T01:08:13.000Z</published>
    <updated>2019-07-12T04:40:25.746Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/upload/pasted-361.png" width="70%"></p><a id="more"></a><h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CAS通常是指（Compare And Swap或 Compare And Set）是硬件操作系统级别提供的具有原子性的原语指令，利用它可以在多线程中取得和同步一样的效果。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>基于<a href="https://www.junglezero.top/2019/04/23/%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81-1/#more">乐观锁</a>。以i++为例子举例，一般情况下是三步操作，分别是取值，+操作，存值，但是如果是多线程操作，就会存在线程安全的问题，对于CAS，首先获取旧的预期值，在准备保存时，和当前内存中的值进行对比（compare）,如果两个值相等，说明这个值没有发生改变，此时就存入新值（swap），如果发生改变，说明这个值已经被别的线程修改，此时当前线程不会进行操作，或者循环几个周期</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>因为加锁花销太大了（悲观锁）<br>结合上一个多线程的学习（AQS）,包括下面的原子类型，就可以发现实际上CAS是java并发包主要应用的一个方法</p><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>既然是基于乐观锁，那么势必会有ABA问题，所谓ABA问题，就是在当前线程准备存储过程中，如果这个值从A变成了B又变回了A，则对于当前线程，值是没有发生改变的，虽然从结果来看没什么影响，但是这实际上是个潜在的问题，解决的方法在上面的那个链接已经说明，就是添加一个版本号，或者时间戳</p><h3 id="自旋式循环"><a href="#自旋式循环" class="headerlink" title="自旋式循环"></a>自旋式循环</h3><p>当存值失败时，就有可能进入循环状态（自旋），如果多次失败，就会有效率上的问题</p><h1 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h1><p>java并发包下提供了java.util.concurrent.atomic包，包中包含了16个类（java8）</p><p><img src="/upload/pasted-339.png" alt="upload successful"></p><h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>摘录自API文档</p><blockquote><p>A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.</p></blockquote><blockquote><p>A CountDownLatch is initialized with a given count. The await methods block until the current count reaches zero due to invocations of the countDown() method, after which all waiting threads are released and any subsequent invocations of await return immediately. This is a one-shot phenomenon – the count cannot be reset. If you need a version that resets the count, consider using a CyclicBarrier.</p><p>A CountDownLatch is a versatile synchronization tool and can be used for a number of purposes. A CountDownLatch initialized with a count of one serves as a simple on/off latch, or gate: all threads invoking await wait at the gate until it is opened by a thread invoking countDown(). A CountDownLatch initialized to N can be used to make one thread wait until N threads have completed some action, or some action has been completed N times.</p><p>A useful property of a CountDownLatch is that it doesn’t require that threads calling countDown wait for the count to reach zero before proceeding, it simply prevents any thread from proceeding past an await until all threads could pass. </p></blockquote><p>从上面的描述中，得知几个事情</p><ul><li>这是一个计数器，用来使一个或者多个线程等待其他线程完成其操作</li><li>使用一个数值初始化，调用await使【当前线程】进入等待状态，当被等待的线程完成其任务时调用countDown()使计数–，直到减到0时【当前线程】不再等待</li><li>可以把countDownLatch理解为一个开关或者，只有【被等待线程】调用countDown()，await的线程才能“从大门进去”</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>文档中给到了一个Driver-Worker的实例<br>使用两个CountDownLatch，第一个在driver准备就绪之前，阻止worker执行，第二个使driver等待直到worker执行完<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123; <span class="comment">// ...</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     CountDownLatch startSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">     CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="comment">// create and start threads</span></span><br><span class="line">       <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(startSignal, doneSignal)).start();</span><br><span class="line"></span><br><span class="line">     doSomethingElse();            <span class="comment">// driver先执行</span></span><br><span class="line">     startSignal.countDown();      <span class="comment">// 调用countDown使startSignal归0</span></span><br><span class="line">     doSomethingElse();</span><br><span class="line">     doneSignal.await();           <span class="comment">// 使driver等着worker的线程执行完（等待doneSignal归0）</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startSignal;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line">   Worker(CountDownLatch startSignal, CountDownLatch doneSignal) &#123;</span><br><span class="line">     <span class="keyword">this</span>.startSignal = startSignal;</span><br><span class="line">     <span class="keyword">this</span>.doneSignal = doneSignal;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//等待startSignal归0</span></span><br><span class="line">       startSignal.await();</span><br><span class="line">       doWork();</span><br><span class="line">       <span class="comment">//worker线程每执行完，调用countdown，是doneSignal减1</span></span><br><span class="line">       doneSignal.countDown();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;&#125; <span class="comment">// return;</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>文档中还给到了一个另一个实例：<br>将一个问题分成多个部分，然后每个线程运行一部分<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver2</span> </span>&#123; <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N);</span><br><span class="line">    Executor e = ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="comment">// create and start threads</span></span><br><span class="line">      e.execute(<span class="keyword">new</span> WorkerRunnable(doneSignal, i));</span><br><span class="line"></span><br><span class="line">    doneSignal.await();           <span class="comment">// wait for all to finish</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkerRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> i;</span><br><span class="line">  WorkerRunnable(CountDownLatch doneSignal, <span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">this</span>.doneSignal = doneSignal;</span><br><span class="line">    <span class="keyword">this</span>.i = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      doWork(i);</span><br><span class="line">      doneSignal.countDown();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;&#125; <span class="comment">// return;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>和上面的CountDownLatch类似，但还是有区别的</p><blockquote><p>A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point. CyclicBarriers are useful in programs involving a fixed sized party of threads that must occasionally wait for each other. The barrier is called cyclic because it can be re-used after the waiting threads are released.</p><p>A CyclicBarrier supports an optional Runnable command that is run once per barrier point, after the last thread in the party arrives, but before any threads are released. This barrier action is useful for updating shared-state before any of the parties continue.</p></blockquote><p>这个强调的是“使一套线程等待彼此，直到所有的线程都到达了检查点（barrier point）”，相比于上面的CountDownLatch，它不需要执行线程去调用变化（countdown）</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>有两个构造方法<br><img src="/upload/pasted-340.png" alt="upload successful"><br>第一个方法的参数是这一组需要互相等待的线程的数量<br>当输入的数量大于需要运行的线程的数量时，由于到达检查点的线程（运行await）的数量小于预定的，所以会一直等待<br>当输入的参数小于需要进行互相等待的数量时，先到者优先，没有抢到的只能顺序运行<br>第二个方法还多一个Runnable对象，包括上面也说到了，这个线程的参数是指当所有的线程到达检查点时，并不会立刻运行，会先跑传入的参数的这个线程，这个线程完了，其他到检查点的线程才会解除等待状态</p><p><img src="/upload/pasted-341.png" alt="upload successful"><br>调用await时，有几个情况会使等待线程不再等待：</p><ul><li>最后一个线程到达检查点</li><li>超时</li><li>别的线程打断当前线程</li><li>别的线程打断别的等待线程（到达检查点的线程）</li><li>别的线程超时</li><li>对于当前的检查点，别的线程调用了它的reset方法</li></ul><p>CylicBarrier比countDownLatch优越在reset上，因为可以重复使用</p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>假设有一个使用场景，需要计算四个地方的值，然后进行汇总，计算部分的值单开一个线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建线程数量为4的检查点，四个线程到达检查点后，运行this的run</span></span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier c=<span class="keyword">new</span> CyclicBarrier(<span class="number">4</span>,<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//假设有4个需要计算的表，启动四个线程</span></span><br><span class="line">    <span class="keyword">private</span> Executor executor= Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">//保存结果</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;String,Integer&gt; results=<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//假设计算结果为1</span></span><br><span class="line">                    results.put(Thread.currentThread().getName(),<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//计算完毕后，在检查点等着</span></span><br><span class="line">                        c.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">"结果计算完毕，"</span>+Thread.currentThread().getName()+<span class="string">"溜了"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String,Integer&gt; sheet:results.entrySet())&#123;</span><br><span class="line">            result+=sheet.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"输出计算结果："</span>+result);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrierTest c=<span class="keyword">new</span> CyclicBarrierTest();</span><br><span class="line">        c.count();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：</p><p><img src="/upload/pasted-342.png" alt="upload successful"></p><h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><h2 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h2><p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。</p><blockquote><p>A counting semaphore. Conceptually, a semaphore maintains a set of permits. Each acquire() blocks if necessary until a permit is available, and then takes it. Each release() adds a permit, potentially releasing a blocking acquirer. However, no actual permit objects are used; the Semaphore just keeps a count of the number available and acts accordingly.</p></blockquote><p>关键点：Semaphore维持一个“许可证”（permit）来控制线程访问数量。通过acquire()获取许可，通过release()释放<br>要想理解其方法的实现，一定要知道一个重要的事情，这个工具是基于AQS实现的，通过观察源码可以发现不管是公平不公平的acquire还是release，都是基于内部自己继承<a href="https://www.junglezero.top/2019/06/28/va%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%88Lock%EF%BC%8CAQS-ReentrantLock%EF%BC%89/">AQS</a>的一个内部类Sync实现的</p><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><p>构造方法：<br><img src="/upload/pasted-343.png" alt="upload successful"><br>两个参数，一个是许可证的数量，再一个是允不允许公平（AQS那一套），默认不公平的</p><p><img src="/upload/pasted-344.png" alt="upload successful"><br>如果还有许可证就马上返回，许可证数量减1，如果没有许可证则进入阻塞序列直到有其他线程调用release或者被打断</p><h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><p>文档中给到了一个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_AVAILABLE = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Semaphore available = <span class="keyword">new</span> Semaphore(MAX_AVAILABLE, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getItem</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    available.acquire();</span><br><span class="line">    <span class="keyword">return</span> getNextAvailableItem();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putItem</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (markAsUnused(x))</span><br><span class="line">      available.release();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not a particularly efficient data structure; just for demo</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> Object[] items = ... whatever kinds of items being managed</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[MAX_AVAILABLE];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Object <span class="title">getNextAvailableItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">         used[i] = <span class="keyword">true</span>;</span><br><span class="line">         <span class="keyword">return</span> items[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// not reached</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">markAsUnused</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (item == items[i]) &#123;</span><br><span class="line">         <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">           used[i] = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个例子实际上并没有很显示的应用在多线程中，但还是有一点要说的，要是看的仔细，就会发现acquire，release方法并没有外面上锁，这是因为Semaphore，内部维持着一个实现AQS的内部类</p><p>当许可证的数量设置为1时，这时Semaphore就成为了一个互斥锁，但是和一般的锁不同的是这个Semaphore可以被其他线程调用（因为Semaphore没有拥有者的概念），这个特性可以用在解决死锁上（文档中说的）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SemaphoreLock lock=<span class="keyword">new</span> SemaphoreLock();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.lock();</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">"抢到了锁"</span>);</span><br><span class="line">                            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"释放了锁"</span>);</span><br><span class="line">                        lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreLock</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Semaphore semaphore=<span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> semaphore.tryAcquire();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/upload/pasted-361.png&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>字符串专题</title>
    <link href="https://www.junglezero.top/2019/06/30/StringProblemsCollection/"/>
    <id>https://www.junglezero.top/2019/06/30/StringProblemsCollection/</id>
    <published>2019-06-30T12:48:01.000Z</published>
    <updated>2019-07-10T13:30:52.320Z</updated>
    
    <content type="html"><![CDATA[<h1 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>题目描述：输入一个矩阵，按照从外向里以顺时针打印出每一个数字，例如：输入如下矩阵，则依次打印出的数字为：1、2、3、4、8、12、16、15、14、13、9、5、6、7、11、10.<br><img src="/upload/pasted-336.png" alt="upload successful"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Problem20</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] array=&#123;</span><br><span class="line">                &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,&#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;,&#123;<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>&#125;&#125;;</span><br><span class="line">        Problem20 testCircle=<span class="keyword">new</span> Problem20();</span><br><span class="line">        testCircle.printMatixClockwisely(array);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMatixClockwisely</span><span class="params">(<span class="keyword">int</span>[][] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(array[<span class="number">0</span>].length&gt;start*<span class="number">2</span>&amp;&amp;array.length&gt;start*<span class="number">2</span>)&#123;</span><br><span class="line">            printOneCircle(array,start);</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printOneCircle</span><span class="params">(<span class="keyword">int</span>[][] array, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;array[<span class="number">0</span>].length-start;i++)&#123;</span><br><span class="line">            System.out.print(array[start][i]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(array.length-<span class="number">1</span>-start&gt;start)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=start+<span class="number">1</span>;i&lt;array.length-start-<span class="number">1</span>;i++)&#123;</span><br><span class="line">                System.out.print(array[i][array[<span class="number">0</span>].length-<span class="number">1</span>-start]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(array[<span class="number">0</span>].length-start-<span class="number">1</span>&gt;start &amp;&amp;</span><br><span class="line">                array.length-start-<span class="number">1</span>&gt;start)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=array.length-start-<span class="number">1</span>;i&gt;start;i--)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(array[array.length-start-<span class="number">1</span>][i]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(array.length-<span class="number">1</span>-start&gt;start &amp;&amp;</span><br><span class="line">                array[<span class="number">0</span>].length-<span class="number">1</span>-start&gt;start)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=array.length-start-<span class="number">1</span>;i&gt;start;i--)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(array[i][start]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h1><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>主要的思路就是定住一个排后面的,对于定住这个问题，用到了递归的思想<br><img src="/upload/pasted-355.png" alt="upload successful"><br>这里存在的问题就是如果后面有重复的字母，就不在进行交换</p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串的排列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">permutation</span><span class="params">(String a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] chars=a.toCharArray();</span><br><span class="line">    permutationHelper(chars,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">permutationHelper</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> current)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (current==chars.length-<span class="number">1</span>)</span><br><span class="line">        System.out.println(chars.toString());</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=current;i&lt;chars.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isExisted(chars,current,i))&#123;</span><br><span class="line">                swap(chars,current,i);</span><br><span class="line">                permutationHelper(chars,current+<span class="number">1</span>);</span><br><span class="line">                swap(chars,i,current);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> current, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp=chars[i];</span><br><span class="line">    chars[i]=chars[current];</span><br><span class="line">    chars[current]=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isExisted</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> current, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=current;k&lt;i;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (chars[k]==chars[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串的组合"><a href="#字符串的组合" class="headerlink" title="字符串的组合"></a>字符串的组合</h1><h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><p>{a,b,c}要求输出{a,b,c,ab,ac,bc,abc}。</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>可以将题目分成小问题来理解，1个字符的组合+2个字符的组合+3个字符的组合，因此我们只要找到一般的方法，即从n个字符中找m个字符的组合就可以了。<br>我们可以把n个字符分成两部分，第一个字符和其他所有字符。如果组合里包含第一个字符，则下一步在剩余的字符里选取m-1个字符；如果组合里不包含第一个字符，则下一步在剩余的n-1个字符里选取m个字符，从中可以看出又是个递归的过程。</p><h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">char</span>[] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= array.length ; i ++ )</span><br><span class="line">            combination(array,<span class="number">0</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">combination</span><span class="params">(<span class="keyword">char</span>[] strArr, <span class="keyword">int</span> begin, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(stack);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (begin &gt;= strArr.length) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//把第一个字符放入组合中,在剩余的字符中选取num-1个字符</span></span><br><span class="line">            stack.push(strArr[begin]);</span><br><span class="line">            combination(strArr, begin + <span class="number">1</span>, num - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//组合里不包含第一个字符,则下一步在剩余的字符中选取num个字符</span></span><br><span class="line">            stack.pop();</span><br><span class="line">            combination(strArr, begin + <span class="number">1</span>, num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>因为组合问题，比如3个元素的组合就有2^3-1种，所以不妨给他们进行编号，就像上面的问题，从a——abc一次编号为 001——111。1就代表该位置出现字符。例如：001-&gt;c,010-&gt;b,101-&gt;ac……，所以原题就是要求输出”001”-“111”这2^n-1个组合对应的字符串。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">　　String s = <span class="string">"abc"</span>;</span><br><span class="line">　　ArrayList&lt;String&gt; result = combineString(s);</span><br><span class="line">　　<span class="keyword">for</span>(String r : result)&#123;</span><br><span class="line">　　　　System.out.println(r);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title">combineString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">　　<span class="keyword">int</span> len = s.length();</span><br><span class="line">　　ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(); </span><br><span class="line">　　<span class="keyword">int</span> count = (<span class="keyword">int</span>) (Math.pow(<span class="number">2</span>, len));</span><br><span class="line">　　<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; ++i)&#123;</span><br><span class="line">　　　　String temp = <span class="string">""</span>;</span><br><span class="line">　　　　String str = Integer.toBinaryString(i);</span><br><span class="line">　　　　<span class="keyword">while</span>(str.length() &lt; len)&#123;</span><br><span class="line">　　　　　　str = <span class="string">"0"</span> + str;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; str.length(); ++j)&#123;</span><br><span class="line">　　　　　　<span class="keyword">if</span>(str.charAt(j) == <span class="string">'1'</span>)&#123;</span><br><span class="line">　　　　　　　　temp += s.charAt(j);</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　list.add(temp);</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;顺时针打印矩阵&quot;&gt;&lt;a href=&quot;#顺时针打印矩阵&quot; class=&quot;headerlink&quot; title=&quot;顺时针打印矩阵&quot;&gt;&lt;/a&gt;顺时针打印矩阵&lt;/h1&gt;&lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; class=&quot;headerlink&quot; title=&quot;描
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>树（二叉树）专题</title>
    <link href="https://www.junglezero.top/2019/06/30/%E9%A2%98/"/>
    <id>https://www.junglezero.top/2019/06/30/题/</id>
    <published>2019-06-30T12:42:06.000Z</published>
    <updated>2019-07-08T10:49:04.496Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本结构（实现）"><a href="#基本结构（实现）" class="headerlink" title="基本结构（实现）"></a>基本结构（实现）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h1><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p>是一种先访问根结点，再访问左子节点，再访问右子结点的访问方式，用递归方式很容易实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preorderTraverse</span><span class="params">(TreeNode t)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(t!=<span class="keyword">null</span>)&#123;</span><br><span class="line">         System.out.println(t.val+<span class="string">""</span>);</span><br><span class="line">         preorderTraverse(t.left);</span><br><span class="line">         preorderTraverse(t.right);</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环的方法实现：<br>对于当前结点，首先访问，然后访问其左子结点，若其左子结点为空（即“访问到头了”）就要访问其右子结点，这个时候，就需要栈来记录其没有访问右子结点的父结点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderTraverse2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    TreeNode pNode = root;</span><br><span class="line">    <span class="comment">//栈不为空表示还有没有访问右结点的父结点存在</span></span><br><span class="line">    <span class="keyword">while</span> (pNode != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//若结点不为空，直接访问，下一步循环其左结点，并将该结点入栈，以便访问其右结点</span></span><br><span class="line">        <span class="keyword">if</span> (pNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(pNode.val+<span class="string">"  "</span>);</span><br><span class="line">            stack.push(pNode);</span><br><span class="line">            pNode = pNode.left;</span><br><span class="line">            <span class="comment">//左节点为空，即“到头”了，此时要从栈中找出没有访问右结点的父结点，出栈，访问其右结点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//pNode == null &amp;&amp; !stack.isEmpty()</span></span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            pNode = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>先访问左子结点，再访问父结点，再访问右子结点<br>递归方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderTraverse1</span><span class="params">(TreeNode node)</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;  </span><br><span class="line">           inOrderTraverse1(root.left);  </span><br><span class="line">           System.out.print(root.val+<span class="string">"  "</span>);  </span><br><span class="line">           inOrderTraverse1(root.right);  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>非递归方式：和之前差不多，只不过这次是在某个结点出栈的时候进行访问<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderTraverse2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    TreeNode pNode = root;</span><br><span class="line">    <span class="keyword">while</span> (pNode != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(pNode);</span><br><span class="line">            pNode = pNode.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//pNode == null &amp;&amp; !stack.isEmpty()</span></span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            System.out.print(node.val + <span class="string">"  "</span>);</span><br><span class="line">            pNode = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p>先访问左结点，再放问右结点，最后访问根结点<br>递归方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrderTraverse1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        postOrderTraverse1(root.left);</span><br><span class="line">        postOrderTraverse1(root.right);</span><br><span class="line">        System.out.print(root.val+<span class="string">"  "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>非递归方法：<br>初始根结点入栈，对于栈顶结点，如果其有左子结点或者右子结点且没有被访问，则按照右子结点，左子结点的顺序入栈，如果是叶子节点名，则出栈，直接访问，并用标记<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="常见题目"><a href="#常见题目" class="headerlink" title="常见题目"></a>常见题目</h1><h2 id="根据前序和中序遍历构造二叉树（假设不包含重复数字）"><a href="#根据前序和中序遍历构造二叉树（假设不包含重复数字）" class="headerlink" title="根据前序和中序遍历构造二叉树（假设不包含重复数字）"></a>根据前序和中序遍历构造二叉树（假设不包含重复数字）</h2><p>重点：</p><p><img src="/upload/pasted-317.png" alt="upload successful"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in)</span> </span>&#123;</span><br><span class="line">TreeNode root = reConstructBinaryTree(pre, <span class="number">0</span>, pre.length - <span class="number">1</span>, in, <span class="number">0</span>, in.length - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序遍历&#123;1,2,4,7,3,5,6,8&#125;和中序遍历序列&#123;4,7,2,1,5,3,8,6&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span> startPre, <span class="keyword">int</span> endPre, <span class="keyword">int</span>[] in, <span class="keyword">int</span> startIn, <span class="keyword">int</span> endIn)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (startPre &gt; endPre || startIn &gt; endIn) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode root = <span class="keyword">new</span> TreeNode(pre[startPre]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = startIn; i &lt;= endIn; i++)</span><br><span class="line"><span class="keyword">if</span> (in[i] == pre[startPre]) &#123;</span><br><span class="line">root.left = reConstructBinaryTree(pre, startPre + <span class="number">1</span>, startPre + i - startIn, in, startIn, i - <span class="number">1</span>);</span><br><span class="line">root.right = reConstructBinaryTree(pre, i - startIn + startPre + <span class="number">1</span>, endPre, in, i + <span class="number">1</span>, endIn);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先在树1中找到树2的根结点，然后在比较左子树和右子树</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树的子结构</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasSubTree</span><span class="params">(TreeNode t1,TreeNode t2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result=<span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1!=<span class="keyword">null</span>&amp;&amp;t2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1==t2)</span><br><span class="line">            result=checkSubTree(t1,t2);</span><br><span class="line">        <span class="keyword">if</span> (!result)</span><br><span class="line">            hasSubTree(t1.left,t2);</span><br><span class="line">        <span class="keyword">if</span> (!result)</span><br><span class="line">            hasSubTree(t1.right,t2);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkSubTree</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t2==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1.val!=t2.val)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> checkSubTree(t1.left,t2.left)&amp;&amp;checkSubTree(t1.right,t2.right);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="镜像二叉树"><a href="#镜像二叉树" class="headerlink" title="镜像二叉树"></a>镜像二叉树</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>输入一个二叉树，输出它的镜像</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p><img src="/upload/pasted-335.png" alt="upload successful"><br>通过示例图可以看出，输出镜像结点的方法就是从根结点开始，交换左右孩子…不断递归知道到达叶子结点<br>需要注意的是递归</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span> <span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    TreeNode temp = root.left;</span><br><span class="line">    root.left=root.right;</span><br><span class="line">    root.right=temp;</span><br><span class="line"></span><br><span class="line">    mirrorTree(root.left);</span><br><span class="line">    mirrorTree(root.right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>输入一个树，判断是不是对称的，即这棵树是不是和他的镜像树相同</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>注意找到递归的突破口</p><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对称二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode t1)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isSymmetrical(t1,t1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t1==<span class="keyword">null</span>&amp;&amp;t2==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1==<span class="keyword">null</span>||t2==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1.val!=t2.val)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (t1.left.val==t2.right.val)&amp;&amp;(t1.right.val==t2.left.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归方法，用栈实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root.left);</span><br><span class="line">    stack.push(root.right);</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">        TreeNode n1 = stack.pop(), n2 = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (n1 == <span class="keyword">null</span> &amp;&amp; n2 == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (n1 == <span class="keyword">null</span> || n2 == <span class="keyword">null</span> || n1.val != n2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        stack.push(n1.left);</span><br><span class="line">        stack.push(n2.right);</span><br><span class="line">        stack.push(n1.right);</span><br><span class="line">        stack.push(n2.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="从上到下打印二叉树"><a href="#从上到下打印二叉树" class="headerlink" title="从上到下打印二叉树"></a>从上到下打印二叉树</h1><h2 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h2><p>从上到下打印一棵二叉树，同一层的结点按照从左到右的顺序打印</p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>利用一个队列放下一系列需要打印的结点</p><h2 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从上到下打印二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTreeTopToBottom</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; q=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>||root.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        q.add(root.left);</span><br><span class="line">        q.add(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(root.val);</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span> (q.peek().left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            q.add(q.peek().left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q.peek().right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            q.add(q.peek().right);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(q.poll().val);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分行从上到下打印二叉树"><a href="#分行从上到下打印二叉树" class="headerlink" title="分行从上到下打印二叉树"></a>分行从上到下打印二叉树</h1><h2 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h2><p>上一道题的一种变式</p><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>添加两个变量，分别对当前行和下一行计数</p><h2 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTreeTopToBottomByLine</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; q=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.add(root);</span><br><span class="line">    <span class="keyword">int</span> currentLine=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> nextLine=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span> (q.peek().left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            q.add(q.peek().left);</span><br><span class="line">            nextLine++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q.peek().right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            q.add(q.peek().right);</span><br><span class="line">            nextLine++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(q.poll().val);</span><br><span class="line">        currentLine--;</span><br><span class="line">        <span class="keyword">if</span> (currentLine==<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println();</span><br><span class="line">            currentLine=nextLine;</span><br><span class="line">            nextLine=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="之字形打印二叉树"><a href="#之字形打印二叉树" class="headerlink" title="之字形打印二叉树"></a>之字形打印二叉树</h1><h2 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h2><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左往右的顺序，第二行从右往左，第三行从左往右依次类推</p><h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><p>有了上两道题的铺垫，我们对于这道题，首先可以看出这也需要逐行的分析，也就是偶数行需要从左往右打印，奇数行需要从右向左（从第0行开始），同样也用队列当做容器</p><h2 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h2><p>LeetCode第103题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">int</span> level=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> num=queue.size();</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(level%<span class="number">2</span>!=<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (queue.peek().left!=<span class="keyword">null</span>)queue.offer(queue.peek().left);</span><br><span class="line">                <span class="keyword">if</span> (queue.peek().right != <span class="keyword">null</span>) queue.offer(queue.peek().right);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (queue.peek().right != <span class="keyword">null</span>) queue.offer(queue.peek().right);</span><br><span class="line">                <span class="keyword">if</span> (queue.peek().left!=<span class="keyword">null</span>)queue.offer(queue.peek().left);</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(queue.poll().val);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(list);</span><br><span class="line">        level++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="二叉搜索树的后续遍历序列"><a href="#二叉搜索树的后续遍历序列" class="headerlink" title="二叉搜索树的后续遍历序列"></a>二叉搜索树的后续遍历序列</h1><h2 id="描述-6"><a href="#描述-6" class="headerlink" title="描述"></a>描述</h2><p>输入一个整数数组，判断该数组是不是某二叉搜素树后续遍历的结果，假设输入的数都各不相同</p><h2 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h2><p>应当抓住<a href="https://www.junglezero.top/2018/02/14/%EF%BC%882%EF%BC%89/">二叉搜索树</a>的特点,即对于根结点，左子树的结点数值都比根结点小，右子树的结点数值都比根结点大，然后递归的方式寻找</p><h2 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的后续遍历序列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence, <span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sequence==<span class="keyword">null</span>||sequence.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> root=sequence[sequence.length-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i=start;</span><br><span class="line">    <span class="comment">//确定左子树边界</span></span><br><span class="line">    <span class="keyword">for</span> (;i&lt;end;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (sequence[i]&gt;root)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j=i;</span><br><span class="line">    <span class="comment">//在右子树中，如果存在小于根结点的值，则说明这个序列不是个搜索树的后续遍历</span></span><br><span class="line">    <span class="keyword">for</span> (;j&lt;end;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (sequence[j]&lt;root)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归判断左子树</span></span><br><span class="line">    <span class="keyword">boolean</span> left=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        left=isSquenceOfBST(sequence,<span class="number">0</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归判断右子树</span></span><br><span class="line">    <span class="keyword">boolean</span> right=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;end)&#123;</span><br><span class="line">        right=isSquenceOfBST(sequence,i,end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left&amp;&amp;right;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h1><h2 id="描述-7"><a href="#描述-7" class="headerlink" title="描述"></a>描述</h2><p>输入一个二叉树和一个整数，打印二叉树中结点的值的和为输入整数的所有路径，从根结点一直到尾结点为一个路径</p><h2 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h2><p>这个题很明显想到用回溯法，用一个栈来存放结点</p><h2 id="实现-8"><a href="#实现-8" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树中和为某一值的路径</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findPath</span><span class="params">(TreeNode root,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root==<span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       <span class="keyword">int</span> curentNum=<span class="number">0</span>;</span><br><span class="line">       findPath(root,num,stack,curentNum);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findPath</span><span class="params">(TreeNode root, <span class="keyword">int</span> num, Stack&lt;Integer&gt; stack, <span class="keyword">int</span> curentNum)</span> </span>&#123;</span><br><span class="line">       curentNum+=root.val;</span><br><span class="line">       stack.push(root.val);</span><br><span class="line">       <span class="keyword">if</span> (root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span> (curentNum==num)&#123;</span><br><span class="line">               System.out.println(<span class="string">"找到一条路径："</span>);</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> n:stack)&#123;</span><br><span class="line">                   System.out.print(n+<span class="string">" "</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (root.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           findPath(root.left,num,stack,curentNum);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (root.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           findPath(root.right,num,stack,curentNum);</span><br><span class="line">       &#125;</span><br><span class="line">       stack.pop();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="二叉搜素树和双向链表"><a href="#二叉搜素树和双向链表" class="headerlink" title="二叉搜素树和双向链表"></a>二叉搜素树和双向链表</h1><h2 id="描述-8"><a href="#描述-8" class="headerlink" title="描述"></a>描述</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求<br>不能创建任何新的结点，只能调整树中结点指针的指向</p><h2 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h2><p>还是要抓住二叉搜素树的特点<br><img src="/upload/pasted-349.png" alt="upload successful"><br>中序遍历恰好可以使一棵二叉搜索树按顺序输出<br><img src="/upload/pasted-350.png" alt="upload successful"><br>按照中序遍历的顺序，当我们遍历到根结点时，它的左子树已经转换成一个排序的好的双向链表了，并且处在链表中最后一个的结点是当前值最大的结点。我们把值为8的结点和根结点链接起来，10就成了最后一个结点，接着我们就去遍历右子树，并把根结点和右子树中最小的结点链接起来。</p><h2 id="实现-9"><a href="#实现-9" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRootOfTree == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(pRootOfTree.left == <span class="keyword">null</span> &amp;&amp; pRootOfTree.right == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">    </span><br><span class="line">    TreeNode leftNode = Convert(pRootOfTree.left);</span><br><span class="line">    TreeNode curNode = leftNode;</span><br><span class="line">    <span class="comment">//找到左子树最右边的叶子节点</span></span><br><span class="line">    <span class="keyword">while</span>(curNode != <span class="keyword">null</span> &amp;&amp; curNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        curNode = curNode.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接根节点与左子树的最右叶子节点</span></span><br><span class="line">    <span class="keyword">if</span>(leftNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        pRootOfTree.left = curNode;</span><br><span class="line">        curNode.right = pRootOfTree;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//右子树的最左叶子节点</span></span><br><span class="line">    TreeNode rightNode = Convert(pRootOfTree.right);</span><br><span class="line">    <span class="comment">//连接根节点与右子树的最左叶子节点</span></span><br><span class="line">    <span class="keyword">if</span>(rightNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        pRootOfTree.right = rightNode;</span><br><span class="line">        rightNode.left = pRootOfTree;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//考虑没有左子树的情况</span></span><br><span class="line">    <span class="keyword">return</span> leftNode==<span class="keyword">null</span>?pRootOfTree:leftNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h1><h2 id="描述-9"><a href="#描述-9" class="headerlink" title="描述"></a>描述</h2><p>请实现两个函数，分别用来序列化和反序列化二叉树</p><h2 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h2><p>二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（$）</p><p>二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p><h2 id="实现-10"><a href="#实现-10" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">Serialize</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    StringBuilder b=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    circleSerialize(root,b);</span><br><span class="line">    <span class="keyword">return</span> b.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">circleSerialize</span><span class="params">(TreeNode root, StringBuilder b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>)</span><br><span class="line">        b.append(<span class="string">"$,"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    b.append(root.val+<span class="string">","</span>);</span><br><span class="line">    circleSerialize(root.left,b);</span><br><span class="line">    circleSerialize(root.right,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反序列化（根据前序遍历结果）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">DeSeriablize</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">   String[] s= str.split(<span class="string">","</span>);</span><br><span class="line">   <span class="keyword">int</span> index=-<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">return</span> DeSeriablizeCore(str,index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">DeSeriablizeCore</span><span class="params">(String str, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    String[]s=str.split(<span class="string">","</span>);</span><br><span class="line">    TreeNode node=<span class="keyword">null</span>;</span><br><span class="line">    index++;</span><br><span class="line">    <span class="keyword">if</span> (!s[index].equals(<span class="string">"$"</span>)) &#123;</span><br><span class="line">        node = <span class="keyword">new</span> TreeNode(Integer.parseInt(s[index]));</span><br><span class="line">        node.left=DeSeriablizeCore(str,index);</span><br><span class="line">        node.right=DeSeriablizeCore(str,index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本结构（实现）&quot;&gt;&lt;a href=&quot;#基本结构（实现）&quot; class=&quot;headerlink&quot; title=&quot;基本结构（实现）&quot;&gt;&lt;/a&gt;基本结构（实现）&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
      <category term="[object Object]" scheme="https://www.junglezero.top/categories/object-Object/"/>
    
    
      <category term="数据结构" scheme="https://www.junglezero.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="树" scheme="https://www.junglezero.top/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Java多线程学习5（Lock，AQS，ReentrantLock，ReentrantReadWriteLock，Condition）</title>
    <link href="https://www.junglezero.top/2019/06/28/va%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%88Lock%EF%BC%8CAQS-ReentrantLock%EF%BC%89/"/>
    <id>https://www.junglezero.top/2019/06/28/va多线程学习（Lock，AQS-ReentrantLock）/</id>
    <published>2019-06-28T08:09:00.000Z</published>
    <updated>2019-07-12T04:41:43.925Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/upload/pasted-362.png" width="70%"></p><a id="more"></a><h1 id="Lock-接口"><a href="#Lock-接口" class="headerlink" title="Lock 接口"></a>Lock 接口</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Java程序是靠synchronized关键字实现锁功能的，而Java SE 5之后，并发包中新增<br>了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized关键字类似的同步功<br>能，只是在使用时需要显式地获取和释放锁。虽然它缺少了（通过synchronized块或者方法所提<br>供的）隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以<br>及超时获取锁等多种synchronized关键字所不具备的同步特性</p><p>相比于Synchronized，Lock具有以下几个特性</p><p><img src="/upload/pasted-331.png" alt="upload successful"></p><h2 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h2><h3 id="void-lock-void-unlock"><a href="#void-lock-void-unlock" class="headerlink" title="void lock(),void unlock()"></a>void lock(),void unlock()</h3><p>这两个方法一个是上锁，一个是解锁<br>基本相当于synchronized关键字，具体使用方法如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="void-lockInterruptibly-throws-InterruptedException"><a href="#void-lockInterruptibly-throws-InterruptedException" class="headerlink" title="void lockInterruptibly() throws InterruptedException;"></a>void lockInterruptibly() throws InterruptedException;</h3><p>这个方法可以中断的获取锁，这就是和synchronized（lock()）很大的一个不同，即在抢锁的过程中可以中断该线程</p><p>演示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">validLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"Thread-"</span>+Thread.currentThread().getName()+<span class="string">"takes the synlock"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">        e.printStackTrace();;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>   <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String arg[])</span></span>&#123;</span><br><span class="line">    Thread t1=<span class="keyword">new</span> Thread()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            validLock();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Thread t2 =<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            validLock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t2.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个例子中，线程2是不会响应中断的</p><p>然而<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">validLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"Thread-"</span>+Thread.currentThread().getName()+<span class="string">"takes the synlock"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">        e.printStackTrace();;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>   <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String arg[])</span></span>&#123;</span><br><span class="line">    Thread t1=<span class="keyword">new</span> Thread()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                validLock();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Thread t2 =<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                validLock();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t2.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个实例中。t2会响应中断</p><h3 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock()"></a>tryLock()</h3><p>通过这个方式可以非阻塞的获取锁，即，即使抢不到锁，该线程也不会进入block状态，tryLock()的返回值是boolean,获取锁成功返回true，没获取锁返回false</p><p>具体用法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">TestTryLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lock.tryLock())&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"抢不到锁，溜了溜了（反正绝对不堵着）"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="boolean-tryLock-long-time-TimeUnit-unit-throws-InterruptedException"><a href="#boolean-tryLock-long-time-TimeUnit-unit-throws-InterruptedException" class="headerlink" title="boolean tryLock(long time, TimeUnit unit) throws InterruptedException;"></a>boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</h3><p>这个就是超时获取锁的体现，如果在指定时间内没有获取锁，就退出，在这个指定的时间内，也可以中断</p><h3 id="Condition-newCondition"><a href="#Condition-newCondition" class="headerlink" title="Condition newCondition();"></a>Condition newCondition();</h3><p>用来创建一个基于当前同步器的Condition对象，下文会介绍Condition</p><h1 id="AQS-AbstractQueuedSynchronizer"><a href="#AQS-AbstractQueuedSynchronizer" class="headerlink" title="AQS(AbstractQueuedSynchronizer)"></a>AQS(AbstractQueuedSynchronizer)</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>队列同步器AbstractQueuedSynchronizer（以下简称同步器），是用来构建锁或者其他同步组<br>件的基础框架，它使用了一个int成员变量（一个atomic int value）表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作，所以说AQS是JUC锁的灵魂所在</p><h2 id="各种概念"><a href="#各种概念" class="headerlink" title="各种概念"></a>各种概念</h2><h3 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h3><p>同步器依赖内部的同步队列（一个FIFO双向队列）来完成同步状态的管理，当前线程获取<br>同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node）并将其<br>加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再<br>次尝试获取同步状态。</p><p>同步器包含了两个节点类型的引用，一个指向头节点，而另一个指向尾节点。<br>试想一下，当一个线程成功地获取了同步状态（或者锁），其他线程将无法获取到同步状态，转<br>而被构造成为节点并加入到同步队列中，而这个加入队列的过程必须要保证线程安全，因此同步器提供了一个基于CAS的设置尾节点的方法：compareAndSetTail(Node expect,Node<br>update)，它需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式<br>与之前的尾节点建立关联</p><p><img src="/upload/pasted-332.png" alt="upload successful"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="独占锁的的实现"><a href="#独占锁的的实现" class="headerlink" title="独占锁的的实现"></a>独占锁的的实现</h3><h4 id="我们要做的"><a href="#我们要做的" class="headerlink" title="我们要做的"></a>我们要做的</h4><p>在API文档中，提到这么一句</p><blockquote><p>Subclasses should be defined as non-public internal helper classes that are used to implement the synchronization properties of their enclosing class. </p></blockquote><p>也就是说在使用上，要把AQS的继承类写在阻塞队列的内部，作为一个内部类出现<br>官方文档中还提到：<br>要想实现一个自定义同步器，就要实现以下几种方法，并且对于线程的状态，运用 getState(), setState(int) and/or compareAndSetState(int, int): </p><ul><li>tryAcquire(int)</li><li>tryRelease(int)</li><li>tryAcquireShared(int)</li><li>tryReleaseShared(int)</li><li>isHeldExclusively(</li></ul><p>API文档中也给了一个非重入式互斥独占锁的实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要自定义的锁</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 上文提到的内部类</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">     <span class="comment">// Reports whether in locked state</span></span><br><span class="line">     <span class="comment">//返回是否独占当前锁（0表示为占用锁，1表示锁已经被占用）</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Acquires the lock if state is zero</span></span><br><span class="line">     <span class="comment">//状态为0时尝试获取锁</span></span><br><span class="line">     <span class="comment">//重点要实现的方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//意思是传入的accauires的值必须要是1，要是不是1就退出了</span></span><br><span class="line">       <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">       <span class="comment">//这是一个原子操作</span></span><br><span class="line">       <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">         <span class="comment">//如果成功将状态从0变成了1，说明抢到锁，并且排他的（Exclusive）占用这把锁（独占）</span></span><br><span class="line">         <span class="comment">//并不用考虑这两个动作会不会发生同步问题，因为该方法是accquire调用的，其内部已经实现了某种竞争机制</span></span><br><span class="line">         setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Releases the lock by setting state to zero</span></span><br><span class="line">     <span class="comment">//将状态设为0来释放锁</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">       <span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">       <span class="comment">//将独占锁的线程设置为空</span></span><br><span class="line">       setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">       <span class="comment">//将状态设置为0</span></span><br><span class="line">       setState(<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Provides a Condition</span></span><br><span class="line">     <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject(); &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Deserializes properly</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">       s.defaultReadObject();</span><br><span class="line">       setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//上面就是几个重要方法的实现，具体使用如下</span></span><br><span class="line">   <span class="comment">// The sync object does all the hard work. We just forward to it.</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//调用Accquire</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>                </span>&#123; sync.acquire(<span class="number">1</span>); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>          </span>&#123; <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>              </span>&#123; sync.release(<span class="number">1</span>); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> sync.newCondition(); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span>         </span>&#123; <span class="keyword">return</span> sync.isHeldExclusively(); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sync.hasQueuedThreads(); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h4 id="细节理解"><a href="#细节理解" class="headerlink" title="细节理解"></a>细节理解</h4><h5 id="acquire"><a href="#acquire" class="headerlink" title="acquire()"></a>acquire()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryAcquire(int arg):线程安全的获取同步状态<br>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)：构造同步节点（独占式<br>Node.EXCLUSIVE，同一时刻只能有一个线程成功获取同步状态）并通过addWaiter(Node node)<br>方法将该节点加入到同步队列的尾部，最后调用acquireQueued(Node node,int arg)方法，使得该<br>节点以“死循环”的方式获取同步状态<br>…<br>。。。<br>…<br>。。。</p><p><img src="/upload/pasted-333.png" alt="upload successful"></p><h3 id="共享锁的实现"><a href="#共享锁的实现" class="headerlink" title="共享锁的实现"></a>共享锁的实现</h3><p>一个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwinsLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//依然是内部类的方式实现</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//状态用“0,1,2”进行标记</span></span><br><span class="line">        Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count must large than zero."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//实现tryAcquireShared</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> reduceCount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();<span class="keyword">int</span> newCount = current - reduceCount;</span><br><span class="line">                <span class="keyword">if</span> (newCount &lt; <span class="number">0</span> || compareAndSetState(current,</span><br><span class="line">                        newCount)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> newCount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//实现tryReleaseShared</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> returnCount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="keyword">int</span> newCount = current + returnCount;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, newCount)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他接口方法略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是一个允许最多两个线程同时访问的共享锁，因而实现的方法是shared那些。同步器会先计算出获取后的同步状态，然后通过CAS确保状态的正确设置，当tryAcquireShared(int reduceCount)方法返回值大于等于0时，当前线程才获取同步状态，对于上层的TwinsLock而言，则表示当前线程获得了锁</p><h1 id="ReentrantLock（重入锁）"><a href="#ReentrantLock（重入锁）" class="headerlink" title="ReentrantLock（重入锁）"></a>ReentrantLock（重入锁）</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>根据其名字，可以知道，这个锁是可“重复使用”的（synchronized也是支持重入的），一般情况下（如上文实现的互斥独占锁），如果让一个已经上锁的线程尝试再次上锁，那么它就会被自己所阻塞，最终进入阻塞状态它实际上，是Lock的一种实现，另外，还涉及到一个公平的问题</p><h2 id="细节分析"><a href="#细节分析" class="headerlink" title="细节分析"></a>细节分析</h2><h3 id="重进入的实现"><a href="#重进入的实现" class="headerlink" title="重进入的实现"></a>重进入的实现</h3><p>锁的获取：<br>识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理重进入的过程</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>锁的释放：<br>重复获取锁n次，就需要重复释放锁n次（有一个计数器）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//每次释放，都要做减法，只有状态值为0才能释放出去，允许其他线程抢</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="公平和不公平"><a href="#公平和不公平" class="headerlink" title="公平和不公平"></a>公平和不公平</h3><p>所谓公平和不公平，是指能不按照运行的绝对时间获取锁，即FIFO<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">    <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">    <span class="comment">// thread is first in queue.</span></span><br><span class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过观察我们可以返现相比于上文的nofair方法，这个方法多了一个hasQueuedPredecessors()，上面也附上了这个方法的实现，可以了解到“公平”就是通过同步器队列实现的，查看当前线程是否有前置结点，如果没有前置结点，则获得锁。<br>有一点要记住：默认的ReentrantLock中的require是非公平的方法，因为其效率更高</p><h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>读写锁在之前已经自己实现过一次了<br><a href="https://www.junglezero.top/2019/04/16/%E7%BA%BF%E7%A8%8B%E8%AF%BB%E5%86%99%E9%94%81%E5%88%86%E7%A6%BB/">自己实现的读写锁</a><br>根据以前的总结，读写锁需要注意的是：读进程和读进程可以同时进行，但是读进程和写进程是互斥的</p><p>API文档介绍了这个类的几个特性：</p><ul><li>支持公平不公平的抢锁（默认是不公平的）</li><li>可重入</li><li>可以从写锁降级至读锁，但不能从读锁升级为写锁</li><li>获取过程可以被打断</li><li>支持Condition</li></ul><h3 id="细节分析-1"><a href="#细节分析-1" class="headerlink" title="细节分析"></a>细节分析</h3><h4 id="读写状态的确定"><a href="#读写状态的确定" class="headerlink" title="读写状态的确定"></a>读写状态的确定</h4><p>实现时，采用了一个整型变量进行维护读写两种状态</p><p><img src="/upload/pasted-334.png" alt="upload successful"><br>当前同步状态值为S，写状态等于S&amp;0x0000FFFF（将高16位全部抹去），读状态等于S&gt;&gt;&gt;16（无符号补0右移<br>16位）。当写状态增加1时，等于S+1，当读状态增加1时，等于S+(1&lt;&lt;16)，也就是<br>S+0x00010000。<br>S不等于0时，当写状态（S&amp;0x0000FFFF）等于0时，则读状态（S&gt;&gt;&gt;16）大于0，即读锁已被获取。</p><h4 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 存在读锁或者当前获取线程不是已经获取写锁的线程</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读写锁要确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞</p><h4 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">int</span> nextc = c + (<span class="number">1</span> &lt;&lt; <span class="number">16</span>);</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; c)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp; owner != Thread.currentThread())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。</p><h4 id="写锁降级"><a href="#写锁降级" class="headerlink" title="写锁降级"></a>写锁降级</h4><p>API文档中给到了一个降级锁的实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CachedData</span> </span>&#123;</span><br><span class="line">  Object data;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">boolean</span> cacheValid;</span><br><span class="line">  <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">processCachedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rwl.readLock().lock();</span><br><span class="line">    <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">      <span class="comment">// Must release read lock before acquiring write lock</span></span><br><span class="line">      rwl.readLock().unlock();</span><br><span class="line">      rwl.writeLock().lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Recheck state because another thread might have</span></span><br><span class="line">        <span class="comment">// acquired write lock and changed state before we did.</span></span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">          data = ...</span><br><span class="line">          cacheValid = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Downgrade by acquiring read lock before releasing write lock</span></span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        rwl.writeLock().unlock(); <span class="comment">// Unlock write, still hold read</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      use(data);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      rwl.readLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>API文档已经说明了适合使用在数据量较大的容器，读操作比写操作更多的情况下，也给到了一个实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RWDictionary</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Data&gt; m = <span class="keyword">new</span> TreeMap&lt;String, Data&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Lock r = rwl.readLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Lock w = rwl.writeLock();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Data <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    r.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.get(key); &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; r.unlock(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String[] allKeys() &#123;</span><br><span class="line">    r.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.keySet().toArray(); &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; r.unlock(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Data <span class="title">put</span><span class="params">(String key, Data value)</span> </span>&#123;</span><br><span class="line">    w.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.put(key, value); &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; w.unlock(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    w.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123; m.clear(); &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; w.unlock(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意，读锁和写锁都有最大值的限制：65535</p><h2 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><p>用官方文档的话来说，Condition的作用就是用来替代object监视器的wait，notify，notifyAll方法，并且，A Condition instance is intrinsically bound to a lock.要想生成一种condition，调用lock方法的new condition创建。<br>下面用一个官方API文档中写的例子讲解用法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">final</span> Condition notFull  = lock.newCondition(); </span><br><span class="line">  <span class="keyword">final</span> Condition notEmpty = lock.newCondition(); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">  <span class="keyword">int</span> putptr, takeptr, count;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (count == items.length)</span><br><span class="line">        notFull.await();</span><br><span class="line">      items[putptr] = x;</span><br><span class="line">      <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">      ++count;</span><br><span class="line">      notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">        notEmpty.await();</span><br><span class="line">      Object x = items[takeptr];</span><br><span class="line">      <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;</span><br><span class="line">      --count;</span><br><span class="line">      notFull.signal();</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个例子实现的是一个有界缓存，类似于<a href="https://www.junglezero.top/2019/03/29/a%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%883%EF%BC%89/">生产者/消费者</a>，当缓存不为空时，消费者就可以拿取数据，当缓存不满时，生产者就可以放入数据，唯一不同的是这里的锁不是synchronized，而监视器用的也不是object</p><h3 id="细节分析-2"><a href="#细节分析-2" class="headerlink" title="细节分析"></a>细节分析</h3><p>一个Condition包含一个FIFO等待队列，队列中的结点都包含一个线程的引用，如果一个线程调用了Condition.await()方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态，对于一个Lock（同步器），其包含一个阻塞队列和多个等待队列（一个Condition对应一个）</p><h4 id="等待await"><a href="#等待await" class="headerlink" title="等待await"></a>等待await</h4><p><img src="/upload/pasted-337.png" alt="upload successful"><br>该方法的线程成功获取了锁的线程，也就是同步队列中的首节点，该方法会将当前线程构造成节点并加入等待队列中，然后释放同步状态，唤醒同步队列中的后继节点，然后当前线程会进入等待状态。<br>等待队列中的节点被唤醒，则唤醒节点的线程开始尝试获取同步状态。如果不是通过其他线程调用Condition.signal()方法唤醒，而是对等待线程进行中断，则会抛出InterruptedException。</p><h4 id="通知signal"><a href="#通知signal" class="headerlink" title="通知signal"></a>通知signal</h4><p><img src="/upload/pasted-338.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/upload/pasted-362.png&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="java多线程" scheme="https://www.junglezero.top/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>链表专题</title>
    <link href="https://www.junglezero.top/2019/06/24/%E4%B8%93%E9%A2%98/"/>
    <id>https://www.junglezero.top/2019/06/24/专题/</id>
    <published>2019-06-24T08:15:00.000Z</published>
    <updated>2019-07-07T02:48:13.866Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在O-1-删除链表中的结点"><a href="#在O-1-删除链表中的结点" class="headerlink" title="在O(1)删除链表中的结点"></a>在O(1)删除链表中的结点</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定单链表的头指针和一个节点指针，定义一个函数在O(1)时间删除该节点</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一般的链表删除结点都是从头结点遍历，找到要删除的结点然后进行删除，但是这个题目由于给了要删除结点的位置，就可以采取一些别的措施<br><img src="/upload/pasted-325.png" alt="upload successful"><br>这里的一个思路就是看重了结点的值：把要删除结点的下一个结点的值赋给要删除的结点，此时在删除要删除结点的下一个结点（如c）<br>但是还要注意特殊情况：</p><ul><li>要删除的结点是尾结点：此时只能从头结点顺序遍历，然后找到尾结点的前一个结点，然后再删除</li><li>要删除的链表只有一个结点，直接将头结点设为空</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除链表中的结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(ListNode first,ListNode deleteNode)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        first=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (deleteNode.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode l=first;</span><br><span class="line">        <span class="keyword">while</span> (l.next!=deleteNode)&#123;</span><br><span class="line">            l=l.next;</span><br><span class="line">        &#125;</span><br><span class="line">        l.next=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    deleteNode.val=deleteNode.next.val;</span><br><span class="line">    deleteNode.next=deleteNode.next.next;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链表中倒数第K个结点"><a href="#链表中倒数第K个结点" class="headerlink" title="链表中倒数第K个结点"></a>链表中倒数第K个结点</h1><h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><p>输入一个链表，输出该链表中倒数第k个结点。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>一般思路：向后找n-k+1个结点，需要两次遍历，第一次遍历找到n<br>更好的想法：两个指针，第一个指针首先移动k-1然后第二指针开始从头移动，此时两个指针同时移动，当第一个指针到达尾结点时，第二个指针所指就是要找到点<br>但是仍然要注意一些特殊的情况：</p><ul><li>输入的头结点为空：结果返回null</li><li>链表数小于k:无意义，结果返回null</li><li>k为0:无意义，结果返回null</li></ul><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">findKthNodeInLinkedList</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (head==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode Ahead=head;</span><br><span class="line">    ListNode Behind=head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (Ahead.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            Ahead=Ahead.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (Ahead!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        Ahead=Ahead.next;</span><br><span class="line">        Behind=Behind.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Behind;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链表中环的入口结点"><a href="#链表中环的入口结点" class="headerlink" title="链表中环的入口结点"></a>链表中环的入口结点</h1><h2 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h2><p>输入一个链表如果有环，返回其入口结点</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>第一步：确定链表有环：用两个指针，一个一次移动一步，另一个一次移动两步，若两个指针在移动中相等，则证明有环<br>第二步，找到环的长度：从两个指针相遇的地方开始，再次回到这个点的计数就是环的长度<br>第三步，找到入口，在知道了环的长度以后，就和上面的题一样了</p><h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//链表中环的入口结点</span></span><br><span class="line">    <span class="function">ListNode <span class="title">findEntryInCircle</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode slow=head;</span><br><span class="line">        ListNode fast=head;</span><br><span class="line">        ListNode meetingNode=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用快慢指针判断是否有环</span></span><br><span class="line">        <span class="keyword">while</span> (slow!=<span class="keyword">null</span>&amp;&amp;fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">            <span class="comment">//记录相遇结点</span></span><br><span class="line">            <span class="keyword">if</span> (slow==fast)</span><br><span class="line">                meetingNode=slow;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//fast到了null时，一定无环</span></span><br><span class="line">        <span class="keyword">if</span> (fast==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> circleLen=<span class="number">1</span>;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">        <span class="comment">//从相遇结点出发，再次回到相遇结点，计数，找出环的长度</span></span><br><span class="line">        <span class="keyword">while</span> (slow!=meetingNode)&#123;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            circleLen++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//两个指针，一个先走n（环的长度），当两个指针相遇时，就是环的入口</span></span><br><span class="line">        ListNode Ahead=head;</span><br><span class="line">        ListNode Behind=head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;circleLen;i++)&#123;</span><br><span class="line">            Ahead=Ahead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (Ahead!=Behind)&#123;</span><br><span class="line">            Ahead=Ahead.next;</span><br><span class="line">            Behind=Behind.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Ahead;</span><br><span class="line">.</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><h2 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h2><p>输入一个链表，反转链表后，输出新链表的表头。</p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>设置三个指针，head为当前节点，pre为当前节点的前一个节点，next为当前节点的下一个节点，需要pre和next的目的是让当前节点从pre-&gt;head-&gt;next1-&gt;next2变成pre<-head next1->next2的过程中，用pre让节点反转所指方向，next节点保存next1节点防止链表断开<br>仍然要注意特殊输入</-head></p><h2 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反转链表</span></span><br><span class="line"> <span class="function">ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">     ListNode ReverseHead=<span class="keyword">null</span>;</span><br><span class="line">     ListNode node=head;</span><br><span class="line">     ListNode pre=<span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">while</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="comment">//先获取当前结点的下一个结点</span></span><br><span class="line">         ListNode Next=node.next;</span><br><span class="line">         <span class="comment">//若下一个结点为空，则证明到头了</span></span><br><span class="line">         <span class="keyword">if</span> (Next==<span class="keyword">null</span>)</span><br><span class="line">             ReverseHead=node;</span><br><span class="line">         <span class="comment">//修改当前结点的下一个结点</span></span><br><span class="line">         node.next=pre;</span><br><span class="line">         <span class="comment">//当前结点成为新的pre</span></span><br><span class="line">         pre=node;</span><br><span class="line">         <span class="comment">//下一个结点成为新的当前结点</span></span><br><span class="line">         node=Next;</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ReverseHead;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h1><h2 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h2><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>注意处理两个链表为空的情况</p><h2 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//合并两个排序链表</span></span><br><span class="line"><span class="function">ListNode <span class="title">Merge</span><span class="params">(ListNode l1,ListNode l2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    ListNode node1=l1;</span><br><span class="line">    ListNode node2=l2;</span><br><span class="line">    ListNode MergeList =<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (l1.val&gt;l2.val)&#123;</span><br><span class="line">        MergeList=l1;</span><br><span class="line">        MergeList.next=Merge(l1.next,l2);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        MergeList=l2;</span><br><span class="line">        MergeList.next=Merge(l1,l2.next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MergeList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h1><h2 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h2><p>实现函数复制一个复杂链表。在复杂链表中，每个结点除了有一个 next，指针指向下一个结点外，还有一个指向链表中任意结点或 null。</p><h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><p>照猫画虎法，<br>先在每个结点后生成其复制结点，下一步是最关键的复杂指针的复制，就是照猫画虎，不管指针有多么的复杂，都会有A1.random=A.random.next，B1.random=B.random.next，C1.random=C.random.next，这样就解决了这个题的难点，最后把链表拆分。</p><h2 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复杂链表的复制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ComplicatedLinkedListNode <span class="title">copyComplicatiedLinkedList</span><span class="params">(ComplicatedLinkedListNode firstNode)</span></span>&#123;</span><br><span class="line">    <span class="comment">//第一步，在每个结点后面复制其自身的结点</span></span><br><span class="line">    ComplicatedLinkedListNode node=firstNode;</span><br><span class="line">    <span class="keyword">while</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        ComplicatedLinkedListNode newNode=<span class="keyword">new</span> ComplicatedLinkedListNode(node.val);</span><br><span class="line">        newNode.next=node.next;</span><br><span class="line">        node.next=newNode;</span><br><span class="line">        node=newNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二步，复制复杂指针，依照A1.random=A.random.next</span></span><br><span class="line">    ComplicatedLinkedListNode node2=firstNode;</span><br><span class="line">    node=firstNode.next;</span><br><span class="line">    <span class="keyword">while</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        node.random=node2.random.next;</span><br><span class="line">        node=node.next.next;</span><br><span class="line">        node2=node2.next.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三步。拆分出目标链表</span></span><br><span class="line">    node=firstNode.next;</span><br><span class="line">    node2=node.next;</span><br><span class="line">    <span class="keyword">while</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        node.next=node2.next;</span><br><span class="line">        node2=node.next.next;</span><br><span class="line">        node=node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ComplicatedLinkedListNode ans=firstNode.next;</span><br><span class="line">    firstNode.next=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;在O-1-删除链表中的结点&quot;&gt;&lt;a href=&quot;#在O-1-删除链表中的结点&quot; class=&quot;headerlink&quot; title=&quot;在O(1)删除链表中的结点&quot;&gt;&lt;/a&gt;在O(1)删除链表中的结点&lt;/h1&gt;&lt;h2 id=&quot;描述&quot;&gt;&lt;a href=&quot;#描述&quot; cla
      
    
    </summary>
    
      <category term="刷算法题" scheme="https://www.junglezero.top/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="数据结构" scheme="https://www.junglezero.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="链表" scheme="https://www.junglezero.top/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数值/数组算法题整理</title>
    <link href="https://www.junglezero.top/2019/06/24/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    <id>https://www.junglezero.top/2019/06/24/算法题/</id>
    <published>2019-06-24T01:07:00.000Z</published>
    <updated>2019-07-14T12:29:04.902Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>分清各种情况：</p><ul><li>指数为负：需要将底数求倒数然后再将指数取正</li><li>指数为最小的负数（Integer.MIN_VALUE），此时不能直接取正，直接二分递归再取正</li><li>底数为0，指数为负：会出现对0求倒数情况，要特殊处理</li><li>指数为0：无论底数，结果为1</li><li>可以用二分的思想减少运算</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"底数为0无意义"</span>);</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        x=<span class="number">1</span>/x;</span><br><span class="line">        n=-n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == Integer.MIN_VALUE)</span><br><span class="line">        <span class="keyword">return</span> myPow(x*x, -(n/<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n%<span class="number">2</span>==<span class="number">0</span>?myPow(x*x,n/<span class="number">2</span>):x*myPow(x*x,n/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="打印从1到最大的n位数"><a href="#打印从1到最大的n位数" class="headerlink" title="打印从1到最大的n位数"></a>打印从1到最大的n位数</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>输入数字n,按顺序打印出从1到最大的n位十进制数，比如输入3,则打印出1,2,3一直到最大的3位数即999</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这个题看似白给，实际容易被白给，因为当n特别特别大时，要是想直接输出数，是不可能的，因此要想到大数模拟，而大数从1到999…999递增的输出，用String模拟就又是一个问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//打印从1到最大的N位数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintOneToMaxNthDigits</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">char</span>[]num=<span class="keyword">new</span> <span class="keyword">char</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//从第一位开始初始化</span></span><br><span class="line">    num[<span class="number">0</span>]=<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        num[<span class="number">0</span>]=(<span class="keyword">char</span>) (i+<span class="string">'0'</span>);</span><br><span class="line">        <span class="comment">//进入递归方法</span></span><br><span class="line">        print1ToMaxOfNDigitsRecursely(num,n,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print1ToMaxOfNDigitsRecursely</span><span class="params">(<span class="keyword">char</span>[] num, <span class="keyword">int</span> n, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//递归终止条件 ：已经填充到了最后一位</span></span><br><span class="line">    <span class="keyword">if</span> (index==n)&#123;</span><br><span class="line">        printNum(num);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前位从0-9依次填充</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        num[index+<span class="number">1</span>]=(<span class="keyword">char</span>)(i+<span class="string">'0'</span>);</span><br><span class="line">        <span class="comment">//递归到下一位</span></span><br><span class="line">        print1ToMaxOfNDigitsRecursely(num,n,index+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印从num中第一个非0位到第0位</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNum</span><span class="params">(<span class="keyword">char</span>[] num)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=num.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span> (num[i]!=<span class="string">'0'</span>)&#123;</span><br><span class="line">            start=i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=start;j++)</span><br><span class="line">        System.out.print(num[j]);</span><br><span class="line"></span><br><span class="line">    System.out.print(<span class="string">"    "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="数组中出现次数超过一半的数"><a href="#数组中出现次数超过一半的数" class="headerlink" title="数组中出现次数超过一半的数"></a>数组中出现次数超过一半的数</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>题目：输入 n 个整数，找出其中最小的 k 个数。例如输入 4,5,1， 6,2,7,3,8 这<br>8 个数字，则最少的 4 个数字是 1,2,3,4.</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>如果某个数在数组中出现的次数超过数组长度的一半，则如果这是个有序数组，这个数肯定是中位数<br>可以利用快排中差分的思想<br>另外，也可以按照数组的特点，遍历数组，然后计数，遇见相同的就+1，遇见不同的就-1，若为0就替换，遍历完数组肯定是</p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组中超过一半的数</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">moreThanHalfNum</span><span class="params">(<span class="keyword">int</span> []data)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (checkInvalidArray(data))</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> middle=data.length/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> end=data.length-<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> index=Partition(data,data.length,start,end);</span><br><span class="line">      <span class="keyword">while</span> (index!=middle)&#123;</span><br><span class="line">          <span class="keyword">if</span> (index&gt;middle)&#123;</span><br><span class="line">              end=index-<span class="number">1</span>;</span><br><span class="line">              index=Partition(data,data.length,start,end);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              start=index+<span class="number">1</span>;</span><br><span class="line">              index=Partition(data,data.length,start,end);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> result=data[middle];</span><br><span class="line">      <span class="keyword">if</span> (checkMoreThanHalf(result,data))</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkMoreThanHalf</span><span class="params">(<span class="keyword">int</span> result, <span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (i&lt;data.length)&#123;</span><br><span class="line">          <span class="keyword">if</span> (data[i]==result)</span><br><span class="line">              count++;</span><br><span class="line">          i++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (count&gt;data.length/<span class="number">2</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkInvalidArray</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (data.length==<span class="number">0</span>||data==<span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> [ ]data,<span class="keyword">int</span> length,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (data==<span class="keyword">null</span>||length&lt;=<span class="number">0</span>||start&lt;<span class="number">0</span>||end&gt;=length)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      Random r=<span class="keyword">new</span> Random();</span><br><span class="line">      <span class="keyword">int</span> index= r.nextInt(end-start+<span class="number">1</span>)+start;</span><br><span class="line">      swap(data,index,end);</span><br><span class="line">      <span class="keyword">int</span> small=start-<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (index=start;index&lt;end;end++)&#123;</span><br><span class="line">          <span class="keyword">if</span> (data[index]&lt;data[end])&#123;</span><br><span class="line">              small++;</span><br><span class="line">              <span class="keyword">if</span> (small!=index)</span><br><span class="line">                  swap(data,index,small);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      small++;</span><br><span class="line">      swap(data,small,end);</span><br><span class="line">      <span class="keyword">return</span> small;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> [] data,<span class="keyword">int</span> index,<span class="keyword">int</span> index2)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> temp=data[index];</span><br><span class="line">       data[index]=data[index2];</span><br><span class="line">       data[index2]=temp;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组中出现次数超过一半的数字</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span>  <span class="title">MoreThanHalfNum</span><span class="params">(<span class="keyword">int</span> [] data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (checkInvalidArray(data))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result=data[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> times=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;data.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (data[i]==result)</span><br><span class="line">            times++;</span><br><span class="line">        <span class="keyword">else</span> times--;</span><br><span class="line">        <span class="keyword">if</span> (times==<span class="number">0</span>) &#123;</span><br><span class="line">            result = data[i];</span><br><span class="line">            times = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!checkMoreThanHalf(result,data))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数组中前K个小的数"><a href="#数组中前K个小的数" class="headerlink" title="数组中前K个小的数"></a>数组中前K个小的数</h1><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>除了排序以外，可以使用最大堆来存放K个数，遇见比堆顶小的数时，删去堆顶元素，新元素进堆</p><h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最小的k个数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">getLeastKNumber</span><span class="params">(<span class="keyword">int</span> [] data,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">      ArrayList&lt;Integer&gt; ans=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">int</span> len=data.length;</span><br><span class="line">      <span class="keyword">if</span> (k&gt;len||k&lt;<span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//使用优先队列创建最大堆（优先队列就是靠堆实现的）</span></span><br><span class="line">      PriorityQueue&lt;Integer&gt; maxHeap=<span class="keyword">new</span> PriorityQueue(k, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">          <span class="keyword">if</span> (maxHeap.size()!=k)&#123;</span><br><span class="line">              maxHeap.add(data[i]);</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span> (maxHeap.peek()&gt;data[i])&#123;</span><br><span class="line">              maxHeap.poll();</span><br><span class="line">              maxHeap.offer(data[i]);</span><br><span class="line">              </span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (Integer i:maxHeap)&#123;</span><br><span class="line">          ans.add(i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="数据流的中位数"><a href="#数据流的中位数" class="headerlink" title="数据流的中位数"></a>数据流的中位数</h1><h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><p>得到一个数据流的中位数，若这个数据流的个数为奇数个，则是中间那个数，若是偶数个数，则是中间两个数的平均数</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>如果把数组分为两个部分，前半部分的最大值和后半部分的最小值要是知道了，就可以确定中位数了，而不用排序的方式，就想到了最大堆和最小堆</p><h2 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据流的中位数</span></span><br><span class="line"> <span class="comment">//使用最大堆和最小堆实现</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMiduemNum</span><span class="params">(<span class="keyword">int</span> [] nums)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">     <span class="comment">//最大堆</span></span><br><span class="line">     PriorityQueue&lt;Integer&gt; maxHeap=<span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="comment">//最小堆</span></span><br><span class="line">     PriorityQueue&lt;Integer&gt; minHeap=<span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="comment">//当i为偶数时，把数字加入到最大堆（从0开始）</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> n:nums)&#123;</span><br><span class="line">         <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">             maxHeap.add(n);</span><br><span class="line">         &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//加入最小堆时，若当前数比最大堆的最大数要小（要是这个时候把这个数加入最小堆就不满足要求了），则把这个数加入最大堆，然后把最大堆的最大数加入最小堆</span></span><br><span class="line">             <span class="keyword">if</span> (n&lt;maxHeap.peek()) &#123;</span><br><span class="line">                 maxHeap.add(n);</span><br><span class="line">                 minHeap.add(maxHeap.poll());</span><br><span class="line">             &#125;<span class="keyword">else</span> minHeap.add(n);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (nums.length%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> (maxHeap.peek()+minHeap.peek())/<span class="number">2</span>;</span><br><span class="line">     &#125;<span class="keyword">else</span> <span class="keyword">return</span> maxHeap.peek();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;数值的整数次方&quot;&gt;&lt;a href=&quot;#数值的整数次方&quot; class=&quot;headerlink&quot; title=&quot;数值的整数次方&quot;&gt;&lt;/a&gt;数值的整数次方&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题
      
    
    </summary>
    
      <category term="刷算法题" scheme="https://www.junglezero.top/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="数据结构" scheme="https://www.junglezero.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>编程常识（各种杂七杂八的东西）</title>
    <link href="https://www.junglezero.top/2019/06/20/%E5%B8%B8%E8%AF%86%EF%BC%88%E5%90%84%E7%A7%8D%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E4%B8%9C%E8%A5%BF%EF%BC%89/"/>
    <id>https://www.junglezero.top/2019/06/20/常识（各种杂七杂八的东西）/</id>
    <published>2019-06-20T12:33:33.000Z</published>
    <updated>2019-06-20T12:36:08.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="各种编码"><a href="#各种编码" class="headerlink" title="各种编码"></a>各种编码</h1><p> 很多人都把Unicode编码挂在嘴边，其实咱们现实生活中遇到的编码基本都是Unicode的</p><p>因为Unicode兼容了大多数老版本的编码规范例如 ASCII</p><p>Unicode编码定义了这个世界上几乎所有字符（就是你眼睛看到的长那个样子的符号）的数字表示</p><p>也就是说Unicode为每个字符发了一张身份证，这张身份证上有一串唯一的数字ID确定了这个字符</p><p>在这个纷乱世界上存在的唯一性。Unicode给这串数字ID起了个名字叫［码点］（Code Point）</p><p>而很多人说的编码其实是想表达［Unicode转换格式］（即UTF，Unicode Transformation Formats）</p><p>有没有觉得眼前一亮豁然开朗？没错 这就是我们看到的UTF-8/UTF-16/UTF-32的前缀来源</p><p>这个［Unicode转换格式］的存在是为了解决［码点］在计算机中的二进制表现形式而设计的</p><p>毕竟我们的机内表示涉及存储位宽，兼容古老编码格式，码点是数值过大的罕见字符等问题</p><p>［码点］经过映射后得到的二进制串的转换格式单位称之为［码元］（Code Unit）。也就是说如果有一种UTF的码点二进制表示有n字节，其码元为8位（1个byte），那么其拥有码元n个。每种UTF的码元都不同，其宽度被作为区分写在了UTF的后缀——这就是UTF-8/UTF-16/UTF-32的由来。UTF-8的码元是8位的，UTF-16的码元是16位的。大部分的编程语言采用16位的码元作为机内表示。这就是我们在各种语言中调用获取一个字符串中character的数量时会出现这么多混乱的原因。事实上我们调用这些方法时取得的不是字符个数，而是码元个数！一旦我们的字符串中包含了位于基本平面之外的码点，那么就会需要更多的码元来表示，这个时候就会出现测试时常见的困惑——为何return的字符数比实际字符数要多？所以实际写代码时要特别注意这个问题。</p><p>采取不同的映射方式可以得到不同格式的二进制串，但是他们背后所表示的［码点］永远是一致的就好像你换身份证但是身份证号不变一样。由于平时人们误把［转换格式］也称为［编码］，所以造成今天Unicode／UTF傻傻分不清楚且遣词造句运用混乱的悲桑局面。</p><p>Unicode 编码 发展到今天 扩展到了 21 位（从 U+0000 到 U+10FFFF ）。这一点很重要： Unicode 不是 16 位的编码， 它是 21 位的。这 21 位提供了 1,114,112 个码点，其中，只有大概 10% 正在使用，所以还有相当大的扩充空间。</p><p>编码空间被分成 17 个平面（plane），每个平面有 65,536 个字符（正好填充2个字节，16位）。0 号平面叫做「基本多文种平面」（ BMP, Basic Multilingual Plane ），涵盖了几乎所有你能遇到的字符，除了 emoji（emoji位于1号平面 - -）。其它平面叫做补充平面，大多是空的。</p><p>总结一下各种编码格式的特质：</p><p>UTF-32</p><p>最清楚明了的一个 UTF 就是 UTF-32 ：它在每个码点上使用整 32 位。32 大于 21，因此每一个 UTF-32 值都可以直接表示对应的码点。尽管简单，UTF-32却几乎从来不在实际中使用，因为每个字符占用 4 字节太浪费空间了。</p><p>UTF-16 以及「代理对」（ Surrogate Pairs ）的概念</p><p>UTF-16要常见得多，它是根据有 16 位固定长度的码元（ code units ）定义的。UTF-16 本身是一种长度可变的编码。基本多文种平面（BMP）中的每一个码点都直接与一个码元相映射。鉴于 BMP 几乎囊括了所有常见字符，UTF-16 一般只需要 UTF-32 一半的空间。其它平面里很少使用的码点都是用两个 16 位的码元来编码的，这两个合起来表示一个码点的码元就叫做代理对（ surrogate pair ）。</p><p>UTF-8</p><p>UTF-8 使用一到四个字节来编码一个码点。从 0 到 127 的这些码点直接映射成 1 个字节（对于只包含这个范围字符的文本来说，这一点使得 UTF-8 和 ASCII 完全相同）。接下来的 1,920 个码点映射成 2 个字节，在 BMP 里所有剩下的码点需要 3 个字节。Unicode 的其他平面里的码点则需要 4 个字节。UTF-8 是基于 8 位的码元的，因此它并不需要关心字节顺序（不过仍有一些程序会在 UTF-8 文件里加上多余的 BOM）。</p><p>有效率的空间使用（仅就西方语言来讲），以及不需要操心字节顺序问题使得 UTF-8 成为存储和交流 Unicode 文本方面的最佳编码。它也已经是文件格式、网络协议以及 Web API 领域里事实上的标准了。</p><p>我们的JVM中保存码点是UTF16的转换格式，从char的位宽为16位也可以看得出来。由于绝大部分编码的码点位于基本平面，所以使用16位可以几乎表示所有常用字符。这就是许多语言编译器或运行时都使用UTF16的原因。英文在使用UTF16时也是2字节表示的。当我们想要使用其他平面的字符时，码元超过2个字节，就需要使用代理对在语言中的特定表示方式，譬如‘\U112233’之类的。</p><p>使用UTF8时，常用的Alphabet和Numeric都在前127字节，被有效率地用一个字节表示。而我们的中文由于排在1920个码点之后，所以使用3个字节表示，这方面就比UTF16转换格式耗费更多空间。</p><p>最后，不论使用哪种UTF转换格式，都是程序员自己可以选择的一种表达方式而已。我们可以通过Java方便的API进行自如转换。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;各种编码&quot;&gt;&lt;a href=&quot;#各种编码&quot; class=&quot;headerlink&quot; title=&quot;各种编码&quot;&gt;&lt;/a&gt;各种编码&lt;/h1&gt;&lt;p&gt; 很多人都把Unicode编码挂在嘴边，其实咱们现实生活中遇到的编码基本都是Unicode的&lt;/p&gt;
&lt;p&gt;因为Unicod
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>栈和队列专题</title>
    <link href="https://www.junglezero.top/2019/06/18/%E9%98%9F%E5%88%97%E4%B8%93%E9%A2%98/"/>
    <id>https://www.junglezero.top/2019/06/18/队列专题/</id>
    <published>2019-06-18T07:33:00.000Z</published>
    <updated>2019-07-02T03:00:16.946Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h1><p>栈和队列一个先进后出，一个先进先出，因此应当想办法“逆转”一下，这就是第二个栈的作用<br><img src="/upload/pasted-318.png" alt="upload successful"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">TwoStackToQueue</span></span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; s1=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; s2=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Qoffer</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        s1.push(num);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">pull</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!s2.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> s2.pop();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s1.isEmpty())&#123;</span><br><span class="line">                s2.push(s1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!s2.isEmpty())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"queue is empty"</span>);</span><br><span class="line">            <span class="keyword">return</span> s2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="用两个队列模拟栈"><a href="#用两个队列模拟栈" class="headerlink" title="用两个队列模拟栈"></a>用两个队列模拟栈</h1><p>对于入栈操作，直接加入队列即可。而对于出栈操作，应当知道对于模拟的情况，是删除队尾元素，而队列又是先入先出的，因此，应当先将队列前的元素移到另外一个栈，然后再“弹栈”</p><p><img src="/upload/pasted-319.png" alt="upload successful"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> Integer <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!q1.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (q1.size() != <span class="number">1</span>) &#123;</span><br><span class="line">                q2.offer(q1.poll());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (Integer) q1.poll();</span><br><span class="line">        &#125;<span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">if</span> (!q2.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">while</span> (q2.size()!=<span class="number">1</span>)&#123;</span><br><span class="line">                    q1.offer(q2.poll());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> (Integer) q2.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"栈为空"</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>定义一个栈，其中有一个获取最小值的方法，在这个栈中，调用push,pop,min的时间复杂度都是O(1)</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这个题的难点就在于如何对于任何入栈出栈，如何实时的维持最小值，应当知道最小值相关的操作都是和入栈出栈操作是同步的，这个时候想到应当维持一个和主栈同步的辅助栈用来维持每个位置的最小值</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  Stack&lt;Integer&gt; mainStack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; helperStack;</span><br><span class="line">    MinStack()&#123;</span><br><span class="line">        mainStack=<span class="keyword">new</span> Stack();</span><br><span class="line">        helperStack=<span class="keyword">new</span> Stack();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        helperStack.pop();</span><br><span class="line">        <span class="keyword">return</span> mainStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Integer i)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i&lt;helperStack.peek())&#123;</span><br><span class="line">            helperStack.push(i);</span><br><span class="line">        &#125;<span class="keyword">else</span> </span><br><span class="line">            helperStack.push(helperStack.peek());</span><br><span class="line">        mainStack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helperStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h1><h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><p>给定两个序列，一个是入栈的序列，一个是出栈的序列，判断出栈序列是否满足前面的入栈序列</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>按照实际的手动操作进行分析：对于入栈序列，如果和出栈序列的第一数相同，说明这个数一进栈就出栈了，所以可以省略进栈这个过程；如果这个数和出栈数不相同，因此这个数入栈，进行下一个数的对比……当入栈序列已经判断完毕，这个时候就要判断栈中的数，这就比较简单了</p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈的压入弹出序列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPopOrder</span><span class="params">(<span class="keyword">int</span>[]pushOrder,<span class="keyword">int</span>[] popOrder)</span></span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j&lt;pushOrder.length)&#123;</span><br><span class="line">        <span class="keyword">if</span> (pushOrder[j]!=popOrder[i]||stack.peek()!=popOrder[i])&#123;</span><br><span class="line">            stack.push(pushOrder[j]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (pushOrder[j]==popOrder[i])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (stack.peek()==popOrder[i])&#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.peek()!=popOrder[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;用两个栈实现队列&quot;&gt;&lt;a href=&quot;#用两个栈实现队列&quot; class=&quot;headerlink&quot; title=&quot;用两个栈实现队列&quot;&gt;&lt;/a&gt;用两个栈实现队列&lt;/h1&gt;&lt;p&gt;栈和队列一个先进后出，一个先进先出，因此应当想办法“逆转”一下，这就是第二个栈的作用&lt;br&gt;
      
    
    </summary>
    
      <category term="刷算法题" scheme="https://www.junglezero.top/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="数据结构" scheme="https://www.junglezero.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="栈和队列" scheme="https://www.junglezero.top/tags/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>《算法分析》课程整理</title>
    <link href="https://www.junglezero.top/2019/06/06/%E6%B3%95%E5%88%86%E6%9E%90%E3%80%8B%E8%AF%BE%E7%A8%8B%E6%95%B4%E7%90%86-1/"/>
    <id>https://www.junglezero.top/2019/06/06/法分析》课程整理-1/</id>
    <published>2019-06-06T01:53:00.000Z</published>
    <updated>2019-07-14T14:47:34.181Z</updated>
    
    <content type="html"><![CDATA[<h1 id="递归和分治"><a href="#递归和分治" class="headerlink" title="递归和分治"></a>递归和分治</h1><h2 id="整数划分问题"><a href="#整数划分问题" class="headerlink" title="整数划分问题"></a>整数划分问题</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>任何一个大于1的自然数，总可以拆分为若干个小于n的自然数之和，试求n的所有拆分，将最大拆分数不超过m的划分个数记做去q(n,m)</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>根据n和m的情况，可以分为以下几种情况：<br>根据n和m的关系，考虑以下几种情况： </p><ol><li>当n=1时，不论m的值为多少（m&gt;0)，只有一种划分即{1}; </li><li>当m=1时，不论n的值为多少，只有一种划分即n个1，{1,1,1,…,1}; </li><li>当n=m时，根据划分中是否包含n，可以分为两种情况：<br> (1) 划分中包含n的情况，只有一个即{n}；<br> (2) 划分中不包含n的情况，这时划分中最大的数字也一定比n小，即n的所有(n-1)划分。因此 f(n,n) =1 + f(n,n-1); </li><li>当n&lt;m时，由于划分中不可能出现负数，因此就相当于f(n,n); </li><li>但n&gt;m时，根据划分中是否包含最大值m，可以分为两种情况：<br> (1) 划分中包含m的情况，即{m, {x1,x2,…xi}}, 其中{x1,x2,… xi} 的和为n-m，可能再次出现m，因此是（n-m）的m划分，因此这种划分个数为f(n-m, m);<br> (2) 划分中不包含m的情况，则划分中所有值都比m小，即n的(m-1)划分，个数为f(n,m-1);因此 f(n, m) = f(n-m, m)+f(n,m-1);</li></ol><p>通过以上规律，得到递推公式：</p><ul><li>f(n, m)= 1; (n=1 or m=1)</li><li>f(n, m)=f(n, n); (n&lt;m)</li><li>1+ f(n, m-1); (n=m)</li><li>f(n-m,m)+f(n,m-1); (n&gt;m)</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/函数：q(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span><br><span class="line"><span class="comment">//作用：用来得到正整数n，最大加数不大于m的划分个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">q</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="comment">//若正整数或最大加数小于1，则返回0</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">1</span>||m&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//若正整数或最大加数等于1，则划分个数为1（n个1相加）</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>||m==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//若最大加数实际上不能大于正整数n，若大于则划分个数等于最大加数为n的划分个数</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;m) <span class="keyword">return</span> q(n,n);</span><br><span class="line">    <span class="comment">//若正整数等于最大加数，则划分个数等于</span></span><br><span class="line">    <span class="keyword">if</span> (n==m) <span class="keyword">return</span> <span class="number">1</span>+q(n,n-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> q(n,m-<span class="number">1</span>)+q(n-m,m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Strassen矩阵乘法"><a href="#Strassen矩阵乘法" class="headerlink" title="Strassen矩阵乘法"></a>Strassen矩阵乘法</h2><h3 id="一般的矩阵乘法思路"><a href="#一般的矩阵乘法思路" class="headerlink" title="一般的矩阵乘法思路"></a>一般的矩阵乘法思路</h3><p><img src="/upload/pasted-297.png" alt="upload successful"><br>复杂度为O(n3)</p><h3 id="一种改进方法"><a href="#一种改进方法" class="headerlink" title="一种改进方法"></a>一种改进方法</h3><p><img src="/upload/pasted-298.png" alt="upload successful"></p><h3 id="Strassen方法"><a href="#Strassen方法" class="headerlink" title="Strassen方法"></a>Strassen方法</h3><p><img src="/upload/pasted-299.png" alt="upload successful"></p><p><img src="/upload/pasted-300.png" alt="upload successful"><br>这个方法的特点就是减少了一次乘法，虽然多了14次加法，但是加法计算基本没有成本<br>时间复杂度：</p><p><img src="/upload/pasted-301.png" alt="upload successful"></p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h2><ul><li>动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题。</li><li>但是经分解得到的子问题往往不是互相独立的。不同子问题的数目常常只有多项式量级。在用分治法求解时，有些子问题被重复计算了许多次。</li><li>如果能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，就可以避免大量重复计算，从而得到多项式时间算法。</li></ul><h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><ul><li>找出最优解的性质，并刻划其结构特征。</li><li>递归地定义最优值。</li><li>以自底向上的方式计算出最优值。</li><li>根据计算最优值时得到的信息，构造最优解</li></ul><h2 id="矩阵连乘问题"><a href="#矩阵连乘问题" class="headerlink" title="矩阵连乘问题"></a>矩阵连乘问题</h2><h3 id="基本内容-1"><a href="#基本内容-1" class="headerlink" title="基本内容"></a>基本内容</h3><p>对于一般的矩阵乘法来说，如矩阵A(m,n)与矩阵B(n,p)相乘需要进行的加法次数为m<em>n</em>p次乘法。</p><p>由于矩阵乘法满足结合律，因此矩阵相乘的结合性，会影响整个计算表达式的乘法执行次数。</p><p>如下面的例子，其中A(10,5)、B(5,20)、C(20,3)：</p><p>　　　　(1) ((AB)C) 执行乘法次数为1300次</p><p>　　　　(2) (A(BC)) 执行乘法次数为450次</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>预处理：<br>将矩阵连乘积AiAi+1…Aj简记为A[i:j]，这里i≤j。<br>考察计算A[i:j]的最优计算次序。设这个计算次序在矩阵Ak和Ak+1之间将矩阵链断开，i≤k&lt;j，则其相应完全加括号方式为（AiAi+1… Ak）（Ak+1 Ak+2… Aj ）。<br>计算量：A[i:k]的计算量加上A[k+1:j]的计算量，再加上A[i:k]和A[k+1:j]相乘的计算量。<br>分析最优解的结构<br>特征：计算A[i:j]的最优次序所包含的计算矩阵子链 A[i:k]和A[k+1:j]的次序也是最优的。<br>矩阵连乘计算次序问题的最优解包含着其子问题的最优解。这种性质称为最优子结构性质。问题的最优子结构性质是该问题可用动态规划算法求解的显著特征。<br>设计算A[i:j]，1≤i≤j≤n，所需要的最少数乘次数m[i,j]，则原问题的最优值为m[1,n]。<br>当i=j时，A[i:j]=Ai，因此，m[i,i]=0，i=1,2,…,n。<br>当i&lt;j时，m[i,j]=m[i,k]+m[k+1,j]+pi-1pkpj，这里Ai的维数为pi-1×pi。<br>可以递归地定义m[i,j]为：<br> <img src="/upload/pasted-306.png" alt="upload successful"><br>k的位置只有j-i种可能。</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MatrixChain</span><span class="params">(<span class="keyword">int</span> [] p，<span class="keyword">int</span> n，<span class="keyword">int</span> [] []m，<span class="keyword">int</span> [][]s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//当m[i][j]中i==j时，m[i][j]==0</span></span><br><span class="line">　<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) m[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//从m[1][2],m[2][3],m[3][4]开始计算</span></span><br><span class="line">　<span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">2</span>; r &lt;= n; r++)</span><br><span class="line">　　<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - r+<span class="number">1</span>; i++) &#123;</span><br><span class="line">　　　<span class="keyword">int</span> j=i+r-<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//先将m[i][j]初始化，即当k=i的时候</span></span><br><span class="line">　　　m[i][j] = m[i+<span class="number">1</span>][j]+ p[i-<span class="number">1</span>]*p[i]*p[j];</span><br><span class="line">            <span class="comment">//初始化s[i][j]</span></span><br><span class="line">　　　s[i][j] = i;</span><br><span class="line">            <span class="comment">//依次遍历k的每一个取值，按照递推公式，取最小值作为m[i][j],此时的k作为s[i][j]的值</span></span><br><span class="line">　　　<span class="keyword">for</span> (<span class="keyword">int</span> k = i+<span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">　　　　<span class="keyword">int</span> t = m[i][k] + m[k+<span class="number">1</span>][j] + p[i-<span class="number">1</span>]*p[k]*p[j];</span><br><span class="line">    <span class="comment">//遍历过程中，若发现 当前k的选择拥有最小的m，则记录m和k的值，此时的k即为拆分的位置</span></span><br><span class="line">　　　　<span class="keyword">if</span> (t &lt; m[i][j]) &#123; m[i][j] = t; s[i][j] = k;&#125;</span><br><span class="line">　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><h3 id="基本内容-2"><a href="#基本内容-2" class="headerlink" title="基本内容"></a>基本内容</h3><p>给定两个字符串，求解这两个字符串的最长公共子序列（Longest Common Sequence）。比如字符串1：BDCABA；字符串2：ABCBDAB</p><p>则这两个字符串的最长公共子序列长度为4，最长公共子序列是：BCBA</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>①最优子结构</p><p>设 X=(x1,x2,…..xn) 和 Y={y1,y2,…..ym} 是两个序列，将 X 和 Y 的最长公共子序列记为LCS(X,Y)</p><p>找出LCS(X,Y)就是一个最优化问题。因为，我们需要找到X 和 Y中最长的那个公共子序列。而要找X 和 Y的LCS，首先考虑X的最后一个元素和Y的最后一个元素。</p><p>1）如果 xn=ym，即X的最后一个元素与Y的最后一个元素相同，这说明该元素一定位于公共子序列中。因此，现在只需要找：LCS(Xn-1，Ym-1)<br>LCS(Xn-1，Ym-1)就是原问题的一个子问题。</p><p>2）如果xn != ym，产生了两个子问题：LCS(Xn-1，Ym) 和 LCS(Xn，Ym-1)</p><p>因为序列X 和 序列Y 的最后一个元素不相等嘛，那说明最后一个元素不可能是最长公共子序列中的元素嘛。</p><p>LCS(Xn-1，Ym)表示：最长公共序列可以在(x1,x2,….x(n-1)) 和 (y1,y2,…yn)中找。<br>LCS(Xn，Ym-1)表示：最长公共序列可以在(x1,x2,….xn) 和 (y1,y2,…y(n-1))中找。<br>求解上面两个子问题，得到的公共子序列谁最长，那谁就是 LCS（X,Y）。用数学表示就是：<br>LCS=max{LCS(Xn-1，Ym)，LCS(Xn，Ym-1)}</p><p>由于条件 1)  和  2)  考虑到了所有可能的情况。因此，我们成功地把原问题 转化 成了 三个规模更小的子问题。</p><p>②重叠子问题<br>重叠子问题是啥？就是说原问题 转化 成子问题后，  子问题中有相同的问题。咦？我怎么没有发现上面的三个子问题中有相同的啊？？？？</p><p>OK，来看看，原问题是：LCS(X,Y)。子问题有 ❶LCS(Xn-1，Ym-1)    ❷LCS(Xn-1，Ym)    ❸LCS(Xn，Ym-1)</p><p>初一看，这三个子问题是不重叠的。可本质上它们是重叠的，因为它们只重叠了一大部分。举例：</p><p>第二个子问题：LCS(Xn-1，Ym) 就包含了：问题❶LCS(Xn-1，Ym-1)，为什么？</p><p>因为，当Xn-1 和 Ym 的最后一个元素不相同时，我们又需要将LCS(Xn-1，Ym)进行分解：分解成：LCS(Xn-1，Ym-1) 和 LCS(Xn-2，Ym)</p><p>也就是说：在子问题的继续分解中，有些问题是重叠的。<br>递推公式：</p><p><img src="/upload/pasted-296.png" alt="upload successful"></p><p>c[i,j]表示：(x1,x2….xi) 和 (y1,y2…yj) 的最长公共子序列的长度</p><p>③得到最长公共子序列的具体内容</p><p><img src="/upload/pasted-303.png" alt="upload successful"><br>由问题的分析可知，我们找最长公共子序列，是比较两个字符串的最后一位，若最后一位相等，则这个字符肯定是最长公共子序列的内容，因此此时，按照递推公式的描述，“斜向上”移动，当两个字符不相等时，此时根据前面的分析，可以是第一个字符串前移，也可以是第二个字符串前移，两种方式都可以，规定一种就好</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findLCS</span><span class="params">(String A, <span class="keyword">int</span> n, String B, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            dp[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A.charAt(i - <span class="number">1</span>) == B.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] &gt; dp[i][j - <span class="number">1</span>] ? dp[i - <span class="number">1</span>][j] : dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h2><h3 id="基本内容-3"><a href="#基本内容-3" class="headerlink" title="基本内容"></a>基本内容</h3><p>求一个序列的最大子段和即最大连续子序列之和。例如序列[4, -3, 5, -2, -1, 2, 6, -2]的最大子段和为11=[4+(-3)+5+(-2)+(-1)+(2)+(6)]。</p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>设前边界为1，后边界为i，且C(i)是子序列A[1,..i]必须包含元素A[i]的向前连续延伸的最大子段和：</p><p>遍历所有以i (1≤i≤n)为后边界的最大子段和Ci得出最优解：<br>f(i)=array<a href="i=0,f(i-1">i</a>&lt;0)<br>f(i)=f(i-1)+array[i]</p><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSumDyn</span><span class="params">( <span class="keyword">int</span> array[],<span class="keyword">int</span> len )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( b &gt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            b += array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            b = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( b &gt; sum )</span><br><span class="line">        &#123;</span><br><span class="line">            sum = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多边形游戏"><a href="#多边形游戏" class="headerlink" title="多边形游戏"></a>多边形游戏</h2><h3 id="基本内容-4"><a href="#基本内容-4" class="headerlink" title="基本内容"></a>基本内容</h3><h2 id="图像压缩"><a href="#图像压缩" class="headerlink" title="图像压缩"></a>图像压缩</h2><p>在计算机中，常用像素点的灰度值序列{p1,p1,……pn}表示图像。其中整数pi,1&lt;=i&lt;=n，表示像素点i的灰度值。通常灰度值的范围是0~255。因此最多需要8位表示一个像素。</p><p>压缩的原理就是把序列{p1,p1,……pn}进行设断点，将其分割成一段一段的。分段的过程就是要找出断点，让一段里面的像素的最大灰度值比较小，那么这一段像素(本来需要8位)就可以用较少的位(比如7位)来表示，从而减少存储空间。</p><p>b代表bits,l代表length,分段是，b[i]表示每段一个像素点需要的最少存储空间(少于8位才有意义)，l[i]表示每段里面有多少个像素点，s[i]表示从0到i压缩为一共占多少存储空间。</p><p> 如果限制l[i]&lt;=255,则需要8位来表示l[i]。而b[i]&lt;=8，需要3位表示b[i]。所以每段所需的存储空间为l[i]*b[i]+11位。假设将原图像分成m段，那么需要</p><p><img src="/upload/pasted-304.png" alt="upload successful"><br>图像压缩问题的本质就是要确定像素序列{p1,p1,……pn}的最优分段，使得依此分段所需的存储空间最小</p><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>最优子结构<br>设l[i],b[i],1&lt;=i&lt;=m是{p1,p1,……pn}的一个最优分段，则l[1],b[1]是{p1,……,pl[1]}的一个最优分段，且l[i],b[i],2&lt;=i&lt;=m是{pl[1]+1,……,pn}的一个最优分段。即图像压缩问题满足最优子结构性质。<br>动态规划方程<br> 设s[i],1&lt;=i&lt;=n是像素序列{p1,p1,……pi}的最优分段所需的存储位数，则s[i]为前i-k个的存储位数加上后k个的存储空间。由最优子结构性质可得：</p><p><img src="/upload/pasted-307.png" alt="upload successful"></p><p><img src="/upload/pasted-308.png" alt="upload successful"></p><h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Compress</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> p[],<span class="keyword">int</span> s[],<span class="keyword">int</span> l[],<span class="keyword">int</span> b[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> Lmax = <span class="number">256</span>,header = <span class="number">11</span>;  </span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        b[i] = length(p[i]);<span class="comment">//计算像素点p需要的存储位数  </span></span><br><span class="line">        <span class="keyword">int</span> bmax = b[i];  </span><br><span class="line">        s[i] = s[i<span class="number">-1</span>] + bmax;  </span><br><span class="line">        l[i] = <span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>; j&lt;=i &amp;&amp; j&lt;=Lmax;j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span>(bmax&lt;b[i-j+<span class="number">1</span>])  </span><br><span class="line">            &#123;  </span><br><span class="line">                bmax = b[i-j+<span class="number">1</span>];  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span>(s[i]&gt;s[i-j]+j*bmax)  </span><br><span class="line">            &#123;  </span><br><span class="line">                s[i] = s[i-j] + j*bmax;  </span><br><span class="line">                l[i] = j;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        s[i] += header;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">(<span class="keyword">int</span> i)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">1</span>;  </span><br><span class="line">    i = i/<span class="number">2</span>;  </span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        k++;  </span><br><span class="line">        i=i/<span class="number">2</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> k;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Traceback</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span>&amp; i,<span class="keyword">int</span> s[],<span class="keyword">int</span> l[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    Traceback(n-l[n],i,s,l);  </span><br><span class="line">    s[i++]=n-l[n];<span class="comment">//重新为s[]数组赋值，用来存储分段位置  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="电路布线问题"><a href="#电路布线问题" class="headerlink" title="电路布线问题"></a>电路布线问题</h2><h3 id="基本内容-5"><a href="#基本内容-5" class="headerlink" title="基本内容"></a>基本内容</h3><p>在一块电路板的上、下两端分别有n个接线柱。根据电路设计，要求用导线(i,π(i)) 将上端接线柱i与下端接线柱π(i)相连，如下图。其中，π(i),1≤ i ≤n,是｛1,2,…,n｝的一个排列。导线(I, π(i))称为该电路板上的第i条连线。对于任何1 ≤ i ≤ j ≤n,第i条连线和第j条连线相交的充要条件是π(i)&gt; π(j).</p><p><img src="/upload/pasted-309.png" alt="upload successful"><br>在制作电路板时，要求将这n条连线分布到若干绝缘层上。在同一层上的连线不相交。电路布线问题要确定将哪些连线安排在第一层上，使得该层上有尽可能多的连线。换句话说，该问题要求确定导线集Nets = ｛i，π(i)，1 ≤ i ≤ n｝的最大不相交子集。 </p><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>记N(i,j) = {t|(t, π(t)) ∈ Nets,t ≤ i, π(t) ≤ j }. N(i,j)的最大不相交子集为MNS（i,j）Size(i,j)=|MNS(i,j)|。<br>(1)当i = 1时</p><p><img src="/upload/pasted-310.png" alt="upload successful"><br>(2)当i &gt;1时</p><p>① j &lt;π(i)。此时，(i,π(i)) 不属于N(i,j)。故在这种情况下，N(i,j) = N(i-1,j)，从而Size(i,j)=Size(i-1,j)。</p><p>② j ≥π(i)。此时，若(i, π(i))∈MNS(i,j)，则对任意(t, π(t))∈MNS(i,j)有t &lt; i且π(t)&lt; π(i)；否则，(t, π(t))与(i, π(i))相交。在这种情况下MNS(i,j)-{(i, π(i))}是N(i-1, π(i)-1)的最大不相交子集。否则，子集MNS(i-1, π(i)-1)∪{(i, π(i))}包含于N(i,j)是比MNS(i,j)更大的N(i,j)的不相交子集。这与MNS(i,j)的定义相矛盾。</p><p>若(i, π(i))不属于MNS(i,j)，则对任意(t, π(t))∈MNS(i,j)，有t&lt;i。从而MNS(i,j)包含于N(i-1,j)，因此，Size(i,j)≤Size(i-1,j)。<br>另一方面，MNS(i-1,j)包含于N(i,j),故又有Size(i,j) ≥Size(i-1,j)，从而Size（i,j）= Size(i-1,j)。</p><p><img src="/upload/pasted-311.png" alt="upload successful"><br>电路布线问题的最优值为Size(n,n)。由该问题的最优子结构性质可知，子问题最优值的递归关系如下：</p><p><img src="/upload/pasted-312.png" alt="upload successful"></p><p>根据递归方程得到如下二维表</p><p><img src="/upload/pasted-313.png" alt="upload successful"></p><h2 id="0-1背包问题（动态规划）"><a href="#0-1背包问题（动态规划）" class="headerlink" title="0-1背包问题（动态规划）"></a>0-1背包问题（动态规划）</h2><h3 id="基本内容-6"><a href="#基本内容-6" class="headerlink" title="基本内容"></a>基本内容</h3><p>给定种物品和一个容量为的背包，物品的重量是，其价值为，背包问题是如何使选择装入背包内的物品，使得装入背包中的物品的总价值最大。其中，每种物品只有全部装入背包或不装入背包两种选择。</p><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>在解决问题之前，为描述方便，首先定义一些变量：Vi表示第 i 个物品的价值，Wi表示第 i 个物品的体积，定义V(i,j)：当前背包容量 j，前 i 个物品最佳组合对应的价值，同时背包问题抽象化（X1，X2，…，Xn，其中 Xi 取0或1，表示第 i 个物品选或不选）。<br>1、建立模型，即求max(V1X1+V2X2+…+VnXn)；<br>2、寻找约束条件，W1X1+W2X2+…+WnXn&lt;capacity；<br>3、寻找递推关系式，面对当前商品有两种可能性：</p><ul><li>包的容量比该商品体积小，装不下，此时的价值与前i-1个的价值是一样的，即V(i,j)=V(i-1,j)；</li><li>还有足够的容量可以装该商品，但装了也不一定达到当前最优价值，所以在装与不装之间选择最优的一个，即V(i,j)=max｛V(i-1,j)，V(i-1,j-w(i))+v(i)｝。<br>其中V(i-1,j)表示不装，V(i-1,j-w(i))+v(i) 表示装了第i个商品，背包容量减少w(i)，但价值增加了v(i)；<br>由此可以得出递推关系式：</li><li>j&lt;w(i)      V(i,j)=V(i-1,j)</li><li>j&gt;=w(i)     V(i,j)=max｛V(i-1,j)，V(i-1,j-w(i))+v(i)｝</li></ul><p>然后就是填表，根据递推公式，填完如下<br>w(2,3,4,5) v(3,4,5,6) cap=8</p><p>根据动态规划函数，v[4,8]就是最大价值<br><img src="/upload/pasted-314.png" alt="upload successful"><br><img src="/upload/pasted-315.png" alt="upload successful"><br><img src="/upload/pasted-316.png" alt="upload successful"></p><h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><h2 id="剪绳子（动态规划）"><a href="#剪绳子（动态规划）" class="headerlink" title="剪绳子（动态规划）"></a>剪绳子（动态规划）</h2><h3 id="基本内容-7"><a href="#基本内容-7" class="headerlink" title="基本内容"></a>基本内容</h3><p>给你一根长度为n绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m≥1）。每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0]<em>k[1]</em>…*k[m]可能的最大乘积是多少？例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18。</p><h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><p>如果不能发现最优子结构，可以自小向大推：绳子长度为1时，最大乘积只能是0，绳子长度为2时，切成1和1，结果也是1，绳子长度为3时，切成1和2，结果是2，绳子长度为4时，可以分为1<em>1</em>1<em>1，1</em>2<em>1，1</em>3，2<em>2，最大乘积为4，因此可以发现最优子结构f(n)=max(f(i)</em>f(n-i))</p><h3 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h3><p>在实现时，可以从下到上实现，利用数组存储中间结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cutRoats</span><span class="params">(<span class="keyword">int</span>  length)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"长度不合法"</span>);</span><br><span class="line">    <span class="keyword">if</span> (length&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (length==<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (length==<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>  []  product=<span class="keyword">new</span> <span class="keyword">int</span>[length+<span class="number">1</span>];</span><br><span class="line">    product[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    product[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    product[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">    product[<span class="number">3</span>]=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">4</span>;i&lt;=length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i/<span class="number">2</span>;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (max &lt; product[j] * product[i - j])</span><br><span class="line">                max = product[j] * product[i - j];</span><br><span class="line">        &#125;</span><br><span class="line">        product[i]=max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> product[length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="剪绳子（贪心算法）"><a href="#剪绳子（贪心算法）" class="headerlink" title="剪绳子（贪心算法）"></a>剪绳子（贪心算法）</h2><h3 id="基本内容-8"><a href="#基本内容-8" class="headerlink" title="基本内容"></a>基本内容</h3><p>给你一根长度为n绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m≥1）。每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0]<em>k[1]</em>…*k[m]可能的最大乘积是多少？例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18</p><h3 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h3><p>多数情况下，贪心算法是得不到最优解的，但是本题依赖于一个数学证明：当绳子长度大于5时，尽可能的剪出长度为3的绳子是最优解</p><h3 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProductAfterCutting_solution2</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> timesOf3 = length / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> timesOf2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (length - timesOf3 * <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        timesOf3--;</span><br><span class="line">        <span class="comment">// timesOf2=2;  //错误！</span></span><br><span class="line">    &#125;</span><br><span class="line">    timesOf2 = (length - timesOf3 * <span class="number">3</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) (Math.pow(<span class="number">3</span>, timesOf3) * Math.pow(<span class="number">2</span>, timesOf2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;递归和分治&quot;&gt;&lt;a href=&quot;#递归和分治&quot; class=&quot;headerlink&quot; title=&quot;递归和分治&quot;&gt;&lt;/a&gt;递归和分治&lt;/h1&gt;&lt;h2 id=&quot;整数划分问题&quot;&gt;&lt;a href=&quot;#整数划分问题&quot; class=&quot;headerlink&quot; title=&quot;整
      
    
    </summary>
    
      <category term="刷算法题" scheme="https://www.junglezero.top/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="课程整理" scheme="https://www.junglezero.top/tags/%E8%AF%BE%E7%A8%8B%E6%95%B4%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>无向图</title>
    <link href="https://www.junglezero.top/2019/04/25/%E5%9B%BE/"/>
    <id>https://www.junglezero.top/2019/04/25/图/</id>
    <published>2019-04-25T01:00:24.000Z</published>
    <updated>2019-06-04T04:45:18.998Z</updated>
    
    <content type="html"><![CDATA[<p>…省略掉图在离散数学中的许多定义</p><h1 id="无向图的数据结构"><a href="#无向图的数据结构" class="headerlink" title="无向图的数据结构"></a>无向图的数据结构</h1><p>这里使用邻接表数组表示</p><p><img src="/upload/pasted-295.png" alt="upload successful"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> V; <span class="comment">//定点数目</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> E;       <span class="comment">//边的数目</span></span><br><span class="line">    <span class="keyword">private</span> Bag&lt;Integer&gt;[] adj; <span class="comment">//邻接表</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以V(定点的个数为依据进行初始化)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  V number of vertices</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> V &lt; 0&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> V)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (V &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Number of vertices must be nonnegative"</span>);</span><br><span class="line">        <span class="keyword">this</span>.V = V;</span><br><span class="line">        <span class="keyword">this</span>.E = <span class="number">0</span>;</span><br><span class="line">        adj = (Bag&lt;Integer&gt;[]) <span class="keyword">new</span> Bag[V];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">            adj[v] = <span class="keyword">new</span> Bag&lt;Integer&gt;();<span class="comment">//初始化所有链表为空</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes a new graph that is a deep copy of &#123;<span class="doctag">@code</span> G&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  G the graph to copy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(Graph G)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(G.V());</span><br><span class="line">        <span class="keyword">this</span>.E = G.E();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++) &#123;</span><br><span class="line">            <span class="comment">// reverse so that adjacency list is in same order as original</span></span><br><span class="line">            Stack&lt;Integer&gt; reverse = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : G.adj[v]) &#123;</span><br><span class="line">                reverse.push(w);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : reverse) &#123;</span><br><span class="line">                adj[v].add(w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回图中结点个数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of vertices in this graph</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of edges in this graph.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of edges in this graph</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">E</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// throw an IllegalArgumentException unless &#123;@code 0 &lt;= v &lt; V&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateVertex</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= V)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"vertex "</span> + v + <span class="string">" is not between 0 and "</span> + (V-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向图中加入v-w边</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  v one vertex in the edge</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  w the other vertex in the edge</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless both &#123;<span class="doctag">@code</span> 0 &lt;= v &lt; V&#125; and &#123;<span class="doctag">@code</span> 0 &lt;= w &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        validateVertex(v);</span><br><span class="line">        validateVertex(w);</span><br><span class="line">        E++;</span><br><span class="line">        adj[v].add(w);</span><br><span class="line">        adj[w].add(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回某结点的邻接表集.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  v the vertex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the vertices adjacent to vertex &#123;<span class="doctag">@code</span> v&#125;, as an iterable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= v &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        validateVertex(v);</span><br><span class="line">        <span class="keyword">return</span> adj[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回结点的个数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  v the vertex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the degree of vertex &#123;<span class="doctag">@code</span> v&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= v &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">degree</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        validateVertex(v);</span><br><span class="line">        <span class="keyword">return</span> adj[v].size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a string representation of this graph.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of vertices &lt;em&gt;V&lt;/em&gt;, followed by the number of edges &lt;em&gt;E&lt;/em&gt;,</span></span><br><span class="line"><span class="comment">     *         followed by the &lt;em&gt;V&lt;/em&gt; adjacency lists</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s.append(V + <span class="string">" vertices, "</span> + E + <span class="string">" edges "</span> + NEWLINE);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">            s.append(v + <span class="string">": "</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : adj[v]) &#123;</span><br><span class="line">                s.append(w + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            s.append(NEWLINE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="深度优先搜索-Depth-First-Search"><a href="#深度优先搜索-Depth-First-Search" class="headerlink" title="深度优先搜索(Depth-First Search)"></a>深度优先搜索(Depth-First Search)</h1><p>深度优先搜索可以理解为拿着一根绳子走迷宫，开始选择一条没有走过的路，每到一个路口，就对当前位置进行标记，当再次到达标记位置时，利用绳子回退到上一个路口，如此往复，循环渐进<br>而实现的程序上描述起来就更为简单：在访问一个顶点时，把当前的结点进行标记，然后递归的访问没有标记的顶点</p><p><img src="/upload/DFS.gif" alt="upload successful"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepthFirstPaths</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;    <span class="comment">// 标记顶点是否被标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] edgeTo;        <span class="comment">// edgeTo[v] = s到v的路径上最后一条边的起点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> s;         <span class="comment">// 搜索的起点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始进行广度优先麦搜索</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> G the graph</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s the source vertex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= s &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DepthFirstPaths</span><span class="params">(Graph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        edgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        <span class="comment">//验证s是否合法</span></span><br><span class="line">        validateVertex(s);</span><br><span class="line">        dfs(G, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键递归步骤</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将当前访问的顶点标记为已访问</span></span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//依次递归访问当前结点的所有相邻结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w : G.adj(v)) &#123;</span><br><span class="line">            <span class="comment">//如果未访问，则访问该顶点</span></span><br><span class="line">            <span class="keyword">if</span> (!marked[w]) &#123;</span><br><span class="line">                edgeTo[w] = v;</span><br><span class="line">                dfs(G, w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判定源结点s和当前结点是有通路</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v the vertex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if there is a path, &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= v &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        validateVertex(v);</span><br><span class="line">        <span class="keyword">return</span> marked[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回源结点s和当前结点v的一条通路路径，如果不存在该路径，则返回null</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  v the vertex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the sequence of vertices on a path between the source vertex</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> s&#125; and vertex &#123;<span class="doctag">@code</span> v&#125;, as an Iterable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= v &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        validateVertex(v);</span><br><span class="line">        <span class="keyword">if</span> (!hasPathTo(v)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Stack&lt;Integer&gt; path = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = v; x != s; x = edgeTo[x])</span><br><span class="line">            path.push(x);</span><br><span class="line">        path.push(s);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// throw an IllegalArgumentException unless &#123;@code 0 &lt;= v &lt; V&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateVertex</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> V = marked.length;</span><br><span class="line">        <span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= V)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"vertex "</span> + v + <span class="string">" is not between 0 and "</span> + (V-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h1><h2 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h2><p><img src="/upload/BFS2.gif" alt="upload successful"><br><strong>引入</strong>：单点路径问题，在一个图中，给定两个结点，找出这两点之间是否存在路径，如果存在，找出最短路径<br><strong>分析</strong>：dfs并不能解决这个问题，因为其遍历整个图的顺序和找出最短路径没有关系,而相比之下，广度优先搜索正是为了这个目标而出现的，要找到s到v的最短路径。从s开始，找到距离s为1条边的点，如果找不到，就在距离为2的边中查找直到找到为止，如果把深度优先搜索比作为一个人拿着绳子走迷宫，那么，那么广度优先搜索就好像一群人向着各个方向走<br><strong>实现</strong>：使用一个队列保存已经被标记但是其邻接表还未进行检查的顶点，先将起点放入队列，然后重复以下步骤知道队列为空</p><ul><li>取队列中下一个顶点v并进行访问标记</li><li>将与v相邻的所有未被标记过的顶点</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  The &#123;<span class="doctag">@code</span> BreadthFirstPaths&#125; class represents a data type for finding</span></span><br><span class="line"><span class="comment"> *  shortest paths (number of edges) from a source vertex &lt;em&gt;s&lt;/em&gt;</span></span><br><span class="line"><span class="comment"> *  (or a set of source vertices)</span></span><br><span class="line"><span class="comment"> *  to every other vertex in an undirected graph.</span></span><br><span class="line"><span class="comment"> *  &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *  This implementation uses breadth-first search.</span></span><br><span class="line"><span class="comment"> *  The constructor takes time proportional to &lt;em&gt;V&lt;/em&gt; + &lt;em&gt;E&lt;/em&gt;,</span></span><br><span class="line"><span class="comment"> *  where &lt;em&gt;V&lt;/em&gt; is the number of vertices and &lt;em&gt;E&lt;/em&gt; is the number of edges.</span></span><br><span class="line"><span class="comment"> *  Each call to &#123;<span class="doctag">@link</span> #distTo(int)&#125; and &#123;<span class="doctag">@link</span> #hasPathTo(int)&#125; takes constant time;</span></span><br><span class="line"><span class="comment"> *  each call to &#123;<span class="doctag">@link</span> #pathTo(int)&#125; takes time proportional to the length</span></span><br><span class="line"><span class="comment"> *  of the path.</span></span><br><span class="line"><span class="comment"> *  It uses extra space (not including the graph) proportional to &lt;em&gt;V&lt;/em&gt;.</span></span><br><span class="line"><span class="comment"> *  &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *  For additional documentation,</span></span><br><span class="line"><span class="comment"> *  see &lt;a href="https://algs4.cs.princeton.edu/41graph"&gt;Section 4.1&lt;/a&gt;   </span></span><br><span class="line"><span class="comment"> *  of &lt;i&gt;Algorithms, 4th Edition&lt;/i&gt; by Robert Sedgewick and Kevin Wayne.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span> Robert Sedgewick</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span> Kevin Wayne</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BreadthFirstPaths</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INFINITY = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;  <span class="comment">// marked[v] = 标记s和v之间有通路</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] edgeTo;      <span class="comment">// edgeTo[v] = previous edge on shortest s-v path</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] distTo;      <span class="comment">// distTo[v] = number of edges shortest s-v path</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">     * Computes the shortest path between the source vertex &#123;<span class="doctag">@code</span> s&#125;</span></span><br><span class="line"><span class="comment">     * and every other vertex in the graph &#123;<span class="doctag">@code</span> G&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> G the graph</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s the source vertex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= s &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BreadthFirstPaths</span><span class="params">(Graph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        distTo = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        edgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        validateVertex(s);</span><br><span class="line">        bfs(G, s);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">check</span><span class="params">(G, s)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes the shortest path between any one of the source vertices in &#123;<span class="doctag">@code</span> sources&#125;</span></span><br><span class="line"><span class="comment">     * and every other vertex in graph &#123;<span class="doctag">@code</span> G&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> G the graph</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sources the source vertices</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= s &lt; V&#125; for each vertex</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> s&#125; in &#123;<span class="doctag">@code</span> sources&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BreadthFirstPaths</span><span class="params">(Graph G, Iterable&lt;Integer&gt; sources)</span> </span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        distTo = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        edgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++)</span><br><span class="line">            distTo[v] = INFINITY;</span><br><span class="line">        validateVertices(sources);</span><br><span class="line">        bfs(G, sources);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// breadth-first search from a single source</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Graph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> Queue&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++)</span><br><span class="line">            distTo[v] = INFINITY;</span><br><span class="line">        distTo[s] = <span class="number">0</span>;</span><br><span class="line">        marked[s] = <span class="keyword">true</span>;</span><br><span class="line">        q.enqueue(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = q.dequeue();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : G.adj(v)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!marked[w]) &#123;</span><br><span class="line">                    edgeTo[w] = v;</span><br><span class="line">                    distTo[w] = distTo[v] + <span class="number">1</span>;</span><br><span class="line">                    marked[w] = <span class="keyword">true</span>;</span><br><span class="line">                    q.enqueue(w);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// breadth-first search from multiple sources</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Graph G, Iterable&lt;Integer&gt; sources)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> Queue&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s : sources) &#123;</span><br><span class="line">            marked[s] = <span class="keyword">true</span>;</span><br><span class="line">            distTo[s] = <span class="number">0</span>;</span><br><span class="line">            q.enqueue(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = q.dequeue();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : G.adj(v)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!marked[w]) &#123;</span><br><span class="line">                    edgeTo[w] = v;</span><br><span class="line">                    distTo[w] = distTo[v] + <span class="number">1</span>;</span><br><span class="line">                    marked[w] = <span class="keyword">true</span>;</span><br><span class="line">                    q.enqueue(w);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Is there a path between the source vertex &#123;<span class="doctag">@code</span> s&#125; (or sources) and vertex &#123;<span class="doctag">@code</span> v&#125;?</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v the vertex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if there is a path, and &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= v &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        validateVertex(v);</span><br><span class="line">        <span class="keyword">return</span> marked[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of edges in a shortest path between the source vertex &#123;<span class="doctag">@code</span> s&#125;</span></span><br><span class="line"><span class="comment">     * (or sources) and vertex &#123;<span class="doctag">@code</span> v&#125;?</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v the vertex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of edges in a shortest path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= v &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">distTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        validateVertex(v);</span><br><span class="line">        <span class="keyword">return</span> distTo[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a shortest path between the source vertex &#123;<span class="doctag">@code</span> s&#125; (or sources)</span></span><br><span class="line"><span class="comment">     * and &#123;<span class="doctag">@code</span> v&#125;, or &#123;<span class="doctag">@code</span> null&#125; if no such path.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  v the vertex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the sequence of vertices on a shortest path, as an Iterable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= v &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        validateVertex(v);</span><br><span class="line">        <span class="keyword">if</span> (!hasPathTo(v)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Stack&lt;Integer&gt; path = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">for</span> (x = v; distTo[x] != <span class="number">0</span>; x = edgeTo[x])</span><br><span class="line">            path.push(x);</span><br><span class="line">        path.push(x);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// check optimality conditions for single source</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(Graph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check that the distance of s = 0</span></span><br><span class="line">        <span class="keyword">if</span> (distTo[s] != <span class="number">0</span>) &#123;</span><br><span class="line">            StdOut.println(<span class="string">"distance of source "</span> + s + <span class="string">" to itself = "</span> + distTo[s]);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check that for each edge v-w dist[w] &lt;= dist[v] + 1</span></span><br><span class="line">        <span class="comment">// provided v is reachable from s</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : G.adj(v)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hasPathTo(v) != hasPathTo(w)) &#123;</span><br><span class="line">                    StdOut.println(<span class="string">"edge "</span> + v + <span class="string">"-"</span> + w);</span><br><span class="line">                    StdOut.println(<span class="string">"hasPathTo("</span> + v + <span class="string">") = "</span> + hasPathTo(v));</span><br><span class="line">                    StdOut.println(<span class="string">"hasPathTo("</span> + w + <span class="string">") = "</span> + hasPathTo(w));</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (hasPathTo(v) &amp;&amp; (distTo[w] &gt; distTo[v] + <span class="number">1</span>)) &#123;</span><br><span class="line">                    StdOut.println(<span class="string">"edge "</span> + v + <span class="string">"-"</span> + w);</span><br><span class="line">                    StdOut.println(<span class="string">"distTo["</span> + v + <span class="string">"] = "</span> + distTo[v]);</span><br><span class="line">                    StdOut.println(<span class="string">"distTo["</span> + w + <span class="string">"] = "</span> + distTo[w]);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check that v = edgeTo[w] satisfies distTo[w] = distTo[v] + 1</span></span><br><span class="line">        <span class="comment">// provided v is reachable from s</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; G.V(); w++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasPathTo(w) || w == s) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> v = edgeTo[w];</span><br><span class="line">            <span class="keyword">if</span> (distTo[w] != distTo[v] + <span class="number">1</span>) &#123;</span><br><span class="line">                StdOut.println(<span class="string">"shortest path edge "</span> + v + <span class="string">"-"</span> + w);</span><br><span class="line">                StdOut.println(<span class="string">"distTo["</span> + v + <span class="string">"] = "</span> + distTo[v]);</span><br><span class="line">                StdOut.println(<span class="string">"distTo["</span> + w + <span class="string">"] = "</span> + distTo[w]);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// throw an IllegalArgumentException unless &#123;@code 0 &lt;= v &lt; V&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateVertex</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> V = marked.length;</span><br><span class="line">        <span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= V)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"vertex "</span> + v + <span class="string">" is not between 0 and "</span> + (V-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// throw an IllegalArgumentException unless &#123;@code 0 &lt;= v &lt; V&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateVertices</span><span class="params">(Iterable&lt;Integer&gt; vertices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (vertices == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument is null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> V = marked.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : vertices) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= V) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"vertex "</span> + v + <span class="string">" is not between 0 and "</span> + (V-<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Unit tests the &#123;<span class="doctag">@code</span> BreadthFirstPaths&#125; data type.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args the command-line arguments</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        In in = <span class="keyword">new</span> In(args[<span class="number">0</span>]);</span><br><span class="line">        Graph G = <span class="keyword">new</span> Graph(in);</span><br><span class="line">        <span class="comment">// StdOut.println(G);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> s = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">        BreadthFirstPaths bfs = <span class="keyword">new</span> BreadthFirstPaths(G, s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bfs.hasPathTo(v)) &#123;</span><br><span class="line">                StdOut.printf(<span class="string">"%d to %d (%d):  "</span>, s, v, bfs.distTo(v));</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x : bfs.pathTo(v)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (x == s) StdOut.print(x);</span><br><span class="line">                    <span class="keyword">else</span>        StdOut.print(<span class="string">"-"</span> + x);</span><br><span class="line">                &#125;</span><br><span class="line">                StdOut.println();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                StdOut.printf(<span class="string">"%d to %d (-):  not connected\n"</span>, s, v);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;…省略掉图在离散数学中的许多定义&lt;/p&gt;
&lt;h1 id=&quot;无向图的数据结构&quot;&gt;&lt;a href=&quot;#无向图的数据结构&quot; class=&quot;headerlink&quot; title=&quot;无向图的数据结构&quot;&gt;&lt;/a&gt;无向图的数据结构&lt;/h1&gt;&lt;p&gt;这里使用邻接表数组表示&lt;/p&gt;
&lt;p&gt;&lt;im
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>乐观锁和悲观锁</title>
    <link href="https://www.junglezero.top/2019/04/23/%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81-1/"/>
    <id>https://www.junglezero.top/2019/04/23/锁和悲观锁-1/</id>
    <published>2019-04-23T06:07:00.000Z</published>
    <updated>2019-04-23T06:14:46.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>当我们要对一个数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。</p><p>这种借助数据库锁机制在修改数据之前先锁定，再修改的方式被称之为悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）。</p><p>之所以叫做悲观锁，是因为这是一种对数据的修改抱有悲观态度的并发控制方式。我们一般认为数据被并发修改的概率比较大，所以需要在修改之前先加锁。</p><p>悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。</p><p>但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，还会降低并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。</p><p><img src="/upload/pasted-285.png" alt="upload successful"></p><p>Java里面的同步原语synchronized关键字的实现也是悲观锁。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>以MySQL为例<br>要使用悲观锁，必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set autocommit=0;<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//0.开始事务</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"></span><br><span class="line">//1.查询出商品库存信息</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> quantity <span class="keyword">from</span> items <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line">//2.修改商品库存为2</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> items <span class="keyword">set</span> quantity=<span class="number">2</span> <span class="keyword">where</span> <span class="keyword">id</span>= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">//3.提交事务</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></p><p>以上，在对id = 1的记录修改前，先通过for update的方式进行加锁，然后再进行修改。这就是比较典型的悲观锁策略。</p><p>如果以上修改库存的代码发生并发，同一时间只有一个线程可以开启事务并获得id=1的锁，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。</p><p>上面我们提到，使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意</p><h1 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p>乐观锁（ Optimistic Locking ） 是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。</p><p>相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。</p><p><img src="/upload/pasted-292.png" alt="upload successful"><br>乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。</p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>使用乐观锁就不需要借助数据库的锁机制了。</p><p>乐观锁的概念中其实已经阐述了他的具体实现细节：主要就是两个步骤：冲突检测和数据更新。其实现方式有一种比较典型的就是Compare and Swap(CAS)。</p><p>CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p><p>比如前面的扣减库存问题，通过乐观锁可以实现如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//查询出商品库存信息，quantity = 3</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> quantity <span class="keyword">from</span> items <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">//修改商品库存为<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> items <span class="keyword">set</span> quantity=<span class="number">2</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">and</span> quantity = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></p><p>以上，我们在更新之前，先查询一下库存表中当前库存数（quantity），然后在做update的时候，以库存数作为一个修改条件。当我们提交更新的时候，判断数据库表对应记录的当前库存数与第一次取出来的库存数进行比对，如果数据库表当前库存数与第一次取出来的库存数相等，则予以更新，否则认为是过期数据。</p><p>以上更新语句存在一个比较重要的问题，即传说中的ABA问题。</p><p>比如说一个线程one从数据库中取出库存数3，这时候另一个线程two也从数据库中库存数3，并且two进行了一些操作变成了2，然后two又将库存数变成3，这时候线程one进行CAS操作发现数据库中仍然是3，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。</p><p><img src="/upload/pasted-293.png" alt="upload successful"><br>有一个比较好的办法可以解决ABA问题，那就是通过一个单独的可以顺序递增的version字段。改为以下方式即可：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//查询出商品信息，version = 1</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">version</span> <span class="keyword">from</span> items <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">//修改商品库存为<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> items <span class="keyword">set</span> quantity=<span class="number">2</span>,<span class="keyword">version</span>= <span class="number">3</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">and</span> <span class="keyword">version</span>= <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p><p>乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现ABA问题，因为版本号只会增加不会减少。</p><p><img src="/upload/pasted-294.png" alt="upload successful"></p><p>以上SQL其实还是有一定的问题的，就是一旦发上高并发的时候，就只有一个线程可以修改成功，那么就会存在大量的失败。</p><p>对于像淘宝这样的电商网站，高并发是常有的事，总让用户感知到失败显然是不合理的。所以，还是要想办法减少乐观锁的粒度的。</p><p>有一条比较好的建议，可以减小乐观锁力度，最大程度的提升吞吐率，提高并发能力！如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//修改商品库存</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> item</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> quantity=quantity - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">and</span> quantity - <span class="number">1</span>&gt; <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>以上SQL语句中，如果用户下单数为1，则通过quantity - 1 &gt; 0的方式进行乐观锁控制。</p><p>以上update语句，在执行过程中，会在一次原子操作中自己查询一遍quantity的值，并将其扣减掉1。</p><h1 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h1><p>在乐观锁与悲观锁的选择上面，主要看下两者的区别以及适用场景就可以了。</p><p>1、乐观锁并未真正加锁，效率高。一旦锁的粒度掌握不好，更新失败的概率就会比较高，容易发生业务失败。</p><p>2、悲观锁依赖数据库锁，效率低。更新失败的概率比较低。</p><p>随着互联网三高架构（高并发、高性能、高可用）的提出，悲观锁已经越来越少的被使用到生产环境中了，尤其是并发量比较大的业务场景。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;悲观锁&quot;&gt;&lt;a href=&quot;#悲观锁&quot; class=&quot;headerlink&quot; title=&quot;悲观锁&quot;&gt;&lt;/a&gt;悲观锁&lt;/h1&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概
      
    
    </summary>
    
      <category term="数据库相关" scheme="https://www.junglezero.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/"/>
    
      <category term="java多线程学习" scheme="https://www.junglezero.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="java多线程" scheme="https://www.junglezero.top/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="数据库" scheme="https://www.junglezero.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>多线程上下文设计模式</title>
    <link href="https://www.junglezero.top/2019/04/22/%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.junglezero.top/2019/04/22/程上下文设计模式/</id>
    <published>2019-04-22T10:17:38.000Z</published>
    <updated>2019-04-22T10:49:02.938Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>上下文是贯穿整个系统或阶段生命周期的对象，其包含了系统全局的一些信息，比如登录之后的用户信息，账号信息以及程序每一个阶段运行时的数据。<br>在有些时候，单个线程执行的任务步骤会非常多，后一个步骤的输入有可能是前一个步骤的输出，比如在单个线程多步骤执行时，为了使得功能单一，有时候我们会采用GOF职责链设计模式。</p><p><img src="/upload/pasted-284.png" alt="upload successful"></p><h1 id="利用ThreadLocal实现"><a href="#利用ThreadLocal实现" class="headerlink" title="利用ThreadLocal实现"></a>利用ThreadLocal实现</h1><p>某个任务，需要分别从数据库和http查询内容<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutionTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> QueryFromDBAction queryAction = <span class="keyword">new</span> QueryFromDBAction();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> QueryFromHttpAction httpAction = <span class="keyword">new</span> QueryFromHttpAction();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接执行不用传参</span></span><br><span class="line">        queryAction.execute();</span><br><span class="line">        System.out.println(<span class="string">"The name query successful"</span>);</span><br><span class="line">        httpAction.execute();</span><br><span class="line">        System.out.println(<span class="string">"The card id query successful"</span>);</span><br><span class="line"></span><br><span class="line">        Context context = ActionContext.getActionContext().getContext();</span><br><span class="line">        System.out.println(<span class="string">"The Name is "</span> + context.getName() + <span class="string">" and CardId "</span> + context.getCardId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上下文类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String cardId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCardId</span><span class="params">(String cardId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cardId = cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCardId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cardId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>全局管理上下文<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Context&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;Context&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Context <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Context();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//嵌套内部类单例模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ActionContext actionContext = <span class="keyword">new</span> ActionContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ActionContext <span class="title">getActionContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ContextHolder.actionContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Context <span class="title">getContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ActionContext</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>任务中具体内容执行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryFromDBAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">            String name = <span class="string">"Alex "</span> + Thread.currentThread().getName();</span><br><span class="line">            <span class="comment">//调用全局context，并直接修改context</span></span><br><span class="line">            ActionContext.getActionContext().getContext().setName(name);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryFromHttpAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个任务就分为两步，首先获取name，从context中，然后再根据name获取cardID，存入context</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Context context = ActionContext.getActionContext().getContext();</span><br><span class="line">        String name = context.getName();</span><br><span class="line">        String cardId = getCardId(name);</span><br><span class="line">        context.setCardId(cardId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getCardId</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"435467523543"</span> + Thread.currentThread().getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;上下文是贯穿整个系统或阶段生命周期的对象，其包含了系统全局的一些信息，比如登录之后的用户信息，账号信息以及程序每一个阶段运行
      
    
    </summary>
    
    
  </entry>
  
</feed>
