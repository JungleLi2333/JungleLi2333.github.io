<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>淋中之虹</title>
  
  <subtitle>向来不知道该说些什么</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.junglezero.top/"/>
  <updated>2019-08-15T08:39:55.835Z</updated>
  <id>https://www.junglezero.top/</id>
  
  <author>
    <name>JungleZero</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring的AOP和IOC</title>
    <link href="https://www.junglezero.top/2019/08/13/pring%E7%9A%84AOP%E5%92%8CIOC/"/>
    <id>https://www.junglezero.top/2019/08/13/pring的AOP和IOC/</id>
    <published>2019-08-13T12:38:06.000Z</published>
    <updated>2019-08-15T08:39:55.835Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h1><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>Spring的核心思想之一：Inversion of Control , 控制反转 IOC<br>所谓控制反转，就是对象的创建以及生命周期的管理交给外部容器完成，这个开发过程中不再需要关注对象的创建和生命周期的管理，而是在需要的时由Spring框架提供。</p><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><h2 id="简单使用过程"><a href="#简单使用过程" class="headerlink" title="简单使用过程"></a>简单使用过程</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><h4 id="用配置文件配置类"><a href="#用配置文件配置类" class="headerlink" title="用配置文件配置类"></a>用配置文件配置类</h4><p>简单来说，就是利用外部的配置文件来管理对象的创建与生命周期<br>在spring的配置文件的xml中，一般名为application.xml，在其中定义需要装配的Bean<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用spring管理对象的创建，还有对象的依赖关系 --&gt;</span>    </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"userManager"</span> <span class="attr">class</span>=<span class="string">"scau.zzf.service.UserMessage"</span>&gt;</span>    </span><br><span class="line">        <span class="comment">&lt;!-- (1)UserMessageImpl使用了userDao，Ioc是自动创建相应的UserDao实现，都是由容器管理--&gt;</span>    </span><br><span class="line">        <span class="comment">&lt;!-- (2)在UserMessageImpl中提供构造函数，让spring将UserDao实现注入（DI）过来 --&gt;</span>    </span><br><span class="line">        <span class="comment">&lt;!-- (3)让spring管理我们对象的创建和依赖关系，必须将依赖关系配置到spring的核心配置文件中 --&gt;</span>    </span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"userDao"</span> <span class="attr">ref</span>=<span class="string">"UserDao"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span>   </span><br><span class="line">    <span class="comment">&lt;!-- 构造注入 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- &lt;constructor-arg ref="userDao"/&gt;  --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"UserDao"</span> <span class="attr">class</span>=<span class="string">"scau.zzf.Dao.UserDao"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"User"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--通过constructor这个节点来指定构造函数的参数类型、名称、第几个--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"zhongfucheng"</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="注解方法配置"><a href="#注解方法配置" class="headerlink" title="注解方法配置"></a>注解方法配置</h4><p>除了用配置文件的方式定义类信息外，也可以通过注解的方式<br>常用的注解：<br>@ComponentScan扫描器<br>@Configuration表明该类是配置类<br>@Component   指定把一个对象加入IOC容器—&gt;@Name也可以实现相同的效果【一般少用】<br>@Repository   作用同@Component； 在持久层使用<br>@Service      作用同@Component； 在业务逻辑层使用<br>@Controller    作用同@Component； 在控制层使用<br>@Resource  依赖关系<br>如果@Resource不指定值，那么就根据类型来找，相同的类型在IOC容器中不能有两个<br>如果@Resource指定了值，那么就根据名字来找</p><p>实例：<br>DAO层<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Repository;</span><br><span class="line"><span class="comment">//把对象添加到容器中,首字母会小写</span></span><br><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"DB:保存用户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Service层<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//把UserService对象添加到IOC容器中,首字母会小写</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果@Resource不指定值，那么就根据类型来找---&gt;UserDao....当然了，IOC容器不能有两个UserDao类型的对象</span></span><br><span class="line">    <span class="comment">//@Resource</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果指定了值，那么Spring就在IOC容器找有没有id为userDao的对象。</span></span><br><span class="line">    <span class="meta">@Resource</span>(name = <span class="string">"userDao"</span>)</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Controller层<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by ozc on 2017/5/10.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//把对象添加到IOC容器中,首字母会小写</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span>(name = <span class="string">"userService"</span>)</span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userService.save();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="配置类配置（利用Bean注解）"><a href="#配置类配置（利用Bean注解）" class="headerlink" title="配置类配置（利用Bean注解）"></a>配置类配置（利用Bean注解）</h4><p>另外，也可以创建一个配置类来管理Bean<br>对于被bean修饰的方法：<br>使用@Bean来修饰方法，该方法返回一个对象。<br>不管方法体内的对象是怎么创建的，Spring可以获取得到对象就行了。<br>Spring内部会将该对象加入到Spring容器中<br>容器中bean的ID默认为方法名<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@org</span>.springframework.context.annotation.Configuration</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Configuration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserDao <span class="title">userDao</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        UserDao userDao = <span class="keyword">new</span> UserDao();</span><br><span class="line">        System.out.println(<span class="string">"我是在configuration中的"</span>+userDao);</span><br><span class="line">        <span class="keyword">return</span> userDao;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>XmlBeanFactory读取xml文件，从而获取相关的Bean信息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    BeanFactory factory=<span class="keyword">new</span> XmlBeanFactory(<span class="keyword">new</span> FileSystemResource(<span class="string">"src/appllication.xml"</span>));</span><br><span class="line">        UserMessage userMessage=(UserMessage)factory.getBean(<span class="string">"UserMessage"</span>);</span><br><span class="line">        userMessage.add(<span class="string">"message"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是获取IOC容器对象的一种方式，另外还有<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加载Spring的资源文件</span></span><br><span class="line">Resource resource = <span class="keyword">new</span> ClassPathResource(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建IOC容器对象【IOC容器=工厂类+applicationContext.xml】</span></span><br><span class="line">BeanFactory beanFactory = <span class="keyword">new</span> XmlBeanFactory(resource);</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 得到IOC容器对象</span></span><br><span class="line">ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(ac);</span><br></pre></td></tr></table></figure><h2 id="细节研究"><a href="#细节研究" class="headerlink" title="细节研究"></a>细节研究</h2><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>spring ioc容器初始化好bean的实例对象之后，会对该对象中的属性进行初始化，初始化的过程依然是由容器自动来完成，这个被称为是依赖注入（dependency injection缩写是DI）。spring里面常用的注入方式有两种，setter方法注入，构造方法注入。</p><h3 id="Bean属性"><a href="#Bean属性" class="headerlink" title="Bean属性"></a>Bean属性</h3><p>1) 对象创建： 单例/多例<br>scope=”singleton”, 默认值， 即 默认是单例 【service/dao/工具类】<br>scope=”prototype”, 多例；              【Action对象】</p><p>2) 什么时候创建?<br>scope=”prototype”  在用到对象的时候，才创建对象。<br>scope=”singleton”  在启动(容器初始化之前)， 就已经创建了bean，且整个应用只有一个。</p><p>3)是否延迟创建<br>         lazy-init=”false”  默认为false,  不延迟创建，即在启动时候就创建对象<br>         lazy-init=”true”   延迟初始化， 在用到对象的时候才创建对象（只对单例有效）</p><p>4) 创建对象之后，初始化/销毁<br>init-method=”init_user”       【对应对象的init_user方法，在对象创建之后执行 】<br>destroy-method=”destroy_user”  【在调用容器对象的destroy方法时候执行，(容器用实现类)】</p><h1 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;IOC&quot;&gt;&lt;a href=&quot;#IOC&quot; class=&quot;headerlink&quot; title=&quot;IOC&quot;&gt;&lt;/a&gt;IOC&lt;/h1&gt;&lt;h2 id=&quot;基本介绍&quot;&gt;&lt;a href=&quot;#基本介绍&quot; class=&quot;headerlink&quot; title=&quot;基本介绍&quot;&gt;&lt;/a&gt;基本介
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式总结（4）【原型模式，责任链模式，建造者模式，命令模式】</title>
    <link href="https://www.junglezero.top/2019/08/04/%E6%A8%A1%E5%BC%8F%E6%B1%87%E6%80%BB%EF%BC%884%EF%BC%89/"/>
    <id>https://www.junglezero.top/2019/08/04/模式汇总（4）/</id>
    <published>2019-08-04T10:01:03.000Z</published>
    <updated>2019-08-13T08:32:31.476Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>原型（Prototype）模式的定义如下：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。例如，Windows 操作系统的安装通常较耗时，如果复制就快了很多。在生活中复制的例子非常多，这里不一一列举了。</p><h2 id="具体结构"><a href="#具体结构" class="headerlink" title="具体结构"></a>具体结构</h2><p><img src="/upload/pasted-477.png" alt="upload successful"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>可以使用Java中的Cloneable来实现一个对象的浅克隆<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//具体原型类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Realizetype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    Realizetype()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(<span class="string">"具体原型创建成功！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体原型复制成功！"</span>);</span><br><span class="line">        <span class="keyword">return</span> (Realizetype)<span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原型模式的测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypeTest</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> CloneNotSupportedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Realizetype obj1=<span class="keyword">new</span> Realizetype();</span><br><span class="line">        Realizetype obj2=(Realizetype)obj1.clone();</span><br><span class="line">        System.out.println(<span class="string">"obj1==obj2?"</span>+(obj1==obj2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>原型模式通常适用于以下场景。</p><ul><li>对象之间相同或相似，即只是个别的几个属性不同的时候。</li><li>对象的创建过程比较麻烦，但复制比较简单的时候</li></ul><h1 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p>责任链（Chain of Responsibility）模式的定义：为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p><p>在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，所以责任链将请求的发送者和请求的处理者解耦了。</p><p>责任链模式是一种对象行为型模式，其主要优点如下。</p><ul><li>降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。</li><li>增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。</li><li>增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。</li><li>责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。</li><li>责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</li></ul><p>其主要缺点如下。</p><ul><li>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。</li><li>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。</li><li>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用</li></ul><h2 id="具体结构-1"><a href="#具体结构-1" class="headerlink" title="具体结构"></a>具体结构</h2><p>职责链模式主要包含以下角色。</p><ul><li>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li><li>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li><li>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程</li></ul><p><img src="/upload/pasted-478.png" alt="upload successful"></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>可以用链表的数据结构，将责任链中的每个处理单元设置为链表的结点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainOfResponsibilityPattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//组装责任链 </span></span><br><span class="line">        Handler handler1=<span class="keyword">new</span> ConcreteHandler1(); </span><br><span class="line">        Handler handler2=<span class="keyword">new</span> ConcreteHandler2(); </span><br><span class="line">        handler1.setNext(handler2); </span><br><span class="line">        <span class="comment">//提交请求 </span></span><br><span class="line">        handler1.handleRequest(<span class="string">"two"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象处理者角色</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Handler next;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNext</span><span class="params">(Handler next)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.next=next; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Handler <span class="title">getNext</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> next; </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="comment">//处理请求的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(String request)</span></span>;       </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体处理者角色1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandler1</span> <span class="keyword">extends</span> <span class="title">Handler</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(String request)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(request.equals(<span class="string">"one"</span>)) </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"具体处理者1负责处理该请求！"</span>);       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(getNext()!=<span class="keyword">null</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                getNext().handleRequest(request);             </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">"没有人处理该请求！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体处理者角色2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteHandler2</span> <span class="keyword">extends</span> <span class="title">Handler</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRequest</span><span class="params">(String request)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(request.equals(<span class="string">"two"</span>)) </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"具体处理者2负责处理该请求！"</span>);       </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(getNext()!=<span class="keyword">null</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                getNext().handleRequest(request);             </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(<span class="string">"没有人处理该请求！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>有多个对象可以处理一个请求，哪个对象处理该请求由运行时刻自动确定。</li><li>可动态指定一组对象处理请求，或添加新的处理者。</li><li>在不明确指定请求处理者的情况下，向多个处理者中的一个提交请求</li></ul><h1 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h1><h2 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h2><p>建造者（Builder）模式的定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。</p><p>该模式的主要优点如下：</p><ul><li>各个具体的建造者相互独立，有利于系统的扩展。</li><li>客户端不必知道产品内部组成的细节，便于控制细节风险。</li></ul><p>其缺点如下：</p><ul><li>产品的组成部分必须相同，这限制了其使用范围。</li><li>如果产品的内部变化复杂，该模式会增加很多的建造者类。</li></ul><p>建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。</p><h2 id="具体结构-2"><a href="#具体结构-2" class="headerlink" title="具体结构"></a>具体结构</h2><p>建造者（Builder）模式的主要角色如下。</p><ul><li>产品角色（Product）：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个滅部件。</li><li>抽象建造者（Builder）：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 getResult()。</li><li>具体建造者(Concrete Builder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。</li><li>指挥者（Director）：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。</li></ul><p><img src="/upload/pasted-479.png" alt="upload successful"></p><h2 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h2><p>产品角色类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Product</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String partA;</span><br><span class="line">    <span class="keyword">private</span> String partB;</span><br><span class="line">    <span class="keyword">private</span> String partC;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPartA</span><span class="params">(String partA)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partA=partA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPartB</span><span class="params">(String partB)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partB=partB;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPartC</span><span class="params">(String partC)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.partC=partC;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//显示产品的特性</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>抽象建造者：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//创建产品对象</span></span><br><span class="line">    <span class="keyword">protected</span> Product product=<span class="keyword">new</span> Product();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartA</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartB</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildPartC</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//返回产品对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getResult</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具体建造者<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">extends</span> <span class="title">Builder</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartA</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        product.setPartA(<span class="string">"建造 PartA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartB</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        product.setPartA(<span class="string">"建造 PartB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPartC</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        product.setPartA(<span class="string">"建造 PartC"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>指挥者：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Director</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder=builder;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//产品构建与组装方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">construct</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        builder.buildPartA();</span><br><span class="line">        builder.buildPartB();</span><br><span class="line">        builder.buildPartC();</span><br><span class="line">        <span class="keyword">return</span> builder.getResult();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Client:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Builder builder=<span class="keyword">new</span> ConcreteBuilder();</span><br><span class="line">        Director director=<span class="keyword">new</span> Director(builder);</span><br><span class="line">        Product product=director.construct();</span><br><span class="line">        product.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h2><p>建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。</p><ul><li>创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。</li><li>创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。</li></ul><h1 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h1><h2 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h2><p>命令（Command）模式的定义如下：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行储存、传递、调用、增加与管理。</p><p>命令模式的主要优点如下。</p><ul><li>降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。</li><li>增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。</li><li>可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。</li><li>方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。</li></ul><p>其缺点是：可能产生大量具体命令类。因为计对每一个具体操作都需要设计一个具体命令类，这将增加系统的复杂性。</p><h2 id="具体结构-3"><a href="#具体结构-3" class="headerlink" title="具体结构"></a>具体结构</h2><p>命令模式包含以下主要角色。</p><ul><li>抽象命令类（Command）角色：声明执行命令的接口，拥有执行命令的抽象方法 execute()。</li><li>具体命令角色（Concrete    Command）角色：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。</li><li>实现者/接收者（Receiver）角色：执行命令功能的相关操作，是具体命令对象业务的真正实现者。</li><li>调用者/请求者（Invoker）角色：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。</li></ul><p><img src="/upload/pasted-480.png" alt="upload successful"></p><h2 id="具体实现-2"><a href="#具体实现-2" class="headerlink" title="具体实现"></a>具体实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandPattern</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Command cmd=<span class="keyword">new</span> ConcreteCommand();</span><br><span class="line">        Invoker ir=<span class="keyword">new</span> Invoker(cmd);</span><br><span class="line">        System.out.println(<span class="string">"客户访问调用者的call()方法..."</span>);</span><br><span class="line">        ir.call();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoker</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Invoker</span><span class="params">(Command command)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command=command;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommand</span><span class="params">(Command command)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command=command;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用者执行命令command..."</span>);</span><br><span class="line">        command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象命令</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Command</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//具体命令</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand</span> <span class="keyword">implements</span> <span class="title">Command</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line">    ConcreteCommand()</span><br><span class="line">    &#123;</span><br><span class="line">        receiver=<span class="keyword">new</span> Receiver();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        receiver.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接收者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"接收者的action()方法被调用..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用场景-2"><a href="#使用场景-2" class="headerlink" title="使用场景"></a>使用场景</h2><p>命令模式通常适用于以下场景。</p><ul><li>当系统需要将请求调用者与请求接收者解耦时，命令模式使得调用者和接收者不直接交互。</li><li>当系统需要随机请求命令或经常增加或删除命令时，命令模式比较方便实现这些功能。</li><li>当系统需要执行一组操作时，命令模式可以定义宏命令来实现该功能。</li><li>当系统需要支持命令的撤销（Undo）操作和恢复（Redo）操作时，可以将命令对象存储起来，采用备忘录模式来实现。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;原型模式&quot;&gt;&lt;a href=&quot;#原型模式&quot; class=&quot;headerlink&quot; title=&quot;原型模式&quot;&gt;&lt;/a&gt;原型模式&lt;/h1&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算机网络总结（5）</title>
    <link href="https://www.junglezero.top/2019/08/02/%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93%EF%BC%885%EF%BC%89-1/"/>
    <id>https://www.junglezero.top/2019/08/02/算机网络总结（5）-1/</id>
    <published>2019-08-02T12:07:31.000Z</published>
    <updated>2019-08-02T12:18:51.391Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计网总结-五-一运输层"><a href="#计网总结-五-一运输层" class="headerlink" title="计网总结(五)一运输层"></a>计网总结(五)一运输层</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>网络层是为主机之间提供逻辑通信，而运输层为应用进程之间提供<strong>端到端的逻辑通信</strong>。</p><p>即: <strong>为相互通信的应用进程提供了逻辑通信</strong>。</p><h3 id="1、基本功能"><a href="#1、基本功能" class="headerlink" title="1、基本功能"></a>1、基本功能</h3><ul><li>传输层是<strong>只有主机才有的层次</strong>；</li><li><strong>为相互通信的应用进程提供了逻辑通信</strong>；</li><li>为应用层提供<strong>通信服务</strong>，使用网络层的服务；</li><li>复用和分用；</li><li>传输层对收到的报文进行差错检测；</li></ul><p><div align="center"><img src="/images/5_3.png" width="700"> </div><br></p><p><strong>复用: 应用层所有的应用进程都可以通过传输层再传输到网路层</strong>。</p><p><strong>分用: 传输层从网路层收到数据后交付指明的应用进程</strong>。</p><h3 id="2、传输层协议和应用层协议之间的关系"><a href="#2、传输层协议和应用层协议之间的关系" class="headerlink" title="2、传输层协议和应用层协议之间的关系"></a>2、传输层协议和应用层协议之间的关系</h3><p>应用层协议很多，传输层就两个协议，如何使用传输层两个协议标识应用层协议呢? 通常传输层协议加一个<strong>端口号</strong>来标识一个应用层协议，如下图所示，展示了传输层协议和应用层协议之间的关系。</p><p>端口用一个 16 位端口号进行标志。</p><p>是逻辑端口/软件端口: 是传输层的SAP，标识主机中的应用进程。只有本地意义。</p><blockquote><p>由此可见，两个计算机中的进程要互相通信，不仅必须知道对方的 IP 地址（为了找到对方的计算机），而且还要知道对方的端口号（为了找到对方计算机中的应用进程）。</p></blockquote><p>端口号以及常用的熟知端口:</p><p><div align="center"><img src="/images/4_59.png" width="530"></div><br></p><blockquote><p>(1)、服务器端使用的端口号</p><ul><li>熟知端口，数值一般为 0~1023(包括)。</li><li>登记端口号，数值为 1024~49151，为没有熟知端口号的应用程序使用的。使用这个范围的端口号必须在 IANA 登记，以防止重复。<br>(2)、客户端使用的端口号</li><li>又称为短暂端口号，数值为 49152~65535，留给客户进程选择暂时使用。</li><li>当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号。通信结束后，这个端口号可供其他客户进程以后使用。</li></ul></blockquote><blockquote><p>套接字: <strong>网络中采用发送方和接收方的套接字组合来识别端点，套接字唯一标识了网络中的一个主机和它上面的一个进程</strong>。即套接字Socket = (主机IP地址，端口号)</p></blockquote><p>整体过程:</p><p><img src="/images/5_4.png" alt="/images/5_4.png"></p><blockquote><p>网络层到传输层，用数据包中的<strong>协议号</strong>来标识是TCP还是UDP协议。</p><p><code>TCP : 6， UDP : 17</code>。</p></blockquote><p>下图展示了A、B、C计算机访问服务器数据包的过程。</p><p>客户端使用IP地址定位服务器，<strong>使用目标端口，定位服务</strong>。</p><p><img src="/images/5_5.png" alt="5_5.png"></p><p>TCP和UDP相当于网络中的两扇大门，门上开的洞就相当于开发TCP和UDP的端口。如果想让服务器更加安全，就把能够通往应用层的TCP和UDP的两扇大门关闭，在大门上只开放必要的端口。</p><p><img src="/images/5_6.png" alt="5_6.png"></p><p>上面讲的是设置服务器的防火墙只开放必要的端口，以加强服务器的网络安全。也可以在路由器上设置访问控制列表<code>ACL</code>来实现网络防火墙的功能，控制内网访问Internet的流量。</p><p><img src="/images/5_7.png" alt="5_7.png"></p><h2 id="二、UDP"><a href="#二、UDP" class="headerlink" title="二、UDP"></a>二、UDP</h2><h3 id="1、UDP协议的特点"><a href="#1、UDP协议的特点" class="headerlink" title="1、UDP协议的特点"></a>1、UDP协议的特点</h3><p><strong>无连接的用户数据报协议</strong>。</p><p>用户数据报协议 (UDP) 只在IP地址的数据报服务之上增加了很少一点功能，就是<strong>复用和分用的功能以及差错检测</strong>的功能，复用和分用，就是使用端口标识不同的应用层协议。</p><ul><li>传送数据之前不需要建立连接，收到UDP报文后也不需要给出任何确认；</li><li><p>使用尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态表(这里面有许多参数)，通信的两端不用保持连接，因此节省系统资源；</p><p>一个数据包就能完成数据通信、不分段、不需要建立会话、不需要流量控制、不可靠传输。</p></li></ul><p>简言之: 不可靠、无连接、时延小、适用于小文件。</p><p>接收方 UDP 对 IP 层交上来的 UDP 用户数据报，在去除首部后就原封不动地交付上层的应用进程，<strong>一次交付一个完整的报文</strong>。</p><h3 id="2、UDP首部格式"><a href="#2、UDP首部格式" class="headerlink" title="2、UDP首部格式"></a>2、UDP首部格式</h3><p>用抓包工具捕获的域名解析的数据包，域名解析使用DNS协议，在传输层使用UDP协议。如下图:</p><p><img src="/images/5_8.png" alt="5_8.png"></p><p>UDP 用户数据报有两个字段: 数据字段和首部字段。如图所示，首部字段很简单，只有8 个字节，由 4 个字段组成，每个字段的长度都是两个字节，各字段含义如下:</p><ul><li>1)、 源端口。源端口号。在需要对方回信时选用。不需要时可用全 0。</li><li>2)、<strong>目的端口。目的端口号。在终点交付报文时必须要使用到</strong>。</li><li>3)、长度。UDP 用户数据报的长度，其最小值是8(仅有首部)。</li><li>4)、检验和。检测 UDP 用户数据报在传输中是否有错。有错就入弃。</li></ul><p><img src="/images/5_9.png" alt="5_9.png"></p><p>UDP 用户数据报首部中检验和的计算方法有些特殊。在计算检验和时，要在 UDP 用户数据报之前增加 12 个字节的<strong>伪首部</strong>。所谓“伪首部” 是因为这种伪首部并不是 UDP 用户数据报真正的首部。</p><p><strong>UDP校验</strong>:</p><p>在发送端:</p><ul><li>1)、填上伪首部；</li><li>2)、全0填充检验和字段；</li><li>3)、全0填充数据部分(UDP数据报要看成许多4B的字串接起来)；</li><li>4)、伪首部+首部+数据部分采用二进制及码求和；</li><li>5)、把和求反码填入检验和字段；</li><li>6)、去掉伪首部，发送；</li></ul><p>在接收端:</p><ul><li>1)、填上伪首部；</li><li>2)、伪首部+首部+数据部分采用二进制反码求和；</li><li>3)、结果全为1则无差错，否则丢弃数据报/交给应用层附上出差错的警告(ICMP)；</li></ul><p><img src="/images/5_10.png" alt="5_10.png"></p><h2 id="三、TCP"><a href="#三、TCP" class="headerlink" title="三、TCP"></a>三、TCP</h2><p><strong>面向连接的传输控制协议</strong>。</p><p>传送数据之前必须建立连接，数据传送结束后要释放连接。适用于大文件。</p><p><strong>不提供广播或多播服务</strong>。</p><p>由于TCP要提供可靠的面向连接的传输服务，因此不可避免增加了许多开销:确认、流量控制、计时器及连接<br>管理等。</p><h3 id="1、TCP协议的特点"><a href="#1、TCP协议的特点" class="headerlink" title="1、TCP协议的特点"></a>1、TCP协议的特点</h3><ul><li>1)、TCP是面向连接 (<strong>虚连接</strong>) 的传输层协议；(类似打call)</li><li>2)、每一条TCP连接只能有两个端点，每一条TCP连接<strong>只能是点对点的</strong>；</li><li>3)、TCP提供可靠交付的服务，无差错、不丢失、不重复、按序到达；(可靠有序，不丢不重)</li><li>4)、TCP提供<strong>全双工通信</strong>。<ul><li>“<strong>发送缓存</strong>“ : 准备发送的数据 &amp; 已发送但尚未收到确认的数据；</li><li>“<strong>接收缓存</strong>“ : 按序到达但尚未被接受应用程序读取的数据 &amp;不按序到达的数据；</li></ul></li><li>5)、TCP面向字节流。TCP把应用程序交下来的数据看成仅仅是一连串的无结构的字节流。流: 流入到进程或从进程流出的字节序列。</li><li>6)、TCP 不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系；但接收方应用程序收到的字节流必须和发送方应用程序发出的字节流完全一样；</li><li>7)、TCP 对应用进程一次把多长的报文发送到TCP 的缓存中是不关心的。 <strong>TCP 根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段应包含多少个字节</strong>（UDP 发送的报文长度是应用进程给出的）。</li></ul><h3 id="2、TCP连接"><a href="#2、TCP连接" class="headerlink" title="2、TCP连接"></a>2、TCP连接</h3><p>TCP 连接的端点不是主机，不是主机的IP 地址，不是应用进程，也不是运输层的协议端口。TCP 连接的端点叫做<strong>套接字 (socket) 或插口</strong>。<br> <strong>端口号拼接到 (contatenated with) IP 地址即构成了套接字</strong>。</p><p>套接字 <code>socket = (IP地址: 端口号)</code>。</p><p><strong>每一条 TCP 连接唯一地被通信两端的两个端点（即两个套接字）所确定</strong>。</p><p>TCP 连接<code>::= {socket1, socket2} = { (IP1: port1)，(IP2: port2) }</code></p><p>同一个 IP 地址可以有多个不同的 TCP 连接。</p><p>同一个端口号也可以出现在多个不同的 TCP 连接中。</p><h3 id="3、TCP首部格式"><a href="#3、TCP首部格式" class="headerlink" title="3、TCP首部格式"></a>3、TCP首部格式</h3><p>首部格式:</p><p><div align="center"> <img src="/images/5_11.png" width="670"></div><br></p><p>相关字段解释(对于理解TCP很重要)</p><ul><li>序号: 在一个TCP连接中传送的字节流中的每一个字节都按顺序编号，本字段表示本报文段所发送数据的第一个字节的序号，例如发送报文段<code>1-2-3</code>，则序号是<code>1</code>。</li><li>确认号: <strong>期望收到对方下一个报文段的第一个数据字节的序号</strong>。若确认号为N,则证明到序号N-1为止的所有数据都已正确收到。例如 B 正确收到 A 发送来的一个报文段，序号为 301，携带的数据长度为 100 字节，因此 B 期望下一个报文段的序号为 401，B 发送给 A 的确认报文段中确认号就为 401；</li><li>数据偏移(<strong>首部长度</strong>) : TCP报文段的数据起始处距离TCP报文段的起始处有多远，以4B位单位，即1个数值是4B。</li><li>6个控制位。<ul><li><strong>紧急位URG</strong> : URG=1时，标明此报文段中有紧急数据，是高优先级的数据，应尽快传送，不用在缓存里排队，配合<strong>紧急指针字段</strong>使用；</li><li><strong>确认位ACK</strong> : ACK=1时确认号有效，在连接建立后所有传送的报文段都必须把ACK置为1；</li><li><strong>推送位PSH</strong> : PSH=1时，<strong>接收方尽快交付接收应用进程，不再等到缓存填满再向上交付</strong>；</li><li><strong>复位RST</strong> : RST=1时，表明TCP连接中出现严重差错，必须释放连接，然后再<strong>重新建立</strong>传输链接；</li><li><strong>同步位SYN</strong> : SYN=1时，表明是一个连接请求/连接接受报文；</li><li><strong>终止位FIN</strong> : FIN=1时，表明此报文段发送方数据已发完，<strong>要求释放连接</strong>。</li></ul></li><li><strong>窗口</strong> ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</li><li>检验和: 占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。 </li><li>紧急指针: URG = 1时才有意义，指出本报文段紧急数据的字节数；</li><li>选项: 最大报文段长度MSS、窗口扩大、时间戳、时间确认….；</li></ul><blockquote><p>MSS (Maximum Segment Size)是 TCP 报文段中的数据字段的最大长度。<strong>数据字段加上 TCP 首部才等于整个的 TCP 报文段</strong>。所以，MSS是 <code>TCP 报文段长度 -  TCP 首部长度</code>；</p></blockquote><p>捕获的TCP报文段:</p><p><img src="/images/5_12.png" alt="5_12.png"></p><h3 id="4、TCP和UDP的区别"><a href="#4、TCP和UDP的区别" class="headerlink" title="4、TCP和UDP的区别"></a>4、TCP和UDP的区别</h3><ul><li>1、TCP面向连接（如打电话要先拨号建立连接）；UDP是无连接的，即发送数据之前不需要建立连接。</li><li>2、TCP提供可靠的服务。也就是说，通过TCP连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP尽最大努力交付，即不保证可靠交付。</li><li>3、TCP面向字节流，实际上是TCP把数据看成一连串无结构的字节流；UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）。</li><li>4、每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信。</li><li>5、TCP首部开销20字节；UDP的首部开销小，只有8个字节。</li><li>6、TCP的逻辑通信信道是全双工的可靠信道；UDP则是不可靠信道。</li></ul><h2 id="三、TCP连接管理"><a href="#三、TCP连接管理" class="headerlink" title="三、TCP连接管理"></a>三、TCP连接管理</h2><h3 id="1、TCP的连接建立"><a href="#1、TCP的连接建立" class="headerlink" title="1、TCP的连接建立"></a>1、TCP的连接建立</h3><h4 id="1-、三次握手"><a href="#1-、三次握手" class="headerlink" title="1)、三次握手"></a>1)、三次握手</h4><p>TCP连接传输三个阶段:</p><ul><li>连接建立；</li><li>数据传送；</li><li>连接释放；</li></ul><p>TCP连接的建立采用客户端服务器方式，主动发起连接建立的应用进程叫做客户端(A)，而被动等待连接建立的应用进程叫服务器(B)。</p><p>假设运行在一台主机(客户)上的一个进程想与另一台主机（服务器）上的一个进程建立一条连接，客户应用进程首先通知客户TCP，他想建立一个与服务器上某个进程之间的连接，客户中的TCP会用以下步骤与服务器中的TCP建立一条TCP连接:</p><p><div align="center"><img src="/images/5_13.png"></div><br></p><p>步骤:</p><ul><li>1)、A 向 B 发送连接请求报文段，SYN=1，ACK=0，选择一个初始的序号 seq = x；</li><li>2)、B 收到连接请求报文段，，如果同意建立连接，服务器为该TCP连接分配缓存和变量，向 A 发送连接确认报文段，SYN=1，ACK=1，确认号<code>ack</code>为 <code>x+1</code>，同时也选择一个初始的序号 seq = y (随机)；</li><li>3)、A 收到 B 的连接确认报文段后，为该TCP连接分配缓存和变量，同时还要向 B 发出确认，ACK = 1，确认号为 ack = y+1，序号为 <code>seq = x+1</code>(接上一开始的<code>x</code>)；(SYN = 0，因为只有在连接请求和连接请求接受的时候才会置为1)；</li><li>4)、最后，B收到A确认报文，状态变为ESTABLISHED(连接建立)，双方就可以进行双向通信了；</li></ul><p>实战:</p><p>(1)、第一次握手</p><p><div align="center"><img src="/images/5_14.png" width></div><br></p><p>(2)、第二次握手</p><p><div align="center"><img src="/images/5_15.png" width></div><br></p><p>(3)、第三次握手</p><p><div align="center"><img src="/images/5_16.png" width></div><br></p><h4 id="2-、为什么TCP连接需要三次握手，两次不可以吗，为什么"><a href="#2-、为什么TCP连接需要三次握手，两次不可以吗，为什么" class="headerlink" title="2)、为什么TCP连接需要三次握手，两次不可以吗，为什么?"></a>2)、为什么TCP连接需要三次握手，两次不可以吗，为什么?</h4><p>主要是 : <strong>为了防止已失效的连接请求报文段突然又传送到了服务端，占用服务器资源</strong> 。(A是客户端，B是服务器)</p><p>现假定出现一种异常情况，即A发出的第一个连接请求报文段并没有丢失，而是在某些网络节点长时间滞留了，以致延误到连接释放以后的某个时间才到B。本来这是一个已失效的报文段，但是B收到此失效的连接请求报文段后，就误认为是A又发出一次新的连接请求。于是就向A发出确认报文段，同意建立连接。假定不采用三次握手，那么只要B发出确认，新的连接就建立了。</p><p>由于现在A并没有发出建立连接的请求，因此不会理睬B的确认，也不会向B发送数据。但B却以为新的运输连接已经建立了，并一直等待A发来数据。B的许多资源就这样白白浪费了。</p><p>采用三次握手的办法可以防止上述现象的发生。例如在刚才的情况下，A不会向B的确认发出确认。B由于收不到确认，就知道A并没有要求建立连接。</p><h4 id="3-、SYN攻击"><a href="#3-、SYN攻击" class="headerlink" title="3)、SYN攻击"></a>3)、SYN攻击</h4><p>SYN洪泛攻击发生在OSI第四层，这种方式利用TCP协议的特性，就是三次握手。<strong>攻击者发送TCP SYN，SYN是TCP三次握手中的第一个数据包，而当服务器返回ACK后，该攻击者就不对其进行再确认，那这个TCP连接就处于挂起状态，也就是所谓的半连接状态</strong>，服务器收不到再确认的话，还会重复发送ACK给攻击者。这样更加会浪费服务器的资源。攻击者就对服务器发送非常大量的这种TCP连接，由于每一个都没法完成三次握手，所以在服务器上，这些TCP连接会因为挂起状态而消耗CPU和内存，最后服务器可能死机，就无法为正常用户提供服务了。</p><h3 id="2、TCP的连接释放"><a href="#2、TCP的连接释放" class="headerlink" title="2、TCP的连接释放"></a>2、TCP的连接释放</h3><h4 id="1-、四次挥手"><a href="#1-、四次挥手" class="headerlink" title="1)、四次挥手"></a>1)、四次挥手</h4><p>过程:</p><p><img src="/images/5_17.png" alt="5_17.png"></p><p>数据传输结束后，通信的双方都可释放连接。现在 A 的应用进程先向其 TCP <strong>发出连接释放报文段</strong>，并停止再发送数据，主动关闭 TCP连接。</p><ul><li>A 把连接释放报文段首部的 FIN = 1，其序号 seq = u，等待 B 的确认。</li><li>B 发出确认(会送一个确认报文段)，ACK = 1，确认号 ack = u+1，而这个报文段自己的序号 seq = v(随机)。（TCP 服务器进程通知高层应用进程）</li><li>从 A 到 B 这个方向的连接就释放了，TCP 连接处于<strong>半关闭状态</strong>。A 不能向 B 发送数据；<strong>B 若发送数据，A 仍要接收</strong>。</li><li>当 B 不再需要连接时，发送连接释放请求报文段，FIN=1，ACK =1，seq = w(随机)，确认号ack = u + 1(为什么确认号是一样的，因为在这段时间内，A没有发送数据) (这时B进入<code>LAST-ACK</code>(最后确认阶段))。</li><li>A 收到后发出确认，ACK =1, seq = u + 1（因为FIN要消耗一个序号，所以从u+1开始），进入 TIME-WAIT 状态，等待 2 MSL（2*2 = 4 mins）时间后释放连接。</li><li>B 收到 A 的确认后释放连接。</li></ul><h4 id="2-、四次挥手的原因"><a href="#2-、四次挥手的原因" class="headerlink" title="2)、四次挥手的原因"></a>2)、四次挥手的原因</h4><p>因为TCP有个半关闭状态，假设A、B要释放连接，那么A发送一个释放连接报文给B，B收到后发送确认，<strong>这个时候A不发数据，但是B如果发数据A还是要接受，这叫半关闭</strong>。然后B还要发给A连接释放报文，然后A发确认，所以是4次。</p><p>客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。<strong>这个状态是为了让服务器端发送还未传送完毕的数据</strong>，传送完毕之后，服务器会发送 FIN 连接释放报文。 </p><p>在tcp连接握手时为何ACK是和SYN一起发送，这里ACK却没有和FIN一起发送呢。原因是因为tcp是<strong>全双工模式</strong>，<strong>接收到FIN时意味将没有数据再发来，但是还是可以继续发送数据。</strong></p><h4 id="3-、为什么A在TIME-WAIT状态必须等待2MSL的时间内？"><a href="#3-、为什么A在TIME-WAIT状态必须等待2MSL的时间内？" class="headerlink" title="3)、为什么A在TIME-WAIT状态必须等待2MSL的时间内？"></a>3)、为什么A在TIME-WAIT状态必须等待2MSL的时间内？</h4><p>MSL是<code>Maximum Segment Lifetime</code>英文的缩写，中文可以译为 “报文最大生存时间”，他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。2MSL = 2*2mins = 4mins<br>客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：</p><ul><li><strong>确保最后一个确认报文段能够到达B</strong>。如果 B 没收到 A 发送来的确认报文段，那么就会重新发送连接释放请求报文段，接着 A 重传一次确认，重新启动 2MSL 计时器。A 等待一段时间就是为了处理这种情况的发生。</li><li>等待一段时间是为了让本连接持续时间内所产生的所有报文段都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文段。</li></ul><h3 id="3、三次握手和四次挥手涉及的状态"><a href="#3、三次握手和四次挥手涉及的状态" class="headerlink" title="3、三次握手和四次挥手涉及的状态"></a>3、三次握手和四次挥手涉及的状态</h3><p>三次握手</p><ul><li>CLOSED：初始状态。</li><li>LISTEN：服务器处于监听状态。</li><li>SYN_SEND：客户端socket执行CONNECT连接，发送SYN包，进入此状态。</li><li>SYN_RECV：服务端收到SYN包并发送服务端SYN包，进入此状态。</li><li>ESTABLISH：表示连接建立。客户端发送了最后一个ACK包后进入此状态，服务端接收到ACK包后进入此状态。</li></ul><p>四次挥手:</p><ul><li>FIN_WAIT_1：终止连接的一方（通常是客户机）发送了FIN报文后进入。等待对方FIN。</li><li>CLOSE_WAIT：（假设服务器）接收到客户机FIN包之后等待关闭的阶段。在接收到对方的FIN包之后，自然是需要立即回复ACK包的，表示已经知道断开请求。但是本方是否立即断开连接（发送FIN包）取决于是否还有数据需要发送给客户端，若有，则在发送FIN包之前均为此状态。</li><li>FIN_WAIT_2：此时是半连接状态，即有一方要求关闭连接，等待另一方关闭。客户端接收到服务器的ACK包，但并没有立即接收到服务端的FIN包，进入FIN_WAIT_2状态。</li><li>LAST_ACK：服务端发动最后的FIN包，等待最后的客户端ACK响应，进入此状态。</li><li>TIME_WAIT：客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，在此之后的2MSL时间称为TIME_WAIT状态。</li></ul><h2 id="四、TCP可靠传输和流量控制"><a href="#四、TCP可靠传输和流量控制" class="headerlink" title="四、TCP可靠传输和流量控制"></a>四、TCP可靠传输和流量控制</h2><p><strong>所谓流量控制就是让发送发送速率不要过快，让接收方来得及接收。利用滑动窗口机制就可以实施流量控制</strong>。</p><p>原理这就是运用TCP报文段中的窗口大小字段来控制，发送方的发送窗口不可以大于接收方发回的窗口大小。考虑一种特殊的情况，就是接收方若没有缓存足够使用，就会发送零窗口大小的报文，此时发送放将发送窗口设置为0，停止发送数据。</p><p>之后接收方有足够的缓存，发送了非零窗口大小的报文，但是这个报文在中途丢失的，那么发送方的发送窗口就一直为零导致死锁。解决这个问题，<strong>TCP为每一个连接设置一个持续计时器</strong>（persistence timer）。</p><p>只要TCP的一方收到对方的零窗口通知，就启动该计时器，周期性的发送一个零窗口探测报文段。对方就在确认这个报文的时候给出现在的窗口大小</p><p>（<strong>注意：TCP规定，即使设置为零窗口，也必须接收以下几种报文段：零窗口探测报文段、确认报文段和携带紧急数据的报文段</strong>）。</p><p>针对可靠传输和流量控制有三种协议: 停止等待协议、后退N帧协议、选择重传协议。</p><p><img src="/images/3_10.png" alt="3_10.png"></p><h3 id="1、停止等待协议"><a href="#1、停止等待协议" class="headerlink" title="1、停止等待协议"></a>1、停止等待协议</h3><p>停止等待协议也可以在传输层讨论。</p><p>停止等待协议是<strong>为了实现流量控制</strong>。</p><p>简言之: <strong>就是每发送一个分组就停止发送，等待对方确认，在收到确认后再发送下一个分组</strong>。</p><p>主要分为: <strong>无差错情况和有差错情况</strong>。</p><h4 id="1-、无差错的情况"><a href="#1-、无差错的情况" class="headerlink" title="1)、无差错的情况"></a>1)、无差错的情况</h4><p><img src="/images/3_12.png" alt="3_12.png"></p><p>这里应注意以下三点。</p><ul><li>第一，A 在发送完一个分组后，必须<strong>暂时保留已发送的分组的副本</strong>(发生超时重传时使用)。只有在收到相应的确认后才能清除暂时保留的分组副本。</li><li>第二，<strong>分组和确认分组都必须进行编号</strong>。这样才能明确是哪一个发送出去的分组收到了确认，而哪一个分组还没有收到确认。</li><li>第三，超时计时器设置的重传时间应当比数据分组传输的平均往返时间(RTT)更长一些。</li></ul><blockquote><p>ACK (Acknowledgement）即是确认字符，在数据通信中，接收站发给发送站的一种传输类控制字符。表示发来的数据已确认接收无误。</p><p>在TCP/IP协议中，如果接收方成功的接收到数据，那么会回复一个ACK数据。通常ACK信号有自己固定的格式,长度大小,由接收方回复给发送方。</p></blockquote><h4 id="2-、有差错的情况"><a href="#2-、有差错的情况" class="headerlink" title="2)、有差错的情况"></a>2)、有差错的情况</h4><p>又可以分为两种:</p><ul><li><p>数据帧丢失或者检验到帧出错；</p></li><li><p>ACK丢失；</p></li><li>ACK迟到；</li></ul><p>数据帧丢失的情况:</p><p><img src="/images/3_13.png" alt="3_13.png"></p><p>ACK丢失和ACK迟到:</p><p><img src="/images/3_14.png" alt="3_14.png"></p><h4 id="3-、缺点"><a href="#3-、缺点" class="headerlink" title="3)、缺点"></a>3)、缺点</h4><p>信道利用率太低:</p><ul><li>大部分时间都在路上；</li><li>即RTT（传输往返时延）太长；</li></ul><p><img src="/images/3_15.png" alt="3_15.png"></p><p>针对上面停止等待协议的缺点，于是就有了在传输数据时的流水线发送数据，也就引出了两种协议:</p><ul><li>后退N帧协议；</li><li>选择重传协议；  </li></ul><p>解决停等协议的流水线解决方案:</p><p><img src="/images/3_16.png" alt="3_16.png"></p><h3 id="2、后退N帧协议-ARQ"><a href="#2、后退N帧协议-ARQ" class="headerlink" title="2、后退N帧协议(ARQ)"></a>2、后退N帧协议(ARQ)</h3><p>用图来看一下步骤:</p><p><div align="center"> <img src="/images/3_17.png" width></div><br></p><p><div align="center">  <img src="/images/3_18.png"></div><br></p><p>在这个过程中，发送方可以分成几个部分:</p><ul><li>发送完被确认的；</li><li>已经发送但等待确认的；</li><li>还能发送的；</li><li>还不能发送的；</li></ul><h4 id="1-、GBN发送方必须做的三件事"><a href="#1-、GBN发送方必须做的三件事" class="headerlink" title="1)、GBN发送方必须做的三件事"></a>1)、GBN发送方必须做的三件事</h4><p>1)、上层的调用</p><p>上层要发送数据时，发送方先检查发送窗口是否已满，如果未满，则产生一个帧并将其发送， 如果窗口已满，<br>发送方只需将数据返回给上层，暗示上层窗口已满。上层等一会再发送。 (实际实现中，发送方可以缓存这<br>些数据，窗口不满时再发送帧) 。</p><p>2)、收到了一个ACK (重要)</p><p>GBN协议中，对n号帧的确认采用<strong>累积确认</strong>的方式，<strong>标明接收方已经收到n号帧和它之前的全部帧</strong>。</p><p>3)、超时事件</p><p><strong>协议的名字为后退N帧/回退N帧</strong>，来源于出现丢失和时延过长帧时发送方的行为。就像在停等协议中一样，<br>定时器将再次用于恢复数据帧或确认帧的丢失。如果出现超时，发送方重传所有已发送但未被确认的帧。</p><h4 id="2-、GBN接收方必须要做的事"><a href="#2-、GBN接收方必须要做的事" class="headerlink" title="2)、GBN接收方必须要做的事"></a>2)、GBN接收方必须要做的事</h4><p>1)、如果正确收到n号帧，并且按序，那么接收方为n帧发送一个ACK，并将该帧中的数据部分交付给上层。</p><p>2)、<strong>其余情况都丢弃帧，并为最近按序接收的帧重新发送ACK。接收方无需缓存任何东西，只需要维护一个信息: expectedseqnum</strong> (下一个按序接收的帧序、我期待的下一个的帧的序号，如果一直没来我就一直丢弃你的不符合的帧) 。</p><blockquote><p>注意发送窗口不能无限大，范围是<code>1 ~ 2^n-1</code>，<code>n</code>是代表用<code>n</code>个比特对帧编号。</p></blockquote><h4 id="3-、GBN总结和注意事项"><a href="#3-、GBN总结和注意事项" class="headerlink" title="3)、GBN总结和注意事项"></a>3)、GBN总结和注意事项</h4><p><img src="/images/3_19.png" alt="3_19.png"></p><p>几个重点:</p><ul><li>累积确认( 偶尔捎带确认)；</li><li><strong>接收方只按顺序接收帧，不按序无情丢弃</strong>；</li><li>确认序列号最大的、按序到达的帧；</li><li><strong>发送窗口最大为 2<sup>n</sup> - 1，接收窗口大小为1</strong>；</li></ul><p><img src="/images/3_20.png" alt="3_20.png"></p><h3 id="3、选择重传协议"><a href="#3、选择重传协议" class="headerlink" title="3、选择重传协议"></a>3、选择重传协议</h3><p>后退N帧协议的缺点 : 有些帧发送的好好的(由于<code>exceptedSeqNum</code>不对)，为什么让我重传呢?</p><p>解决办法:</p><p>设置单个确认，同时加大接收窗口，设置接收缓存，缓存乱序到达的帧。</p><p>基本方法:</p><p><img src="/images/3_21.png" alt="3_21.png"></p><h4 id="1-、SR发送方必须做的三件事"><a href="#1-、SR发送方必须做的三件事" class="headerlink" title="1)、SR发送方必须做的三件事"></a>1)、SR发送方必须做的三件事</h4><p>1)、从上层收到数据后，<strong>SR发送方检查下一个可用于该帧的序号，如果序号位于发送窗口内，则发送数据帧</strong>；否<br>则就像GBN一样，要么将数据缓存，要么返回给上层之后再传输；</p><p>2)、如果收到ACK，加入该帧序号在窗口内，则SR发送方将那个被确认的帧标记为已接收。如果该帧序号是窗口<br>的下界(最左边第一个窗口对应的序号) ，<strong>则窗口向前移动到具有最小序号的未确认帧处</strong>。如果窗口移动了<br>并且有序号在窗口内的未发送帧，则发送这些帧。</p><p>3)、每个帧都有自己的定时器，一个超时时间发生之后只重传一个帧。</p><h4 id="2-、SR接收方必须要做的事"><a href="#2-、SR接收方必须要做的事" class="headerlink" title="2)、SR接收方必须要做的事"></a>2)、SR接收方必须要做的事</h4><p>1)、<strong>SR接收方将确认一个正确接收的帧而不管其是否按序</strong>。<strong>失序的帧将被缓存</strong>，并返回给发送方一个该帧的确认帧【收谁确认谁】，直到所有帧(<strong>即序号更小的帧)</strong>皆被收到为止，这时才可以将一批帧按序交付给上层，然后向前移动滑动口上。</p><p>2)、<strong>如果收到了小于窗口下界的帧，就返回一个ACK，否则就忽略该帧</strong>。</p><h4 id="3-、SR总结和注意事项"><a href="#3-、SR总结和注意事项" class="headerlink" title="3)、SR总结和注意事项"></a>3)、SR总结和注意事项</h4><p><img src="/images/3_22.png" alt="3_22.png"></p><p>SR重点:</p><ul><li>对数据帧逐一确认，收一个确认一个(先来着不拒)；</li><li>只重传出错帧；</li><li>接收方有<strong>缓存</strong>；</li><li>W<sub>发送方</sub> = W<sub>接收方</sub> = 2 <sup>n-1</sup>；</li></ul><p><img src="/images/3_23.png" alt="3_23.png"></p><p>以字节为单位的滑动窗口技术详解（总的流程图）:</p><p><img src="/images/滑动窗口.png" alt="滑动窗口.png"></p><p><strong>窗口是缓存的一部分，用来暂时存放字节流</strong>。发送方和接收方各有一个窗口，<strong>接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小</strong>。</p><p>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。<strong>如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离</strong>，直到左部第一个字节不是已发送并且已确认的状态；</p><p>接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。</p><p>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {1, 2, 4, 5}，其中 {1, 2} 按序到达，而 {4, 5} 就不是，因此只对字节 {1, 2}  进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。</p><blockquote><p>发送缓存用来暂时存放：</p><ul><li>发送应用程序传送给发送方 TCP 准备发送的数据；</li><li>TCP 已发送出但尚未收到确认的数据。</li></ul><p>接收缓存用来暂时存放：</p><ul><li>按序到达的、但尚未被接收应用程序读取的数据；</li><li><strong>不按序到达的数据</strong>。</li></ul></blockquote><h3 id="4、流量控制"><a href="#4、流量控制" class="headerlink" title="4、流量控制"></a>4、流量控制</h3><p><img src="/images/流量控制.png" alt="流量控制.png"></p><blockquote><p>rwnd : Receive Window，即接收窗口。注意TCP的窗口单位是字节，不是报文段。</p></blockquote><p>这个过程主机B进行了三次流量控制，第一次把窗口减小到<code>rwnd = 300</code>，第二次又减到<code>rwnd = 100</code>，最后减到<code>rwnd = 0</code>，即不允许发送方再发送数据了。</p><blockquote><p>可能发生死锁的问题:</p><p>B 向 A 发送了零窗口的报文段后不久，B 的接收缓存又有了一些存储空间。于是 B 向 A 发送了 rwnd =<br>400 的报文段。<br>但这个报文段在传送过程中丢失了。A 一直等待收到B 发送的非零窗口的通知，而 B 也一直等待 A 发送的<br>数据。<br>如果没有其他措施，这种互相等待的死锁局面将一直延续下去。<br>为了解决这个问题，TCP 为每一个连接设有一个<strong>持续计时器</strong> (persistence timer)。</p></blockquote><h2 id="五、TCP拥塞控制"><a href="#五、TCP拥塞控制" class="headerlink" title="五、TCP拥塞控制"></a>五、TCP拥塞控制</h2><h3 id="1、拥塞控制原理"><a href="#1、拥塞控制原理" class="headerlink" title="1、拥塞控制原理"></a>1、拥塞控制原理</h3><p>拥塞控制原理</p><ul><li>在某段时间，若<strong>对网络中某资源的需求超过了该资源所能提供的可用部分</strong>，网络的性能就要变坏——产生拥塞(congestion)。</li><li>出现资源拥塞的条件：<strong>对资源需求的总和  &gt; 可用资源</strong>；</li><li>若网络中有许多资源同时产生拥塞，网络的性能就要明显变坏，整个网络的吞吐量将随输入负荷的增大而下降。</li></ul><p>拥塞控制: 防止过多的数据注入到网络中。</p><p>注意流量控制和拥塞控制的本质区别: <strong>流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度</strong>。</p><p><div align="center"> <img src="/images/5_18.png" width="550"></div><br></p><blockquote><p>rwnd : Receive Window，即接收窗口。接收方根据接受缓存设置的值，并告知给发送方，反映接收方容量。</p><p>cwnd: Congestion Window，即拥塞窗口。发送方根据自己估算的网络拥塞程度而设置的窗口值，反映网络当前容量。</p><p>接收窗口: 是接收方设置的。拥塞窗口: 是发送方设置的</p><p>拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p></blockquote><p><div align="center"> <img src="/images/5_19.png" width="550"></div><br></p><blockquote><p>提供的负载，就是往网络上放的数据的量。</p></blockquote><p>TCP 主要通过四种算法来进行拥塞控制：<strong>慢开始、拥塞避免、快重传、快恢复</strong>。</p><p>虽然 TCP 的窗口基于字节，但是这里按照窗口的大小单位为报文段来讨论。</p><h3 id="2、慢开始和拥塞避免"><a href="#2、慢开始和拥塞避免" class="headerlink" title="2、慢开始和拥塞避免"></a>2、慢开始和拥塞避免</h3><p>慢开始的原理: <strong>由小到大逐渐增大拥塞窗口数值</strong>。每次可以按照收到的确认的个数来判断成功的概率。逐步增大发送方的拥塞窗口 cwnd，可以使分组注入到网络的速率更加合理。发送方每收到一个对新报文段的确认（重传的不算在内）就使 cwnd 加 1。</p><p><div align="center"> <img src="/images/5_20.png" width="650"></div><br></p><p>过程:</p><p><div align="center"> <img src="/images/5_21.png" width="690"></div><br></p><p>发送的最初执行慢开始，令 cwnd=1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …</p><p>注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能也就更高。</p><p>设置一个慢开始阈值 (门限)ssthresh，当 <code>cwnd &gt;= ssthresh</code> 时，进入拥塞避免，每个轮次只将 cwnd 加 1。</p><p>如果出现了超时(最大拥塞窗口)，则令 <code>ssthresh = cwnd/2</code>，然后重新执行慢开始。</p><blockquote><p> 慢开始门限 ssthresh 的用法如下：</p><ul><li>当 cwnd &lt; ssthresh 时，使用慢开始算法。</li><li>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</li><li>当cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞避免算法。</li></ul></blockquote><h3 id="3、快重传和快恢复"><a href="#3、快重传和快恢复" class="headerlink" title="3、快重传和快恢复"></a>3、快重传和快恢复</h3><p>思想: 发送方只要一连收到<strong>三个重复确认</strong>，就知道接收方确实没有收到报文段，因而应当立即进行重传（即“快重传”），这样就不会出现超时，发送方也不就会误认为出现了网络拥塞。</p><p>不难看出，快重传并非取消重传计时器，而是在某些情况下可更早地重传丢失的报文段。</p><p><div align="center"><img src="/images/5_22.png" width"690"></div><br></p><p>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。</p><p>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。</p><p>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令<code>ssthresh = cwnd/2 ，cwnd = ssthresh</code>，注意到此时直接进入拥塞避免。</p><p>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。</p><blockquote><p>注意: </p><p>发送方的发送窗口的上限值应当取为接收方窗口 rwnd 和拥塞窗口 cwnd 这两个变量中较小的一个，即应按以下公式确定：</p><p>发送窗口的上限值 = <code>min {rwnd, cwnd}</code><br>当 rwnd &lt; cwnd 时，是接收方的接收能力限制发送窗口的最大值。<br>当 cwnd &lt; rwnd 时，则是网络的拥塞限制发送窗口的最大值。</p></blockquote><h3 id="4、流量控制和拥塞控制区分"><a href="#4、流量控制和拥塞控制区分" class="headerlink" title="4、流量控制和拥塞控制区分"></a>4、流量控制和拥塞控制区分</h3><ul><li>拥塞控制是一个全局性的过程，涉及到所有的主机、所有的路由器，以及与降低网络传输性能有关的所有因素。</li><li>流量控制往往指在给定的发送端和接收端之间的<strong>点对点</strong>通信量的控制。</li><li>流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</li><li>流量控制属于通信双方协商；拥塞控制涉及通信链路<strong>全局</strong>。</li><li>流量控制需要通信双方各维护一个发送窗、一个接收窗，对任意一方，接收窗大小由自身决定，发送窗大小由接收方响应的TCP报文段中窗口值确定；拥塞控制的拥塞窗口大小变化由<strong>试探性</strong>发送一定数据量数据探查网络状况后而自适应调整。 </li></ul><h3 id="5、超时重传、RTO、RTT"><a href="#5、超时重传、RTO、RTT" class="headerlink" title="5、超时重传、RTO、RTT"></a>5、超时重传、RTO、RTT</h3><ul><li>超时重传：发送端发送报文后若长时间未收到确认的报文则需要重发该报文。可能有以下几种情况：<ul><li>发送的数据没能到达接收端，所以对方没有响应。    </li><li>接收端接收到数据，但是ACK报文在返回过程中丢失。</li><li>接收端拒绝或丢弃数据。</li></ul></li><li>RTO(<code>Retransmission TimeOut</code>)：<strong>从上一次发送数据，因为长期没有收到ACK响应，到下一次重发之间的时间</strong>。就是重传间隔。通常每次重传RTO是前一次重传间隔的两倍，计量单位通常是RTT。例：1RTT，2RTT，4RTT，8RTT……重传次数到达上限之后停止重传。</li><li>RTT (<code>Round Trip Time</code>)：<strong>数据从发送到接收到对方响应之间的时间间隔</strong>，即数据报在网络中一个往返用时。大小不稳定。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计网总结-五-一运输层&quot;&gt;&lt;a href=&quot;#计网总结-五-一运输层&quot; class=&quot;headerlink&quot; title=&quot;计网总结(五)一运输层&quot;&gt;&lt;/a&gt;计网总结(五)一运输层&lt;/h1&gt;&lt;h2 id=&quot;一、概述&quot;&gt;&lt;a href=&quot;#一、概述&quot; class=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算机网络总结（4）</title>
    <link href="https://www.junglezero.top/2019/08/01/%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93%EF%BC%884%EF%BC%89/"/>
    <id>https://www.junglezero.top/2019/08/01/机网络总结（4）/</id>
    <published>2019-08-01T06:26:11.000Z</published>
    <updated>2019-08-02T02:25:03.102Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计网总结-四-一网络层"><a href="#计网总结-四-一网络层" class="headerlink" title="计网总结(四)一网络层"></a>计网总结(四)一网络层</h1><p>先上一张总结图:</p><p><img src="/images/第四章总结脑图.png" alt="第四章总结脑图.png"></p><h2 id="一、数据交换方式"><a href="#一、数据交换方式" class="headerlink" title="一、数据交换方式"></a>一、数据交换方式</h2><p>第一章提到数据交换方式分为电路交换、报文交换、分组交换。</p><p>其中在网络层。分组交换又可以分为<strong>数据报方式和虚电路方式</strong>。</p><p>其中，<strong>数据报方式为网络层提供无连接服务</strong>。<strong>虚电路方式为网路层提供连接服务</strong>。</p><blockquote><p>无连接服务: 不事先为分组的传输确定传输路径，每个分组独立确定传输路径，不同分组传输路径可能不同。</p><p>连接服务: 首先为分组的<strong>传输确定传输路径</strong>(建立连接) ，然后沿该路径传输系列分组，系列分组传输路径相同，传输结束后拆除连接。</p></blockquote><p>几种传输单元在各层的位置:</p><p><img src="/images/4_1.png" alt="4_1.png"></p><p>下面看数据包方式和虚电路交换方式:</p><p><img src="/images/4_2.png" alt="4_2.png"></p><p>对比:</p><p><img src="/images/4_3.png" alt="4_3.png"></p><h2 id="二、IP数据报"><a href="#二、IP数据报" class="headerlink" title="二、IP数据报"></a>二、IP数据报</h2><h3 id="1、IP数据报格式"><a href="#1、IP数据报格式" class="headerlink" title="1、IP数据报格式"></a>1、IP数据报格式</h3><p><img src="/images/4_6.png" alt="4_6.png"></p><p>一个 IP 数据报由首部和数据两部分组成。首部的前一部分是固定长度，共<code>20</code>字节，是所有 IP 数据报必须具有的。在首部的固定部分的后面是一些可选字段，其长度是可变的。 </p><ul><li><p>版本——占 4 位，指 IP 协议的版本。目前的 IP 协议版本号为 4 (即 IPv4)；</p></li><li><p>首部长度——占 4 位，可表示的最大数值是 15 个单位(一个单位为 4 字节)，因此 IP 的首部长度的最大值是 60 字节；</p></li><li><p>总长度——占 16 位，指首部和数据之和的长度，单位为字节，因此数据报的最大长度为 65535 字节。总长度必须不超过最大传送单元 MTU(数据链路层规定)；</p></li><li><p>标识(identification) ——占 16 位，它是一个计数器，用来产生 IP 数据报的标识。；</p></li><li><p>标志(flag) ——占 3 位，目前只有前两位有意义。标志字段的最低位是 MF (More Fragment)。MF = 1 表示后面“还有分片”。MF = 0 表示最后一个分片。标志字段中间的一位是 DF (Don’t Fragment) 。只有当 DF = 0 时才允许分片； </p></li><li><p>片偏移——占13 位，指出：较长的分组在分片后某片在原分组中的相对位置。片偏移以 8 个字节为偏移单位；</p></li><li><p>生存时间——占8 位，记为 TTL (Time To Live)，指示数据报在网络中可通过的路由器数的最大值；</p></li><li><p>协议——占8 位，指出此数据报携带的数据使用何种协议，以便目的主机的 IP 层将数据部分上交给那个处理过程；</p></li><li><p>首部检验和——占16 位，只检验数据报的首部，不检验数据部分。这里不采用 CRC 检验码而采用简单的计算方法。 </p></li></ul><p><img src="/images/4_14.png" alt="在这里插入图片描述"></p><h3 id="2、IP数据报分片"><a href="#2、IP数据报分片" class="headerlink" title="2、IP数据报分片"></a>2、IP数据报分片</h3><p>当IP数据报传送到链路层的时候，如果IP数据报长度超过MTU，就需要分片。</p><p><img src="/images/4_16.png" alt="4_16.png"></p><p>具体的分片过程:</p><p><img src="/images/4_7.png" alt="4_7.png"></p><blockquote><p>中间位 DF(Don’t Fragment)</p><ul><li>DF = 1 ，禁止分片；</li><li>DF = 0，允许分片；</li></ul><p>最低位MF(More Fragment)</p><ul><li>MF = 1，后面”还有分片”；</li><li>MF = 0，代表最后一片/没分片；</li></ul></blockquote><h2 id="三、IP地址"><a href="#三、IP地址" class="headerlink" title="三、IP地址"></a>三、IP地址</h2><h3 id="1、IP地址概念"><a href="#1、IP地址概念" class="headerlink" title="1、IP地址概念"></a>1、IP地址概念</h3><ul><li><code>IP</code> 地址就是给每个连接在互联网上的主机（或路由器）分配一个在全世界范围是唯一的 <code>32</code> 位的标识符，用来定位网络中的计算机和网络设备；</li><li>IP 地址用 <code>32</code> 位二进制来表示， 也就是<code>32</code> 比特， 换算成字节， 就 是 <code>4</code> 个字节。例如一个采用二进制形式的 IP 地址是<code>10101100 00010000 00011110 00111000</code>， 这么长的地址， 处理起来太费劲。于是这些位被分割为<code>4</code>    个部分， 每一部分<code>8</code>位二进制， 中间使用符号 <code>.</code>分开 ，上面的 <code>IP</code> 地址可以表示为<code>172.16.30.56</code>。<code>IP</code> 地址的这种表示法叫做“点分十进制表示法”；</li><li>计算机的 <code>IP</code> 地址由两部分组成， <strong>一部分为网络标识， 一部分为主机标识</strong>；同 一网段的计算机网络部分相同。路由器连接不同网段，负责不同网段之间的数据转发，交换机连接的则是同一网段的计算机；见下图:<br><img src="/images/4_9.png" alt="在这里插入图片描述"></li></ul><blockquote><p>计算机在和其他计算机通信之前， 首先要判断目标 <code>IP</code>  地址和自己的<code>IP</code>  地址是否在一个网段， 这决定了数据链路层的目标 <code>MAC</code> 地址是目标计算机的还是路由器接口的。 </p></blockquote><p><strong>IP地址和硬件地址的区别</strong> </p><p><img src="/images/4_8.png" alt="在这里插入图片描述"></p><h3 id="2、子网掩码"><a href="#2、子网掩码" class="headerlink" title="2、子网掩码"></a>2、子网掩码</h3><ul><li>子网掩码 ( <code>Subnet Mask</code>) 又叫网络掩码、地址掩码，它是一种用来指明一个<code>IP</code>地址的哪些位标识的是主机所在的子网以及哪些位标识的是主机的位掩码。<strong>子网掩码只有一个作用，就是将某个<code>IP</code>  地址划分成网络地址和主机地址两部分</strong>。</li><li>例如: 计算机的 <code>IP</code> 地址是 <code>131.107.41.6</code>,  子网掩码是 <code>255.255.0.0</code>,  计算机所在网段是<code>131.107.0.0</code>。该计算机和远程计算机通信 ，目标 <code>IP</code> 地址只要前面两部分是 <code>131.107</code>就认为和 该计算机在同一个网段；</li></ul><p>通过<code>IP</code>和子网掩码计算网段: </p><p>方法:  IP 地址和子网掩码做<strong>与运算</strong>：</p><p><img src="/images/4_10.png" alt="在这里插入图片描述"></p><p>有关二进制的特殊转换和特征(和划分子网有关系):<br>|二进制|十进制|备注|<br>|  —-  | —-  | —-  |<br>|1000 0000    |128||<br>|1100 0000|192| 1000 0000+ 10 0000 也就是 128 + 64=192|<br>|1110 0000|224| 1000 0000 + 100 0000 + 10 0000 也就是 128  + 64 + 32=224|<br>|1111 0000|240| 128 + 64 + 32 + 16 = 240|<br>|1111 1000|248| 128 + 64 + 32 + 16 + 8 = 248|<br>|1111 1100|252| 128 + 64 + 32 + 16 + 8 + 4 = 252|<br>|1111 1110|254| 128 + 64 + 32+ 16 + 8 + 4 + 2=254|<br>|1111 1111|255| 128 + 64 + 32 + 16 + 8 + 4 + 2 + 1=255|</p><p><img src="/images/4_11.png" alt="在这里插入图片描述"></p><p>一个规律，<strong>如果要你写出十进制转换成二进制后，后n位二进制是多少</strong>: </p><blockquote><ul><li>能够被 <code>2</code> 整除的数， 写成二进制形式， 后一位是 <code>0</code>。如果余数是<code>1</code>,  则最后一位是 <code>1</code>。 </li><li>能够被 <code>4</code>整除的数， 写成二进制形式， 后两位是 <code>00</code>。如果余数是<code>2</code> , 那就把 <code>2</code>写成二进制，后两位是<code>10</code>。</li><li>能够被 <code>8</code> 整除的数， 写成二进制形式， 最后三位是 <code>000</code>。如果余 <code>5</code> , 就把<code>5</code>写成二进制， 后三位是 <code>101</code>。</li><li>能够被 <code>16</code> 整除的数， 写成二进制形式， 最后四位是 <code>0000</code> 。如果余 <code>6</code> ,   就把<code>6</code>写成二进制， 最后四位是 <code>0110</code> 。</li></ul></blockquote><p>我们可以找出规律， 如果让你写出一个十进制数转换成二进制数后面的 <code>n</code> 位二进制数 ，你可以将该数除以 2<sup>n</sup>,    将余数写成 <code>n</code> 位二进制即可。</p><p>举例:  写出十进制数 242 转换成二进制数后的最后 4 位:<br>2<sup>4</sup>   是 <code>16</code> ,  <code>242</code> 除以 <code>16</code>,  余 <code>2</code> ,  将余数写成 4 位二进制，就是 <code>0010</code> 。</p><h3 id="3、IP地址分类"><a href="#3、IP地址分类" class="headerlink" title="3、IP地址分类"></a>3、IP地址分类</h3><p>如图所示: </p><ul><li>A类地址: <strong>网络地址最高位是 <code>0</code> 的地址为 A 类地址</strong>。网络 ID 全 <code>0</code> 不能用，<code>127</code> 作为保留网段，因此 A 类地址的第 1 部分取值范围为 <code>1~126</code>；A 类网络默认子网掩码为<code>255.0.0.0</code>。主机ID 由第 2 部分、第 3 部分和第 4 部分组成，每部分的取值范围为 <code>0~255</code>，共 256 种取值，由排列组合知道，一个 A 类网络主机数量是 <code>256 * 256 * 256=166777216</code>，这里还需减去<code>2</code>，主机 ID 全 0 的地址为网络地址，而主机ID 全 <code>1</code> 的地址为广播地址，如果你给主机 ID 全 <code>1</code> 的地址发送数据包，计算机产生一个数据链路层广播帧，<strong>发送到本网段全部计算机</strong>；</li><li>B类地址: <strong>网络地址最高位是<code>10</code>的地址为B类地址</strong>。IP地址第一部分取值范围为<code>128 ~ 191</code>。B类网络默认子网掩码为 <code>255.255.0.0</code>。主机 ID 由第 3 部分和第 4 部分组成，每个 B 类网络可以容纳的最大主机数量为 <code>256X256-2=65023</code> ；</li><li>C类地址: <strong>网络地址最高位是<code>110</code>的地址为C类地址</strong>。IP地址第一部分取值范围为<code>192 ~ 223</code>。子网掩码是<code>255.255.255.0</code>，主机ID由第4部分组成，每个C类网络可以容纳的最大主机数量为<code>256 - 2 = 254</code>；</li></ul><p><img src="/images/4_12.png" alt="在这里插入图片描述"></p><p> 数轴表示:<img src="/images/4_13.png" alt="在这里插入图片描述"></p><ul><li>一个<code>A</code>类网络的主机数量是<code>256</code><em><code>256</code></em><code>256</code>个，这里还需要减去<code>2</code>，因为主机<code>ID</code>全<code>0</code>的地址为网络地址，而主机<code>ID</code>全<code>1</code>的地址为广播地址，如果给主机<code>ID</code>全1的<code>IP</code>地址发送数据包，这个电脑将产生一个数据链路层广播帧，发送到本网段全部计算机；</li><li>在电脑中，我们只需要写出自己的<code>IP</code>地址，按下<code>TAB</code>键，就能自动将子网掩码补全，这就说明，可以按照前<code>8</code>位来推断是哪一类地址，然后推断子网掩码。子网掩码可以来划分网络部分(<code>net-id</code>)和主机部分(<code>host-id</code>)；</li><li>在同一个局域网上的主机或路由器的IP 地址中的网络号(<code>net-id</code>)必须是一样的。</li><li>路由器总是具有两个或两个以上的 IP 地址。路由器的每一个接口(<code>fastethernet</code>或者<code>serial</code>)都有一个不同网络号的 IP 地址。</li></ul><p><strong>保留的IP地址</strong><br>有些 IP 地址被保留用于某些特殊目的， 网络管理员不能将这些地址分配给计算机。</p><ul><li>主机 <code>ID</code> 全为 0 的地址： 特指某个网段， 比如 <code>192.168. 10.0 255.255.255.0</code>,  指 <code>192.168.10.0</code>网段(<strong>网段也叫网络地址</strong>)；</li><li>主机<code>ID</code> 全为 1 的地址： 特指该网段的全部主机 ，如果你的计算机发送数据包使用主机 ID 全是 1 的 IP  地址， 数据链路层地址用广播地址 <code>FF-FF-FF-FF-FF-FF</code>。同一网段计算机名称解析就需要发送名称解析的广播包。比如你的计算机 lP 地址是<code>192.168.10.10</code> ,  子网掩码是 <code>255.255.255.0</code>, 它要发送一个广播包， 如目标 IP 地址是 <code>192.168.10.255</code> , 帧的目标MAC  地址是 <code>FF-FF-FF-FF-FF-FF</code>，该网段中全部计算机都能收到；</li><li><code>127.0.0.1</code>：  是回送地址， 指本机地址， 一般用作测试使用。回送地址 ( <code>127.x.x.x</code> )  即本机回送地址 ( <code>Loopback Address</code> ) , 指主机 IP 堆栈内部的 IP 地址， 主要用于网络软件测试以及本地机进程间通信， 无论什么程序， 一旦使用回送地址发送数据， 协议软件立即返回， 不进行任何网络传输。任何计算机都可以用该地址访问自己的共享资源或网站，如果  ping该地址能够通， 说明你的计算机的 <code>TCP/IP</code>协议栈工作正常， 即便你的计算机没有网卡，ping <code>127.0.0.1</code> 还是能够通的；</li><li><code>169. 254.0.0</code>： <code>169.254.0.0 ~ 169.254.255.255</code> 实际上是自动私有 IP 地址。 如果计算机无法获取 IP 地址， 对于Windows  2000 以后的操作系统， 则在无法获取 IP  地址时自动配置成 <code>&quot; IP地址： 169.254.x.x &quot;，&quot; 子网掩码：255.255.0.0“</code>，这样可以使所有获取不到IP地址的计算机能够通信；</li></ul><p><strong>私网地址和公网地址</strong></p><p>私网 IP 地址可以被用于私有网络 ，在 lnternet 上没有这些 IP 地址， Internet 上的路由器也没有到私有网络的路由表。<strong>我们在 Internet 上不能访问这些私网地址， 从这一点来说使用私网地址的计算机更加安全 ，也有效地节省了宝贵的公网IP 地址</strong>。使用私网地址的计算机可以通过 <strong>NAT</strong> ( Network Address Translation , 网络地址转换）技术访问Internet。</p><p>下面列出保留的私有IP 地址。</p><ul><li>A 类： <code>10.0.0.0 [255.0.0.0]</code>，  保留了一个 A 类网络。</li><li>B 类： <code>172.16.0.0 [255.255.0.0] ~ 172.31.0.0 [255.255.0.0]</code>,    保留了16个B类网络。</li><li>C 类： <code>192.168.0.0 [255.255.255.0]  ~ 192.168.255.0 [255.255.255.0]</code>，   保留了 256 个C类网络。</li></ul><p>关于<strong>网络地址转换NAT</strong></p><p>由于<strong>路由器对目的地址是私有IP地址的数据包一律不转发</strong>。所以需要使用<code>NAT</code>来使得私有地址访问<code>Internet</code>。</p><p>在专用网链接到因特网的路由器上安装了NAT软件，安装了NAT软件的路由器叫NAT路由器。</p><p><img src="/images/4_18.png" alt="4_18.png"></p><p>IP地址分类总结(<strong>下面的表格重要</strong>):</p><p><img src="/images/4_36.png" alt="4_36.png"></p><p><img src="/images/4_47.png" alt="4_47.png"></p><h3 id="4、子网划分"><a href="#4、子网划分" class="headerlink" title="4、子网划分"></a>4、子网划分</h3><p>子网划分就是<strong>将一个网段等分成多个网段，也就是等分成多个子网</strong>。</p><p>任务:</p><ul><li>确定子网掩码的长度；</li><li>确定子网中第一个可用的IP地址和最后一个可用的IP地址；</li></ul><p>在划分子网后，有些人将原来的网络号(地址)和主机号(地址)变成了三部分，即<strong>网络号、子网号、主机号</strong>：</p><p><img src="/images/4_37.png" alt="4_37.png"></p><p><img src="/images/4_38.png" alt="4_38.png"></p><blockquote><p>例题1:</p><p>已知IP地址是<code>141.14.72.24</code>，子网掩码是<code>255.255.192.0</code>，求网络地址。如果子网掩码是<code>255.255.224.0</code>，求网络地址。</p><p>(1)、答:　网络地址就是直接将子网掩码和IP地址逐位相与，这里只需要将<code>72和192</code>相与:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">01001000</span></span><br><span class="line">&gt; <span class="number">11000000</span></span><br><span class="line">&gt; --------</span><br><span class="line">&gt; <span class="number">01000000</span>   =  <span class="number">64</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>所以: 网络地址是 <code>141.14.64.0</code>。<strong>这里子网号占2位，剩下的主机号占6 + 8 = 14位</strong>。</p><p>(2)、同理:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="number">01001000</span></span><br><span class="line">&gt; <span class="number">11100000</span></span><br><span class="line">&gt; --------</span><br><span class="line">&gt; <span class="number">01100000</span>  = <span class="number">64</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>可见网络地址还是<code>141.14.64.0</code>。<strong>这里子网号占3位，剩下的主机号占5 + 8 = 13位</strong>。</p><p><strong>这个例子说明同样的IP地址可以和不同的子网掩码相与得出不同的网络地址</strong>。</p><p>例题2:</p><p>某主机的IP地址为<code>180.80.77.55</code>，子网掩码为<code>255.255.252.0</code>。若该主机向其所在子网发送广播分组，则目的地址可以是:  (<strong>D</strong>)</p><p>A、 <code>180.80.76.0</code>          B、<code>180.80.76.255</code>        C、<code>180.80.77.255</code>       D、<code>180.80.79.255</code></p><p>首先发现子网掩码是划分了子网的，因为第三位是<code>252</code>，对应二进制是<code>11111100</code>，则可以知道IP地址的<strong>网络号是16位、子网号是6位、主机号是2+8=10位</strong>。</p><p>将<code>77</code>写成二进制<code>01001101</code>，由于子网号是<code>6</code>位，所以我们取掉前<code>6</code>位 即<code>01001100</code>即<code>76</code>，但由于是广播地址，所以后面<code>+11</code>，即<code>01001111 11111111</code>，也就是<code>79.255</code>，即D。</p></blockquote><p>划分后的路由器分组转发算法(<strong>下面(五)路由算法那里也有讲</strong>)</p><ul><li>1、提取目的IP地址；</li><li>2、是否直接交付；</li><li>3、特定主机路由；</li><li>4、检测路由表中有无路径；</li><li>5、默认路由0.0.0.0；</li><li>6、丢弃，报告转发分组出错； </li></ul><h4 id="1-、无分类编址CIDR"><a href="#1-、无分类编址CIDR" class="headerlink" title="1)、无分类编址CIDR"></a>1)、无分类编址CIDR</h4><p><img src="/images/4_39.png" alt="4_39.png"></p><blockquote><p>IP地址后面跟<code>/24</code>表示掩码位是24位，即子网掩码是255.255.255.0的IP地址，其主机位最多有254个。 　<br>子网掩码通常有以下2种格式的表示方法： </p><ul><li>1、通过与IP地址格式相同的点分十进制表示。如：<code>255.0.0.0</code> 或 <code>255.255.255.128</code>等。</li><li>2、在IP地址后加上<code>&quot;/&quot;</code>符号以及<code>1-32</code>的数字，其中<code>1-32</code>的数字表示子网掩码中<strong>网络标识位</strong>的长度 　　如：<code>192.168.1.1/24</code> 的子网掩码也可以表示为<code>255.255.255.0</code>。</li></ul></blockquote><p>下面举几个划分的例子。</p><h4 id="2-、C类地址等分成两个子网"><a href="#2-、C类地址等分成两个子网" class="headerlink" title="2)、C类地址等分成两个子网"></a>2)、C类地址等分成两个子网</h4><p>下面以一个 C 类网络划分为两个子网为例，讲解子网划分的过程。</p><p>如图 所示，某公司有两个部门，每个部门 100 台计算机，通过路由器连接 Internet。给这200台电脑分配一个 C 类网络 <code>192.168.0.0</code>，该网段的子网掩码为 <code>255.255.255.0</code>，连接局域网的路由器接口使用该网段的第一个可用的IP地址 <code>192.168.0.1</code>。</p><p><img src="/images/4_19.png" alt="4_19.png"></p><p>为了安全考虑，打算将这两个部门的计算机分为两个网段，中间使用路由器隔开。计算机数量没有增加，还是 200 台，因此一个 C 类网络的IP地址是足够用的。现在将 <code>192.168.0.0 [255.255.255.0]</code>这个 C 类网络划分成两个子网。</p><p>如图所示，将IP地址的第 4 部分写成二进制形式，子网掩码使用两种方式表示: 二进制和十进制。<strong>子网掩码往右移一位，这样C类地址主机ID 第1位就成为网络位, 该位为 0 是 A子网，该位为1是B子网</strong>。</p><p><img src="/images/4_20.png" alt="4_20.png"></p><p>如图所示，IP 地址的第 4 部分，其值在 <code>0~127</code> 之间的，第 1 位均为 0；其值在 <code>128~255</code>之间的，第 1 位均为 1。分成A、B 两个子网，以 128 为界。现在的子网掩码中的1变成了 25 个，写成十进制就是 255.255.255.128。子网掩码向后移动了 1 位，就划分出 2 个子网。<strong>A和B 两个子网的子网掩码都为255.255.255.128</strong> 。</p><p>A子网可用的地址范围为 <code>192.168.0.1~192.168.0.126</code>，IP 地址 192.168.0.0 由于主机位全为 0，不能分配给计算机使用，如图 所示，<code>192.168.0.127</code> 由于主机位全为 1，也不能分配计算机。</p><p><img src="/images/4_21.png" alt="4_21.png"></p><p>B 子网可用的地址范围为<code>192.168.0.129~192.168.0.254</code>，IP 地址 <code>192.168.0.128</code> 由于主机位全为0，不能分配给计算机使用，IP 地址 <code>192.168.0.255</code> 由于主机位全为 1，也不能分配给计算机。划分成两个子网后网络规划如图所示。</p><p><img src="/images/4_22.png" alt="4_22.png"></p><h4 id="3-、C类地址等分成四个子网"><a href="#3-、C类地址等分成四个子网" class="headerlink" title="3)、C类地址等分成四个子网"></a>3)、C类地址等分成四个子网</h4><p>假如公司有 4 个部门，每个部门有 50 台计算机，现在使用 <code>192.168.0.0/24</code> 这个 C 类网络。从安全考虑，打算将每个部门的计算机放置到独立的网段，这就要求将 <code>192.168.0.0  [255.255.255.0]</code> 这个 C 类网络划分为4个子网，那么如何划分成4 个子网呢?</p><p>如图 所示， 将 <code>192.168.0.0  [255.255.255.0]</code> 网段的地址的第 4 部分写成二进制，要想分成4个子网，需要将子网掩码<strong>往右移动两位</strong>，这样第 1 位和第 2 位就变为网络位。<strong>就可以分成4个子网，第 1 位和第2 位为00是A子网，01是B子网，10是C子网，11是D子网</strong>。</p><p><img src="/images/4_23.png" alt="4_23.png"></p><p>A、B、C、D 子网的子网掩码都为 <code>255.255.255.192</code>。</p><ul><li>A子网可用的开始地址和结束地址为 <code>192.168.0.1~192.168.0.62</code>；</li><li>B子网可用的开始地址和结束地址为 <code>192.168.0.65~192.168.0.126</code>；</li><li>C子网可用的开始地址和结束地址为 <code>192.168.0.129~192.168.0.190</code>；</li><li>D子网可用的开始地址和结束地址为 <code>192.168.0.193~192.168.0.254</code>；</li></ul><p>注意: 如图所示，<strong>每个子网的最后一个地址都是本子网的广播地址</strong>，不能分配给计算机使用，如A子网的63、B子网的 127、C子网的191和D子网的 255。</p><p><img src="/images/4_24.png" alt="4_24.png"></p><h4 id="4-、C类地址等分成八个子网"><a href="#4-、C类地址等分成八个子网" class="headerlink" title="4)、C类地址等分成八个子网"></a>4)、C类地址等分成八个子网</h4><p>如果想把一个C类网络等分成 8 个子网，如图所示，子网掩码需要往右移 3 位，才能划分出 8个子网，<strong>第 1 位、第 2 位和第 3 位都变成网络位</strong>。</p><p><img src="/images/4_25.png" alt="4_25.png"></p><p>每个子网的子网掩码都一样，为<code>255.255.255.224</code>。</p><ul><li>A 子网可用的开始地址和结束地址为<code>192.168.0.1 ~ 192.168.0.30</code>；</li><li><p>B 子网可用的开始地址和结束地址为 <code>192.168.0.33 ~ 192.168.0.62</code>；</p></li><li><p>C 子网可用的开始地址和结束地址为 <code>192.168.0.65 ~ 192.168.0.94</code>；</p></li><li><p>D 子网可用的开始地址和结束地址为 <code>192.168.0.97 ~ 192.168.0.126</code>；</p></li><li><p>E 子网可用的开始地址和结束地址为 <code>192.168.0.129 ~ 192.168.0.158</code>；</p></li><li><p>F 子网可用的开始地址和结束地址为 <code>192.168.0.161 ~ 192.168.0.190</code>；</p></li><li><p>G 子网可用的开始地址和结束地址为 <code>192.168.0.193 ~ 192.168.0.222</code>；</p></li><li><p>H 子网可用的开始地址和结束地址为 <code>192.168.0.225 ~ 192.168.0.254</code>；</p></li></ul><p>注意: 每个子网能用的主机 IP地址，都要去掉主机位全 0 和主机位全 1 的地址。 如上图所示，31、63、95、127、159、191、223、255 都是相应子网的广播地址。</p><p>每个子网是原来的了<code>1/2 * 1/2 * 1/2</code>，即3个<code>1/2</code>， 子网掩码往右移 3 位。</p><p>总结: 如果一个子网地址是原来网段的<code>(1/2)^n</code> ，子网掩码就在原网段的基础上后移<code>n</code>位。</p><h4 id="5-、B类地址划分子网"><a href="#5-、B类地址划分子网" class="headerlink" title="5)、B类地址划分子网"></a>5)、B类地址划分子网</h4><p>将<code>131.107.0.0 [255.255.0.0]</code>等分成2个子网。子网掩码往右移动1位，就能等分成两个子网。</p><p><img src="/images/4_28.png" alt="4_28.png"></p><p>这两个子网的子网掩码都是 <code>255.255.128.0</code>。</p><p>先确定 A 子网第一个可用地址和最后一个可用地址，按照下图将主机部分写成二进制，<strong>主机位不能全是 0，也不能全是 1</strong>，然后再根据二进制写出第一个可用地址和最后一个可用地址。同理B也是。</p><p><img src="/images/4_29.png" alt="4_29.png"></p><h4 id="6-、A类地址划分子网"><a href="#6-、A类地址划分子网" class="headerlink" title="6)、A类地址划分子网"></a>6)、A类地址划分子网</h4><p>和 C 类地址和 B 类地址划分子网的规律一样，A 类地址子网掩码往右移动 1 位，也能划分出两个子网。只是写出每个网段第一个和最后一个可用的地址时，需要谨慎。</p><p>下面以 A 类网络 <code>42.0.0.0 [255.0.0.0]</code> 等分成4 个子网为例，写出各个子网的第一个和最后一个可用的IP地址。如图所示，划分出 4 个子网，子网掩码需要右移 2 位。每个子网的子网掩码为<code>255.192.0.0</code>。</p><p><img src="/images/4_26.png" alt="4_26.png"></p><p>参照上图，可以很容易地写出这些子网能够使用的第一个IP地址和最后一个IP地址。</p><ul><li>A子网可用的第一个地址为 <code>42.0.0.1</code>，最后一个可用的地址为<code>42.63.255.254</code>；</li><li>B 子网可用的第一个地址为<code>42.64.0.1</code>，最后一个可用的地址为 <code>42.127.255.254</code>；</li><li>C 子网可用的第一个地址为 <code>42.128.0.1</code>，最后一个可用的地址为 <code>42.191.255.254</code>；</li><li>D 子网可用的第一个地址为 <code>42.192.0.1</code>，最后一个可用的地址为 <code>42.255.255.254</code>；</li></ul><p>具体如图:</p><p><img src="/images/4_27.png" alt="4_27.png"></p><h3 id="5、变长子网划分"><a href="#5、变长子网划分" class="headerlink" title="5、变长子网划分"></a>5、变长子网划分</h3><p>如图所示，有一个 C 类网络 <code>192.168.0.0  [255.255.255.0]</code>，需要将该网络划分成5个网段以满足以下网络需求，该网络中有 3 个交换机，<strong>分别连接 20 台电脑、50 台电脑和 100 台电脑</strong>，路由器之间的连接接口也需要地址，这两个地址也是一个网段，这样网络中一共有 5 个网段。</p><p>如图所示，将 <code>192.168.0.0  [255.255.255.0]</code> 的主机位从 0~255 画一条数轴。</p><p>从 <code>128~255</code> 的地址空间给 100 台电脑的网段比较合适， 该子网的地址范围是原来网络的， 子网掩码往后移 1位，写成十进制形式就是 <code>255.255.255.128</code>。第一个能用的地址是<code>192.168.0.129</code>，最后一个能用的地址是 <code>192.168.0.254</code>。<br>64~128 之间的地址空间给 50 台电脑的网段比较合适，该子网的地址范围是原来的<code>1/2 * 1/2</code>，子网掩码往后移 2 位，写成十进制就是 <code>255.255.255.192</code>。第一个能用的地址是 <code>192.168.0.65</code>，最后一个能用的地址是<code>192.168.0.126</code>。</p><p>32~64之间的地址空间给 20 台电脑的网段比较合适， 该子网的地址范围是原来的<code>1/2 * 1/2 * 1/2</code> ，<br>子网掩码往后移 3 位，写成十进制就是 <code>255.255.255.224</code>。第一个能用的地址是 <code>192.168.0.33</code>，最后<br>一个能用的地址是 <code>192.168.0.62</code>。</p><p><img src="/images/4_30.png" alt="4_30.png"></p><p>当然我们也可以使用以下的子网划分方案，100 台电脑的网段可以使用 <code>0~128</code> 之间的子网，50 台电脑的网段可以使用 <code>128~192</code> 之间的子网, 20 台电脑的网段可以使用 <code>192~224</code> 之间的子网，如图所示。</p><p><img src="/images/4_31.png" alt="4_31.png"></p><p>总结规律: <strong>如果一个子网地址块是原来网段的<code>(1/2) ^ n</code>，子网掩码就在原网段的基础上后移n位，不等长子网，子网掩码也不同</strong>。</p><h3 id="6、超网合并网段"><a href="#6、超网合并网段" class="headerlink" title="6、超网合并网段"></a>6、超网合并网段</h3><p>前面讲的子网划分是将一个网络的主机位当作网络位, 来划分出多个子网。我们也可以将多个网段合并成一个大的网段，合并后的网段称为超网，下面就来讲解合并网段的方法。</p><p>如图所示，某企业有一个网段，该网段有 200 台计算机，使用 <code>192.168.0.0 [255.255.255.0]</code>网段，后来计算机数量增加到 400 台。</p><p><img src="/images/4_32.png" alt="4_32.png"></p><p>在该网络中添加交换机，可以扩展网络的规模，一个C类 IP 地址不够用，再添加一个 C 类地址 <code>192.168.1.0 [255.255.255.0]</code>。这些计算机物理上在一个网段，但是IP地址没在一个网段，即逻辑上不在一个网段。</p><p>如果想让这些计算机之间能够通信，可以在路由器的接口添加这两个 C 类网络的地址作为这两个网段的网关。</p><p>在这种情况下，A 计算机到 B 计算机进行通信，必须通过路由器转发，这样两个子网才能够通信，本来这些计算机物理上在一个网段，还需要路由器转发，可见效率不高。</p><p>有没有更好的办法？，可以让这两个 C 类网段的计算机认为在一个网段，这就需要将<code>192.168.0.0/24</code> 和 <code>192.168.1.0/24</code> 两个 C 类网络合并。如图所示，将这两个网段的 IP地址第 3 部分和第 4 部分写成二进制，可以看到将子网掩码往左移动1位，两个网段的网络部分就一样了，两个网段就在一个网段了。</p><p><img src="/images/4_33.png" alt="4_33.png"></p><p>合并后的网段为 <code>192.168.0.0/23</code>， 子网掩码写成十进制 <code>255.255.254.0</code>，可用地址为<code>192.168.0.1　~　192.168.1.254</code>，网络中计算机的 IP 地址和路由器接口的地址配置，如图所示。</p><p><img src="/images/4_34.png" alt="4_34.png"></p><p><img src="/images/4_35.png" alt="4_35.png"></p><p>有关超网合并的题目: (有一个<strong>最长匹配算法</strong>)</p><p><img src="/images/4_40.png" alt="4_40.png"></p><blockquote><p>附加题目:</p><p>某网络的IP地址空间为<code>192.168.5.0/24</code>，采用定长子网划分，子网掩码为<code>255.255.255.248</code>，则该网络中的最大子网个数、每个子网内的最大可分配地址个数分别是(  <strong>B</strong> ) 。<br>A. 32，8     B. 32，6     C. 8，32     D. 8，30</p><p>答:由于 248 的二进制 <code>11111000</code>，子网号占<code>5</code>位，所以最大可以分配子网的个数<code>2 ^ 5 = 32</code>(注意CIDR中不要去掉全0和全1)。</p><p>而主机位只剩下<code>3</code>位，就是<code>2 ^ 3 - 2 = 6</code>(这里要减去全0和全1)。</p></blockquote><h2 id="四、重要协议"><a href="#四、重要协议" class="headerlink" title="四、重要协议"></a>四、重要协议</h2><p>网络层的四个主要的协议: <code>ARP</code>、<code>IP</code>、<code>ICMP</code>、<code>IGMP</code>。</p><p><img src="/images/4_4.png" alt="在这里插入图片描述"></p><h3 id="1、ARP协议-地址解析协议"><a href="#1、ARP协议-地址解析协议" class="headerlink" title="1、ARP协议(地址解析协议)"></a>1、ARP协议(地址解析协议)</h3><p>ARP是为IP服务的。<code>Address Resolution Protocol</code>。</p><p><img src="/images/4_15.png" alt="在这里插入图片描述"></p><p>由于在实际网络的链路上传送数据帧时，最终必须使用MAC地址。</p><p>ARP协议: <strong>完成主机或路由器IP地址到MAC地址的映射。 解决下一跳走哪的问题</strong>。</p><p>ARP协议使用过程:</p><p><strong>检查ARP高速缓存，有对应表项则写入MAC帧，没有则用目的MAC地址为<code>FF-FF-FF-FF-FF-FF</code>的帧封装并广播ARP请求分组，同一局域网中所有主机都能收到该请求。目的主机收到请求后就会向源主机单播一个ARP响应分组，源主机收到后将此映射写入ARP缓存 (10-20min更新一次)</strong> 。ARP协议是自动进行的。</p><p>先看<strong>源主机和目的主机在同一个网络内的情况</strong>:</p><p>比如1号主机要和3号主机进行通信:</p><p><img src="/images/4_41.png" alt="4_41.png"></p><p>再看<strong>源主机和目的主机不在同一个网络内的情况</strong>:</p><p>则1号主机会先判断一下，即将自己IP和目的IP相与一下，判断在不在同一个网段。</p><p>则需要先查询默认网关的MAC地址，即需要先跳到<code>MAC6</code>，在路由器需要封装，然后从路由器到目的主机再进行ARP转发请求:</p><p>这个过程要进行三次APR请求：①第一次是PC1到路由器1； ②第二次是路由器1到路由器2(因为这里我画的是点到点的，但是实际上第一个路由器可能连着多个路由器)；③ 第三次是路由器2到目的主机PC5。</p><p><img src="/images/4_42.png" alt="4_42.png"></p><p>给个图，<strong>注意如果R1和R2中间是点到点的连接</strong>(中间没有别的路由器)，则不需要ARP协议解析MAC地址。</p><p><img src="/images/4_17.png" alt="4_17.png"></p><blockquote><p>ARP协议4种典型情况:</p><ul><li>1、主机A发给本网络上的主机B: 用ARP找到主机B的硬件地址;</li><li>2、主机A发给另一网络上的主机B: 用ARP找到本网络上一个路由器(网关) 的硬件地址，</li><li>3、路由器发给本网络的主机A: 用ARP找到主机A的硬件地址;</li><li>4、路由器发给另一网络的主机B: 用ARP找到本网络上的一个路由器的硬件地址。</li></ul></blockquote><h3 id="2、DCHP-动态主机设置协议，传输层协议"><a href="#2、DCHP-动态主机设置协议，传输层协议" class="headerlink" title="2、DCHP(动态主机设置协议，传输层协议)"></a>2、DCHP(动态主机设置协议，传输层协议)</h3><p><code>Dynamic Host Configuration Protocol</code>。</p><p>静态主机配置: 例如机房的电脑的配置，你左边同学的配置的IP和你的IP一般是相邻的。</p><p>动态主机配置: 例如我们大学教师上课，是需要经常移动的，到了某个教室，会选择动态分配一个暂用IP。</p><p><img src="/images/4_43.png" alt="4_43.png"></p><h3 id="3、ICMP-网际控制报文协议"><a href="#3、ICMP-网际控制报文协议" class="headerlink" title="3、ICMP(网际控制报文协议)"></a>3、ICMP(网际控制报文协议)</h3><p><code>Internet Control Message Protocol</code>。</p><p> ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会(桥梁作用)。它封装在 IP 数据报中，但是不属于高层协议。主要有两种: <strong>ICMP差错报文、ICMP询问报文</strong>。</p><p><img src="/images/4_44.png" alt="4_44.png"></p><h4 id="1-、ICMP差错报文"><a href="#1-、ICMP差错报文" class="headerlink" title="1)、ICMP差错报文"></a>1)、ICMP差错报文</h4><p>主要有四种:</p><ul><li>1)、终点不可达: 当路由器或主机不能交付数据报时就向源点发送终点不可达报文。</li><li>2)、时间超过: 当路由器收到生存时间<code>TTL=0</code>的数据报时，除丢弃该数据报外，还要向源点发送时间超过报文。当终点在预先规定的时间内不能收到一个数据报的全部数据报片时，就把已收到的数据报片都丢弃，并向源点发送时间超过报文。</li><li>3)、参数问题: 当路由器或目的主机收到的数据报的首部中有的字段的值不正确时，就丢弃该数据报，并向源点发送参数问题报文。</li><li>4)、路由器把改变路由报文发送给主机，让主机知道下次应将数据报发送给另外的路由器(可通过更好的路由) </li></ul><p><img src="/images/4_45.png" alt="4_45.png"></p><h4 id="2-、ICMP询问报文"><a href="#2-、ICMP询问报文" class="headerlink" title="2)、ICMP询问报文"></a>2)、ICMP询问报文</h4><p>也有两种：</p><ul><li>1)、<strong>回送请求和回答报文</strong> :  主机或路由器向特定目的主机发出的询问，收到此报文的主机必须给源主机或路由<br>器发送ICMP回送回答报文。<strong>测试目的站是否可达以及了解其相关状态</strong>；</li><li>2)、<strong>时间戳请求和回答报文</strong> : 请某个主机或路由器回答当前的日期和时间。<strong>用来进行时钟同步和测量时间</strong>。</li></ul><p>一表总结差错报文和询问报文:</p><p><img src="/images/4_46.png" alt="4_46.png"></p><h4 id="3-、ICMP应用"><a href="#3-、ICMP应用" class="headerlink" title="3)、ICMP应用"></a>3)、ICMP应用</h4><p>ICMP有两个应用命令: <code>PING</code>和<code>Traceroute</code>。</p><p><strong>PING</strong></p><p>测试两个主机之间的连通性，<strong>使用了ICMP回送请求和回答报文</strong>。</p><p>Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。</p><p><strong>Traceroute</strong></p><p>跟踪一个分组从源点到终点的路径，<strong>使用了ICMP时间超过差错报告报文</strong>。</p><p>a)、源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文；<br>b)、源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文；<br>c)、不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文；<br>d)、最后源主机就知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间；</p><h3 id="4、IGMP"><a href="#4、IGMP" class="headerlink" title="4、IGMP"></a>4、IGMP</h3><h4 id="1-、IP数据报的三种传输方式"><a href="#1-、IP数据报的三种传输方式" class="headerlink" title="1)、IP数据报的三种传输方式"></a>1)、IP数据报的三种传输方式</h4><p>分为<strong>单播、广播、组播(多播)</strong>。</p><ul><li>单播:用于发送数据包到单个目的地，且每发送一份单播报文都使用一个单播IP地址作为目的地址。是一种<strong>点对点</strong>传输方式。</li><li>广播: 广播是指发送数据包到同一广播域或子网内的所有设备的一种数据传输方式。是一种<strong>点对多点</strong>传输方式。</li><li>组播(多播): 当网络中的某些用户需要特定数据时，<strong>组播数据发送者仅发送一次数据</strong>，借助<strong>组播路由协议</strong>为组播数据包建立<strong>组播分发树</strong>，被传递的数据到达距离用户端尽可能近的节点后才开始复制和分发，是一种<strong>点对多点</strong>传输方式。</li></ul><p><img src="/images/4_56.png" alt="4_56.png"></p><h4 id="2-、IP组播地址"><a href="#2-、IP组播地址" class="headerlink" title="2)、IP组播地址"></a>2)、IP组播地址</h4><p>IP组播地址让源设备能够将分组发送给一组设备。<strong>属于多播组的设备将被分配一个组播组IP地址</strong>(一群共同需求主机的相同标识) 。</p><p>组播地址范围为<code>224.0.0.0一239.255.255.255</code>(D类地址) ，一个D类地址表示一个组播组。<strong>只能用作分组的目标地址。源地址总是为单播地址</strong> 。</p><ul><li>1)、组播数据报也是“尽最大努力交付”，不提供可靠交付，应用于UDP；</li><li>2)、对组播数据报不产生ICMP差错报文；</li><li>3)、并非所有D类地址都可以作为组播地址；</li></ul><h4 id="3-、IGMP"><a href="#3-、IGMP" class="headerlink" title="3)、IGMP"></a>3)、IGMP</h4><p>IGMP 实现如下双向的功能:</p><ul><li>(1)、主机通过 IGMP 通知路由器<strong>希望接收或离开某个特定组播组</strong>的信息。</li><li>(2)、路由器通过 IGMP 周期性地查询局域网内的组播组成员是否处于活动状态，实现所连网</li></ul><p>段组成员关系的收集与维护。</p><p>IGMP工作的两个阶段:</p><ul><li>1)、某主机要加入组播组时，该主机向组播组的组播地址发送一个IGMP报文，声明自己要称为该组的成员。</li></ul><p>本地组播路由器收到IGMP报文后，要利用<strong>组播路由选择协议</strong>把这组成员关系发给因特网上的其他组播路由器。</p><ul><li>2)、本地组播路由器周期性探询本地局域网上的主机，以便知道这些主机是否还是组播组的成员。只要有一个主机对某个组响应，那么组播路由器就认为这个组是活跃的，如果经过几次探询后没有一个主机响应，组播路由器就认为本网络上的没有此组播组的主机，因此就不再把这组的成员关系发给其他的组播路由器。</li></ul><p>ICMP和IGMP都使用<strong>IP数据报</strong>传递报文。</p><p><img src="/images/4_57.png" alt="4_57.png"></p><blockquote><p>组播路由协议:</p><ul><li>目的: 找出以源主机为根节点的组播转发树；</li><li>对不同的多播组对应于不同的多播转发树，同一个多播组，对不同的源点也会有不同的多播转发树。</li></ul></blockquote><h2 id="五、路由算法和路由选择协议"><a href="#五、路由算法和路由选择协议" class="headerlink" title="五、路由算法和路由选择协议"></a>五、路由算法和路由选择协议</h2><h3 id="1、路由器结构"><a href="#1、路由器结构" class="headerlink" title="1、路由器结构"></a>1、路由器结构</h3><p>路由器从功能上可以划分为：<strong>路由选择和分组转发</strong>。</p><p>分组转发结构由三个部分组成：交换结构(<code>Switch fabric</code>)、一组输入端口、一组输出端口。</p><p><img src="/images/4_48.png" alt="4_48.png"> </p><h3 id="2、路由转发分组流程"><a href="#2、路由转发分组流程" class="headerlink" title="2、路由转发分组流程"></a>2、路由转发分组流程</h3><p>流程:</p><ul><li>从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。</li><li>若 N 就是与此路由器直接相连的某个网络地址，则进行<strong>直接交付</strong>；</li><li>若路由表中有目的地址为 D 的<strong>特定主机路由</strong>，则把数据报传送给表中<strong>所指明</strong>的下一跳路由器；</li><li>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所<strong>指明的下一跳路由器；</strong></li><li>若路由表中有一个<strong>默认路由</strong>，则把数据报传送给路由表中所指明的默认路由器；</li><li>报告转发分组出错。</li></ul><h3 id="3、路由算法概括"><a href="#3、路由算法概括" class="headerlink" title="3、路由算法概括"></a>3、路由算法概括</h3><p>静态路由算法和动态路由算法:</p><p><img src="/images/4_49.png" alt="4_49.png"></p><p>分层次的路由选择协议: 分成自治系统内(<code>RIP</code>和<code>OSPF</code>)的和自治系统外(<code>BGP</code>)的。</p><blockquote><p>由于因特网规模很大，许多单位不想让外界知道自己的路由选择协议，但还是想连入因特网。于是有了自治系统<code>AS</code>。</p><p>自治系统AS: 在单一的技术管理下的一组路由器，而这些路由器使用一种AS内部的路由选择协议和共同的度<br>量以确定分组在该AS内的路由，同时还使用一种AS之间的路由协议以确定在AS之间的路由。一个As内的所有网络都属于一个行政单位来管辖，一个自治系统的所有路由器在本自治系统内都必须连通。</p></blockquote><p><img src="/images/4_50.png" alt="4_50.png"></p><h3 id="4、RIP-距离向量"><a href="#4、RIP-距离向量" class="headerlink" title="4、RIP(距离向量)"></a>4、RIP(距离向量)</h3><p><code>Routing Information Protocol</code>，路由信息协议。<strong>RIP其实是应用层的协议</strong>。</p><p>RIP是一种分布式的基于<strong>距离向量</strong>的路由选择协议，是因特网的协议标准，最大优点是简单。</p><p>RIP协议要求网络中每一个路由器都维护<strong>从它自己到其他每一个目的网络的唯一最佳距离记录</strong> (即一组距离) 。</p><p>距离 :  通常为“跳数”，<strong>即从源端口到目的端口所经过的路由器个数，经过一个路由器跳数+1。特别的，从一路</strong><br><strong>由器到直接连接的网络距离为1。RIP允许一条路由最多只能包含15个路由器，因此距离为16表示网络不可达</strong>。所以RIP只适用于小型网络。</p><p>看个路由表例子:</p><p><img src="/images/4_51.png" alt="4_51.png"></p><p>相关问题: <strong>RIP协议和谁交换? 多久交换一次？ 交换什么？</strong></p><ul><li>仅和<strong>相邻路由器</strong>交换信息；</li><li><strong>路由器交换的信息是自己的路由表</strong>；</li><li><strong>每30秒交换一次路由信息</strong>，然后路由器根据新信息更新路由表。若超过180s没收到邻居路由器的通告，则判定邻居没了，并更新自己路由表；</li></ul><p><strong>距离向量算法(重要)</strong>:</p><p><img src="/images/4_52.png" alt="4_52.png"></p><p>例题:</p><p><img src="/images/4_53.png" alt="4_53.png"></p><p>RIP协议报文格式:</p><p><img src="/images/4_54.png" alt="4_54.png"></p><h3 id="5、OSPF-开放式最短路径优先"><a href="#5、OSPF-开放式最短路径优先" class="headerlink" title="5、OSPF(开放式最短路径优先)"></a>5、OSPF(开放式最短路径优先)</h3><p><code>Open Shortest Path First</code>。开放式最短路径优先算法。</p><p>RIP协议当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。且只使用小型网络。而OSPF就是为了克服RIP协议的缺点的。</p><p>开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。</p><p>OSPF 具有以下特点：</p><ul><li>向本自治系统中的<strong>所有路由器发送信息</strong>，这种方法是<strong>洪泛法</strong>(即路由器通过输出端口向所有相邻的路由器发送信息)。</li><li>发送的信息<strong>就是与相邻路由器的链路状态</strong>，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。</li><li><strong>只有当链路状态发生变化时，路由器才会发送信息</strong>。</li></ul><p>所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程<strong>收敛的很快</strong>。</p><h3 id="6、BGP-边界网关"><a href="#6、BGP-边界网关" class="headerlink" title="6、BGP(边界网关)"></a>6、BGP(边界网关)</h3><p>边界网关协议。<code>Border Gateway Protocol</code>。</p><ul><li>和谁交换? : 与其他AS的邻站BGP发言人交换信息；</li><li>交换什么? : <strong>交换的网络可达性的信息</strong>，即要到达某个网络所要经过的一些列AS；</li><li>多久交换? : 发生变化时更新有变化的部分；</li></ul><p><strong>BGP 只能寻找一条比较好的路由，而不是最佳路由</strong>。</p><p><strong>每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息</strong>。</p><p><strong>BGP的邻站是交换整个的BGP路由表，但以后只需要在发生变化时更新有变化的部分</strong>。</p><p><img src="/images/4_55.png" alt="4_55.png"></p><h2 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h2><h3 id="1、数据包传输过程以及简单的静态路由配置实验"><a href="#1、数据包传输过程以及简单的静态路由配置实验" class="headerlink" title="1、数据包传输过程以及简单的静态路由配置实验"></a>1、数据包传输过程以及简单的静态路由配置实验</h3><p><img src="/images/4_5.png" alt="在这里插入图片描述"></p><p>发送过程: </p><ul><li>应用程序准备要传输的文件；</li><li>传输层: 将文件分段 并编号；</li><li>网络层: 添加目标<code>IP</code>地址和源<code>IP</code>地址，路由器根据路由表来选择路径(出口)；</li><li>数据链路层 两种情况： 先使用自己的子网掩码，判断自己在哪个网段，然后判断目标地址在哪个网段， 如果是同一个网段 <code>arp</code>协议广播解析目标IP地址的<code>MAC</code> ；这一层的交换机接收到数字信号，看<code>MAC</code>地址，决定发送到下一个哪个交换机，即数据转发或存储转发。 (交换机看不到<code>ip</code>地址，只能看<code>MAC</code>地址)；</li><li>物理层负责转换成比特流，进行数字信号的传输(注意这一层的集线器只是负责传输比特流)；</li></ul><blockquote><p>数据包的目标 <code>IP</code> 地址决定了数据包最终到达哪一个计算机， 而目标 <code>MAC</code>地址决定了该数据包下一跳由哪个设备接收。</p></blockquote><p>附上路由器<code>Router0</code>和<code>Router1</code>的配置代码<br><code>Router0</code>配置: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Router&gt;en</span><br><span class="line">Router<span class="meta">#conf ter</span></span><br><span class="line">Router(config)<span class="meta">#int f0/0</span></span><br><span class="line">Router(config-<span class="keyword">if</span>)<span class="meta">#no shut</span></span><br><span class="line">Router(config-<span class="keyword">if</span>)<span class="meta">#ip address 10.0.0.1 255.0.0.0</span></span><br><span class="line">Router(config-<span class="keyword">if</span>)<span class="meta">#exit</span></span><br><span class="line">Router(config)<span class="meta">#interface serial 2/0</span></span><br><span class="line">Router(config-<span class="keyword">if</span>)<span class="meta">#no shutdown</span></span><br><span class="line">Router(config-<span class="keyword">if</span>)<span class="meta">#clock rate 64000</span></span><br><span class="line">Router(config-<span class="keyword">if</span>)<span class="meta">#ip address 11.0.0.1 255.0.0.0</span></span><br><span class="line">Router(config-<span class="keyword">if</span>)<span class="meta">#end</span></span><br><span class="line">Router<span class="meta">#show ip route</span></span><br><span class="line">Router<span class="meta">#conf ter</span></span><br><span class="line">Router(config)<span class="meta">#ip route 12.0.0.0 255.0.0.0 11.0.0.2</span></span><br><span class="line">Router<span class="meta">#show ip route</span></span><br></pre></td></tr></table></figure><p><code>Router1</code>路由器配置: </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Router&gt;en</span><br><span class="line">Router<span class="meta">#conf ter</span></span><br><span class="line">Router(config)<span class="meta">#interface fastethernet 0/0</span></span><br><span class="line">Router(config-<span class="keyword">if</span>)<span class="meta">#ip address 12.0.0.1 255.0.0.0</span></span><br><span class="line">Router(config-<span class="keyword">if</span>)<span class="meta">#no shut</span></span><br><span class="line">Router(config-<span class="keyword">if</span>)<span class="meta">#exit</span></span><br><span class="line">Router(config)<span class="meta">#interface serial 2/0</span></span><br><span class="line">Router(config-<span class="keyword">if</span>)<span class="meta">#ip address 11.0.0.2 255.0.0.0</span></span><br><span class="line">Router(config-<span class="keyword">if</span>)<span class="meta">#no shutdown</span></span><br><span class="line">Router(config)<span class="meta">#exit</span></span><br><span class="line">Router<span class="meta">#show ip route</span></span><br><span class="line">Router<span class="meta">#conf ter</span></span><br><span class="line">Router(config)<span class="meta">#ip route 10.0.0.0 255.0.0.0 11.0.0.1</span></span><br><span class="line">Router(config)<span class="meta">#end</span></span><br><span class="line">Router<span class="meta">#show ip route</span></span><br><span class="line">Router<span class="meta">#show running-config</span></span><br></pre></td></tr></table></figure><h3 id="2、IPV6"><a href="#2、IPV6" class="headerlink" title="2、IPV6"></a>2、IPV6</h3><p>解决IPV4不够用的问题。</p><p>注意点：</p><ul><li><strong>IPv6将地址从32位(4B) 扩大到128位(16B)</strong> ，更大的地址空间；</li><li>IPv6将IPv4的校验和字段彻底移除，以减少每跳的处理时间；</li><li>IPv6将IPv4的可选字段移出首部，变成了<strong>扩展首部</strong>，成为灵活的首部格式，路由器通常不对扩展首部进行检查，大大提高了路由器的处理效率。</li><li>IPv6支持即播即用(即自动配置) ，<strong>不需要DHCP协议</strong>。</li><li><strong>IPv6首部长度必须是8B的整数倍，IPv4首部是48B的整数倍</strong>。</li><li>IPv6只能在主机处分片，IPv4可以在路由器和主机处分片；</li></ul><p><img src="/images/4_58.png" alt="4_58.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计网总结-四-一网络层&quot;&gt;&lt;a href=&quot;#计网总结-四-一网络层&quot; class=&quot;headerlink&quot; title=&quot;计网总结(四)一网络层&quot;&gt;&lt;/a&gt;计网总结(四)一网络层&lt;/h1&gt;&lt;p&gt;先上一张总结图:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算机网络总结（3）</title>
    <link href="https://www.junglezero.top/2019/07/31/%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93%EF%BC%883%EF%BC%89/"/>
    <id>https://www.junglezero.top/2019/07/31/机网络总结（3）/</id>
    <published>2019-07-31T14:28:36.000Z</published>
    <updated>2019-08-01T06:21:55.183Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计网总结-三-一数据链路层"><a href="#计网总结-三-一数据链路层" class="headerlink" title="计网总结(三)一数据链路层"></a>计网总结(三)一数据链路层</h1><hr><h2 id="一、概括"><a href="#一、概括" class="headerlink" title="一、概括"></a>一、概括</h2><p>七层模型中所处位置以及涉及知识概括: </p><p><img src="/images/3_1.png" alt="在这里插入图片描述"></p><p>数据链路层使用的信道主要有以下两种类型：</p><ul><li><strong>点对点信道</strong>。这种信道使用一对一的点对点通信方式。</li><li><strong>广播信道</strong>。这种信道使用一对多的广播通信方式，因此过程比较复杂。广播信道上连接的主机很多，因此必须使用专用的共享信道协议来协调这些主机的数据发送。<blockquote><p>结点：主机、路由器；</p><p>帧：链路层的协议数据单元、封装网络层数据报；</p></blockquote></li></ul><p><strong>区分链路与数据链路:</strong></p><ul><li>链路(<code>link</code>):  是一条点到点的物理线路段，中间没有任何其他的交换结点。一条链路只是一条通路的一个组成部分。</li><li>数据链路(<code>data link</code>) : 除了物理线路外，还必须有通信协议来控制这些数据的传输(<strong>逻辑链路</strong>)。若把实现这些协议的硬件和软件加到链路上，就构成了数据链路。现最常用的方法是使用适配器(即网卡)来实现这些协议的硬件和软件。一般的适配器都包括了数据链路层和物理层这两层的功能。</li></ul><h2 id="二、链路层的功能"><a href="#二、链路层的功能" class="headerlink" title="二、链路层的功能"></a>二、链路层的功能</h2><p>三个基本功能: <strong>封装成帧、透明传输、差错检测</strong></p><p>数据链路层在物理层提供服务的基础上向网络层提供服务，其最基本的服务是将源自网络层来的数据<strong>可靠地传输到</strong><br><strong>相邻节点的目标机网络</strong>层。</p><p>其主要作用是<strong>加强物理层传输原始比特流的功能</strong>，将物理层提供的可能出错的物理连接改造成为<strong>逻辑上无差错的数据链路</strong>，使之对网络层表现为一条无差错的链路。</p><ul><li>功能一 : 为网络层提供服务。无确认无连接服务，有确认无连接服务，有确认面向连接服务；</li><li>功能二 : 链路管理，即连接的建立、维持、释放(用于面向连接的服务) ；</li><li>功能三 : 组帧 (封装成帧)；</li><li>功能四 : 流量控制；</li><li>功能五 : 差错控制(帧错/位错)；</li></ul><h3 id="1、封装成帧和透明传输"><a href="#1、封装成帧和透明传输" class="headerlink" title="1、封装成帧和透明传输"></a>1、封装成帧和透明传输</h3><p><strong>点到点信道的数据链路层的协议数据单元 一 帧</strong></p><p><img src="/images/3_2.png" alt="在这里插入图片描述"></p><p><img src="/images/3_3.png" alt="在这里插入图片描述"></p><p>封装成帧:</p><ul><li>封装成帧(framing)就是<strong>在一段数据的前后分别添加首部和尾部</strong>，然后就构成了一个帧。接收端在收到物理层上交的比特流后，就能根据首部和尾部的标记，从收到的比特流中识别帧的开始和结束。</li><li>首部和尾部包含许多的控制信息，他们的重要作用就是进行帧定界；</li></ul><p>帧同步: 接收方应当能从接收到的二进制比特流中区分出帧的起始和终止。</p><p>透明传输:</p><ul><li>指不管所传数据是什么样的比特组合，都应当能在链路上传送；</li><li>因此，链路层就看不见有什么妨碍数据传输的东西；</li></ul><p><strong>组帧的四种方法: 1.字符计数法，2.字符(节) 填充法，3.零比特填充法，4.违规编码法</strong>。</p><p><img src="/images/3_4.png" alt="3_4.png"></p><p>这里简单介绍一下字符计数法和字符填充法:</p><p>字符计数法：</p><p><img src="/images/3_5.png" alt="3_5.png"></p><p>字符填充法:</p><p><div align="center"> <img src="/images/3_6.png" width="700"></div><br></p><blockquote><p>帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入<strong>转义字符</strong>。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。<strong>这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在</strong>。</p></blockquote><h3 id="2、差错检验"><a href="#2、差错检验" class="headerlink" title="2、差错检验"></a>2、差错检验</h3><p>概括来说，传输中的差错都是由于噪声引起的。</p><ul><li>全局性: 由于线路本身电气特性所产生的随机噪声(热噪声)，是信道固有的，随机存在的。解决办法: 提高信噪比来减少或避免干扰。( 对传感器下手)</li><li>局部性: 外界特定的短暂原因所造成的冲击噪声，<strong>是产生差错的主要原因</strong>。解决办法: 通常利用编码技术来解决。</li></ul><p>局部性的又可以分为:</p><p><div align="center"> <img src="/images/3_7.png"></div><br></p><blockquote><p>如果通信质量好，且用有线传输链路，一般会是<strong>无确认无连接服务</strong>。</p><p>如果通信质量差，采用无线传输链路，则会采用<strong>有确认面向连接服务</strong>。</p></blockquote><p>几种处理的方式</p><p><div align="center"> <img src="/images/3_8.png"> </div><br></p><p>检错编码:</p><p><img src="/images/3_9.png" alt="3_9.png"></p><h3 id="3、流量控制"><a href="#3、流量控制" class="headerlink" title="3、流量控制"></a>3、流量控制</h3><p>较高的发送速度和较低的接收能力的不匹配，会造成传输出错，因此流量控制也是数据链路层的一项重要工作。</p><p>数据链路层的流量控制和传输层的流量控制不同：<strong>数据链路层的流量控制是点对点的，而传输层的流量控制是端到端的 </strong>: </p><ul><li>数据链路层流量控制手段: <strong>接收方收不下就不回复确认</strong>；</li><li>传输层流量控制手段: <strong>接收端给发送端一个窗口公告</strong>。</li></ul><p>注意可靠传输和流量控制都和滑动窗口有关:</p><p><img src="/images/3_11.png" alt="3_11.png"></p><p>TCP的滑动窗口主要有两个作用，一是提供TCP的可靠性，二是提供TCP的流控特性。同时滑动窗口机制还体现了TCP面向字节流的设计思路。</p><p>滑动窗口：<br>（一）、“窗口”对应的是一段可以被发送者发送的字节序列，其连续的范围称之为“窗口”；<br>（二）、“滑动”则是指这段“允许发送的范围”是可以随着发送的过程而变化的，变化的方式就是按顺序“滑动”。</p><p>滑动窗口协议是传输层进行流控的一种措施，接收方通过通告发送方自己的窗口大小，从而控制发送方的速度，从而达到防止发送方发送速度过快导致网络故障的目的。<br>滑动窗口的基本原理是：<br>TCP使用窗口机制进行流量控制。当连接建立后，发送方和接收方都要分配一块自己的缓冲区来存储接收的数据，为了防止接收方已经没有缓冲区进行接收而发送方在在继续发送，出现网络拥塞和故障。所以用滑动窗口进行了流控。<br>具体实现：接收方将缓冲区剩余的尺寸和期待接收的下一个字节序号在确认信息中发送给发送方，发送方根据接收方剩余的大小空间来定量的发送合适的数据给接收方。它也是建立在“确认重传”的基础之上。</p><p>滑动窗口的原理图如下所示：</p><p><img src="/upload/pasted-476.png" alt="upload successful"></p><p>窗口的大小属性：</p><p>TCP的window是一个16bit位字段，它代表的是窗口的字节容量，也就是TCP标准窗口最大为2^16-1=65535个字节；另外在TCP的选项字段中还包含了一个TCP窗口的扩展因子，option-kind为3，option-length为3个字节，option-data取值范围0-14。窗口扩大因子用来扩大TCP窗口，可把原来的16bit的窗口，扩大为31bit。</p><p>发送窗口和接收窗口：<br>TCP是双工的协议，会话的双方都可以同时接收、发送数据。TCP会话的双方都各自维护一个“发送窗口”和一个“接收窗口”。其中各自的“接收窗口”大小取决于应用、系统、硬件的限制，但是tcp的传输速率不能大于应用的数据处理能力，否则就会缓冲区淹没。各自的“发送窗口”则取决于对端通告的“接收窗口”，也就是取决于接收的缓冲区的大小。</p><p>发送窗口只有在收到对端对于本段发送窗口内字节的ACK确认，才会移动发送窗口的左边界。<br>接收窗口只有在前面的所有数据确认收到的情况下，才会移动左边的窗口。当在前面还有未接受的字节，而后面的字节已接收的情况下，窗口也不会移动，并不会对后续的字节进行确认。一次确保对端会对这些未收到的数据进行重传。主要涉及到接收端的累积确认接收机制。</p><h2 id="三、介质访问控制"><a href="#三、介质访问控制" class="headerlink" title="三、介质访问控制"></a>三、介质访问控制</h2><p>数据传输时使用的两种链路:</p><ul><li><strong>点对点信道</strong>: 一对一通信。因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。</li><li><strong>广播信道</strong>: 一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA/CD 协议。</li></ul><p>介质访问控制就是解决避免广播信道产生冲突的:</p><p>采取一定的措施，使得两个节点之间的通信不会发生互相干扰的情况。 例如一堆对讲机，不能同时有两个人同时的讲话。</p><p>主要的措施:</p><p><img src="/images/3_24.png" alt="3_24.png"></p><h3 id="1、静态划分信道－信道划分介质访问控制-信道复用技术"><a href="#1、静态划分信道－信道划分介质访问控制-信道复用技术" class="headerlink" title="1、静态划分信道－信道划分介质访问控制-信道复用技术"></a>1、静态划分信道－信道划分介质访问控制-信道复用技术</h3><p>信道划分介质访问控制: 将使用介质的每个设备与来自同一信道上的其他设备的通信隔离开，把时域和<br>频域资源合理地分配给网络上的设备。</p><p><img src="/images/3_25.png" alt="3_25.png"></p><h4 id="1-、频分多路FDM"><a href="#1-、频分多路FDM" class="headerlink" title="1)、频分多路FDM"></a>1)、频分多路FDM</h4><p><img src="/images/3_26.png" alt="3_26.png"></p><h4 id="2-、时分多路TDM"><a href="#2-、时分多路TDM" class="headerlink" title="2)、时分多路TDM"></a>2)、时分多路TDM</h4><p><img src="/images/3_27.png" alt="3_27.png"></p><p>使用频分复用和时分复用进行通信，在通信的过程中主机会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其它用户使用，因此这两种方式对信道的利用率都不高。更好的方法是统计时分复用。</p><p><strong>统计时分复用</strong>:</p><p><img src="/images/3_28.png" alt="3_28.png"></p><h4 id="3-、波分多路WDM"><a href="#3-、波分多路WDM" class="headerlink" title="3)、波分多路WDM"></a>3)、波分多路WDM</h4><p>波分多路复用就是<strong>光的频分多路复用</strong>，在一根光纤中传输多种不同波长(频率) 的光信号，由于波长(频率)<br>不同，所以各路光信号互不干扰，最后再用波长分解复用器将各路波长分解出来。</p><h4 id="4-、码分多路CDM"><a href="#4-、码分多路CDM" class="headerlink" title="4)、码分多路CDM"></a>4)、码分多路CDM</h4><p>码分多址(CDMA) 是码分复用的一种方式。</p><p>1个比特分为多个码片/芯片 (chip) ，每一个站点被指定一个唯一的m位的蕊片序列。<br>发送1时站点发送芯片序列，发送0时发送芯片序列反码(通常把0写成-1) 。</p><h3 id="2、动态划分信道"><a href="#2、动态划分信道" class="headerlink" title="2、动态划分信道"></a>2、动态划分信道</h3><h4 id="1-、随机访问介质访问控制-随机访问MAC协议"><a href="#1-、随机访问介质访问控制-随机访问MAC协议" class="headerlink" title="1)、随机访问介质访问控制(随机访问MAC协议)"></a>1)、随机访问介质访问控制(随机访问MAC协议)</h4><h5 id="a-、ALOHA协议-不听就说，想说就说"><a href="#a-、ALOHA协议-不听就说，想说就说" class="headerlink" title="a)、ALOHA协议(不听就说，想说就说)"></a>a)、ALOHA协议(不听就说，想说就说)</h5><p>分为两种: 纯ALOHA协议和时隙ALOHA协议。</p><p>纯ALOHA协议: 不按时间槽发送，随机重发。想发就发。</p><p>时隙ALOHA协议: 把时间分成若干个相同的时间片，所有用户在时间开始时刻同步接入网络信道，若发生冲突，则必须等到下一个时间片开始时刻再发送。</p><p>纯ALOHA协议比时隙ALOHA协议吞吐量更低，效率更低。</p><h5 id="b-、CSMA协议-先听再说"><a href="#b-、CSMA协议-先听再说" class="headerlink" title="b)、CSMA协议(先听再说)"></a>b)、CSMA协议(先听再说)</h5><p>协议思想: <strong>发送帧之前，监听信道</strong>。发送数据之前要检测一下总线上是否有其他计算机在发送数据。</p><p>具体又可以分为三种：</p><p><img src="/images/3_29.png" alt="3_29.png"></p><p>具体:</p><ul><li>1)、1-坚持CSMA: 空闲则直接传输，不必等待；忙则一直监听，直到空闲马上传输；(可能冲突)</li><li>2)、非坚持CSMA: 空闲则直接传输，不必等待；忙则等待一个随机的时间之后再进行监听；</li><li>3)、p-坚持: 空闲则以<code>p</code>概率直接传输，以<code>1-p</code>概率等待到下一个时间槽再传输；忙则等待一个随机的时间之后再进行监听；</li></ul><p><img src="/images/3_30.png" alt="3_30.png"></p><h5 id="c-、CSMA-CD协议-重点"><a href="#c-、CSMA-CD协议-重点" class="headerlink" title="c)、CSMA/CD协议(重点)"></a>c)、CSMA/CD协议(重点)</h5><p>英文名：<code>Carrier sense multiple access with collision detection</code>。(CSMA/CD)</p><p>主要用于<strong>总线式以太网</strong>。</p><p>CSMA/CD协议思想: <strong>先监听再发送，边监听边发送</strong>。</p><p>CSMA/CD 表示载波监听多点接入 / 碰撞检测。</p><ul><li><strong>载波监听(CS)</strong> ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。</li></ul><ul><li><strong>多点接入(MA)</strong> ：说明这是总线型网络，许多主机以多点的方式连接到总线上。</li><li><strong>碰撞检测(CD)</strong> ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞(冲突检测)。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞(所以适用在半双工网络)。</li></ul><p>传播时延对载波监听的影响:</p><p><img src="/images/3_31.png" alt="3_31.png"></p><p>记端到端的传播时延为 <code>τ</code>，最先发送的站点最多经过 <code>2τ</code> 就可以知道是否发生了碰撞，称 <code>2τ</code> 为 <strong>争用期</strong> 。<strong>只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞</strong>。</p><p>当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 <strong>截断二进制指数退避算法</strong> 来确定。从离散的整数集合 <code>{0, 1, 2, 4 .., (2^k-1)}</code> 中随机取出一个数，记作 <code>r</code>，然后取 <code>r</code> 倍的争用期作为重传等待时间。</p><p>帧的传播时延至少要两倍于信号在总线中的传播时延。</p><p>即 <strong>帧长(bit) / 数据传输速率 &gt;= 2τ</strong>。</p><h5 id="d-、CSMA-CA协议"><a href="#d-、CSMA-CA协议" class="headerlink" title="d)、CSMA/CA协议"></a>d)、CSMA/CA协议</h5><p>英文名: <code>Carrier sense multiple access with collision avoidance</code>。(后面是碰撞<strong>避免</strong>)。</p><p>主要用于<strong>无线网</strong>，可以全面的检测碰撞。</p><p>过程:</p><p>1)、发送数据前，先检测信道是否空闲-空闲则发出<code>RTS</code>(<code>request to send</code>) ，<code>RTS</code>包括发射端的地址、接收端的地址、下一份数据将持续发送的时间等信息。 信道忙则等待。</p><p>2)、接收端收到<code>RTS</code>后，将响应<code>CTS</code> ( <code>clear to send</code>) 。</p><p>3)、发送端收到<code>CTS</code>后，开始发送数据帧，同时<strong>预约信道:</strong> 发送方告知其他站点自己要传多久数据)。</p><p>4)、接收端收到数据帧后，将用<code>CRC</code>(循环冗余)来检验数据是否正确，正确则响应ACK帧-发送方收到ACK就可以进行下一个数据帧的发送，若没有则一直重传至规定重发次数为止（采用<strong>二进制指数退避算法</strong>来确定随机的推迟时间) 。</p><h4 id="2-、轮询访问介质访问控制"><a href="#2-、轮询访问介质访问控制" class="headerlink" title="2)、轮询访问介质访问控制"></a>2)、轮询访问介质访问控制</h4><p>主要有两个: <strong>轮询协议和令牌传递协议</strong>。</p><p><strong>轮询协议</strong>: 主节点轮流“邀请”从属节点发送数据。</p><p><strong>令牌传递协议</strong>: 在所有主机之间，有一个特殊格式的令牌(MAC控制帧，不含任何信息)来控制信道的使用，确保同一时刻只有一个节点独占信道。</p><h2 id="四、局域网和广域网体系结构"><a href="#四、局域网和广域网体系结构" class="headerlink" title="四、局域网和广域网体系结构"></a>四、局域网和广域网体系结构</h2><h3 id="1、局域网"><a href="#1、局域网" class="headerlink" title="1、局域网"></a>1、局域网</h3><p>英文: Local Area Network，简称LAN，<strong>指在某一区域由多态计算机互联组成的计算机组，使用广播信道</strong>。</p><p>决定局域网的主要因素: <strong>网络拓扑、传输介质和介质访问控制方法</strong>。</p><p>局域网拓扑结构有: <strong>星型拓扑、总线型拓扑、环形拓扑、树型拓扑</strong>。</p><p>传输介质: </p><ul><li>有线局域网 常用介质: 双绞线、同轴电缆、光纤</li><li>无线局域网 常用介质: 电磁波</li></ul><p>局域网分类</p><ul><li>1)、以太网，应用最广泛，符合<code>IEE802.3</code>系列标准。逻辑拓扑是总线型，物理拓扑是星型。</li><li>2)、令牌环网: 不用了。</li><li>3)、FDDI网: 双环拓扑。</li><li>4)、ATM网。</li><li>5)、无线局域网(WLAN): 采用<code>IEE802.11</code>标准<br><img src="/images/3_32.png" alt="3_32.png"></li></ul><blockquote><p>MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（<strong>网卡</strong>）。</p><p>一台主机拥有多少个<strong>网络适配器</strong>就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。</p></blockquote><h3 id="2、以太网-属于局域网"><a href="#2、以太网-属于局域网" class="headerlink" title="2、以太网(属于局域网)"></a>2、以太网(属于局域网)</h3><p><strong>以太网是一种星型拓扑结构局域网</strong>。</p><p>早期使用<strong>集线器</strong>进行连接，集线器是一种物理层设备， 作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，<strong>并将其能量强度放大</strong>，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线器同时收到两个不同接口的帧，那么就发生了碰撞()。</p><p>目前以太网使用<strong>交换机替代了集线器</strong>，交换机是一种链路层设备，它不会发生碰撞，<strong>能根据 MAC 地址进行存储转发</strong>。</p><p>以太网帧格式(<strong>图可以看最文章上面那张图的下方</strong>)：</p><ul><li><strong>类型</strong> ：标记上层使用的协议；</li><li><strong>数据</strong> ：长度在 46-1500 之间，如果太小则需要填充；</li><li><strong>FCS</strong> ：帧检验序列，使用的是 CRC 检验方法；</li></ul><p><img src="/images/3_33.png" alt="3_33.png"></p><p>以太网提供<strong>无连接、不可靠</strong>的服务。</p><p>无连接: 发送方和接收方之间无握手过程。</p><p>不可靠: 不对发送方的数据帧编号，接收方不向发送方进行确认，帧错直接丢弃，差错纠正由高层负责。</p><h3 id="3、广域网和PPP协议"><a href="#3、广域网和PPP协议" class="headerlink" title="3、广域网和PPP协议"></a>3、广域网和PPP协议</h3><p>广域网 (<code>WAN</code>，Wide Area Network) ，通常跨接很大的物理范围。</p><p>广域网的通信子网主要使用<strong>分组交换技术</strong>。因特网 (Internet)是世界范围内最大的广域网。</p><p>PPP(Point-to-Point Protocol)协议是目前使用最广泛的数据链路层协议，<strong>是在广域网使用的协议，只支持全双工链路</strong>。</p><p>特点:</p><ul><li>简单: 对于链路层的帧，无需纠错，无需序号，无需流量控制。</li><li>封装成帧: 加上帧定界符</li><li>透明传输: 与帧定界符一样比特组合的数据应该如何处理: 异步线路用字节填充，同步线路用比特填充。</li><li>多种网络层协议: 封装的IP数据报可以采用多种协议。</li><li>多种类型链路”串行/并行，同步/异步，电/光…</li><li>差错检测: 错就丢弃</li><li>检测连接状态 : 链路是否正常工作。</li><li>最大传送单元: <strong>数据部分最大长度MTU</strong>。</li><li>网络层地址协商: 知道通信双方的网络层地址</li></ul><blockquote><p>（1）PPP具有动态分配IP地址的能力，允许在连接时刻协商IP地址；<br>（2）PPP支持多种网络协议，比如TCP/IP、NetBEUI、NWLINK等；<br>（3）PPP<strong>具有错误检测能力，但不具备纠错能力，所以ppp是不可靠传输协议</strong>；</p></blockquote><p>组成部分:</p><p>(1)、高级数据链路控制协议<br>高级数据链路控制协议是将 卫 数据报封装到串行链路的方法。PPP 既支持异步链路 (无奇偶校验的 8 比特数据)，也支持面向比特的同步链路。IP 数据报在 PPP 帧中就是其信息部分，这个信息部分的长度受最大传送单元 MTU 的限制。<br>(2)、链路控制协议<br>链路控制协议(Link Control Protocol，LCP) 用来建立、配置和测试数据链路连接，通信的双方可协商一些选项(进行<strong>身份验证</strong>)。<br>(3)、网络控制协议<br>网络控制协议 NCP (Network Control Protocol) 中的每一个协议支持不同的网络层协议, 如IP、IPv6、DECnet，以及 AppleTalk 等。</p><p><img src="/images/3_34.png" alt="3_34.png"></p><p>PPP 的帧格式：</p><ul><li>F 字段为<strong>帧的定界符</strong></li><li>FCS 字段是使用 CRC 的检验序列</li><li><p>信息部分的长度不超过 1500</p><p><img src="/images/3_35.png" alt="3_35.png"></p></li></ul><h3 id="4、链路层设备"><a href="#4、链路层设备" class="headerlink" title="4、链路层设备"></a>4、链路层设备</h3><p>物理层设备: 中继系统，即转发器（repeater）或集线器（hub）。  </p><p>数据链路层:  即交换机(switch)或网桥（交换机前身）。</p><p><strong>网桥根据MAC帧的目的地址对帧进行转发和过滤</strong>。当网桥收到一个帧时，并不向所有接口转发此帧，而是<br><strong>先检查此帧的目的MAC地址，然后再确定将该帧转发到哪一个接口</strong>，或者是把它丢弃 (即过滤) ，这就是比集线器好的地方。</p><p><img src="/images/3_36.png" alt="3_36.png"> </p><p>集线器既不能分割冲突域也不能分割广播域，它就像一根接口比较多的网线一样。</p><p><img src="/images/3_37.png" alt="3_37.png"></p><p>一个小例题:</p><p><img src="/images/3_38.png" alt="3_38.png"></p><p>关于冲突域和广播域更多可以看<a href="https://blog.csdn.net/gui951753/article/details/79402528" target="_blank" rel="noopener"><strong>这篇博客</strong></a>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计网总结-三-一数据链路层&quot;&gt;&lt;a href=&quot;#计网总结-三-一数据链路层&quot; class=&quot;headerlink&quot; title=&quot;计网总结(三)一数据链路层&quot;&gt;&lt;/a&gt;计网总结(三)一数据链路层&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;一、概括&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算机网络总结（2）</title>
    <link href="https://www.junglezero.top/2019/07/31/%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%BB%E7%BB%93%EF%BC%882%EF%BC%89/"/>
    <id>https://www.junglezero.top/2019/07/31/机网络总结（2）/</id>
    <published>2019-07-31T12:50:30.000Z</published>
    <updated>2019-07-31T14:24:51.516Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计网总结-二-一物理层"><a href="#计网总结-二-一物理层" class="headerlink" title="计网总结(二)一物理层"></a>计网总结(二)一物理层</h1><p>知识总览:</p><p><img src="/images/2_8.png" alt="2_8.png"></p><h2 id="一、物理层基本概念"><a href="#一、物理层基本概念" class="headerlink" title="一、物理层基本概念"></a>一、物理层基本概念</h2><p>简单定义以及涉及相关知识: </p><ul><li>定义: 为传输数据所需要的物理链路创建、维持、拆除，而提供具有机械的，电子的，功能的和规范的特性。简单的说，<strong>物理层确保原始的数据可在各种物理媒体上传输</strong>，即传输数据比特流。</li><li>物理层设计的相关知识点:  数字信号、双绞线 、同轴电缆 、 光纤 、  时分多路 、波分复用 、 编码方式 、模拟信号、  频分多路复用  、  码分复用技术、  全双工 、半双工 、单工通信；</li></ul><p>四大特性:</p><ul><li><strong>机械特性</strong>: 指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置等。</li><li><strong>电器特性</strong>: 指明在接口电缆的各条线上出现的电压的范围；</li><li><strong>功能特性</strong>: 指明某条线上出现的某一电平的电压的意义；</li><li><strong>过程特性</strong>: 定义了在信号线上进行二进制比特流传输的一组操作过程，包括各信号线的工作顺序和时序，使得比特流传输得以完成；</li></ul><h2 id="二、数据通信基础"><a href="#二、数据通信基础" class="headerlink" title="二、数据通信基础"></a>二、数据通信基础</h2><h3 id="1、数据通信模型"><a href="#1、数据通信模型" class="headerlink" title="1、数据通信模型"></a>1、数据通信模型</h3><p>分别看局域网通信模型和广域网通信模型:</p><p><img src="/images/2_1.png" alt="在这里插入图片描述"></p><blockquote><p>不过现在很多用户已经通过<strong>光纤</strong>接入<code>Internet</code>了，这就需要将计算机网卡的数字信号通过<strong>光电转换设备</strong>转换成光信号进行长距离传输，在接收端通过光电转换设备转换成数字信号。</p></blockquote><h3 id="2、数据通信的一些术语"><a href="#2、数据通信的一些术语" class="headerlink" title="2、数据通信的一些术语"></a>2、数据通信的一些术语</h3><p><img src="/images/2_2.png" alt="在这里插入图片描述"></p><h3 id="3、模拟信号和数字信号"><a href="#3、模拟信号和数字信号" class="headerlink" title="3、模拟信号和数字信号"></a>3、模拟信号和数字信号</h3><ul><li>模拟信号: 代表消息的参数的取值是<strong>离散</strong>的，在一定的范围内可以有无限多个不同的取值； </li><li>数字信号: 代表消息的参数的取值是<strong>连续</strong>的；在数字信号中通常用码元(时间间隔相同的符号)来表示一个二进制数字；</li><li>码元: 在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形。(可以表示一、二、三、四位二进制数)；</li><li>模拟信号和数字信号之间的转换；</li></ul><p>看下图: </p><p><img src="/images/2_3.png" alt="在这里插入图片描述"></p><h3 id="4、信道"><a href="#4、信道" class="headerlink" title="4、信道"></a>4、信道</h3><p>信道: 一般用来表示向某一个方向传送信息的媒体。</p><p>按照信号传送方向与时间的关系，数据通信分为三种类型: </p><ul><li>单向通信（单工通信）: 只能有一个方向的通信而没有反方向的交互。</li><li>双向交替通信（半双工通信) :  通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。</li><li>双向同时通信（全双工通信) : 通信的双方可以同时发送和接收信息。</li></ul><p><img src="/images/2_4.png" alt="在这里插入图片描述"></p><h3 id="5、调制"><a href="#5、调制" class="headerlink" title="5、调制"></a>5、调制</h3><p>调制分为两大类：</p><ul><li>基带调制：仅对基带信号的波形进行变换，使它能够与信道特性相适应。变换后的信号仍然是基带信号。把这种过程称为编码 (<code>coding</code>)。</li><li>带通调制：使用载波 (<code>carrier</code>)进行调制，把基带信号的频率范围搬移到较高的频段，并转换为模拟信号，这样就能够更好地在模拟信道中传输（即仅在一段频率范围内能够通过信道） 。</li><li>带通信号：经过载波调制后的信号。</li></ul><p>常用编码方式: </p><ul><li>不归零制：正电平代表 <code>1</code>，负电平代表 <code>0</code>。(效率最高，但是如果发送端发送连续的<code>0</code>或者<code>1</code>，接收端不容易判断码元的边界)；</li><li>归零制：正脉冲代表 <code>1</code>，负脉冲代表 <code>0</code>。</li><li>曼彻斯特编码：位周期中心的向上跳变代表 <code>0</code>，位周期中心的向下跳变代表 <code>1</code>。但也可反过来定义。(<code>1</code>比特需要<code>2</code>码元)</li><li>差分曼彻斯特编码：在每一位的中心处始终都有跳变。位开始边界有跳变代表 <code>0</code>，而位开始边界没有跳变代表 <code>1</code>。</li></ul><p>基本带通调制方法: </p><ul><li>基带信号往往包含有较多的低频成分，甚至有直流成分，而许多信道并不能传输这种低频分量或直流分量。为了解决这一问题，就必须对基带信号进行调制 (<code>modulation</code>)。 </li><li>最基本的二元制调制方法有以下几种：①　调幅(AM)。②调频(FM)。③调相(PM) 。</li></ul><p><img src="/images/2_5.png" alt="在这里插入图片描述"></p><ul><li>从信号波形中可以看出，曼彻斯特 (Manchester) 编码和差分曼彻斯特编码产生的信号频率比不归零制高。</li><li>从自同步能力来看，不归零制不能从信号波形本身中提取信号时钟频率（这叫作没有自同步能力），而曼彻斯特编码和差分曼彻斯特编码具有自同步能力。</li></ul><blockquote><p>不是码元越多越好。若每一个码元可表示的比特数越多，则在接收端进行解调时要正确识别每一种状态就越困难，出错率增加。</p></blockquote><h3 id="6、信道极限容量"><a href="#6、信道极限容量" class="headerlink" title="6、信道极限容量"></a>6、信道极限容量</h3><p>基本概念:</p><ul><li>任何实际的信道都不是理想的，在传输信号时会产生各种失真以及带来多种干扰。 </li><li>影响信道上的数字信息传输速率的因素有两个: <strong>码元的传输速度和每个码元承载的比特信息量</strong>，码元传输的速率越高，或信号传输的距离越远，或传输媒体质量越差，在信道的输出端的波形的失真就越严重。 </li></ul><p>从概念上讲，限制码元在信道上的传输速率的因素有以下两个：</p><ul><li>信道能够通过的频率范围</li><li>信噪比</li></ul><p>①信道能够通过的频率范围</p><ul><li>具体的信道所能通过的频率范围总是有限的。信号中的许多高频分量往往不能通过信道。</li><li>1924年，奈奎斯特 (Nyquist) 就推导出了著名的奈氏准则。<strong>他给出了在假定的理想条件下，为了避免码间串扰，码元的传输速率的上限值</strong>。</li><li>在任何信道中，码元传输的速率是有上限的，否则就会出现码间串扰的问题，使接收端对码元的判决（即识别）成为不可能。</li><li><strong>如果信道的频带越宽，也就是能够通过的信号高频分量越多，那么就可以用更高的速率传送码元而不出现码间串扰</strong>。  (可以通过信道的传输速度，计算码元的最高传输速率) </li></ul><p>②信噪比(香农公式)</p><ul><li>噪声存在于所有的电子设备和通信信道中。噪声是随机产生的，它的瞬时值有时会很大。因此噪声会使接收端对码元的判决产生错误；</li><li>但噪声的影响是相对的。如果信号相对较强，那么噪声的影响就相对较小；</li><li>信噪比就是信号的平均功率和噪声的平均功率之比。常记为 <code>S/N</code>，并用分贝 (<code>dB</code>) 作为度量单位。即：<br>信噪比(<code>dB</code>) = <strong>10 log10(S/N)</strong>   (<code>dB</code>) 。例如，当 S/N = 10 时，信噪比为 10 <code>dB</code>，而当 S/N = 1000时，信噪比为 30 <code>dB</code>。 例如，当 S/N = 10 时，信噪比为 10 dB，而当 S/N = 1000时，信噪比为 30 dB；</li><li>1984年，香农 (Shannon) 用信息论的理论推导出了带宽受限且有高斯白噪声干扰的信道的极限、无差错的信息传输速率（香农公式）。</li><li>信道的极限信息传输速率 C 可表达为：<code>C = W log2(1+S/N)</code>   (<code>bit/s</code>) ；其中，<code>W</code> 为信道的带宽（以 Hz 为单位）；<code>S</code> 为信道内所传信号的平均功率；<code>N</code> 为信道内部的高斯噪声功率。  </li></ul><p>香农公式表明: </p><ul><li>信道的带宽或信道中的信噪比越大，则信息的极限传输速率就越高。 </li><li>只要信息传输速率低于信道的极限信息传输速率，就一定可以找到某种办法来实现无差错的传输。 </li><li>若信道带宽 W 或信噪比 S/N 没有上限（当然实际信道不可能是这样的），则信道的极限信息传输速率 C 也就没有上限。</li><li>实际信道上能够达到的信息传输速率要比香农的极限传输速率低不少。  </li><li>对于频带宽度已确定的信道，如果信噪比不能再提高了，并且码元传输速率也达到了上限值，那么还有办法提高信息的传输速率。这就是：<strong>用编码的方法让每一个码元携带更多比特的信息量</strong>。 </li></ul><h2 id="三、物理层下的传输媒体"><a href="#三、物理层下的传输媒体" class="headerlink" title="三、物理层下的传输媒体"></a>三、物理层下的传输媒体</h2><ul><li>传输媒体也称为传输介质或传输媒介，它就是<strong>数据传输系统中在发送器和接收器之间的物理通路</strong>。</li><li>传输媒体可分为两大类，即导引型传输媒体和非导引型传输媒体。<ul><li>在导引型传输媒体中，<strong>电磁波被导引沿着固体媒体（铜线或光纤）传播</strong>。</li><li>非导引型传输媒体就是指自由空间。<strong>在非导引型传输媒体中，电磁波的传输常称为无线传输</strong>。</li></ul></li></ul><h3 id="1、导引型传输媒体"><a href="#1、导引型传输媒体" class="headerlink" title="1、导引型传输媒体"></a>1、导引型传输媒体</h3><h4 id="1-、双绞线-网线"><a href="#1-、双绞线-网线" class="headerlink" title="1)、双绞线(网线)"></a>1)、双绞线(网线)</h4><ul><li>最常用的传输媒体；</li><li>模拟传输和数字传输都可以使用双绞线，其通信距离一般为几到十几公里。  屏蔽双绞线 <code>STP</code> 无屏蔽双绞线 <code>UTP</code>；</li></ul><p><img src="/images/2_6.png" alt="在这里插入图片描述"></p><h4 id="2-、同轴电缆"><a href="#2-、同轴电缆" class="headerlink" title="2)、同轴电缆"></a>2)、同轴电缆</h4><ul><li>同轴电缆具有很好的抗干扰特性，被广泛用于传输较高速率的数据。</li><li>同轴电缆的带宽取决于电缆的质量。<br>50  同轴电缆 —— LAN / 数字传输常用<br>75  同轴电缆 —— 有线电视 / 模拟传输常用<h4 id="3-、光缆"><a href="#3-、光缆" class="headerlink" title="3)、光缆"></a>3)、光缆</h4></li><li>光纤是光纤通信的传输媒体。</li><li>由于可见光的频率非常高，约为 <code>108</code> MHz 的量级，因此一个光纤通信系统的传输带宽远远大于目前其他各种传输媒体的带宽。</li></ul><p>多模光纤和单模光纤: </p><ul><li>多模光纤 : 可以存在多条不同角度入射的光线在一条光纤中传输。这种光纤就称为多模光纤(适合近距离)。</li><li>单模光纤 :  若光纤的直径减小到只有一个光的波长，则光纤就像一根波导那样，它可使光线一直向前传播，而不会产生多次反射。这样的光纤称为单模光纤。<h3 id="2、非导引型传输媒体"><a href="#2、非导引型传输媒体" class="headerlink" title="2、非导引型传输媒体"></a>2、非导引型传输媒体</h3></li><li>将自由空间称为“非导引型传输媒体”。</li><li>无线传输所使用的频段很广。</li><li>短波通信（即高频通信）主要是靠电离层的反射，但短波信道的通信质量较差，传输速率低。</li><li>微波在空间主要是直线传播。</li><li>传统微波通信有两种方式：①地面微波接力通信；②卫星通信  ；</li></ul><p><img src="/images/2_7.png" alt="在这里插入图片描述"></p><h2 id="四、物理层设备"><a href="#四、物理层设备" class="headerlink" title="四、物理层设备"></a>四、物理层设备</h2><p>两个主要设备:</p><ul><li>中继器；</li><li>集线器；</li></ul><p>中继器：</p><p><img src="/images/2_9.png" alt="2_9.png"></p><p>集线器:</p><p><img src="/images/2_10.png" alt="2_10.png"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计网总结-二-一物理层&quot;&gt;&lt;a href=&quot;#计网总结-二-一物理层&quot; class=&quot;headerlink&quot; title=&quot;计网总结(二)一物理层&quot;&gt;&lt;/a&gt;计网总结(二)一物理层&lt;/h1&gt;&lt;p&gt;知识总览:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/2_8
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>计算机网络总结（1）</title>
    <link href="https://www.junglezero.top/2019/07/28/eInternet1/"/>
    <id>https://www.junglezero.top/2019/07/28/eInternet1/</id>
    <published>2019-07-28T09:18:02.000Z</published>
    <updated>2019-07-30T07:57:54.107Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计网总结-一-一计算机网络和协议"><a href="#计网总结-一-一计算机网络和协议" class="headerlink" title="计网总结(一)一计算机网络和协议"></a>计网总结(一)一计算机网络和协议</h1><hr><h2 id="一、互联网概述"><a href="#一、互联网概述" class="headerlink" title="一、互联网概述"></a>一、互联网概述</h2><ul><li>计算机网络: 由若干节点和连接这些节点的链路组成，网络中的节点可以是计算机、集线器、交换机、或路由器等；</li><li>网络之间可以通过路由器相互连接，这就构成了一个更大范围的计算机网路，这样的网路称为<strong>互连网</strong>，因此互连网是<strong>网路的网路</strong>；</li><li>因特网(互联网):  全球最大的特定互连网；</li></ul><p>注意以下两个意思相差很大的名词 <code>internet</code> 和 <code>Internet</code> [RFC 1208]:</p><ul><li><p>以小写字母 i 开始的 <code>internet</code> (互连网) 是一个通用名词，它泛指由多个计算机网络互连而成的计算机网络。在这些网络之间的通信协议〈即通信规则) 可以任意选择，不一定非要使用<code>TCP/IP</code> 协议；</p></li><li><p>以大写字母 I 开始的 <code>Internet</code> 〈互联网或因特网) 则是一个专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定互连网，它采用 <code>TCP/IP</code> 协议族作为通信的规则，且其前身是美国的 ARPANET；</p></li><li><p>可见，任意把几个计算机网络互连起来〈不管采用什么协议)，并能够相互通信，这样构成的是一个互连网(<code>internet</code>，而不是互联网(<code>Internet</code>)。</p></li></ul><p><img src="/images/1_1.png" alt="在这里插入图片描述"></p><ul><li>路由器（Router），是连接因特网中各局域网、广域网的设备，它会根据信道的情况自动选择和设定路由，以最佳路径，按前后顺序发送信号。</li><li>路由器是互联网络的枢纽，”交通警察”。<strong>路由和交换机之间的主要区别就是交换机发生在OSI参考模型第二层（数据链路层），而路由发生在第三层，即网络层</strong>。这一区别决定了路由和交换机在移动信息的过程中需使用不同的控制信息，所以说两者实现各自功能的方式是不同的。</li><li>路由器（<code>Router</code>）又称网关设备（<code>Gateway</code>）是用于连接多个逻辑上分开的网络，所谓逻辑网络是代表一个单独的网络或者一个子网。当数据从一个子网传输到另一个子网时，可通过路由器的路由功能来完成。因此，路由器具有判断网络地址和选择IP路径的功能。</li><li><strong>交换机是将不同IP地址的电脑连在一起，共享一根网线；路由器是将同一个IP给不同的电脑使用，就像一条大路分成很多条小路。一句话，路由器是接外网的,交换机是接内网的。(交换机没有开关，路由器有开关)</strong></li></ul><p><img src="/images/1_2.png" alt="在这里插入图片描述"></p><hr><h2 id="二、互联网组成"><a href="#二、互联网组成" class="headerlink" title="二、互联网组成"></a>二、互联网组成</h2><h3 id="1、基本组成"><a href="#1、基本组成" class="headerlink" title="1、基本组成"></a>1、基本组成</h3><p>基本组成:</p><ul><li>①边缘部分: 由所有连接在互联网上的主机组成，这部分是用户直接使用的，用来进行通信（传送数据，音频或视频）和资源共享；</li><li>②核心部分: 由大量网络 和连接这些网络的<strong>路由器</strong> 组成，这部分是为边缘部分提供服务的(提供连通性和交换)；</li></ul><p><img src="/images/1_3.png" alt="在这里插入图片描述"></p><p>边缘部分的主机间的通信方式: </p><p><img src="/images/1_4.png" alt="在这里插入图片描述"></p><p><strong>(1)客户程序:</strong></p><ul><li>被用户调用后运行，在通信时主动向远地服务器发起通信(请求服务)。因此，客</li></ul><p>户程序必须知道服务器程序的地址。</p><ul><li>不需要特殊的硬件和很复杂的操作系统。</li></ul><p><strong>(2)服务器程序:</strong></p><ul><li>是一种专门用来提供某种服务的程序，可同时处理多个远地或本地客户的请求。</li><li>系统启动后即自动调用并一直不断地运行着，被动地等待并接受来自各地的客户的</li></ul><p>通信请求。因此，服务器程序不需要知道客户程序的地址。</p><p><strong>客户与服务器的通信关系建立后，通信可以是双向的，客户和服务器都可发送和接收数据。</strong></p><h3 id="2、数据交换方式"><a href="#2、数据交换方式" class="headerlink" title="2、数据交换方式"></a>2、数据交换方式</h3><p><strong>电路交换</strong></p><p><div align="center"> <img src="/images/1_6.png" width="550"></div><br></p><p><strong>分组交换</strong></p><p><div align="center"> <img src="/images/1_7.png" width="750"></div><br></p><p><strong>三种交换方式的比较</strong></p><ul><li>电路交换: 整个报文的比特流连续地从源点直达终点，好像在一个管道中传送。</li><li><p>报文交换: 整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。</p></li><li><p>分组交换 : 单个分组(这只是整个报文的一部分) 传送到相邻结点，存储下来后查找转发表，转发到下一个结点。</p></li></ul><p><div align="center"> <img src="/images/1_8.png" width></div><br></p><p>选择: </p><ul><li>报文交换和分组交换都采用存储转发。</li><li>传送数据量大，且传送时间远大于呼叫时选择电路交换。电路交换传输时延最小。</li><li>从信道利用率看，报文交换和分组交换优于电路交换，其中分组交换时延更小。</li></ul><hr><h2 id="三、计算机网络的性能指标"><a href="#三、计算机网络的性能指标" class="headerlink" title="三、计算机网络的性能指标"></a>三、计算机网络的性能指标</h2><h3 id="1、速率"><a href="#1、速率" class="headerlink" title="1、速率"></a>1、速率</h3><ul><li>网络技术中的速率是指每秒钟传输的比特数量，称为数据率或比特率，速率的单位是<code>bit/s</code>，或<code>b/s</code>(比特每秒)；</li><li>速率较高时，就可以使用kb/s，Mb/s，Gb/s，Tb/s，人们现在所说的10M网速，其实是10Mb/s；</li><li>360等可以显示网速的软件，测试你电脑的那个网速，这里单位是B/秒，大写的B是字节(byte)，8bit = 1byte，也就是说如果测速为3.82MB/s，则下载速率为3.82 * 8Mb/s。</li></ul><h3 id="2、带宽"><a href="#2、带宽" class="headerlink" title="2、带宽"></a>2、带宽</h3><ul><li>带宽用来表示网络通信线路传输数据的能力(数字信道所能传送的最高数据率)，即最高速率；</li><li>比如说家里使用ADSL拨号，有4M带宽、8M带宽，这里说的带宽就是你访问Internet的最高带宽，你家里的带宽由电信运营商控制；</li></ul><h3 id="3、吞吐量"><a href="#3、吞吐量" class="headerlink" title="3、吞吐量"></a>3、吞吐量</h3><ul><li>吞吐量表示在单位时间内通过某个网络或接口的数据量，包括全部上传和下载的流量；</li><li>吞吐量受网络带宽或网络额定速率的限制，计算机的网卡如果连接交换机，网卡就可以工作在全双工模式，即能够同时接收和发送数据；如果计算机的网卡连接的是集线器，网卡就只能工作在半双工模式，即不能同时发送和接收数据；</li></ul><p><img src="/images/1_10.png" alt="在这里插入图片描述"></p><h3 id="4、时延"><a href="#4、时延" class="headerlink" title="4、时延"></a>4、时延</h3><ul><li>时延(delay)是指数据(一个数据包或bit)从网络的一段传送到另一端所需要的时间，是一个很重要的性能指标；</li><li>时延包括: 发送时延、传播时延、处理时延、排队时延；（数据在网络中经历的的总时延就是这四种时延的累加和）；</li></ul><h4 id="1-、发送时延"><a href="#1-、发送时延" class="headerlink" title="1)、发送时延"></a>1)、发送时延</h4><p><img src="/images/1_11.png" alt="在这里插入图片描述"></p><h4 id="2-、传播时延"><a href="#2-、传播时延" class="headerlink" title="2)、传播时延"></a>2)、传播时延</h4><p>传播时延是电磁波在信道中传播一定的距离要花费的时间； </p><p><img src="/images/1_12.png" alt="在这里插入图片描述"></p><h4 id="3-、排队时延和处理时延"><a href="#3-、排队时延和处理时延" class="headerlink" title="3)、排队时延和处理时延"></a>3)、排队时延和处理时延</h4><p><img src="/images/1_13.png" alt="在这里插入图片描述"></p><h4 id="4-、时延带宽积"><a href="#4-、时延带宽积" class="headerlink" title="4)、时延带宽积"></a>4)、时延带宽积</h4><p><img src="/images/1_14.png" alt="在这里插入图片描述"></p><h3 id="5、往返时间"><a href="#5、往返时间" class="headerlink" title="5、往返时间"></a>5、往返时间</h3><p>表示从发送端发送数据开始，到发送端接收到来自接收端的确认(发送端收到确认立即发送确认)，总共经历的时间；</p><h3 id="6、利用率"><a href="#6、利用率" class="headerlink" title="6、利用率"></a>6、利用率</h3><p><img src="/images/1_15.png" alt="在这里插入图片描述"></p><hr><h2 id="四、OSI参考模型以及TCP-IP四层模型、五层协议"><a href="#四、OSI参考模型以及TCP-IP四层模型、五层协议" class="headerlink" title="四、OSI参考模型以及TCP/IP四层模型、五层协议"></a>四、OSI参考模型以及TCP/IP四层模型、五层协议</h2><p>分层的方法可以是7层、5层、4层。</p><p><img src="/images/1_18.png" alt="在这里插入图片描述"></p><p>七层中各层的作用一览:</p><p><img src="/images/1_31.png" alt="1_31.png"></p><p>具体:</p><ul><li>应用层：提供用户接口，特制能够发起网络通信的应用程序，比如客户端程序，QQ，浏览器等，服务器程序有Web服务器，邮件服务器，流媒体服务器等。</li><li>表示层：使用何种编码方式。比如要传输的数据使用ASCI编码，Unicode编码还是二进制文件，是否要加密和压缩。发送端和接收端程序必须使用相同的编码方式，才能正确显示，否则就产生乱码。</li><li>会话层: 通信的应用程序之间建立、维护和释放面向用户的连接。通信的应用程序之间立会话，需要传输层建立1个或多个连接。</li><li>传输层: 负责在通信的两个计算机之间建立连接，实现可靠的或不可靠的数据通信， 能够发现发送端和接收端的丢包重传，访量控制。</li><li>网路层: 路由器查看数据包目标IP地址，根据路由表为数据包选择路径。路由表中的条目可以人工添加静态路由) 也可以动态生成(动态路由) 。</li><li>数据链路层: 不同的网络类型，发送数据的机制不同，数据链路层就是将数据包封装成能够在不同网络传输的帧。能够进行差错检查，但不纠错，检测出错误去掉该帧。</li><li>物理层: 该层规定了网络设备接口标准、电压标准。尽可能的通过频分复用、时分复用技术在通信和链路上更快的传输数据。</li></ul><p>七层模型各层作用:</p><p><div align="center"> <img src="/images/1_17.png" width="650"></div><br></p><p>TCP/IP只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p><p>TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p><p>最后看一下<code>TCP/IP</code>和<code>ISO/OSI</code>的对比:</p><p><img src="/images/1_32.png" alt="1_32.png"></p><hr><h2 id="五、通信过程、数据传输、网络设备"><a href="#五、通信过程、数据传输、网络设备" class="headerlink" title="五、通信过程、数据传输、网络设备"></a>五、通信过程、数据传输、网络设备</h2><h3 id="1、通信过程"><a href="#1、通信过程" class="headerlink" title="1、通信过程"></a>1、通信过程</h3><p><img src="/images/1_20.png" alt="在这里插入图片描述"></p><blockquote><p><strong>注意: MAC地址由48位二进制数组成，在Windows操作系统命令提示符下，    输入”ipconfig / all”能够看到计算机网卡的MAC地址，物理地址…. : C8-60-00-2E-6E-EB，这里显示的是十六进制表示的MAC地址，使用MA和MB代替MAC地址是为了简化说明。</strong></p></blockquote><p>相关解释</p><p><img src="/images/1_21.png" alt></p><p><img src="/images/1_22.png" alt></p><p><img src="/images/1_23.png" alt></p><blockquote><p>为什么计算机通信需要物理地址和IP地址?，物理地址决定了数据帧下一跳给谁，而 IP地址决定了数据包最终给谁。如果全球的计算机都使用集线器或交换机连接，就可以只使用 MAC 地址进行通信了。</p></blockquote><p><img src="/images/1_24.png" alt></p><p>通过本图也可以看出:</p><ul><li><strong>目标MAC地址决定了数据帧下一跳由哪个设备接收；</strong></li><li><strong>目标IP地址决定了数据包最终到达那个计算机；</strong></li><li><strong>不同的网络数据链路层使用不同的协议，帧格式也不相同，路由器在不同网络转发数据包，需要将数据包重新封装；</strong></li></ul><p><strong>通信过程上面四层是端到端的，下面三层是点到点的</strong>。</p><p><img src="/images/1_29.png" alt="1_29.png"></p><h3 id="2、数据封装和解封-数据传输"><a href="#2、数据封装和解封-数据传输" class="headerlink" title="2、数据封装和解封(数据传输)"></a>2、数据封装和解封(数据传输)</h3><p>下面看几张类似的图，来理解这个过程:</p><p><img src="/images/1_25.png" alt="在这里插入图片描述"></p><p><img src="/images/1_30.png" alt="1_30.png"></p><p><strong>网络的传输过程(从客户端和服务器的角度来看)</strong></p><p><img src="images/1_5.png" alt="在这里插入图片描述"></p><h3 id="3、网络设备"><a href="#3、网络设备" class="headerlink" title="3、网络设备"></a>3、网络设备</h3><p>现实中各个网络设备的样子: </p><p><div align="center"><img src="/images/1_28.png" width="650"></div><br></p><h2 id="六、小结"><a href="#六、小结" class="headerlink" title="六、小结"></a>六、小结</h2><ul><li><p>计算机网络〈可简称为网络) 把许多计算机连接在一起，而互连网则把许多网络连接在一起，是网络的网络。</p></li><li><p>以小写字母<code>i</code>开始的 <code>internet</code> 〈互连网) 是通用名词，它泛指由多个计算机网络互连而成的网络。在这些网络之间的通信协议〈即通信规则) 可以是任意的。</p></li><li><p>以大写字母 <code>I</code>开始的 Internet (互联网) 是专用名词，它指当前全球最大的、开放的、由众多网络相互连接而成的特定互连网，并采用 TCP/P 协议族作为通信规则，且其前身是美国的 ARPANET。Internet 的推荐译名是“因特网” 但很少被使用。</p></li><li><p>互联网现在采用存储转发的分组交换技术，以及三层 ISP 结构。</p></li><li><p>互联网按工作方式可划分为<strong>边缘部分与核心部分</strong>。<strong>主机在网络的边缘部分，其作用是进行信息处理。路由器在网络的核心部分，其作用是按存储转发方式进行分组交换。</strong></p></li><li><p>计算机通信是计算机中的进程〈即运行着的程序) 之间的通信。<strong>计算机网络采用的通信方式是客户-服务器方式和对等连接方式 (P2P 方式)。</strong></p></li><li><p>客户和服务器都是指通信中所涉及的应用进程。客户是服务请求方，服务器是服务 提供方。</p></li><li><p>按作用范围的不同，计算机网络分为广域网 WAN、城域网 MAN、局域网 LAN 和个人区域网 PAN。</p></li><li><p>计算机网络最常用的性能指标是: <strong>速率、带宽、吞吐量、时延〈发送时延、传播时延、处理时延、排队时延)、时延带宽积、往返时间和信道(或网络)利用率。</strong></p></li><li><p>网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层及其协议的集合，称为网络的体系结构。</p></li><li><p>五层协议的体系结构由应用层、运输层、网络层〈或网际层)、数据链路层和物理层组成。<strong>运输层最重要的协议是 <code>TCP</code> 和 <code>UDP</code> 协议，而网络层最重要的协议是 <code>IP</code>协议。</strong></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计网总结-一-一计算机网络和协议&quot;&gt;&lt;a href=&quot;#计网总结-一-一计算机网络和协议&quot; class=&quot;headerlink&quot; title=&quot;计网总结(一)一计算机网络和协议&quot;&gt;&lt;/a&gt;计网总结(一)一计算机网络和协议&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;一、互联
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式总结（3）【模板方法模式、迭代器模式、代理模式、桥接模式】</title>
    <link href="https://www.junglezero.top/2019/07/26/%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>https://www.junglezero.top/2019/07/26/模式总结/</id>
    <published>2019-07-26T07:40:10.000Z</published>
    <updated>2019-08-06T07:26:25.617Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.3dmgame.com/uploads/images/news/20190331/1554021622_367580.jpg" width="70%"></p><a id="more"></a><h1 id="模板方法设计模式"><a href="#模板方法设计模式" class="headerlink" title="模板方法设计模式"></a>模板方法设计模式</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p><strong>模板方法模式是类的行为模式。准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。这就是模板方法模式的用意。</strong></p><blockquote><p>例如: 在现实生活中，完成某件事情是需要 n 个固定步骤的。如”在淘宝进行购物”这件事情的完成一般需要三个步骤: <strong>登录网站、挑选商品、 付款</strong>。但对于登录网站与付款这两步，每个人几乎都是相同的操作。但不同的地方是，每个人所挑选的商品是不同的。<br>在软件开发过程中同样存在这样的情况。某类的某个方法的实现，需要几个固定步骤。在这些固定步骤中,对于该类的不同对象， 有些步骤的实现是固定不变的，有些步骤的实现是大相径庭的，有些步骤的实现是可变可不变的。对于这种情况，就适合使用模板方法设计模式编程。</p></blockquote><h2 id="二、结构"><a href="#二、结构" class="headerlink" title="二、结构"></a>二、结构</h2><p>基本结构:</p><p>在模板方法设计模式中，存在一个<strong>父类</strong>(一般是<strong>抽象</strong>的)。其中包含 两类方法:  模板方法 和 3 种步骤方法；</p><ul><li>模板方法: 即实现某种算法的方法步骤。这些步骤都是调用的步骤方法实现的。</li><li>步骤方法:即完成模板方法的每个阶段性方法。<ul><li>抽象方法: 子类必须实现的方法。即子类的个性化定义；</li><li>最终方法(固定方法): 子类不能重写的方法，即所有子类都要做的步骤；</li><li>钩子方法: 父类给了默认实现，子类可以重写，也可以不重写的方法；</li></ul></li></ul><p>结构:</p><p><img src="/images/09_template_02.png" alt="09_template_02.png"></p><h2 id="三、案例"><a href="#三、案例" class="headerlink" title="三、案例"></a>三、案例</h2><blockquote><p>实现在网站上购物的案例。</p></blockquote><p>基本逻辑图:</p><p><img src="/images/09_template_01.png" alt="09_template_01.png"></p><p>代码:</p><p>首先看<code>Shopping</code>类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shopping</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模板方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyGoods</span><span class="params">()</span></span>&#123;</span><br><span class="line">        useLogin(); <span class="comment">//固定的方法，子类不能重写</span></span><br><span class="line">        buy();      <span class="comment">//抽象方法，子类必须实现</span></span><br><span class="line">        pay();      <span class="comment">//钩子方法(hook)，子类可以重写</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 固定方法(最终方法)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">useLogin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用户登录"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 钩子方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用银联支付"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是两个子类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShoesShopping</span> <span class="keyword">extends</span> <span class="title">Shopping</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"购买Nike鞋子!!!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClothesShopping</span> <span class="keyword">extends</span> <span class="title">Shopping</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"购买海澜之家男装!!!!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写了钩子方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用支付宝支付"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Shopping shoesShopping = <span class="keyword">new</span> ShoesShopping();</span><br><span class="line">        shoesShopping.buyGoods();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">        Shopping clothesShopping = <span class="keyword">new</span> ClothesShopping();</span><br><span class="line">        clothesShopping.buyGoods();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">用户登录</span><br><span class="line">购买Nike鞋子!!!!</span><br><span class="line">使用银联支付</span><br><span class="line">-----------------------</span><br><span class="line">用户登录</span><br><span class="line">购买海澜之家男装!!!!!</span><br><span class="line">使用支付宝支付</span><br></pre></td></tr></table></figure><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>有时候为了防止恶意操作，模板方法也会加上 <code>final</code> 关键词。</p><h2 id="五、实际使用"><a href="#五、实际使用" class="headerlink" title="五、实际使用"></a>五、实际使用</h2><p>Spring对数据库的操作在jdbc上面做了深层次的封装，使用spring的注入功能，可以把DataSource注册到JdbcTemplate之中。<br>这个JdbcTemplate用的是一种更高级的模板思想，具体说来，它引入了一种回调模式<br>对于JdbcTemplate，它是个抽象类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplate</span> </span>&#123;  </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">final</span> Object execute（String sql）&#123;  </span><br><span class="line">        Connection con=<span class="keyword">null</span>;  </span><br><span class="line">        Statement stmt=<span class="keyword">null</span>;  </span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            con=getConnection（）;  </span><br><span class="line">            stmt=con.createStatement（）;  </span><br><span class="line">            Object retValue=executeWithStatement（stmt,sql）;  </span><br><span class="line">            <span class="keyword">return</span> retValue;  </span><br><span class="line">        &#125;<span class="keyword">catch</span>（SQLException e）&#123;  </span><br><span class="line">             ...  </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;  </span><br><span class="line">            closeStatement（stmt）;  </span><br><span class="line">            releaseConnection（con）;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Object executeWithStatement（Statement   stmt, String sql）;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>要是想使用，就必须要实现，但是其中的方法太多<br>因此就引出了中间态的回调<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StatementCallback</span></span>&#123;  </span><br><span class="line">    Object doWithStatement（Statement stmt）;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后在进行具体的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplate</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object execute（StatementCallback callback）&#123;  </span><br><span class="line">        Connection con=<span class="keyword">null</span>;  </span><br><span class="line">        Statement stmt=<span class="keyword">null</span>;  </span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            con=getConnection（）;  </span><br><span class="line">            stmt=con.createStatement（）;  </span><br><span class="line">            Object retValue=callback.doWithStatement（stmt）;  </span><br><span class="line">            <span class="keyword">return</span> retValue;  </span><br><span class="line">        &#125;<span class="keyword">catch</span>（SQLException e）&#123;  </span><br><span class="line">            ...  </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;  </span><br><span class="line">            closeStatement（stmt）;  </span><br><span class="line">            releaseConnection（con）;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    ...<span class="comment">//其它方法定义  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><h2 id="一、基本概念-1"><a href="#一、基本概念-1" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>迭代器模式属于行为型模式。</p><p>这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。</p><p>如果我们需要统一遍历不同的集合(容器)，也可以利用迭代器模式解决(下面的案例就是解决这个问题)。</p><h2 id="二、结构-1"><a href="#二、结构-1" class="headerlink" title="二、结构"></a>二、结构</h2><p>结构:</p><p><img src="/images/10_iterator_01.png" alt="10_iterator_01.png"></p><ul><li><code>Container</code> 是聚合类，其中 <code>getIterator()</code> 方法可以产生一个 <code>Iterator</code>；</li><li><code>Iterator</code> 主要定义了 <code>hasNext()</code> 和 <code>next()</code> 方法；</li><li>每一个<code>Container</code>的实现类都会有一个具体的<code>Iterator</code>实现类来帮助实现迭代；</li></ul><h2 id="三、案例-1"><a href="#三、案例-1" class="headerlink" title="三、案例"></a>三、案例</h2><blockquote><p>实现两个容器能够统一遍历。(或者两个以上)</p></blockquote><p>先看代码结构: (<strong>这里我将两个迭代器实现类写在两个容器内部</strong>)</p><p><img src="/images/10_iterator_02.png" alt="10_iterator_02.png"></p><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="function">Iterator <span class="title">getIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个容器类，他们内部的容器不同，内部有自带不同的迭代器:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteContainer1</span> <span class="keyword">implements</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteContainer1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> Integer[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) arr[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteIterator1&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator1</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(index &lt; arr.length)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(hasNext())</span><br><span class="line">                <span class="keyword">return</span> arr[index++];</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteContainer2</span> <span class="keyword">implements</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArrayList arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteContainer2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) arr.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteIterator1&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator1</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(index &lt; arr.size())</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(hasNext())</span><br><span class="line">                <span class="keyword">return</span> arr.get(index++);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果不这么做，需要区分c1和c2的遍历方式, 一个是数组，一个是List</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Container c1 = <span class="keyword">new</span> ConcreteContainer1();</span><br><span class="line">        Container c2 = <span class="keyword">new</span> ConcreteContainer2();</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Iterator&gt;its = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        its.add(c1.getIterator()); <span class="comment">// 将c1迭代器加入its</span></span><br><span class="line">        its.add(c2.getIterator()); <span class="comment">// 将c1迭代器加入its</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现了统一遍历, 只需要将迭代器加入到 its中即可</span></span><br><span class="line">        <span class="keyword">for</span>(Iterator it : its) &#123;</span><br><span class="line">            <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">                System.out.print( it.next() + <span class="string">" "</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><h2 id="四、总结-1"><a href="#四、总结-1" class="headerlink" title="四、总结"></a>四、总结</h2><p>优点:</p><ul><li>在同一个聚合上可以有多个遍历；</li><li>在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码；</li></ul><h1 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h1><h2 id="一、基本概念-2"><a href="#一、基本概念-2" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>代理模式是对象的结构模式。</p><p><strong>代理模式给某一个对象提供一个代理对象，并由代理对象控制对原对象的引用(接口的引用)</strong></p><h2 id="二、静态代理"><a href="#二、静态代理" class="headerlink" title="二、静态代理"></a>二、静态代理</h2><p>静态代理是指，代理类在程序运行前就已经定义好，其与<strong>目标类(被代理类)</strong>的关系在程序运行前就已经确立。</p><p>静态代理类似于企业与企业的法律顾问间的关系。<strong>法律顾问与企业的代理关系，并不是在“官司“发生后才建立的，而是之前就确立好的一种关系</strong>。</p><p>而动态代理就是外面打官司一样，是官司发生了之后临时请的律师。</p><p>代理可以看做就是在被代理对象外面包裹一层（和装饰者类似但又不同）:</p><p><strong>案例: 比如我们有一个可以移动的坦克，它的主要方法是<code>move()</code>，但是我们需要记录它移动的时间，以及在它移动前后做日志，其静态代理的实现模式就类似下面的图</strong>:</p><p><img src="/images/11_proxy_01.png" alt="11_proxy_01.png"></p><p>两个代理类以及结构关系:</p><p><img src="/images/11_proxy_02.png" alt="11_proxy_02.png"></p><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tank</span> <span class="keyword">implements</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 坦克移动</span></span><br><span class="line">        System.out.println(<span class="string">"Tank Moving......"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5000</span>)); <span class="comment">// 随机产生 1~5秒, 模拟坦克在移动　</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个代理类: <code>TankTimeProxy</code>和<code>TankLogProxy</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TankTimeProxy</span> <span class="keyword">implements</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Movable tank;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TankTimeProxy</span><span class="params">(Movable tank)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tank = tank;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在前面做一些事情: 记录开始时间</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"start time : "</span> + start);</span><br><span class="line"></span><br><span class="line">        tank.move();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在后面做一些事情: 记录结束时间,并计算move()运行时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"end time : "</span> + end);</span><br><span class="line">        System.out.println(<span class="string">"spend all time : "</span> + (end - start)/<span class="number">1000</span> + <span class="string">"s."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TankLogProxy</span> <span class="keyword">implements</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Movable tank;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TankLogProxy</span><span class="params">(Movable tank)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tank = tank;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// tank 移动前记录日志</span></span><br><span class="line">        System.out.println(<span class="string">"Tank Log start......."</span>);</span><br><span class="line"></span><br><span class="line">        tank.move();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// tank 移动后记录日志</span></span><br><span class="line">        System.out.println(<span class="string">"Tank Log end......."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Movable target = <span class="keyword">new</span> TankLogProxy(<span class="keyword">new</span> TankTimeProxy(<span class="keyword">new</span> Tank()));    <span class="comment">//先记录时间，再记录日志</span></span><br><span class="line"><span class="comment">//        Movable target = new TankTimeProxy(new TankLogProxy(new Tank())); //先记录日志，再记录时间</span></span><br><span class="line">        target.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Tank Log start.......</span><br><span class="line">start time : <span class="number">1551271511619</span></span><br><span class="line">Tank Moving......</span><br><span class="line">end time : <span class="number">1551271514522</span></span><br><span class="line">spend all time : <span class="number">2</span>s.</span><br><span class="line">Tank Log end.......</span><br></pre></td></tr></table></figure><p>这其中有两个很重要的点，那就是:</p><ul><li>两个代理对象内部都<strong>有着被代理对象(target)实现的接口的引用</strong>；</li><li>且两个代理对象都<strong>实现了被代理对象(target)实现的接口</strong>；</li></ul><h2 id="三、基本动态代理"><a href="#三、基本动态代理" class="headerlink" title="三、基本动态代理"></a>三、基本动态代理</h2><p>上面静态代理的缺点在哪?</p><p><strong>现在单看做时间这个代理，如果我们现在多了一个飞机，飞机里面的方法是<code>fly()</code>，现在要给飞机做代理，那么我们不能用之前写的<code>TankTimeProxy</code>，我们需要额外的写一个<code>PlaneTimeProxy</code>，这明显是冗余代码，所以这就是静态代理最大的缺点，这可以用动态代理解决</strong>。</p><p>动态代理是指，<strong>程序在整个运行过程中根本就不存在目标类的代理类(在JDK内部叫<code>$Proxy0</code>，我们看不到)</strong>，目标对象的代理对象只是由代理生成工具(如代理工厂类) 在程序运行时由 JVM 根据反射等机制动态生成的。代理对象与目标对象的代理关系在程序运行时才确立。</p><p>对比静态代理，静态代理是指在程序运行前就已经定义好了目标类的代理类。代理类与目标类的代理关系在程序运行之前就确立了。</p><p>首先看动态代理的一些特点:</p><ul><li>动态代理不需要写出代理类的名字，你要的代理对象我直接给你产生，是使用的时候生成的；</li><li>只需要调用<code>Proxy.newProxyInstance()</code>就可以给你产生代理类；</li></ul><p>JDK动态代理相关API:</p><p><img src="/images/12_proxy_07.png" alt="12_proxy_07.png"></p><p>下面看使用动态代理解决上面的问题(可以用<code>TimeProxy</code>代理一切对象):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tank</span> <span class="keyword">implements</span> <span class="title">Movable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 坦克移动</span></span><br><span class="line">        System.out.println(<span class="string">"Tank Moving......"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5000</span>)); <span class="comment">// 随机产生 1~5秒, 模拟坦克在移动　</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>新增的飞机:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plane</span> <span class="keyword">implements</span> <span class="title">Flyable</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Plane Flying......"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5000</span>)); <span class="comment">// 随机产生 1~5秒, 飞机在飞行　</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们的关键处理，即编写<code>MyTimeProxyInvocationHandler</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态代理做不到既为飞机做时间代理，又为坦克做时间代理，但是动态代理可以为所有对象做代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTimeProxyInvocationHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object target;<span class="comment">//注意这里是 Object ，不是Movable或者Flyable</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTimeProxyInvocationHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// proxy  : 代理对象  可以是一切对象 (Object)</span></span><br><span class="line">    <span class="comment">// method : 目标方法</span></span><br><span class="line">    <span class="comment">// args   : 目标方法的参数</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在前面做一些事情: 记录开始时间</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"start time : "</span> + start);</span><br><span class="line"></span><br><span class="line">        method.invoke(target, args); <span class="comment">// 调用目标方法  invoke是调用的意思, 可以有返回值的方法(我们这里move和fly都没有返回值)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在后面做一些事情: 记录结束时间,并计算move()运行时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"end time : "</span> + end);</span><br><span class="line">        System.out.println(<span class="string">"spend all time : "</span> + (end - start)/<span class="number">1000</span> + <span class="string">"s."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后测试类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Movable tank = <span class="keyword">new</span> Tank();</span><br><span class="line">        <span class="comment">//可以为所有对象产生时间代理的 InvocationHandler</span></span><br><span class="line">        MyTimeProxyInvocationHandler myInvocationHandler = <span class="keyword">new</span> MyTimeProxyInvocationHandler(tank);</span><br><span class="line">        Movable tankProxy = (Movable) Proxy.newProxyInstance(</span><br><span class="line">                tank.getClass().getClassLoader(),</span><br><span class="line">                tank.getClass().getInterfaces(),</span><br><span class="line">                myInvocationHandler</span><br><span class="line">        );</span><br><span class="line">        tankProxy.move();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line"></span><br><span class="line">        Flyable plane = <span class="keyword">new</span> Plane();</span><br><span class="line">        myInvocationHandler = <span class="keyword">new</span> MyTimeProxyInvocationHandler(plane);</span><br><span class="line">        <span class="comment">// 为飞机产生代理, 为..产生代理，这样可以为很多东西产生代理，静态代理做不到</span></span><br><span class="line">        Flyable planeProxy = (Flyable) Proxy.newProxyInstance(</span><br><span class="line">                plane.getClass().getClassLoader(),</span><br><span class="line">                plane.getClass().getInterfaces(),</span><br><span class="line">                myInvocationHandler</span><br><span class="line">        );</span><br><span class="line">        planeProxy.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出(同时为<code>Tank</code>和<code>Plane</code>做了代理):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">start time : <span class="number">1551275526486</span></span><br><span class="line">Tank Moving......</span><br><span class="line">end time : <span class="number">1551275531193</span></span><br><span class="line">spend all time : <span class="number">4</span>s.</span><br><span class="line">--------------------</span><br><span class="line">start time : <span class="number">1551275531195</span></span><br><span class="line">Plane Flying......</span><br><span class="line">end time : <span class="number">1551275532996</span></span><br><span class="line">spend all time : <span class="number">1</span>s.</span><br></pre></td></tr></table></figure><p>我们分析一下这个代理过程:</p><p><img src="/images/11_proxy_03.png" alt="11_proxy_03.png"></p><p>调用过程(重要):</p><ul><li>JDK内部的<code>Proxy</code>类在内部创建了一个<code>$Proxy0</code>的代理对象(它实现了目标对象所在接口<code>Movable</code>；</li><li><code>$Proxy0</code>内部有<code>InvocationHandler</code>接口的引用，然后在<code>$Proxy</code>中调用了接口的<code>invoke()</code>方法；</li><li>而我们将<code>InvocationHandler</code>接口的实现类传入了<code>Proxy</code>，所以我们在实现类中加入的前后逻辑就会得到执行；</li></ul><p>如果这里还不够理解，可以看代理模式(二)，会模拟实现JDK的底层实现。</p><h2 id="四、CGLIB动态代理"><a href="#四、CGLIB动态代理" class="headerlink" title="四、CGLIB动态代理"></a>四、CGLIB动态代理</h2><p>问题: 使用 JDK 的 Proxy 实现代理，要求目标类与代理类实现相同的接口。<strong>若目标类不存在接口，则无法使用该方式实现</strong>。</p><p>可以用 CGLIB 来解决上面的问题。</p><p>CGLIB 代理的生成原理是<strong>生成目标类的子类，而子类是增强过的，这个子类对象就是代理对象</strong>。</p><p>所以，使用CGLIB 生成动态代理，<strong>要求目标类必须能够被继承，即不能是 final 的类</strong>。 </p><p>基本结构:</p><p><img src="images/12_proxy_06.png" alt="12_proxy_06.png"></p><p>代码:</p><p><code>Tank</code>类(没有接口)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有实现接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tank</span>   </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 坦克移动</span></span><br><span class="line">        System.out.println(<span class="string">"Tank Moving......"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5000</span>)); <span class="comment">// 随机产生 1~5秒, 模拟坦克在移动　</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>MyCglibFactory</code>类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">//需要实现MethodInterceptor, 当前这个类的对象就是一个回调对象</span></span><br><span class="line"><span class="comment">// MyCglibFactory 是 类A，它调用了Enhancer(类B)的方法: setCallback(this)，而且将类A对象传给了类B</span></span><br><span class="line"><span class="comment">// 而类A 的 方法intercept会被类B的 setCallback调用，这就是回调设计模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCglibFactory</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;  <span class="comment">//public interface MethodInterceptor extends Callback</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Tank target;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCglibFactory</span><span class="params">(Tank target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Tank <span class="title">myCglibCreator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置需要代理的对象 :  目标类(target) , 也是父类</span></span><br><span class="line">        enhancer.setSuperclass(Tank.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置代理对象， 这是回调设计模式:  设置回调接口对象 :</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>); <span class="comment">// this代表当前类的对象，因为当前类实现了Callback</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (Tank) enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个就是回调方法（类A的方法）</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// 在前面做一些事情: 记录开始时间</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"start time : "</span> + start);</span><br><span class="line"></span><br><span class="line">        method.invoke(target, args);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在后面做一些事情: 记录结束时间,并计算move()运行时间</span></span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"end time : "</span> + end);</span><br><span class="line">        System.out.println(<span class="string">"spend all time : "</span> + (end - start)/<span class="number">1000</span> + <span class="string">"s."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Tank proxyTank = <span class="keyword">new</span> MyCglibFactory(<span class="keyword">new</span> Tank()).myCglibCreator();</span><br><span class="line">        proxyTank.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出(进行了时间代理<code>TimeProxy</code>):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">start time : <span class="number">1551327522964</span></span><br><span class="line">Tank Moving......</span><br><span class="line">end time : <span class="number">1551327526214</span></span><br><span class="line">spend all time : <span class="number">3</span>s.</span><br></pre></td></tr></table></figure><blockquote><p> 上面的设计模式用到了回调设计模式:<br> 在 Java 中，类 <code>A</code>调用类 <code>B</code> 中的某个方法 <code>b()</code>，然后类 <code>B</code> 又在某个时候反过来调用类 <code>A</code>中的某个方法 <code>a()</code>，对于 <code>A</code>来说，这个<code>a()</code> 方法便叫做回调方法。</p><p> Java 的接口提供了一种很好的方式来实现方法回调。这个方式就是定义一个简单的接口，在接口之中定义一个我们希望回调的方法。这个接口称为回调接口。(<code>Callback</code>)<br> 在前面的例子中，我们定义的 <code>MyCglibFactory</code> 类就相当于前面所说的 <code>A</code>类，而 <code>Enhancer</code> 类则是 <code>B</code> 类。<code>A</code> 类中调用了<code>Enhancer</code> 类的 <code>setCallback(this)</code>方法，并将回调对象 <code>this</code> 作为实参传递给了Enhancer 类。Enhancer 类在后续执行过程中，会调用<code>A</code>类中的<code>intercept()</code>方法，<strong>这个 intercept()方法就是回调方法</strong>。 </p></blockquote><h2 id="五、实际应用"><a href="#五、实际应用" class="headerlink" title="五、实际应用"></a>五、实际应用</h2><p>Spring的AOP<br><a href="https://www.cnblogs.com/flowwind/p/4782606.html" target="_blank" rel="noopener">https://www.cnblogs.com/flowwind/p/4782606.html</a></p><h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><h2 id="一、基本概念-3"><a href="#一、基本概念-3" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>桥接模式属于结构型模式。</p><p>桥接模式其实只需要记住关键的一点: <strong>解决的是不同的子类之间排列组合可以构成巨多的类的问题</strong>。</p><p>比如:</p><p><img src="/images/13_brige_01.png" alt="13_brige_01.png"></p><p>举个例子，你要画画了，画画本身是一个类，你画画要考虑画什么形状(<code>Shape</code>) (<code>A</code>)，你画画还需要考虑用什么颜色去画(<code>Color</code>)(<code>B</code>)。</p><p>形状可以有圆、长方形、正方形….，而颜色可以用红、蓝、绿…..。</p><p>那我现在要用蓝笔画长方形，这是一种新的组合，用红笔画长方形，又是一种组合，这样会产生很多的排列组合，如果我们都写一个类，那就是不好的设计了。</p><h2 id="二、案例"><a href="#二、案例" class="headerlink" title="二、案例"></a>二、案例</h2><p>就用上面那个画画的例子来引出我们的桥接模式。</p><p>我们的改造就是。不需要那个<code>A</code>类了，而是在形状类<code>B</code>类这边有这<code>C</code>类(这里改成接口， 也可以用类)的引用。</p><p>具体结构如下:</p><p><img src="/images/13_bridge_02.png" alt="13_bridge_02.png"></p><p>然后还有一个关键的点:</p><p>注意一定要在<code>Shape</code>中有<code>ColorAPI</code>的引用，而且子类也要调用父类的构造函数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ColorAPI</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">draw</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>颜色(<code>B</code>)这边的三个实现类:    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BluePen</span> <span class="keyword">implements</span> <span class="title">ColorAPI</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用蓝笔画 "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreenPen</span> <span class="keyword">implements</span> <span class="title">ColorAPI</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用绿笔画 "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedPen</span> <span class="keyword">implements</span> <span class="title">ColorAPI</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用红笔画 "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>形状这边的大父类(<code>A</code>):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> ColorAPI colorAPI;  <span class="comment">//这个父类必须要有 另一边的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Shape</span><span class="params">(ColorAPI colorAPI)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.colorAPI = colorAPI;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">dw</span><span class="params">()</span></span>; <span class="comment">// color</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>形状的实现类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Circle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(String name, ColorAPI colorAPI)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(colorAPI);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        colorAPI.draw(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rectangle</span><span class="params">(String name, ColorAPI colorAPI)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(colorAPI);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        colorAPI.draw(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//桥接模式简单的说:  解决排列组合导致组合类巨多的问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Shape blueRectangle = <span class="keyword">new</span> Rectangle(<span class="string">"长方形"</span>, <span class="keyword">new</span> BluePen());</span><br><span class="line">        blueRectangle.dw();</span><br><span class="line"></span><br><span class="line">        Shape redCircle = <span class="keyword">new</span> Circle(<span class="string">"圆"</span>, <span class="keyword">new</span> RedPen());</span><br><span class="line">        redCircle.dw();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用蓝笔画 长方形</span><br><span class="line">用红笔画 圆</span><br></pre></td></tr></table></figure><p>再看一下整体框架图:</p><p><img src="/images/13_bridge_03.png" alt="13_bridge_03.png"></p><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>对于两个独立变化的维度，使用桥接模式再适合不过了。实现减少排列组合减少的类。<br>可以这样理解：当想要使用某一模块的完整功能时，就把这一模块的基类和接口扩展到这个类中，这个类就充当了一个桥的作用（对于要使用的方法）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.3dmgame.com/uploads/images/news/20190331/1554021622_367580.jpg&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式总结（2）【策略模式、观察者模式、装饰者模式，适配器模式】</title>
    <link href="https://www.junglezero.top/2019/07/25/signpattern2/"/>
    <id>https://www.junglezero.top/2019/07/25/signpattern2/</id>
    <published>2019-07-25T14:27:09.000Z</published>
    <updated>2019-07-27T00:05:00.779Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://img.3dmgame.com/uploads/images/thumbpicfirst/20190219/1550567116_731464.jpg" width="70%"></p><a id="more"></a><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>策略模式是<strong>行为型</strong>设计模式。</p><p>其用意是针对一组算法，<strong>将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换</strong>。</p><p>策略模式使得算法可以在不影响到客户端的情况下发生变化。</p><h2 id="二、结构"><a href="#二、结构" class="headerlink" title="二、结构"></a>二、结构</h2><p>下面是基本结构:</p><p><img src="/images/01_stratgy_01.png" alt></p><p>三类角色:</p><ul><li><strong>环境(Context)角色</strong>：持有一个<code>Strategy</code>的引用。</li><li><strong>抽象策略(Strategy)角色</strong>：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</li><li><strong>具体策略(ConcreteStrategy)角色</strong>：包装了相关的算法或行为。</li></ul><h2 id="三、案例"><a href="#三、案例" class="headerlink" title="三、案例"></a>三、案例</h2><p>案例实现:</p><blockquote><p>定义一族算法，可以实现对两个数的操作，例如<code>+、-、*、/</code>等。</p></blockquote><p>实现代码整体框架图:</p><p><img src="/images/01_stratgy_02.png" alt="pic"></p><p>具体代码实现:</p><p><code>Context</code>类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Context 是一个使用了某种策略的类。 实现了 Strategy 接口的实体策略类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeStrategy</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strategy.doOperation(num1, num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Strategy</code>接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**策略的公共接口*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种对应的算法实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 算法１: 实现加法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationAdd</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 算法2：实现减法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationSubstract</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 算法3: 实现乘法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationMultiply</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 * num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Context context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationAdd());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"10 + 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationSubstract());</span><br><span class="line">        System.out.println(<span class="string">"10 - 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationMultiply());</span><br><span class="line">        System.out.println(<span class="string">"10 * 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> + <span class="number">5</span> = <span class="number">15</span></span><br><span class="line"><span class="number">10</span> - <span class="number">5</span> = <span class="number">5</span></span><br><span class="line"><span class="number">10</span> * <span class="number">5</span> = <span class="number">50</span></span><br></pre></td></tr></table></figure><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><ul><li>策略模式的重心不是如何实现算法，而是如何组织、调用这些算法；</li><li>策略模式一个很大的特点就是各个策略算法的平等性。对于一系列具体的策略算法，大家的地位是完全一样的，正因为这个平等性，才能实现算法之间可以相互替换；</li><li>使用策略模式可以避免使用多重条件(if-else)语句；</li></ul><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="一、基本概念-1"><a href="#一、基本概念-1" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>观察者模式是行为型设计模式。</p><ul><li><strong>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新</strong>；</li><li>被依赖的对象为<code>Subject</code>(被观察者)，依赖的对象为<code>Observer</code>，<code>Subject</code>通知<code>Observer</code>变化；</li><li><code>Subject</code> : 登记注册<code>register/attach</code>、移除<code>remove</code>、通知<code>notify</code>；</li><li><code>Observer</code> : 接收变化<code>update</code>； </li><li>可以把观察者模式想象成订报纸一样，<strong>出版者+订阅者 = 观察者模式</strong>；</li></ul><h2 id="二、结构-1"><a href="#二、结构-1" class="headerlink" title="二、结构"></a>二、结构</h2><p>观察者模式所涉及的角色有：</p><p>　　● <strong>抽象主题(Subject)角色：</strong>抽象主题角色把所有对<strong>观察者对象</strong>的引用保存在一个聚集（比如<code>List</code>对象）里。抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色；</p><p>　　● <strong>具体主题(ConcreteSubject)角色</strong>：将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色；</p><p>　　● <strong>抽象观察者(Observer)角色</strong>：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。</p><p>　　● <strong>具体观察者(ConcreteObserver)角色</strong>：存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。如果需要，具体观察者角色可以保持一个指向具体主题对象(Concrete Subject)的引用；</p><p><img src="/images/02_observer_02.png" alt="02_observer_02.png"></p><h2 id="三、案例-1"><a href="#三、案例-1" class="headerlink" title="三、案例"></a>三、案例</h2><p>案例：</p><blockquote><p>实现的功能是气象站的管理，给你一个<code>WeatherData</code>类(<strong>被观察者</strong>)，提供了获取温度，湿度，和气压的函数，要你设计类并添加一些公告板(<strong>观察者</strong>)，可以显示相关的信息；</p></blockquote><p>基本结构图:</p><p><img src="/images/02_observer_01.png" alt="02_observer_01.png"></p><p><strong>下面使用自定义的观察者和Java内置观察者实现</strong>。</p><h3 id="1、自定义的观察者实现"><a href="#1、自定义的观察者实现" class="headerlink" title="1、自定义的观察者实现"></a>1、自定义的观察者实现</h3><p>基本代码结构组织图:</p><p><img src="/images/02_observer_03.png" alt="02_observer_03.png"></p><p>先看被观察者包<code>subjects</code>里面的两个:</p><p><code>Subject</code>接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**被观察者接口*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerObservers</span><span class="params">(Observer o)</span></span>;<span class="comment">//注册</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeObservers</span><span class="params">(Observer o)</span></span>; <span class="comment">//移除</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span>; <span class="comment">//通知</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WeatherData</code>类 (被观察者的实现):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被观察者的实现</span></span><br><span class="line"><span class="comment"> * 里面有:</span></span><br><span class="line"><span class="comment"> *   1、观察者接口的集合数据结构</span></span><br><span class="line"><span class="comment"> * 　2、实现添加观察者方法(registerObservers)</span></span><br><span class="line"><span class="comment"> *   3、移除观察者方法(removeObservers)</span></span><br><span class="line"><span class="comment"> *   4、通知所有观察者的方法(notifyObservers)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> pressure;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以提供getter()方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Observer&gt;observers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">double</span> temperature, <span class="keyword">double</span> humidity, <span class="keyword">double</span> pressure)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line"></span><br><span class="line">        dataChanged();<span class="comment">//更新完信息就马上通知观察者</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据改变之后就通知观察者(从气象站得到更新的观测值之后，通知观察者)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">()</span></span>&#123;</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObservers</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObservers</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = observers.indexOf(o);</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            observers.remove(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; observers.size(); i++)&#123;</span><br><span class="line">            Observer observer = observers.get(i);</span><br><span class="line">            observer.update(temperature, humidity, pressure);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 然后再看<code>observers</code>包的接口和实现类:</p><p><code>Observer</code>接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 观察者 接口*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">double</span> temperature, <span class="keyword">double</span> humidity, <span class="keyword">double</span> pressure)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个实现类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 观察者1 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentConditionDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> pressure;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">double</span> temperature, <span class="keyword">double</span> humidity, <span class="keyword">double</span> pressure)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"CurrentDisplay : "</span> +</span><br><span class="line">                <span class="string">"["</span> + temperature  +</span><br><span class="line">                <span class="string">", "</span> + humidity  +</span><br><span class="line">                <span class="string">", "</span> + pressure + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 观察者2  明天的天气展示 : Math.random * 当前设置值, 主要是为了展示和上一个观察者的不同*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TomorrowConditionDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> pressure;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">double</span> temperature, <span class="keyword">double</span> humidity, <span class="keyword">double</span> pressure)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ( (int)(10 * Math.random())/2 + 1)  生成 [1,5]的随机数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"TomorrowDisplay : "</span> +</span><br><span class="line">                <span class="string">"["</span> + temperature * ( (<span class="keyword">int</span>)(<span class="number">10</span> * Math.random())/<span class="number">2</span> + <span class="number">1</span>) +</span><br><span class="line">                <span class="string">", "</span> + humidity * ( (<span class="keyword">int</span>)(<span class="number">10</span> * Math.random())/<span class="number">2</span> + <span class="number">1</span>) +</span><br><span class="line">                <span class="string">", "</span> + pressure * ( (<span class="keyword">int</span>)(<span class="number">10</span> * Math.random())/<span class="number">2</span> + <span class="number">1</span>) + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WeatherData weatherData = <span class="keyword">new</span> WeatherData(); <span class="comment">// 创建一个被观察者(Subject的实现类)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建两个观察者 (Observer的实现类)</span></span><br><span class="line">        CurrentConditionDisplay current = <span class="keyword">new</span> CurrentConditionDisplay();</span><br><span class="line">        TomorrowConditionDisplay tomorrow = <span class="keyword">new</span> TomorrowConditionDisplay();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在被观察者的List中注册两个观察者</span></span><br><span class="line">        weatherData.registerObservers(current);</span><br><span class="line">        weatherData.registerObservers(tomorrow);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置完(天气更新)就会自动通知两个观察者</span></span><br><span class="line">        weatherData.setData(<span class="number">10</span>,<span class="number">100</span>,<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"----------移除Tomorrow公告板----------"</span>);</span><br><span class="line">        weatherData.removeObservers(tomorrow);</span><br><span class="line"></span><br><span class="line">        weatherData.setData(<span class="number">20</span>,<span class="number">200</span>,<span class="number">25</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CurrentDisplay : [<span class="number">10.0</span>, <span class="number">100.0</span>, <span class="number">50.0</span>]</span><br><span class="line">TomorrowDisplay : [<span class="number">10.0</span>, <span class="number">100.0</span>, <span class="number">150.0</span>]</span><br><span class="line">----------移除Tomorrow公告板----------</span><br><span class="line">CurrentDisplay : [<span class="number">20.0</span>, <span class="number">200.0</span>, <span class="number">25.0</span>]</span><br></pre></td></tr></table></figure><h3 id="2、Java内置观察者实现"><a href="#2、Java内置观察者实现" class="headerlink" title="2、Java内置观察者实现"></a>2、Java内置观察者实现</h3><p>被观察者继承自<code>Observable</code>类，观察者实现<code>Observer</code>接口:</p><ul><li><code>Observable</code>类中有<code>addObserver()</code>方法，类似于我们的<code>registerObserver()</code>；</li><li><code>Observable</code>类中有<code>deleteObserver()</code>方法，类似与我们的<code>removeObserver()</code>；</li><li>此外<code>Observable</code>类中还有两个<code>notifyObservers()</code>方法。为什么两个呢?<ul><li>Java内置的被观察者更新的方法有两种，一种是推，一种是拉；</li><li><code>public void notifyObservers(Object arg)</code>对应的是”推”；意思就是推送给观察者；</li><li><code>public void notifyObservers()</code>对应的是”拉”；意思就是需要观察者自己拉取数据；</li></ul></li><li>内置的和自己定义的在更新的时候有一个很大的不同就是: Java内置观察者在更新的时候，需要先调用一个<code>setChanged()</code>方法，标记状态已经被改变的事实。这个可以更加灵活的使用观察者模式(在调用<code>setChanged()</code>之前添加一些条件)；</li></ul><p>基本代码结构组织图:</p><p><img src="/images/02_observer_04.png" alt="02_observer_04.png"></p><p>代码如下:</p><p>首先看被观察者: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里需要继承Java的Observable类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> pressure;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTemperature</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> temperature;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getHumidity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> humidity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPressure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pressure;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">double</span> temperature, <span class="keyword">double</span> humidity, <span class="keyword">double</span> pressure)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">        dataChanged();<span class="comment">//更新完信息就马上通知观察者</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据改变之后就通知观察者(从气象站得到更新的观测值之后，通知观察者)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setChanged(); <span class="comment">//这个很重要，一定要设置这个，java底层有一个boolean值 changed = true; , 可以不那么灵活 (可以设置一些条件然后调用setChanged()方法)</span></span><br><span class="line">        notifyObservers(<span class="keyword">new</span> Data(temperature, humidity, pressure)); <span class="comment">//这个是 "推" 数据</span></span><br><span class="line"><span class="comment">//        notifyObservers();  // 靠观察者自己 "拉" 数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个类的作用就是为了 适应Observable里面的这个方法(推数据) : public void notifyObservers(Object arg)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Data</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span> temperature;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span> humidity;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span> pressure;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Data</span><span class="params">(<span class="keyword">double</span> temperature, <span class="keyword">double</span> humidity, <span class="keyword">double</span> pressure)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">            <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">            <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTemperature</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> temperature;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getHumidity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> humidity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPressure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> pressure;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是两个观察者:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentConditionDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> pressure;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里表示的是直接接受　被观察者的数据("推"　过来的数据　)　　--&gt;  也可以自己获取("拉")数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object data)</span> </span>&#123; <span class="comment">//注意这里还有被观察者的引用</span></span><br><span class="line">        <span class="keyword">this</span>.temperature = ((WeatherData.Data)data).getTemperature(); <span class="comment">//强制类型转换一下</span></span><br><span class="line">        <span class="keyword">this</span>.humidity = ((WeatherData.Data)data).getHumidity();</span><br><span class="line">        <span class="keyword">this</span>.pressure = ((WeatherData.Data)data).getPressure();</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"CurrentDisplay : "</span> +</span><br><span class="line">                <span class="string">"["</span> + temperature  +</span><br><span class="line">                <span class="string">", "</span> + humidity  +</span><br><span class="line">                <span class="string">", "</span> + pressure + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TomorrowConditionDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> pressure;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个就是</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable observable, Object data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 两种设值方式  "推" | "拉"</span></span><br><span class="line">        <span class="comment">// "推"　过来的</span></span><br><span class="line"><span class="comment">//        this.temperature = ((WeatherData.Data)data).getTemperature();</span></span><br><span class="line"><span class="comment">//        this.humidity = ((WeatherData.Data)data).getHumidity();</span></span><br><span class="line"><span class="comment">//        this.pressure = ((WeatherData.Data)data).getPressure();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自己 "拉" 过来的</span></span><br><span class="line">        <span class="keyword">this</span>.temperature = ((WeatherData)observable).getTemperature();</span><br><span class="line">        <span class="keyword">this</span>.humidity = ((WeatherData)observable).getHumidity();</span><br><span class="line">        <span class="keyword">this</span>.pressure = ((WeatherData)observable).getPressure();</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ( (int)(10 * Math.random())/2 + 1)  生成 [1,5]的随机数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"TomorrowDisplay : "</span> +</span><br><span class="line">                <span class="string">"["</span> + temperature * ( (<span class="keyword">int</span>)(<span class="number">10</span> * Math.random())/<span class="number">2</span> + <span class="number">1</span>) +</span><br><span class="line">                <span class="string">", "</span> + humidity * ( (<span class="keyword">int</span>)(<span class="number">10</span> * Math.random())/<span class="number">2</span> + <span class="number">1</span>) +</span><br><span class="line">                <span class="string">", "</span> + pressure * ( (<span class="keyword">int</span>)(<span class="number">10</span> * Math.random())/<span class="number">2</span> + <span class="number">1</span>) + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WeatherData weatherData = <span class="keyword">new</span> WeatherData();<span class="comment">// 创建被观察者</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建两个观察者</span></span><br><span class="line">        CurrentConditionDisplay current = <span class="keyword">new</span> CurrentConditionDisplay();</span><br><span class="line">        TomorrowConditionDisplay tomorrow = <span class="keyword">new</span> TomorrowConditionDisplay();</span><br><span class="line"></span><br><span class="line">        weatherData.addObserver(current);</span><br><span class="line">        weatherData.addObserver(tomorrow);</span><br><span class="line"></span><br><span class="line">        weatherData.setData(<span class="number">11</span>,<span class="number">222</span>,<span class="number">33</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"----------移除Tomorrow公告板----------"</span>);</span><br><span class="line">        weatherData.deleteObserver(tomorrow);</span><br><span class="line">        weatherData.setData(<span class="number">22</span>,<span class="number">444</span>,<span class="number">66</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TomorrowDisplay : [<span class="number">33.0</span>, <span class="number">666.0</span>, <span class="number">33.0</span>]</span><br><span class="line">CurrentDisplay : [<span class="number">11.0</span>, <span class="number">222.0</span>, <span class="number">33.0</span>]</span><br><span class="line">----------移除Tomorrow公告板----------</span><br><span class="line">CurrentDisplay : [<span class="number">22.0</span>, <span class="number">444.0</span>, <span class="number">66.0</span>]</span><br></pre></td></tr></table></figure><h2 id="四、总结-1"><a href="#四、总结-1" class="headerlink" title="四、总结"></a>四、总结</h2><p><strong>使用场景</strong></p><ul><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li><li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li><li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li><li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li></ul><h2 id="五、实际应用"><a href="#五、实际应用" class="headerlink" title="五、实际应用"></a>五、实际应用</h2><p>在spring中，通过ApplicationEvent类和ApplicationListener接口，可以实现ApplicationContext事件处理，这种机制就是利用的观察者模式<br>spring有一些内置的事件，当完成某种操作时会发出某些事件动作。比如监听ContextRefreshedEvent事件，当所有的bean都初始化完成并被成功装载后会触发该事件，实现ApplicationListener<contextrefreshedevent>接口可以收到监听动作，然后可以写自己的逻辑。<br>使用时实现 ApplicationListener接口并传入ContextRefreshedEvent参数</contextrefreshedevent></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestApplicationListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent contextRefreshedEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(contextRefreshedEvent);</span><br><span class="line">        System.out.println(<span class="string">"TestApplicationListener............................"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，jdk中的诸多listener都是用的这种设计模式<br>java.util.EventListener<br>javax.servlet.http.HttpSessionBindingListener<br>javax.servlet.http.HttpSessionAttributeListener<br>javax.faces.event.PhaseListener </p><h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><h2 id="一、基本概念-2"><a href="#一、基本概念-2" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>装饰者模式是结构型设计模式。</p><p>装饰模式以<strong>对客户端透明的方式扩展对象的功能</strong>，是继承关系的一个替代方案。</p><p>允许向一个现有的对象添加新的功能。同时又不改变其结构，它是作为现有的类的一个包装。</p><p>主要解决的问题: 一般我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，<strong>子类会很膨胀</strong>。</p><h2 id="二、结构-2"><a href="#二、结构-2" class="headerlink" title="二、结构"></a>二、结构</h2><p>结构：</p><ul><li>装饰者（Decorator）和具体组件（ConcreteComponent）都继承自组件（Component）；</li><li>所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能；</li><li>装饰者的方法有一部分是自己的，这属于它的功能(<strong>半透明的装饰者模式</strong>)。然后调用被装饰者的方法实现，从而也保留了被装饰者的功能；</li></ul><p><img src="/images/03_decorator_02.png" alt="03_decorator_02.png"></p><h2 id="三、案例-2"><a href="#三、案例-2" class="headerlink" title="三、案例"></a>三、案例</h2><h3 id="1、装饰者模式案例"><a href="#1、装饰者模式案例" class="headerlink" title="1、装饰者模式案例"></a>1、装饰者模式案例</h3><blockquote><p>模拟在餐馆点饮料，我们可以点咖啡，而咖啡有<code>Decaf</code>咖啡和<code>Espresso</code>咖啡，而这两种咖啡都可以加牛奶和巧克力进去。</p></blockquote><p>具体的代码组织结构图:</p><p><img src="/images/03_decorator_01.png" alt="03_decorator_01.png"></p><p>具体代码:</p><p>先看最高的<code>component</code>包下的<code>Drink</code>类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Component的超类</span></span><br><span class="line"><span class="comment"> * 单品和装饰者都要继承自这个类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String description = <span class="string">""</span>; <span class="comment">//一开始没有描述</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price = <span class="number">0</span>; <span class="comment">//一开始价格为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽象方法</span></span><br><span class="line"><span class="comment">     *  1、如果是单品的话就直接是自己的价格</span></span><br><span class="line"><span class="comment">     *  2、如果是装饰者的话就还要加上装饰品自己的价格</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// setter getter</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDescription</span><span class="params">(String description)</span> </span>&#123; <span class="comment">//描述的时候顺便把价格描述一下</span></span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看两个具体的<code>Component</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** ConcreteComponent 1*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decaf</span> <span class="keyword">extends</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decaf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setDescription(<span class="string">"Decaf"</span>);</span><br><span class="line">        <span class="keyword">super</span>.setPrice(<span class="number">3</span>); <span class="comment">//3块钱</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice();<span class="comment">//super.getPrice()//这个就是父类的价格(自己什么也没加 (没有被装饰))</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写getter 后面加上自己的花费</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getDescription() + <span class="string">"-"</span> + cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** ConcreteComponent 2</span></span><br><span class="line"><span class="comment"> *  也可以在ConcreteComponent和Drink类有一个过渡的类)  (比如Coffee类)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Espresso</span> <span class="keyword">extends</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Espresso</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setDescription(<span class="string">"Espresso"</span>);</span><br><span class="line">        <span class="keyword">super</span>.setPrice(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice();<span class="comment">//super.getPrice()//这个就是父类的价格(自己什么也没加)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getDescription() + <span class="string">"-"</span> + cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看<code>decorator</code>下的三个类:</p><p>第一个是装饰者的超类，继承自<code>Drink</code>类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Drink</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个引用很重要，可以是单品，也可以是被包装过的类型，所以使用的是超类的对象</span></span><br><span class="line"><span class="comment">     * 这个就是要被包装的单品(被装饰的对象)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Drink drink; <span class="comment">//这里要拿到父类的引用，因为要控制另一个分支(具体的组件)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Drink drink)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.drink = drink;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果drink是已经被装包过的，那么就会产生递归调用　　最终到单品</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getPrice() + drink.cost(); <span class="comment">// 自己的价格和被包装单品的价格</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getDescription() + <span class="string">"-"</span> + <span class="keyword">super</span>.getPrice()</span><br><span class="line">                + <span class="string">" &amp;&amp; "</span> + drink.getDescription();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是两个装饰者:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个是具体的装饰者() --&gt; 继承自中间的装饰着Decorator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chocolate</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chocolate</span><span class="params">(Drink drink)</span> </span>&#123; <span class="comment">//如果父类搞了一个　带参数的构造函数，子类必须显示的使用super调用</span></span><br><span class="line">        <span class="keyword">super</span>(drink);</span><br><span class="line">        <span class="keyword">super</span>.setDescription(<span class="string">"Chocolate"</span>);</span><br><span class="line">        <span class="keyword">super</span>.setPrice(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Milk</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Milk</span><span class="params">(Drink drink)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(drink); <span class="comment">//调用父类的构造函数</span></span><br><span class="line">        <span class="keyword">super</span>.setDescription(<span class="string">"Milk"</span>);</span><br><span class="line">        <span class="keyword">super</span>.setPrice(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//只点一个单品 (Decaf 咖啡)</span></span><br><span class="line">        Drink order = <span class="keyword">new</span> Decaf();</span><br><span class="line">        System.out.println(<span class="string">"order description : "</span> + order.getDescription());</span><br><span class="line">        System.out.println(<span class="string">"order price : "</span> + order.cost());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"---------------加了调料的----------------"</span>);</span><br><span class="line"></span><br><span class="line">        order = <span class="keyword">new</span> Milk(order);<span class="comment">// 加了牛奶</span></span><br><span class="line">        order = <span class="keyword">new</span> Chocolate(order);</span><br><span class="line">        order = <span class="keyword">new</span> Chocolate(order); <span class="comment">// 加了两个巧克力</span></span><br><span class="line">        System.out.println(<span class="string">"order description : "</span> + order.getDescription());</span><br><span class="line">        System.out.println(<span class="string">"order price : "</span> + order.cost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">order description : Decaf-<span class="number">3.0</span></span><br><span class="line">order price : <span class="number">3.0</span></span><br><span class="line">---------------加了调料的----------------</span><br><span class="line">order description : Chocolate-<span class="number">1.0</span> &amp;&amp; Chocolate-<span class="number">1.0</span> &amp;&amp; Milk-<span class="number">3.0</span> &amp;&amp; Decaf-<span class="number">3.0</span></span><br><span class="line">order price : <span class="number">8.0</span></span><br></pre></td></tr></table></figure><h3 id="2、JavaIO中使用装饰者模式"><a href="#2、JavaIO中使用装饰者模式" class="headerlink" title="2、JavaIO中使用装饰者模式"></a>2、JavaIO中使用装饰者模式</h3><p>由于Java I/O库需要很多性能的各种组合，如果这些性能都是用继承的方法实现的，那么每一种组合都需要一个类，这样就会造成大量性能重复的类出现，所以Java IO使用的是装饰者设计模式。</p><p><img src="/images/03_decorator_03.png" alt></p><p>所以我们可以定义自己的装饰者。</p><blockquote><p> 这里我们定义一个流，这个流将读入的小写字母转换成大写字母。</p></blockquote><p><code>UpperCaseInputStream</code>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自己定义的输入流　　</span></span><br><span class="line"><span class="comment"> * 扩展FilterInputStream(这个类就是我们的Decorator) 中间装饰者　　</span></span><br><span class="line"><span class="comment"> * 所以我们只要继承这个就可以扩展自己的输入流装饰者　</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UpperCaseInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">UpperCaseInputStream</span><span class="params">(InputStream in)</span> </span>&#123;  <span class="comment">//这个InputStream就是我们的Drink 类(超类)</span></span><br><span class="line">        <span class="keyword">super</span>(in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现两个read()方法，将大写转化成小写的读入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写　相当于cost和description</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="keyword">super</span>.read(); <span class="comment">//读取一个字节</span></span><br><span class="line">        <span class="keyword">return</span> index == -<span class="number">1</span> ? index : Character.toUpperCase((<span class="keyword">char</span>)(index));  <span class="comment">//小写转换成大写</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字节数组</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="keyword">super</span>.read(b, off, len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            b[i] = (<span class="keyword">byte</span>)Character.toUpperCase((<span class="keyword">char</span>)(b[i]));</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下使用这个类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InputStream in = <span class="keyword">new</span> UpperCaseInputStream(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"/home/zxzxin/Java_Maven/DesignPatterns/src/main/java/decorator/java/in.txt"</span>)));<span class="comment">// 将这个in.txt文件读入的内容转换成大写</span></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = in.read()) &gt;= <span class="number">0</span>)</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)(len));</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果演示:</p><p><img src="/images/03_decorator_04.png" alt="03_decorator_04.png"></p><h2 id="四、总结-2"><a href="#四、总结-2" class="headerlink" title="四、总结"></a>四、总结</h2><p>优缺点:</p><ul><li><strong>优点</strong> : 装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</li><li><strong>缺点</strong> : 多层装饰比较复杂。</li></ul><p>实际应用: 　<strong>大多数情况下，装饰模式的实现都要比上面给出的示意性例子要简单。</strong></p><ul><li>如果只有一个ConcreteComponent类，那么可以考虑去掉抽象的Component类（接口），把Decorator作为一个ConcreteComponent子类；</li><li>　如果只有一个ConcreteDecorator类，那么就没有必要建立一个单独的Decorator类，而可以把Decorator和ConcreteDecorator的责任合并成一个类。</li></ul><p>可以把装饰模式理解为不需要实现接口就可以扩展某些实例的功能<br>更加详细的解释具体可以看<a href="http://www.cnblogs.com/java-my-life/archive/2012/04/20/2455726.html" target="_blank" rel="noopener"><strong>这篇博客</strong></a>。</p><h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><h2 id="一、基本概念-3"><a href="#一、基本概念-3" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。</p><p>可以将适配器理解为我们日常用的电脑充电器: 家庭电压为<code>220V</code>，而电脑充电频率是<code>20V</code>左右，所以需要适配。</p><h2 id="二、结构-3"><a href="#二、结构-3" class="headerlink" title="二、结构"></a>二、结构</h2><p>适配器可以分为两种: 对象适配器和类适配器。</p><p><strong>对象适配器</strong>:</p><p><img src="/images/07_adapter_01.png" alt="07_adapter_01.png"></p><p>从用户的角度看不到<strong>被适配者</strong>。</p><p>用户调用适配器转换出来的目标接口方法。适配器再调用被适配者的相关接口方法。</p><p>用户收到反馈结果，感觉只是和目标接口交互。</p><p><strong>类适配器</strong>:</p><p><img src="/images/07_adapter_05.png" alt="07_adapter_05.png"></p><p>通过多重继承目标接口和被适配者类方式来实现适配。</p><h2 id="三、案例-3"><a href="#三、案例-3" class="headerlink" title="三、案例"></a>三、案例</h2><blockquote><p>案例: 将火鸡冒充成鸭子。</p></blockquote><h3 id="1、对象适配器模式"><a href="#1、对象适配器模式" class="headerlink" title="1、对象适配器模式"></a>1、对象适配器模式</h3><p>逻辑图:</p><p><img src="/images/07_adapter_03.png" alt="07_adapter_03.png"></p><p>代码组织结构图:</p><p><img src="/images/07_adapter_02.png" alt="07_adapter_02.png"></p><p>被适配者火鸡<code>Turkey</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Turkey</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">gobble</span><span class="params">()</span></span>; <span class="comment">// 火鸡叫声</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 野火鸡 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildTurkey</span> <span class="keyword">implements</span> <span class="title">Turkey</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gobble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Go Go!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I am Flying a short distance!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目标对象<code>Duck</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 鸭子的接口 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>;<span class="comment">//鸭子叫声</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>适配器<code>TurkeyAdapter</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在外面表现是 鸭子(目标)，但是实质是火鸡(被适配者)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TurkeyAdapter</span> <span class="keyword">implements</span> <span class="title">Duck</span> </span>&#123; <span class="comment">//实现目标的接口</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Turkey turkey; <span class="comment">//这种对象型适配器必须要组合  被适配者，也就是要有适配者的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TurkeyAdapter</span><span class="params">(Turkey turkey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.turkey = turkey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际是火鸡在叫</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        turkey.gobble();<span class="comment">//外面表现是quack,但是内部是turkey.gobble()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//由于火鸡飞的短，所以多飞几次，让火鸡更像鸭子</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">            turkey.fly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WildTurkey turkey = <span class="keyword">new</span> WildTurkey();</span><br><span class="line">        Duck duck = <span class="keyword">new</span> TurkeyAdapter(turkey);</span><br><span class="line">        duck.quack(); <span class="comment">//看似是鸭子，其实内置是火鸡</span></span><br><span class="line">        duck.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Go Go!</span><br><span class="line">I am Flying a <span class="keyword">short</span> distance!</span><br><span class="line">I am Flying a <span class="keyword">short</span> distance!</span><br><span class="line">I am Flying a <span class="keyword">short</span> distance!</span><br><span class="line">I am Flying a <span class="keyword">short</span> distance!</span><br><span class="line">I am Flying a <span class="keyword">short</span> distance!</span><br><span class="line">I am Flying a <span class="keyword">short</span> distance!</span><br></pre></td></tr></table></figure><h3 id="2、类适配器模式"><a href="#2、类适配器模式" class="headerlink" title="2、类适配器模式"></a>2、类适配器模式</h3><p>基本结构图:</p><p><img src="/images/07_adapter_04.png" alt="07_adapter_04.png"></p><p>虽然Java不支持多继承，但是可以实现的同时继承。</p><p>只有<code>TurkeyAdapter</code>有一些代码变动，其他不变:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 和 对象适配器模式唯一的不同就是  : 适配器直接继承 被适配者 (而不是组合)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TurkeyAdapter</span> <span class="keyword">extends</span> <span class="title">WildTurkey</span> <span class="keyword">implements</span>  <span class="title">Duck</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.gobble(); <span class="comment">//直接继承 被适配者</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//让火鸡飞6次，飞的像鸭子</span></span><br><span class="line">        <span class="keyword">super</span>.fly();</span><br><span class="line">        <span class="keyword">super</span>.fly();</span><br><span class="line">        <span class="keyword">super</span>.fly();</span><br><span class="line">        <span class="keyword">super</span>.fly();</span><br><span class="line">        <span class="keyword">super</span>.fly();</span><br><span class="line">        <span class="keyword">super</span>.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TurkeyAdapter duck = <span class="keyword">new</span> TurkeyAdapter();<span class="comment">//直接new即可</span></span><br><span class="line">        duck.quack();</span><br><span class="line">        duck.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出和上面对象适配器一样。</p><h3 id="3、Java中从以前枚举器Enumeration到迭代器Iterator的适配"><a href="#3、Java中从以前枚举器Enumeration到迭代器Iterator的适配" class="headerlink" title="3、Java中从以前枚举器Enumeration到迭代器Iterator的适配"></a>3、Java中从以前枚举器Enumeration到迭代器Iterator的适配</h3><p>从<code>Enumeration</code>到<code>Iterator</code>适配的结构图:</p><p><img src="/images/07_adapter_06.png" alt="07_adapter_06.png"></p><p>一个实例代码:(下面<code>EnumerationIterator</code>就是一个适配器)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 对象适配器的举例 java中的枚举到迭代器 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumerationIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Enumeration enumeration; <span class="comment">//枚举 : 被适配者</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EnumerationIterator</span><span class="params">(Enumeration enumeration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.enumeration = enumeration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> enumeration.hasMoreElements(); <span class="comment">//实际调用的是 被适配者 的方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> enumeration.nextElement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个可以说是适配器的缺点， 有些不能适配，比如两个插孔的插头不能适配为三个插孔的插头</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、总结-3"><a href="#四、总结-3" class="headerlink" title="四、总结"></a>四、总结</h2><p>对象适配器和类适配器使用了不同的方法实现适配，<strong>对象适配器使用组合，类适配器使用继承</strong>。<br>总的来说，这种模式的思想就是把不能使用在特定环境的对象或类，通过适配器类，转换为可以用在该环境下的类或对象。</p><h2 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h2><p>除了上面提到的使用外，在springmvc中，这种模式也有使用<br>Spring MVC中的Controller种类众多，不同类型的Controller通过不同的方法来对请求进行处理。如果不利用适配器模式的话，DispatcherServlet直接获取对应类型的Controller，需要的自行来判断，每增加一个controller，就会多一层判断<br>为了实现适配器模式，首先定义一个接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span></span>;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function">ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>supports()方法传入处理器（宽泛的概念Controller，以及HttpRequestHandler，Servlet，等等）判断是否与当前适配器支持如果支持则从DispatcherServlet中的HandlerAdapter实现类中返回支持的适配器实现类。handler方法就是代理Controller来执行请求的方法并返回结果。</p><p>在DispatchServlert中的doDispatch方法中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br></pre></td></tr></table></figure></p><p>此代码通过调用DispatchServlert 中getHandlerAdapter传入Controller（宽泛的概念Controller，以及HttpRequestHandler，Servlet，等等），来获取对应的HandlerAdapter 的实现子类，从而做到使得每一种Controller有一种对应的适配器实现类</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://img.3dmgame.com/uploads/images/thumbpicfirst/20190219/1550567116_731464.jpg&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>设计模式总结（1）【单例模式，三种工厂模式】</title>
    <link href="https://www.junglezero.top/2019/07/25/sign-pattern/"/>
    <id>https://www.junglezero.top/2019/07/25/sign-pattern/</id>
    <published>2019-07-25T14:21:02.000Z</published>
    <updated>2019-07-25T14:50:01.202Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/upload/pasted-433.png" width="70%"></p><a id="more"></a><hr><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>单例模式属于创建型设计模式。</p><p>确保一个类只有一个实例，并提供该实例的全局访问点。</p><p>实现: <strong>使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现</strong>。</p><h2 id="二、结构"><a href="#二、结构" class="headerlink" title="二、结构"></a>二、结构</h2><p>类图:</p><p><img src="/upload/14_singleton.png" alt="14_singleton.png"></p><p><strong>私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量</strong>。</p><h2 id="三、几类经典单例模式实现"><a href="#三、几类经典单例模式实现" class="headerlink" title="三、几类经典单例模式实现"></a>三、几类经典单例模式实现</h2><h3 id="1、懒汉式-线程不安全"><a href="#1、懒汉式-线程不安全" class="headerlink" title="1、懒汉式-线程不安全"></a>1、懒汉式-线程不安全</h3><p>所谓懒汉式，就是说等到用的时候再进行创建</p><p>这种实现方法线程不安全，如果多个线程能够同时进入 <code>if (uniqueInstance == null)</code> ，并且此时 <code>uniqueInstance == null</code>，那么会有多个线程执行 <code>uniqueInstance = new Singleton();</code> 语句，这将导致实例化多次 <code>uniqueInstance</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式: 线程不安全</span></span><br><span class="line"><span class="comment">// 有延迟加载: 不是在类加载的时候就创建了，而是在调用newStance()的时候才会创建</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有静态实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、懒汉式-线程安全-性能不好"><a href="#2、懒汉式-线程安全-性能不好" class="headerlink" title="2、懒汉式-线程安全-性能不好"></a>2、懒汉式-线程安全-性能不好</h3><p>解决上面线程不安全的最直接方法就是上锁</p><p>但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待，即使 <code>uniqueInstance</code> 已经被实例化了。这会让线程阻塞时间过长，因此该方法有性能问题<br><strong>不推荐使用</strong>。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">newInstance</span><span class="params">()</span></span>&#123;<span class="comment">//在上面的基础上加了synchronized</span></span><br><span class="line">    <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)</span><br><span class="line">        uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、饿汉式-线程安全-无延迟加载"><a href="#3、饿汉式-线程安全-无延迟加载" class="headerlink" title="3、饿汉式-线程安全-无延迟加载"></a>3、饿汉式-线程安全-无延迟加载</h3><p>饿汉式：类一初始化就进行实例的创建（等不及了）</p><p>这种方式比较常用，但容易产生垃圾对象(丢失了延迟实例化(<code>lazy loading</code>)带来的节约资源的好处)。</p><p>它基于 <strong>classloader机制</strong>避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， <strong>但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazyloading 的效果</strong>。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、双重校验锁-线程安全"><a href="#4、双重校验锁-线程安全" class="headerlink" title="4、双重校验锁-线程安全"></a>4、双重校验锁-线程安全</h3><p><code>uniqueInstance</code> 只需要被实例化一次，之后就可以直接使用了。这种线程安全的优化方式就是缩小加锁的范围，只有当<code>uniqueInstance</code> 没有被实例化时，才需要进行加锁。</p><p>双重校锁：<br><strong>第一次校验：</strong>由于单例模式只需要创建一次实例，如果后面再次调用getInstance方法时，则直接返回之前创建的实例，因此大部分时间不需要执行同步方法里面的代码，大大提高了性能。如果不加第一次校验的话，那跟上面的懒汉模式没什么区别，每次都要去竞争锁。<br><strong>第二次校验：</strong>如果没有第二次校验，假设线程t1执行了第一次校验后，判断为null，这时t2也获取了CPU执行权，也执行了第一次校验，判断也为null。接下来t2获得锁，创建实例。这时t1又获得CPU执行权，由于之前已经进行了第一次校验，结果为null（不会再次判断），获得锁后，直接创建实例。结果就会导致创建多个实例。所以需要在同步代码里面进行第二次校验，如果实例为空，则进行创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双重加锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不需要先实例化</span></span><br><span class="line">    <span class="comment">// 使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一次校验</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// //第二次校验</span></span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p><ul><li>1)、为 <code>uniqueInstance</code> 分配内存空间；</li><li>2)、初始化 <code>uniqueInstance</code>；</li><li>3)、将 <code>uniqueInstance</code> 指向分配的内存地址；</li></ul><p>但是由于 JVM 具有<strong>指令重排</strong>的特性，执行顺序有可能变成 <code>1&gt;3&gt;2</code>。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 <code>T1</code> 执行了 1 和 3，此时 <code>T2</code>调用 <code>newInstance()</code> 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code>，但此时 <code>uniqueInstance</code> 还未被初始化。</p><p><strong>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行</strong>。</p><h3 id="5、静态内部类实现"><a href="#5、静态内部类实现" class="headerlink" title="5、静态内部类实现"></a>5、静态内部类实现</h3><p>当 <code>Singleton</code> 类加载时，<strong>静态内部类 Holder 没有被加载进内存</strong>。只有当调用 <code>newInstance()</code> 方法从而触发 <code>Holder.uniqueInstance</code> 时 <code>Holder</code>才会被加载，此时初始化<code>uniqueInstance</code> 实例，并且 JVM 能确保 <code>uniqueInstance</code> 只被实例化一次。</p><p>这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。</p><blockquote><p>这种方式是 Singleton 类被装载了，<code>uniqueInstance</code> 不一定被初始化。因为 <code>Holder</code>s 类没有被主动使用，只有通过显式调用 <code>newInstance()</code>方法时，才会显式装载 Holder 类，从而实例化<code>uniqueInstance</code>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、枚举实现"><a href="#6、枚举实现" class="headerlink" title="6、枚举实现"></a>6、枚举实现</h3><p>这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。</p><p>该实现在多次序列化再进行反序列化之后，不会得到多个实例。而其它实现需要使用 <code>transient</code> 修饰所有字段，并且实现序列化和反序列化的方法。</p><p>枚举实现单例 (+测试):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Sing.INSTANCE.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> Sing &#123;</span><br><span class="line"></span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//jvm guarantee only run once</span></span><br><span class="line">        Sing() &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Singleton <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line"></span><br><span class="line">        Set&lt;Singleton&gt;set = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;&gt;());<span class="comment">//注意set也要加锁</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line"></span><br><span class="line">                    set.add(Singleton.newInstance());</span><br><span class="line"></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">        System.out.println(set.size());<span class="comment">//1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于序列化和反序列化:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 单例测试</span></span><br><span class="line">        Singleton s1 = Singleton.INSTANCE;</span><br><span class="line">        s1.setName(<span class="string">"firstName"</span>);</span><br><span class="line">        System.out.println(<span class="string">"s1.getName(): "</span> + s1.getName());</span><br><span class="line"></span><br><span class="line">        Singleton s2 = Singleton.INSTANCE;</span><br><span class="line">        s2.setName(<span class="string">"secondName"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意我这里输出s1 ，但是已经变成了 secondName</span></span><br><span class="line">        System.out.println(<span class="string">"s1.getName(): "</span> + s1.getName());</span><br><span class="line">        System.out.println(<span class="string">"s2.getName(): "</span> + s2.getName());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反射获取实例测试</span></span><br><span class="line">        Singleton[] enumConstants = Singleton.class.getEnumConstants();</span><br><span class="line">        <span class="keyword">for</span> (Singleton enumConstant : enumConstants)</span><br><span class="line">            System.out.println(enumConstant.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1.getName(): firstName</span><br><span class="line">s1.getName(): secondName</span><br><span class="line">s2.getName(): secondName</span><br><span class="line">-----------------</span><br><span class="line">secondName</span><br></pre></td></tr></table></figure><blockquote><p>该实现可以防止反射攻击。在其它实现中，通过 <code>setAccessible()</code>(反射中的强制访问私有属性方法) 方法可以将私有构造函数的访问级别设置为 public，然后调用构造函数从而实例化对象，如果要防止这种攻击，需要在构造函数中添加防止多次实例化的代码。该实现是由 JVM 保证只会实例化一次，因此不会出现上述的反射攻击。</p></blockquote><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>一般情况下，<strong>不建议使用懒汉方式</strong>，建议使用饿汉方式。</p><p>只有在要明确实现 <code>lazy loading</code> 效果时，才会使用<strong>静态内部类方式</strong>。</p><p>如果涉及到<strong>反序列化创建对象</strong>时，可以尝试使用枚举方式。</p><p>如果有其他特殊的需求，可以考虑使用双检锁方式。</p><h2 id="五、应用实例"><a href="#五、应用实例" class="headerlink" title="五、应用实例"></a>五、应用实例</h2><p>Spring下默认的bean均为singleton，可以通过singleton=“true|false” 或者 scope=“？”来指定<br>这样做可以减少cpu内存的浪费。可能有人觉得多用户走多线程只运行一个实例肯定会引发线程安全问题，但在这里应当理解线程安全问题的本质：全局变量，公共变量被多个线程同时操作。虽然spring对象是单例的，但类里面方法对每个线程来说都是独立运行的，不存在多线程问题，只有成员变量有多线程问题，所以方法里面如果有用到成员变量就要考虑用安全的数据结构。对于有着特殊状态值（一定意义上的全局变量）的单例对象，spring使用ThreadLocal维护线程安全，不过这是另一个问题了。<br><a href="https://blog.csdn.net/zengdeqing2012/article/details/77098994" target="_blank" rel="noopener">https://blog.csdn.net/zengdeqing2012/article/details/77098994</a><br>在java JDK中</p><p>java.lang.Runtime#getRuntime()<br>java.awt.Desktop#getDesktop()<br>java.lang.System#getSecurityManager()<br>使用的都是单例模式，为什么？因为只要一个就够了。</p><h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><h2 id="一、基本概念-1"><a href="#一、基本概念-1" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p><strong>简单工厂模式是类的创建模式，又叫做静态工厂方法（Static Factory Method）模式。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例</strong>。</p><p>在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。<br>这个模式严格来讲是下面工厂方法模式的一个特例</p><h2 id="二、结构-1"><a href="#二、结构-1" class="headerlink" title="二、结构"></a>二、结构</h2><p>简单工厂把实例化的操作单独放到一个类中，这个类就是简单工厂类(Simple Factory)，<strong>让简单工厂类来决定应该用哪个具体子类来实例化 (而不是在客户端中决定)</strong>。</p><p>这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。</p><p>客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。</p><p>结构:</p><p><img src="/upload/04_simple_01.png" alt="04_simple_01.png"></p><h2 id="三、案例"><a href="#三、案例" class="headerlink" title="三、案例"></a>三、案例</h2><blockquote><p>模拟在<code>type == 1</code>的时候创建<code>ConcreteProduct1</code>、在<code>type == 2</code>的时候创建<code>ConcreteProduct2</code>、其他时候创建<code>ConcreteProduct</code>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们按照下面的方式创建，则我们在客户端包含了这些需要判断条件的实例化代码，则可以将这些实例化代码放到简单工厂中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不好的设计</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> type = <span class="number">1</span>;</span><br><span class="line">        Product product;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">            product = <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">            product = <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            product = <span class="keyword">new</span> ConcreteProduct();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// do something with the product</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是我们可以增加一个简单工厂类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以将createProduct写成静态的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们的测试类可以写成下面的样子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleFactory simpleFactory = <span class="keyword">new</span> SimpleFactory();</span><br><span class="line">        Product product = simpleFactory.createProduct(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// do something with product</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样既让客户端和具体类解耦，而且在客户端也看不到具体的繁杂的实例化代码。</p><h2 id="四、总结-1"><a href="#四、总结-1" class="headerlink" title="四、总结"></a>四、总结</h2><p>缺点 : 这个工厂类集中了所有的创建逻辑，当有复杂的多层次等级结构时，所有的业务逻辑都在这个工厂类中实现。什么时候它不能工作了，整个系统都会受到影响。</p><p>我们强调<strong>职责单一</strong>原则，一个类只提供一种功能。</p><h2 id="五、应用实例-1"><a href="#五、应用实例-1" class="headerlink" title="五、应用实例"></a>五、应用实例</h2><p>spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。如下配置，就是在 HelloItxxz 类中创建一个 itxxzBean。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"singletonBean"</span> <span class="attr">class</span>=<span class="string">"com.itxxz.HelloItxxz"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>Hello! 这是singletonBean!value&gt;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/ <span class="attr">bean</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"itxxzBean"</span> <span class="attr">class</span>=<span class="string">"com.itxxz.HelloItxxz"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">singleton</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>Hello! 这是itxxzBean! value&gt;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在juc中，类Executors就是一个典型的简单工厂方法类，在这类下，提供了创建多种ExecutorService的静态方法，在使用时直接调用这个类的静态方法创建不同的ExecutorService即可，而不需要再在客户端创建不同的实例</p><h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><h2 id="一、基本概念-2"><a href="#一、基本概念-2" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p><strong>工厂方法模式是类的创建模式，又叫做虚拟构造子(Virtual Constructor)模式或者多态性工厂（Polymorphic Factory）模式</strong>。<br>工厂方法模式的用意是<strong>定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中</strong>。</p><p>或者说引入工厂模式的目的就是我们需要多个工厂，但是每个工厂内部又要划分情况，如果只用一个工厂的话，会产生多种复合的情况。</p><p>比如说我们有两个工厂，每个工厂有3种情况，如果用简单工厂模式，要分为 <code>3 * 2 = 6</code>种情况，所以可以用工厂方法模式解决。</p><h2 id="二、结构-2"><a href="#二、结构-2" class="headerlink" title="二、结构"></a>二、结构</h2><p>在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由大工厂的子类(或者实现类)来创建对象。</p><p>即上面有一个大工厂，下面是分类的工厂。</p><p><img src="/upload/05_method_03.png" alt="05_method_03.png"></p><h2 id="三、案例-1"><a href="#三、案例-1" class="headerlink" title="三、案例"></a>三、案例</h2><blockquote><p>案例，模拟需要生成中国食物A，中国食物B，美国食物A，美国食物B。</p></blockquote><p>代码逻辑结构图:</p><p><img src="/upload/05_method_01.png" alt="05_method_01.png"></p><p>基本结构图:</p><p><img src="/upload/04_method_02.png" alt="04_method_02.png"></p><p>先给出这些食物(<code>Product</code>):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmericanFoodA</span> <span class="keyword">implements</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmericanFoodB</span> <span class="keyword">implements</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChineseFoodA</span> <span class="keyword">implements</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChineseFoodB</span> <span class="keyword">implements</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是抽象工厂:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FoodFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Food <span class="title">makeFood</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是两个子工厂:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChineseFoodFactory</span> <span class="keyword">implements</span> <span class="title">FoodFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">makeFood</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">"A"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ChineseFoodA();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">"B"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ChineseFoodB();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmericanFoodFactory</span> <span class="keyword">implements</span> <span class="title">FoodFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">makeFood</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">"A"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AmericanFoodA();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">"B"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AmericanFoodB();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先选择一个具体的工厂</span></span><br><span class="line">        FoodFactory factory = <span class="keyword">new</span> ChineseFoodFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由第一步的工厂产生具体的对象，不同的工厂造出不一样的对象</span></span><br><span class="line">        Food food = factory.makeFood(<span class="string">"A"</span>); <span class="comment">//  chineseFood * A</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、总结-2"><a href="#四、总结-2" class="headerlink" title="四、总结"></a>四、总结</h2><p>工厂方法模式和简单工厂模式在结构上的不同很明显。</p><p><strong>工厂方法模式的核心是一个抽象工厂类，而简单工厂模式把核心放在一个具体类上</strong>。</p><p>工厂方法模式退化后可以变得很像简单工厂模式。设想如果非常确定一个系统只需要一个具体工厂类，那么不妨把抽象工厂类合并到具体工厂类中去。由于只有一个具体工厂类，所以不妨将工厂方法改为静态方法，这时候就得到了简单工厂模式。</p><h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><h2 id="一、基本概念-3"><a href="#一、基本概念-3" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>当涉及到<strong>产品族</strong>的时候，就需要引入抽象工厂模式了。</p><p>每一个模式都是针对一定问题的解决方案。抽象工厂模式与工厂方法模式的最大区别就在于，<strong>工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则需要面对多个产品等级结构</strong>。</p><p>在学习抽象工厂具体实例之前，应该明白两个重要的概念：产品族和产品等级。</p><p>所谓产品族，是指位于不同产品等级结构中，功能相关联的产品组成的家族。比如AMD的主板、芯片组、CPU组成一个家族，Intel的主板、芯片组、CPU组成一个家族。而这两个家族都来自于三个产品等级：主板、芯片组、CPU。一个等级结构是由相同的结构的产品组成，示意图如下：</p><p><img src="/upload/06_abstract_06.png" alt="06_abstract_06.png"></p><h2 id="二、案例"><a href="#二、案例" class="headerlink" title="二、案例"></a>二、案例</h2><p>一个经典的例子是造一台电脑。我们先不引入抽象工厂模式，看看怎么实现。</p><p>因为电脑是由许多的构件组成的，我们将 CPU 和主板进行抽象，然后 CPU 由 CPUFactory 生产，主板由 MainBoardFactory 生产，然后，我们再将 CPU 和主板搭配起来组合在一起，如下:</p><p><img src="/upload/06_abstract_01.png" alt="06_abstract_01.png"></p><p>代码组织结构:</p><p><img src="/upload/06_abstract_02.png" alt="06_abstract_02.png"></p><p>这个时候的客户端调用是这样的（测试类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 得到 Intel 的 CPU</span></span><br><span class="line">        CPUFactory intelCPUFactory = <span class="keyword">new</span> IntelCPUFactory();</span><br><span class="line">        CPU cpu = intelCPUFactory.makeCPU();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到 AMD 的主板</span></span><br><span class="line">        MainBoardFactory mainBoardFactory = <span class="keyword">new</span> AmdMainBoardFactory();</span><br><span class="line">        MainBoard mainBoard = mainBoardFactory.makeMB();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 组装 CPU 和主板</span></span><br><span class="line">        Computer computer = <span class="keyword">new</span> Computer(cpu, mainBoard);</span><br><span class="line">        System.out.println(computer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体的完整代码可以看<a href="https://github.com/ZXZxin/ZXNotes/tree/master/%E6%9D%82%E9%A1%B9/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/factory" target="_blank" rel="noopener">这里</a></strong></p><p>单独看 CPU 工厂和主板工厂，它们分别是前面我们说的<strong>工厂模式</strong>。</p><p>这种方式也容易扩展，因为要给电脑加硬盘的话，只需要加一个 HardDiskFactory 和相应的实现即可，不需要修改现有的工厂。</p><p>但是，这种方式有一个问题，那就是如果 <strong>Intel 家产的 CPU 和 AMD 产的主板不能兼容使用</strong>，那么这代码就容易出错，因为客户端并不知道它们不兼容，也就会错误地出现随意组合。</p><p>下面就是我们要说的<strong>产品族</strong>的概念，它代表了组成某个产品的一系列附件的集合：</p><p><img src="/upload/06_abstract_03.png" alt="06_abstract_03.png"></p><p>当涉及到这种产品族的问题的时候，就需要抽象工厂模式来支持了。我们不再定义 CPU 工厂、主板工厂、硬盘工厂、显示屏工厂等等，<strong>我们直接定义电脑工厂，每个电脑工厂负责生产所有的设备，这样能保证肯定不存在兼容问题</strong>。</p><p><img src="/upload/06_abstract_04.png" alt="06_abstract_04.png"></p><p>这个时候，对于客户端来说，不再需要单独挑选 CPU厂商、主板厂商、硬盘厂商等，直接选择一家品牌工厂，品牌工厂会负责生产所有的东西，而且能保证肯定是兼容可用的。</p><p>改装的抽象工厂模式代码组织结构如下:</p><p><img src="/upload/06_abstract_05.png" alt="06_abstract_05.png"></p><p>主要的代码:</p><p>三个工厂:(一个超类工厂<code>PCFactory</code>，两个大厂工厂<code>AmdFactory</code>、<code>InterFactory</code>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PCFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">CPU <span class="title">makeCPU</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">MainBoard <span class="title">makeMB</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// HardDisk makeHD();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmdFactory</span> <span class="keyword">implements</span> <span class="title">PCFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CPU <span class="title">makeCPU</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AmdCPU();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MainBoard <span class="title">makeMB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AmdMainBoard();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntelFactory</span> <span class="keyword">implements</span> <span class="title">PCFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CPU <span class="title">makeCPU</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IntelCPU();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MainBoard <span class="title">makeMB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IntelMainBoard();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的测试类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 第一步就要选定一个“大厂”</span></span><br><span class="line">        PCFactory cf = <span class="keyword">new</span> AmdFactory();</span><br><span class="line">        <span class="comment">// 从这个大厂造 CPU</span></span><br><span class="line">        CPU cpu = cf.makeCPU();</span><br><span class="line">        <span class="comment">// 从这个大厂造主板</span></span><br><span class="line">        MainBoard board = cf.makeMB();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//... 从这个大厂造硬盘。等等</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将同一个厂子出来的 CPU、主板、硬盘组装在一起</span></span><br><span class="line">        Computer computer = <span class="keyword">new</span> Computer(cpu, board);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>当然，抽象工厂的问题也是显而易见的，比如我们要加个显示器，就需要修改所有的工厂，给所有的工厂都加上制造显示器的方法。这有点违反了<strong>对修改关闭，对扩展开放</strong>这个设计原则。</p><h1 id="三种工厂方法对比"><a href="#三种工厂方法对比" class="headerlink" title="三种工厂方法对比"></a>三种工厂方法对比</h1><p><img src="/upload/pasted-470.png" alt="06_abstract_03.png"><br><img src="/upload/pasted-472.png" alt="06_abstract_03.png"><br><img src="/upload/pasted-473.png" alt="06_abstract_03.png"><br><img src="/upload/pasted-474.png" alt="06_abstract_03.png"><br><img src="/upload/pasted-475.png" alt="06_abstract_03.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/upload/pasted-433.png&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL深入学习（3）【ID策略，横向扩展】</title>
    <link href="https://www.junglezero.top/2019/07/23/SQLDeepLearn3/"/>
    <id>https://www.junglezero.top/2019/07/23/SQLDeepLearn3/</id>
    <published>2019-07-23T00:58:56.000Z</published>
    <updated>2019-07-23T07:47:07.490Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://img2.ali213.net/picfile/News/2015/05/14/2015051494057329.jpg" width="70%"><br><a id="more"></a></p><h1 id="ID策略"><a href="#ID策略" class="headerlink" title="ID策略"></a>ID策略</h1><ol><li><p>利用数据库自增ID<br>优点：最简单。 缺点：单点风险、单机性能瓶颈。</p></li><li><p>利用数据库集群并设置相应的步长（Flickr方案）<br>优点：高可用、ID较简洁。 缺点：需要单独的数据库集群。</p></li><li><p>Twitter Snowflake<br>优点：高性能高可用、易拓展。 缺点：需要独立的集群以及ZK。</p></li><li><p>一大波GUID、Random算法<br>优点：简单。 缺点：生成ID较长，有重复几率。</p></li></ol><h1 id="横向扩展MySQL服务器"><a href="#横向扩展MySQL服务器" class="headerlink" title="横向扩展MySQL服务器"></a>横向扩展MySQL服务器</h1><p>由多台MySQL服务器，提供数据存储服务器。<br>横向扩展是根本提升数据库服务器性能的手段！受限于单台计算机的硬件处理能力，去使用多台计算机完成同一个服务的支持。<br>比较典型的概念：<br>读写分离，负载均衡。<br>需要用到的技术，MySQL复制技术，负载均衡中间件。</p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。</p><ul><li>binlog 线程 ：负责将主服务器上的数据更改写入二进制文件（binlog）中。</li><li>I/O 线程 ：负责从主服务器上读取二进制日志文件，并写入从服务器的中继日志中。</li><li>SQL 线程 ：负责读取中继日志并重放其中的 SQL 语句。</li></ul><p><img src="/upload/pasted-453.png" alt="upload successful"></p><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>主服务器用来处理写操作以及实时性要求比较高的读操作，而从服务器用来处理读操作。<br>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个<br>服务器。<br>MySQL 读写分离能提高性能的原因在于：<br>主从服务器负责各自的读和写，极大程度缓解了锁的争用；<br>从服务器可以配置 MyISAM 引擎，提升查询性能以及节约系统开销；<br>增加冗余，提高可用性。</p><p><img src="/upload/pasted-452.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://img2.ali213.net/picfile/News/2015/05/14/2015051494057329.jpg&quot; width=&quot;70%&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL深入研究（2）【查询优化，分区，分表】</title>
    <link href="https://www.junglezero.top/2019/07/21/QLDeepLearn/"/>
    <id>https://www.junglezero.top/2019/07/21/QLDeepLearn/</id>
    <published>2019-07-21T09:24:00.000Z</published>
    <updated>2019-07-23T07:10:10.234Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://images.ali213.net/picfile/pic/2017/10/27/927_2017102712122202.jpg" width="70%"><br><a id="more"></a></p><h1 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h1><h2 id="减少请求的数据量"><a href="#减少请求的数据量" class="headerlink" title="减少请求的数据量"></a>减少请求的数据量</h2><p>（一）只返回必要的列<br>最好不要使用 SELECT * 语句。<br>（二）只返回必要的行<br>使用 WHERE 语句进行查询过滤，有时候也需要使用 LIMIT 语句来限制返回的数据。<br>（三）缓存重复查询的数据<br>使用缓存可以避免在数据库中进行查询，特别要查询的数据经常被重复查询，缓存可以带来的查询性能提升将会是非常明显的。<br>若想要应用缓存，首先在my.ini或者my.cnf中配置query_cache_type，1表示默认缓存，需要sql_no_cache提示为不缓存，2表示默认不缓存，需要sql_cache主动缓存，0表示不缓存 。query_cache_size配置缓存大小<br>对于配置为2选项，若要进行缓存<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">SQL_CACHE</span> *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student</span><br></pre></td></tr></table></figure></p><p>调用reset query cache 可以清空缓存<br>当数据表改动时，基于整个表的缓存就会被删除<br>动态数据无法缓存</p><h2 id="重构查询方式"><a href="#重构查询方式" class="headerlink" title="重构查询方式"></a>重构查询方式</h2><h3 id="切分大查询"><a href="#切分大查询" class="headerlink" title="切分大查询"></a>切分大查询</h3><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。因此，可以把一个大范围操作切分为一个小范围操作<br>一个全范围的删除操作，可以切分为多个小段删除操作<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">messages</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">CREATE</span> &lt; <span class="keyword">DATE_SUB</span>(<span class="keyword">NOW</span>(), <span class="built_in">INTERVAL</span> <span class="number">3</span> <span class="keyword">MONTH</span>);</span><br></pre></td></tr></table></figure></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rows_affected = 0</span><br><span class="line"><span class="keyword">DO</span></span><br><span class="line">&#123; rows_affected = do_query (</span><br><span class="line"><span class="string">"DELETE FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 M</span></span><br><span class="line"><span class="string">ONTH) LIMIT 10000"</span></span><br><span class="line">) &#125;</span><br><span class="line"><span class="keyword">WHILE</span> rows_affected &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="分解大的连接查询"><a href="#分解大的连接查询" class="headerlink" title="分解大的连接查询"></a>分解大的连接查询</h3><ol start="2"><li>分解大连接查询<br>将一个大连接查询（JOIN）分解成对每一个表进行一次单表查询，然后将结果在应用程序中<br>进行关联，这样做的好处有：</li></ol><ul><li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li><li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li><li>减少锁竞争；</li><li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可扩展。</li><li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">tab</span><br><span class="line"><span class="keyword">JOIN</span> tag_post <span class="keyword">ON</span> tag_post.tag_id = tag.id</span><br><span class="line"><span class="keyword">JOIN</span> post <span class="keyword">ON</span> tag_post.post_id = post.id</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">tag.tag = <span class="string">'mysql'</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag <span class="keyword">WHERE</span> tag=<span class="string">'mysql'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag_post <span class="keyword">WHERE</span> tag_id=<span class="number">1234</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> post <span class="keyword">WHERE</span> post.id <span class="keyword">IN</span> (<span class="number">123</span>,<span class="number">456</span>,<span class="number">567</span>,<span class="number">9098</span>,<span class="number">8904</span>);</span><br></pre></td></tr></table></figure><h1 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>将一个表中的数据和索引，分散到不同的文件中进行存储，称之为分区操作，划分出来到文件就是不同的分区<br>分区的意义是将一个具有大量数据的表，将其分散到不同的数据和索引文件中进行储存<br>对于Innodb来说，相当于一个表对应对个ibd文件<br>分散之后，每个文件对应的数据量显著减少，保证单个文件的执行速度<br>一般情况就是根据id主键字段进行分区，或者为主键，唯一键的一个子集，在创建表时，利用partition进行设定<br>例如下面，就是利用id字段，使用hash算法，将数据分布在10个分区中<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t2 (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> auto_increment promary <span class="keyword">key</span>,</span><br><span class="line">col2 <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">col3 <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">col4 <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (col1),</span><br><span class="line"><span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> (col3)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">HASH</span>(<span class="keyword">id</span>)</span><br><span class="line"><span class="keyword">PARTITIONS</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure></p><p>分区完成后，客户端看上去还是一张表。</p><h2 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h2><p>range分区：基于一个给定的连续区间范围(区间要求连续并且不能重叠)，把数据分配到不同的分区<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t2 (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> auto_increment promary <span class="keyword">key</span>,</span><br><span class="line">col2 <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">col3 <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">pubtime <span class="built_in">INT</span> ,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>,pubtime),</span><br><span class="line"><span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> (col3)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>(pubtime)(</span><br><span class="line"><span class="keyword">PARTITION</span> p201907 <span class="keyword">VALUES</span> <span class="keyword">less</span> <span class="keyword">than</span> (<span class="number">1509665599</span>) <span class="comment">-- 某个时间的时间戳</span></span><br><span class="line"><span class="keyword">PARTITION</span> p201907 <span class="keyword">VALUES</span> <span class="keyword">less</span> <span class="keyword">than</span> (<span class="number">1512355599</span>) <span class="comment">-- 某个时间的时间戳</span></span><br><span class="line"><span class="keyword">PARTITION</span> p201907 <span class="keyword">VALUES</span> <span class="keyword">less</span> <span class="keyword">than</span> (<span class="number">1540765599</span>) <span class="comment">-- 某个时间的时间戳</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>条件只能用小于，更小的时间戳要放在前面<br>list分区：类似于range分区，区别在于list分区是居于枚举出的值列表分区，range是基于给定的连续区间范围分区，使用 in(值列表)<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t2 (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> auto_increment promary <span class="keyword">key</span>,</span><br><span class="line">col2 <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">col3 <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">status</span> <span class="built_in">INT</span> ,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>,pubtime),</span><br><span class="line"><span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> (col3)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>(<span class="keyword">status</span>)(</span><br><span class="line"><span class="keyword">PARTITION</span> p1 <span class="keyword">VALUES</span> <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>),</span><br><span class="line"><span class="keyword">PARTITION</span> p2 <span class="keyword">VALUES</span> <span class="keyword">in</span> (<span class="number">3</span>,<span class="number">4</span>),</span><br><span class="line"><span class="keyword">PARTITION</span> p3 <span class="keyword">VALUES</span> <span class="keyword">in</span> (<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>hash分区：基于给定的分区个数，把数据分配到不同的分区，采取的是求余方案，所谓hash算法，就是对于输入，得到某个特定的输出，要求如果输入相同的值应当得到相同的输出。这种算法在业务逻辑上表现为均匀分配<br>key分区：类似于hash分区，在hash中，只能对整数进行分区，但是key可以使用非整数类型进行分区（如字符串）</p><h2 id="分区管理"><a href="#分区管理" class="headerlink" title="分区管理"></a>分区管理</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除list或者range分区(同时删除分区对应的数据)</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> &lt;<span class="keyword">table</span>&gt; <span class="keyword">drop</span> <span class="keyword">partition</span> &lt;分区名称&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 新增分区</span></span><br><span class="line"><span class="comment">-- range添加新分区</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> &lt;<span class="keyword">table</span>&gt; <span class="keyword">add</span> <span class="keyword">partition</span>(<span class="keyword">partition</span> p4 <span class="keyword">values</span> <span class="keyword">less</span> <span class="keyword">than</span> MAXVALUE);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- list添加新分区</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> &lt;<span class="keyword">table</span>&gt; <span class="keyword">add</span> <span class="keyword">partition</span>(<span class="keyword">partition</span> p4 <span class="keyword">values</span> <span class="keyword">in</span> (<span class="number">25</span>,<span class="number">26</span>,<span class="number">28</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- hash重新分区</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> &lt;<span class="keyword">table</span>&gt; <span class="keyword">add</span> <span class="keyword">partition</span> <span class="keyword">partitions</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- key重新分区</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> &lt;<span class="keyword">table</span>&gt; <span class="keyword">add</span> <span class="keyword">partition</span> <span class="keyword">partitions</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 子分区添加新分区，虽然我没有指定子分区，但是系统会给子分区命名的</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> &lt;<span class="keyword">table</span>&gt; <span class="keyword">add</span> <span class="keyword">partition</span>(<span class="keyword">partition</span> p3 <span class="keyword">values</span> <span class="keyword">less</span> <span class="keyword">than</span> MAXVALUE);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- range重新分区</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> REORGANIZE <span class="keyword">PARTITION</span> p0,p1,p2,p3,p4 <span class="keyword">INTO</span> (<span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> MAXVALUE);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- list重新分区</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;<span class="keyword">table</span>&gt; REORGANIZE <span class="keyword">PARTITION</span> p0,p1,p2,p3,p4 <span class="keyword">INTO</span> (<span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在客户端程序不变的情况下，将服务器端的数据分布到不同的物理文件中，进而提供数据表的处理能力<br>当数据量比较大时，分区可以提升效率<br>且只有检索字段为分区字段时，分区效率才会明显提高</p><h1 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h1><p>如果一个表的每条记录的内容很大，那么就需要更多的IO操作，如果字段值比较大，而使用频率相对比较低，可以将大字段移到另一张表中，当查询不查大字段的时候，这样就减少了I/O操作<br>如果一个表的数据量很少，那么查询就很快；如果表的数据量非常非常大，那么查询就变的比较慢；也就是表的数据量影响这查询的性能。<br>表中的数据本来就有独立性，例如分别记录各个地区的数据或者不同时期的数据，特别是有些数据常用，而另外一些数据不常用。</p><p>通过应用程序，把数据划分到不同的表中存储，分表的操作会在客户端出现多张表<br>水平切分：<br><img src="/upload/pasted-450.png" alt="upload successful"><br>水平切分类似于分区，但是它是实实在在的把一个大表分成两个小表，可以根据某个查询值分块来把表水平切分</p><p>垂直切分：<br><img src="/upload/pasted-451.png" alt="upload successful"><br>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。 垂直分割一般用于拆分大字段和访问频率低的字段，分离冷热数据。</p><p>垂直分割适用于记录不是非常多的，但是字段却很多，这样占用空间比较大，检索时需要执行大量的I/O，严重降低了性能，这个时候需要把大的自读那拆分到另一个表中，并且该表与源表时一对一关系。<br>垂直拆分的优点： 可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。<br>垂直拆分的缺点： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://images.ali213.net/picfile/pic/2017/10/27/927_2017102712122202.jpg&quot; width=&quot;70%&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>MySQL深入研究（1）【字段设计，存储引擎介绍，锁机制，索引】</title>
    <link href="https://www.junglezero.top/2019/07/20/MySQLDeepLearn/"/>
    <id>https://www.junglezero.top/2019/07/20/MySQLDeepLearn/</id>
    <published>2019-07-19T23:24:42.000Z</published>
    <updated>2019-07-22T04:15:11.574Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://www.3dmgame.com/uploads/images/thumbpicfirst/20180830/1535616414_320863.jpg" width="70%"><br><a id="more"></a></p><h1 id="字段的设计"><a href="#字段的设计" class="headerlink" title="字段的设计"></a>字段的设计</h1><h2 id="优先使用符合业务需要的最小的数据类型"><a href="#优先使用符合业务需要的最小的数据类型" class="headerlink" title="优先使用符合业务需要的最小的数据类型"></a>优先使用符合业务需要的最小的数据类型</h2><p>1.比如ip地址，可以用无符号整型数直接储存（MySQL内置函数INET_ATON(字符串)和INTE_NTOA(整数)分别是把ip地址转换为整型和把整型转换为字符串）<br>2.对于非负数的存储，就没必要用一般的int形，用无符号就可以解决<br>3.不要用TEXT，BLOB，或者把他们都分离到单独的扩展表中<br>4.对于一些选择项，可以用数字代替原来的字符串</p><h2 id="用关联表替代枚举"><a href="#用关联表替代枚举" class="headerlink" title="用关联表替代枚举"></a>用关联表替代枚举</h2><p>枚举若发生改变，可能会对整张表造成影响，修改的思路是把性别抽离出来单独成一张关联表</p><h2 id="金额类型的存储"><a href="#金额类型的存储" class="headerlink" title="金额类型的存储"></a>金额类型的存储</h2><p>涉及到对精度的要求，应当用Decimal，另外的思路就是小金额大数据，用一个bigint存，这个思路就是消除小数点，消除关于精度的问题</p><h2 id="not-null"><a href="#not-null" class="headerlink" title="not null"></a>not null</h2><p>对于任何字段，应当尽量使其存储内容不为null，应当用数据域不会出现的某个值来替代。</p><h2 id="表中字段数量不宜过多"><a href="#表中字段数量不宜过多" class="headerlink" title="表中字段数量不宜过多"></a>表中字段数量不宜过多</h2><p>利用第三范式将表细化，减少表中字段数量</p><h2 id="表间关系设计"><a href="#表间关系设计" class="headerlink" title="表间关系设计"></a>表间关系设计</h2><p>利用合理的外键将表串联</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>只有很大内容上的需求采用text<br>字符串列的最大长度比平均长度大很多;列的更新很少（所以碎片不是问题）;使用了像UTF8这样的字符集（每个字符都使用不同的字节数进行存储）这个时候用varchar<br>很短，或者所有值都接近同一个长度（如MD5）;列经常变更，这个时候用char</p><h2 id="日期时间注意"><a href="#日期时间注意" class="headerlink" title="日期时间注意"></a>日期时间注意</h2><p>不要用字符串存储日期型数据，浪费空间<br>DATE能保存从1001到9999年，精度为秒，他把日期和时间封装到格式为YYYYMMDDHHMMSS的整数中，使用8字节<br>TIMESTAMP保存了从1970年以来的秒数，和Unix时间戳相同，只能保存1970到2038,使用4字节<br>FROM_UNIXTIME()和UNIX_TIMESTAMP()两个函数转换日期和Unix时间戳<br>通常用TIMESTAMP，空间效率高<br>MYSQL没有提供比秒更小粒度的日期和时间值，如果需要，可以用BIGINT存储微妙级别的时间戳，或用DOUBLE存储秒之后的小数部分</p><h1 id="数据引擎"><a href="#数据引擎" class="headerlink" title="数据引擎"></a>数据引擎</h1><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>MyISAM 设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操<br>作，则依然可以使用 MyISAM。<br>MyISAM 提供了大量的特性，包括压缩表、空间数据索引等。<br>不支持事务。<br>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加<br>排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入<br>（CONCURRENT INSERT）。<br>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数<br>据丢失，而且修复操作是非常慢的。<br>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据<br>写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应<br>的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成<br>索引损坏，需要执行修复操作</p><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>InnoDB 是 MySQL 默认的事务型存储引擎，只有在需要 InnoDB 不支持的特性时，才考虑使<br>用其它存储引擎。<br>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离<br>级别下，通过多版本并发控制（MVCC）+ 间隙锁（next-key locking）防止幻影读。<br>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的<br>提升。<br>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建<br>的自适应哈希索引、能够加速插入操作的插入缓冲区等。支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有<br>表的写入，而在读写混合场景中，停止写入可能也意味着停止读取</p><h1 id="MySQL的锁"><a href="#MySQL的锁" class="headerlink" title="MySQL的锁"></a>MySQL的锁</h1><p>MySQL的锁的初衷和java中的锁出发点是一样的，是计算机协调多个进程或线程并发访问某一资源的机制<br>在数据库中，除传统的 计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一 个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。</p><h2 id="一般描述"><a href="#一般描述" class="headerlink" title="一般描述"></a>一般描述</h2><p>MySQL不同的存储引擎所使用的锁的情况不太一样，但是大体分为三类：</p><ul><li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。 </li><li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。 </li><li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般<h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3>MyISAM主要采用的就是表锁，有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）。<br>对于这种读写锁分离设计，可以结合java的读写锁来进行理解<br>举例：当一个上了写锁时,其他读和写都会被阻塞<br><img src="/upload/pasted-431.png" alt="upload successful"></li></ul><p>当一个上了读锁时，和java中的有些区别：一个session使用LOCK TABLE命令给表film_text加了读锁，这个session可以查询锁定表中的记录，但更新或访问其他表都会提示错误；同时，另外一个session可以查询表中的记录，但更新就会出现锁等待。 </p><p><img src="/upload/pasted-436.png" alt="upload successful"></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作 （UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁</p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>MyISAM存储引擎有一个系统变量concurrent_insert，专门用以控制其并发插入的行为，其值分别可以为0、1或2。<br>当concurrent_insert设置为0时，不允许并发插入。<br>当concurrent_insert设置为1时，如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录。这也是MySQL的默认设置。<br>当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录。</p><p><img src="/upload/pasted-440.png" alt="upload successful"></p><h2 id="InnoDB锁"><a href="#InnoDB锁" class="headerlink" title="InnoDB锁"></a>InnoDB锁</h2><p>众所周知，Innodb支持事务<br>因此先了解下事务</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务是由一组sql语句组成的逻辑处理单元，具有ACID属性</p><p><img src="/upload/pasted-437.png" alt="upload successful"></p><ul><li>原子性（Actomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。</li><li>一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以操持完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。</li><li>隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。</li><li>持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。<br>实际上，这些特性并不是一种同级关系</li><li>只有满足一致性，事务的执行结果才是正确的。</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时要只要能满足原子性，就</li><li>一定能满足一致性。</li><li>在并发的情况下，多个事务并发执行，事务不仅要满足原子性，还需要满足隔离性，才能</li><li>满足一致性。事务满足持久化是为了能应对数据库奔溃的情况</li></ul><p><img src="/upload/pasted-438.png" alt="upload successful"></p><h3 id="事务并发的问题"><a href="#事务并发的问题" class="headerlink" title="事务并发的问题"></a>事务并发的问题</h3><p>和java中的并发一样，事务的并发也会带来读写的问题</p><ul><li>丢失更新(Lost Update)<br>由于事务之间是不知道彼此的存在的，因此当两个事务同时对同一个数据进行修改时，可能会发生先修改的数据被后修改的所覆盖的问题<br><img src="/upload/pasted-441.png" alt="upload successful"></li><li>脏读（Dirty Reads）：<br>一个事务正在对一条记录做修改，在这个事务并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做“脏读”。<br><img src="/upload/pasted-442.png" alt="upload successful"></li><li>不可重复读（Non-Repeatable Reads）：<br>一个事务在读取某些数据已经发生了改变、或某些记录已经被删除了！这种现象叫做“不可重复读”。<br><img src="/upload/pasted-443.png" alt="upload successful"></li><li>幻读（Phantom Reads）：<br>一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”</li></ul><p><img src="/upload/pasted-444.png" alt="upload successful"></p><h3 id="问题的解决"><a href="#问题的解决" class="headerlink" title="问题的解决"></a>问题的解决</h3><p>在并发事务处理带来的问题中，“更新丢失”通常应该是完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。</p><p>“脏读”、“不可重复读”和“幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。数据库实现事务隔离的方式，基本可以分为以下两种。</p><p>一种是在读取数据前，对其加锁，阻止其他事务对数据进行修改。<br>另一种是不用加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot），并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户的角度，好像是数据库可以提供同一数据的多个版本，因此，这种技术叫做数据多版本并发控制（ＭultiVersion Concurrency Control，简称MVCC或MCC），也经常称为多版本数据库。</p><p>在MVCC并发控制中，读操作可以分成两类：快照读 (snapshot read)与当前读 (current read)。快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。<br>在一个支持MVCC并发控制的系统中，哪些读操作是快照读？哪些操作又是当前读呢？以MySQL InnoDB为例：</p><ul><li><p>快照读：<br>简单的select操作，属于快照读，不加锁。(当然，也有例外)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ?;</span><br></pre></td></tr></table></figure></li><li><p>当前读：<br>特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。<br>下面语句都属于当前读，读取记录的最新版本。并且，读取之后，还需要保证其他并发事务不能修改当前记录，对读取记录加锁。其中，除了第一条语句，对读取记录加S锁 (共享锁)外，其他的操作，都加的是X锁 (排它锁)。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="keyword">values</span> (…);</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> <span class="keyword">set</span> ? <span class="keyword">where</span> ?;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ?;</span><br></pre></td></tr></table></figure></li></ul><p>为了解决“隔离”与“并发”的矛盾，ISO/ANSI SQL92定义了4个事务隔离级别，每个级别的隔离程度不同，允许出现的副作用也不同，应用可以根据自己的业务逻辑要求，通过选择不同的隔离级别来平衡 “隔离”与“并发”的矛盾。下表很好地概括了这4个隔离级别的特性</p><p><img src="/upload/pasted-445.png" alt="upload successful"></p><h3 id="InnoDB的行级锁"><a href="#InnoDB的行级锁" class="headerlink" title="InnoDB的行级锁"></a>InnoDB的行级锁</h3><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><ul><li>排它锁（Exclusive），简写为 X 锁，又称写锁。<br>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li><li>共享锁（Shared），简写为 S 锁，又称读锁。<br>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁</li></ul><h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p><ul><li>意向共享锁（IS）：事务打算给数据行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</li><li>意向排他锁（IX）：事务打算给数据行加排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</li></ul><p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务<br>对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。<br>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的<br>某个数据行上加 X 锁或 S 锁。有以下两个规定：</p><ul><li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li><li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。<br>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了<br>X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T<br>加 X 锁失败。<h4 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h4>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的 索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁 （Next-Key锁）。<br>利用这种锁可以解决幻读的问题，但是对于频繁插入的业务会造成严重的阻塞<br>比如以下例子</li></ul><p><img src="/upload/pasted-449.png" alt="upload successful"></p><h4 id="锁的使用"><a href="#锁的使用" class="headerlink" title="锁的使用"></a>锁的使用</h4><p>意向锁是InnoDB自动加的，不需用户干预。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁。<br>事务可以通过以下语句显式给记录集加共享锁或排他锁：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ... <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br></pre></td></tr></table></figure></p><h4 id="具体情况"><a href="#具体情况" class="headerlink" title="具体情况"></a>具体情况</h4><p>只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！<br>对一个没有创建索引的表进行查询</p><p><img src="/upload/pasted-446.png" alt="upload successful"><br>在上面的例子中，看起来session_1只给一行加了排他锁，但session_2在请求其他行的排他锁时，却出现了锁等待！原因就是在没有索引的情况下，InnoDB只能使用表锁</p><p>创建索引后<br><img src="/upload/pasted-447.png" alt="upload successful"></p><p>访问相同的索引并加锁就会阻塞</p><p><img src="/upload/pasted-448.png" alt="upload successful"></p><h1 id="MySQL的索引"><a href="#MySQL的索引" class="headerlink" title="MySQL的索引"></a>MySQL的索引</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>索引是一种可以加快数据查询速度的一种数据结构<br>虽然索引可以加快查询速度，提高 MySQL 的处理性能，但是过多地使用索引也会造成以下弊端：</p><ul><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li><li>除了数据表占数据空间之外，每一个索引还要占一定的物理空间。如果要建立聚簇索引，那么需要的空间就会更大。</li><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。<br>因此，索引的不能随便创建，应当结合具体情况具体分析</li></ul><p>根据数据结构划分，可以把索引划分为B树索引以及哈希索引</p><h2 id="B树索引"><a href="#B树索引" class="headerlink" title="B树索引"></a>B树索引</h2><p>这是比较常见的索引形式，是基于B树的数据结构，需要注意的就是这种索引遵循左边前缀原则，即索引的查找要从被选定为索引的最左边一列查询。<br>可以根据索引选择性判断是否需要创建索引<br>所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值：<br>Index Selectivity = Cardinality / #T<br>显然选择性的取值范围为(0, 1]，选择性越高的索引价值越大，这是由B+Tree的性质决定的。<br>有一种与索引选择性有关的索引优化策略叫做前缀索引，就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。<br>在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。(基于Innodb的聚集索引)</p><p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a><br>这篇文章讲的非常好</p><h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h2><p>哈希索引也称为散列索引或 HASH 索引。MySQL 目前仅有 MEMORY 存储引擎和 HEAP 存储引擎支持这类索引。其中，MEMORY 存储引擎可以支持 B- 树索引和 HASH 索引，且将 HASH 当成默认索引。<br>HASH 索引不是基于树形的数据结构查找数据，而是根据索引列对应的哈希值的方法获取表的记录行。哈希索引的最大特点是访问速度快，但也存在下面的一些缺点：</p><ul><li>MySQL 需要读取表中索引列的值来参与散列计算，散列计算是一个比较耗时的操作。也就是说，相对于 B- 树索引来说，建立哈希索引会耗费更多的时间。</li><li>不能使用 HASH 索引排序。</li><li>HASH 索引只支持等值比较，如“=”“IN()”或“&lt;=&gt;”。</li><li>HASH 索引不支持键的部分匹配，因为在计算 HASH 值的时候是通过整个索引值来计算的。</li></ul><h2 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h2><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查<br>找条件使用 MATCH AGAINST，而不是普通的 WHERE。<br>全文索引一般使用倒排索引实现，它记录着关键词到其所在文档的映射。<br>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p><h2 id="空间数据索引（R-tree）"><a href="#空间数据索引（R-tree）" class="headerlink" title="空间数据索引（R-tree）"></a>空间数据索引（R-tree）</h2><p>MyISAM 存储引擎支持空间数据索引，可以用于地理数据存储。空间数据索引会从所有维度<br>来索引数据，可以有效地使用任意维度来进行组合查询。<br>必须使用 GIS 相关的函数来维护数据。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://www.3dmgame.com/uploads/images/thumbpicfirst/20180830/1535616414_320863.jpg&quot; width=&quot;70%&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库SQL部分复习（4）【自定义函数，存储过程，触发器，依赖和三范式】</title>
    <link href="https://www.junglezero.top/2019/07/18/tabasereview4/"/>
    <id>https://www.junglezero.top/2019/07/18/tabasereview4/</id>
    <published>2019-07-18T14:13:28.000Z</published>
    <updated>2019-07-19T06:45:56.565Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/upload/pasted-279.png" width="70%"><br><a id="more"></a></p><h1 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>函数由一系列sql语句组成，调用函数就是一次性执行这些语句。所以函数可以降低语句重复。【但注意的是函数注重返回值，不注重执行过程，所以一些语句无法执行。所以函数并不是单纯的sql语句集合。】<br>函数只能返回单个值而不能返回一整个结果集。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> selectMAXgrade (sub <span class="built_in">VARCHAR</span>(<span class="number">10</span>)) <span class="keyword">RETURNS</span> <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DECLARE</span> c <span class="built_in">INT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">MAX</span>(grade)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">sc</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">cno = sub <span class="keyword">INTO</span> c;</span><br><span class="line"></span><br><span class="line">RETURN c;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">selectMAXgrade (<span class="string">'1001'</span>);</span><br></pre></td></tr></table></figure><h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p>存储过程是一组为了完成特定功能的 SQL 语句集合。使用存储过程的目的是将常用或复杂的工作预先用 SQL 语句写好并用一个指定名称存储起来，这个过程经编译和优化后存储在数据库服务器中，因此称为存储过程。当以后需要数据库提供与已定义好的存储过程的功能相同的服务时，只需调用“CALL存储过程名字”即可自动完成<br>存储过程有如下优点：<br>1) 封装性<br>存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的 SQL 语句，并且数据库专业人员可以随时对存储过程进行修改，而不会影响到调用它的应用程序源代码。<br>2) 可增强 SQL 语句的功能和灵活性<br>存储过程可以用流程控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。<br>3) 可减少网络流量<br>由于存储过程是在服务器端运行的，且执行速度快，因此当客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而可降低网络负载。<br>4) 高性能<br>存储过程执行一次后，产生的二进制代码就驻留在缓冲区，在以后的调用中，只需要从缓冲区中执行二进制代码即可，从而提高了系统的效率和性能。<br>5) 提高数据库的安全性和数据的完整性<br>使用存储过程可以完成所有数据库操作，并且可以通过编程的方式控制数据库信息访问的权限。</p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>找出给定的学科编号的考的90分以上的学生姓名<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">delimiter //</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> showOver90Stu (sub <span class="built_in">VARCHAR</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sno <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sno</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">sc</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">cno = sub</span><br><span class="line"><span class="keyword">AND</span> grade &gt; <span class="number">90</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">END</span> //</span><br><span class="line">    </span><br><span class="line"><span class="keyword">call</span> showOver90Stu(<span class="string">'1001'</span>)</span><br></pre></td></tr></table></figure></p><p>需要注意的是，在begin和end之间定义的sql结尾要加；，但是为了让语句不会提前运行，需要自定义终止字符，调用delimiter //，//表示希望作为终止符的符号。</p><h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><h2 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h2><p>MySQL 数据库中触发器是一个特殊的存储过程，不同的是执行存储过程要使用 CALL 语句来调用，而触发器的执行不需要使用 CALL 语句来调用，也不需要手工启动，只要一个预定义的事件发生就会被 MySQL自动调用</p><p>在实际使用中，MySQL 所支持的触发器有三种：INSERT 触发器、UPDATE 触发器和 DELETE 触发器。<br>1) INSERT 触发器<br>在 INSERT 语句执行之前或之后响应的触发器。<br>使用 INSERT 触发器需要注意以下几点：</p><ul><li>在 INSERT 触发器代码内，可引用一个名为 NEW（不区分大小写）的虚拟表来访问被插入的行。</li><li>在 BEFORE INSERT 触发器中，NEW 中的值也可以被更新，即允许更改被插入的值（只要具有对应的操作权限）。</li><li>对于 AUTO_INCREMENT 列，NEW 在 INSERT 执行之前包含的值是 0，在 INSERT 执行之后将包含新的自动生成值。</li></ul><p>2) UPDATE 触发器<br>在 UPDATE 语句执行之前或之后响应的触发器。<br>使用 UPDATE 触发器需要注意以下几点：</p><ul><li>在 UPDATE 触发器代码内，可引用一个名为 NEW（不区分大小写）的虚拟表来访问更新的值。</li><li>在 UPDATE 触发器代码内，可引用一个名为 OLD（不区分大小写）的虚拟表来访问 UPDATE 语句执行前的值。</li><li>在 BEFORE UPDATE 触发器中，NEW 中的值可能也被更新，即允许更改将要用于 UPDATE 语句中的值（只要具有对应的操作权限）。</li><li>OLD 中的值全部是只读的，不能被更新。</li></ul><p>3) DELETE 触发器<br>在 DELETE 语句执行之前或之后响应的触发器。<br>使用 DELETE 触发器需要注意以下几点：</p><ul><li>在 DELETE 触发器代码内，可以引用一个名为 OLD（不区分大小写）的虚拟表来访问被删除的行。</li><li>OLD 中的值全部是只读的，不能被更新。</li></ul><h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><p>当删除某个学生时，同时删除他的成绩等<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> deleteSc <span class="keyword">AFTER</span> <span class="keyword">DELETE</span> <span class="keyword">ON</span> student <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">sc</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sno = old.sno ;</span><br><span class="line"><span class="keyword">END</span> $$</span><br></pre></td></tr></table></figure></p><h1 id="依赖和三范式"><a href="#依赖和三范式" class="headerlink" title="依赖和三范式"></a>依赖和三范式</h1><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>设R(U)是一个属性集U上的关系模式，X和Y是U的子集。<br>若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等， 而在Y上的属性值不等， 则称 “X函数确定Y” 或  “Y函数依赖于X”。记作X→Y。<br>对于这个概念，可以这么理解：要是学号定了，确定了某个人，那么性别，姓名就都确定了</p><ul><li><p>平凡依赖和非平凡依赖<br><img src="/upload/pasted-432.png" alt="upload successful"><br>例如在sc中，<br>平凡函数依赖：(Sno, Cno) → Sno<br>非平凡依赖：(Sno, Cno) → Grade</p></li><li><p>完全依赖和部分依赖：<br><img src="/upload/pasted-434.png" alt="upload successful"><br>可以这么理解：只有全部的关系才能决定下一个属性，这就是完全依赖，如果其中一个就可以决定下一个属性，那么就是部分依赖<br>例如grade完全依赖于sno和cno，而由于sname依赖于sno，则sname部分依赖于sno和cno</p></li><li><p>传递依赖<br><img src="/upload/pasted-435.png" alt="upload successful"><br>比如对于关系，Std(Sno, Sdept, Mname)<br>sno决定sdept,sdept决定Mname,则相当于Mname传递依赖于sno</p></li></ul><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><h3 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h3><p>如果一个关系模式R的所有属性都是不可分的基本数据项，则R∈1NF。<br>意思是对于任意一个数据项，都能没有歧义存入数据库，比如说一个关系学生（学生信息），这就不满足第一范式</p><h3 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h3><p>若关系模式R∈1NF，并且每一个非主属性都完全函数依赖于R的码，则R∈2NF。<br>就是说只要主键确定了，别的数据项就都能确定了<br>对于关系scn(sno,cno,sname,grade)<br>grade对于主键(sno,cno)是完全依赖的，而sname对于（sno,cno）是部分依赖的，因此若要满足第二范式，则需要将原表拆成sc(sno,cno,grade),s(sno,sname)</p><h3 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h3><p><img src="/upload/pasted-439.png" alt="upload successful"><br>如S1（SNO，SNAME，DNO，DNAME，LOCATION） 各属性分别代表学号，姓名，所在系，系名称，系地址。<br>关系中存在传递依赖。即SNO -&gt; DNO。 而DNO -&gt; SNO却不存在，DNO -&gt; LOCATION, 因此关键字 SNO 对 LOCATION 函数决定是通过传递依赖 DNO -&gt; LOCATION 实现的。也就是说，SNO不直接决定非主属性LOCATION。<br>因此需要拆成两个关系<br>S（SNO，SNAME，DNO），D（DNO，DNAME，LOCATION）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/upload/pasted-279.png&quot; width=&quot;70%&quot;&gt;&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库SQL部分复习（3）【数据更新，视图，查询练习】</title>
    <link href="https://www.junglezero.top/2019/07/17/tabasereview/"/>
    <id>https://www.junglezero.top/2019/07/17/tabasereview/</id>
    <published>2019-07-17T11:29:36.000Z</published>
    <updated>2019-07-18T08:45:46.198Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/upload/pasted-430.png" width="70%"></p><a id="more"></a><h1 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h1><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>一般的插入<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SC (Sno,Cno)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">' 200215128 '</span> , <span class="string">' 1 '</span>)</span><br></pre></td></tr></table></figure></p><p>插入查询结果<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Deptage (Sdept, Avgage) <span class="keyword">SELECT</span></span><br><span class="line">Sdept,</span><br><span class="line"><span class="keyword">AVG</span>(Sage)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">Student</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">Sdept</span><br></pre></td></tr></table></figure></p><p>插入多条结果<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSERTINTO table_name (col_one, col_two)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">'c1'</span>, <span class="string">'c2'</span>),</span><br><span class="line">(<span class="string">'c3'</span>, <span class="string">'c4'</span>)</span><br></pre></td></tr></table></figure></p><p>这种方式只能在mysql里面写</p><h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><p>一般修改<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Student</span><br><span class="line"><span class="keyword">SET</span> Sage = <span class="number">22</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">Sno = <span class="string">' 200215121 '</span></span><br></pre></td></tr></table></figure></p><p>批量修改<br>若不设置条件，则是针对全部<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> sc</span><br><span class="line"><span class="keyword">SET</span> grade = grade + <span class="number">1</span></span><br></pre></td></tr></table></figure></p><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">S</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">Sno = <span class="string">'200215125'</span></span><br></pre></td></tr></table></figure><h1 id="视图（View）"><a href="#视图（View）" class="headerlink" title="视图（View）"></a>视图（View）</h1><p>视图是一个虚拟表，其内容由查询定义。同真实表一样，视图包含一系列带有名称的列和行数据，但视图并不是数据库真实存储的数据表。<br>视图是从一个、多个表或者视图中导出的表，包含一系列带有名称的数据列和若干条数据行。<br>视图并不同于数据表，它们的区别在于以下几点：</p><ul><li>视图不是数据库中真实的表，而是一张虚拟表，其结构和数据是建立在对数据中真实表的查询基础上的。</li><li>存储在数据库中的查询操作 SQL 语句定义了视图的内容，列数据和行数据来自于视图查询所引用的实际表，引用视图时动态生成这些数据。</li><li>视图没有实际的物理记录，不是以数据集的形式存储在数据库中的，它所对应的数据实际上是存储在视图所引用的真实表中的。</li><li>视图是数据的窗口，而表是内容。表是实际数据的存放单位，而视图只是以不同的显示方式展示数据，其数据来源还是实际表。</li><li>视图是查看数据表的一种方法，可以查询数据表中某些字段构成的数据，只是一些 SQL 语句的集合。从安全的角度来看，视图的数据安全性更高，使用视图的用户不接触数据表，不知道表结构。</li><li>视图的建立和删除只影响视图本身，不影响对应的基本表。</li></ul><h1 id="查询题目练习"><a href="#查询题目练习" class="headerlink" title="查询题目练习"></a>查询题目练习</h1><p>设有三个关系：<br>S(sno,sname,sex,age)<br>SC(sno,cno,grade)<br>C(cno,cname,teacher)</p><ol><li><p>查询LIU老师所授课程的课程号和课程名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">cno,</span><br><span class="line">cname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">C</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">teacher = <span class="string">'LIU'</span></span><br></pre></td></tr></table></figure></li><li><p>查询年龄大于23岁的男学生的学号和姓名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sno,</span><br><span class="line">sname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">S</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">age &gt; <span class="number">23</span></span><br><span class="line"><span class="keyword">AND</span> sex = <span class="string">'M'</span></span><br></pre></td></tr></table></figure></li><li><p>查询学号为S3学生所学课程的课程名与任课教师名<br>连接查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">cname,</span><br><span class="line">teacher</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">SC,</span><br><span class="line">C</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">SC.cno = C.cno</span><br><span class="line"><span class="keyword">AND</span> sno = <span class="string">'S3'</span></span><br></pre></td></tr></table></figure></li></ol><p>嵌套查询<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">cname,</span><br><span class="line">teacher</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">C</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">cno <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">cno</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">SC</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sno = <span class="string">'S3'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><ol start="4"><li>查询至少选修LIU老师所授课程中一门课程的女学生姓名<br>连接查询<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">S,</span><br><span class="line">SC,</span><br><span class="line">C</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">S.sno = SC.sno</span><br><span class="line"><span class="keyword">AND</span> SC.cno = C.cno</span><br><span class="line"><span class="keyword">AND</span> sex = <span class="string">'F'</span></span><br><span class="line"><span class="keyword">AND</span> teacher = <span class="string">'LIU'</span></span><br></pre></td></tr></table></figure></li></ol><p>嵌套查询<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">S</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sex = ‘F’</span><br><span class="line"><span class="keyword">AND</span> sno <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sno</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">SC</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">cno <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">cno</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">C</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">teacher = ‘LIU’</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><ol start="5"><li><p>查询WANG同学不学的课程的课程号<br>NOT EXISTS嵌套查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">cno</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">C</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">S,</span><br><span class="line">SC</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">S.sno = SC.sno</span><br><span class="line"><span class="keyword">AND</span> SC.cno = C.cno</span><br><span class="line"><span class="keyword">AND</span> sname = ‘WANG’</span><br><span class="line">)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>查询至少选修两门课的学生学号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sno</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">sno</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line"><span class="keyword">count</span>(*) &gt;= <span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>统计每门课程的学生选修人数（超过10人的课程才统计）。要求显示课程号和人数，查询结果按人数降序排列，若人数相同，按课程号升序排列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">cno,</span><br><span class="line"><span class="keyword">count</span>(sno)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">cno</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line"><span class="keyword">count</span>(*) &gt; <span class="number">10</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line"><span class="keyword">count</span>(sno) <span class="keyword">DESC</span>,</span><br><span class="line">cno</span><br></pre></td></tr></table></figure></li><li><p>求LIU老师所授课程的每门课程的平均成绩</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> C.cno,<span class="keyword">avg</span>(grade) </span><br><span class="line"><span class="keyword">from</span> SC,C</span><br><span class="line"><span class="keyword">where</span> SC.cno=C.cno </span><br><span class="line">    <span class="keyword">and</span> teacher=‘LIU’ </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> C.cno</span><br></pre></td></tr></table></figure></li><li><p>检索姓名以L打头的所有学生的姓名和年龄</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sname,</span><br><span class="line">age</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">S</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sname <span class="keyword">LIKE</span> <span class="string">'L%'</span></span><br></pre></td></tr></table></figure></li><li><p>求年龄大于所有女同学年龄的男学生姓名和年龄</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sname,</span><br><span class="line">age</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">S</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sex = ‘M’</span><br><span class="line"><span class="keyword">AND</span> age &gt; <span class="keyword">ALL</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">age</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">S</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sex = ‘F’</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/upload/pasted-430.png&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库SQL部分复习(2)【约束，数据类型，查询，连接查询，嵌套查询】</title>
    <link href="https://www.junglezero.top/2019/07/16/tabaseSQLReview-2/"/>
    <id>https://www.junglezero.top/2019/07/16/tabaseSQLReview-2/</id>
    <published>2019-07-16T08:22:35.000Z</published>
    <updated>2019-07-19T06:49:49.922Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/upload/pasted-427.png" width="70%"></p><a id="more"></a><hr><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><h2 id="模式（SCHEMA）-数据库（DATABASE）相关"><a href="#模式（SCHEMA）-数据库（DATABASE）相关" class="headerlink" title="模式（SCHEMA）,数据库（DATABASE）相关"></a>模式（SCHEMA）,数据库（DATABASE）相关</h2><p>MySQL官方文档指出，从概念上讲，模式是一组相互关联的数据库对象，如表，表列，列的数据类型，索引，外键等等。但是从物理层面上来说，模式与数据库是同义的。你可以在MySQL的SQL语法中用关键字SCHEMA替代DATABASE，例如使用CREATE SCHEMA来代替CREATE DATABASE。<br>也就是说，一个SCHEMA就是一套关系<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">SCHEMA</span> <span class="number">123</span></span><br></pre></td></tr></table></figure></p><p>就可以创建出一个新的数据库（DATABASE）</p><h2 id="表（TABLE）相关"><a href="#表（TABLE）相关" class="headerlink" title="表（TABLE）相关"></a>表（TABLE）相关</h2><h3 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h3><ul><li>主键约束（PRIMARY KEY)<br>主键约束是用来保证表中记录唯一可区分的列。一个表可以通过一列或列组合的数据来唯一标识表中的每一条记录。</li><li>唯一约束（UNIQUE)<br>规定一条记录的一个字段值或几个字段的组合值不得与其他记录的相同字段或字段组合的值重复，将这种限制成为“唯一约束”。</li><li>外键约束 (FOREIGN KEY)<br>1）外键列可以由是一个列或多个列组成。<br>2）外键列的取值可以为空，可以有重复值，但必须是它所引用列的列值之一。引用列必须是创建了主键约束或唯一约束的列。</li><li><p>检查约束 （CHECK)<br>检查约束是用来检查一个字段或多个字段的输入值是否满足指定的约束条件。</p></li><li><p>默认值约束（DEFAULT)<br>在用户定义数据类型的情况下，如果使用默认值约束，则默认值被插入到使用这个自定义数据的所有字段中。</p></li><li><p>空值约束（NULL)<br>空值约束就是指尚不知道或不确定的数据值，它不等同于0或空格。</p></li></ul><h3 id="数据库的基本数据类型（以MySQL为标准）"><a href="#数据库的基本数据类型（以MySQL为标准）" class="headerlink" title="数据库的基本数据类型（以MySQL为标准）"></a>数据库的基本数据类型（以MySQL为标准）</h3><h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><p>MySQL中提供了以下几种整数类型，可以设置自增约束</p><p><img src="/upload/pasted-414.png" alt="upload successful"><br>各个整数类型范围如下<br><img src="/upload/pasted-415.png" alt="upload successful"></p><h4 id="小数类型"><a href="#小数类型" class="headerlink" title="小数类型"></a>小数类型</h4><p>MySQL 中使用浮点数和定点数来表示小数。<br>浮点类型有两种，分别是单精度浮点数（FLOAT）和双精度浮点数（DOUBLE）；定点类型只有一种，就是 DECIMAL<br>两种类型都可以用（M,D）表示，其中M称为精度，表示总共的位数；D称为标度，表示小数的位数。<br>浮点数类型的取值范围为 M（1～255）和 D（1～30，且不能大于 M-2）DECIMAL 的默认 D 值为 0、M 值为 10<br> FLOAT 和 DOUBLE 在不指定精度时，默认会按照实际的精度（由计算机硬件和操作系统决定），DECIMAL 如果不指定精度，默认为（10，0）。<br> 不论是定点还是浮点类型，如果用户指定的精度超出精度范围，则会四舍五入进行处理。</p><p><img src="/upload/pasted-416.png" alt="upload successful"><br> 在 MySQL 中，定点数以字符串形式存储，在对精度要求比较高的时候（如货币、科学数据），使用 DECIMAL 的类型比较好，另外两个浮点数进行减法和比较运算时也容易出问题，所以在使用浮点数时需要注意，并尽量避免做浮点数比较。</p><h4 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h4><p>MySQL 中表示日期的数据类型：YEAR、TIME、DATE、DTAETIME、TIMESTAMP。当只记录年信息的时候，可以只使用 YEAR 类型。<br>当指定确定不合法的值时，系统将“零”值插入数据库中</p><p><img src="/upload/pasted-417.png" alt="upload successful"><br>对于YEAR,除了整数外也可以匹配形如YYYY的四位字符串或者两位字符串，对于两位的数字和字符串，0-69回转化为2001-2069，而70-99会转化为1970-1999<br>对于TIME,小时部分之所以会大出一部分的原因是可以用TIME表示某件事发展的时长，除了给定的格式外，可以用HHMMSS表示，但是对于这种输入，MySQL是从秒开始处理的。对于非法的输入，则储存0时间<br>对于DATE基本和上面有相似的规则，可以调用CURRENT_DATE 或者 NOW()，插入当前系统日期</p><p>DATETIME 在存储日期数据时，按实际输入的格式存储，即输入什么就存储什么，与时区无关；<br>TIMESTAMP 值的存储是以 UTC（世界标准时间）格式保存的，存储时对当前时区进行转换，检索时再转换回当前时区。即查询时，根据当前时区的不同，显示的时间值是不同的。</p><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p>MySQL 中的字符串类型有 CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、ENUM、SET 等。</p><p><img src="/upload/pasted-418.png" alt="upload successful"><br>char是定长字符串类型，即不管要储存的字符串多长，它只储存规定的长度，不管多短，会用空格补齐剩下的，而varchar是变长的，只能规定最大长度，其实际的储存空间为字符串占的空间+1（字符串结束标识）</p><p><img src="/upload/pasted-419.png" alt="upload successful"><br>ENUM是MySQL内的枚举类型，每个具体字符串对应一个索引值，ENUM 类型的字段在取值时，能在指定的枚举列表中获取，而且一次只能取一个。如果创建的成员中有空格，尾部的空格将自动被删除。ENUM 列总有一个默认值。如果将 ENUM 列声明为 NULL，NULL 值则为该列的一个有效值，并且默认值为 NULL。如果 ENUM 列被声明为 NOT NULL，其默认值为允许的值列表的第 1 个元素。<br>SET是一个加强版的枚举，可以选择多个值加入</p><h4 id="二进制类型"><a href="#二进制类型" class="headerlink" title="二进制类型"></a>二进制类型</h4><p>MySQL 中的二进制字符串有 BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。</p><p><img src="/upload/pasted-420.png" alt="upload successful"></p><h3 id="表的创建"><a href="#表的创建" class="headerlink" title="表的创建"></a>表的创建</h3><p>建立一个“学生选课”表SC，它由学号Sno、课程号Cno，修课成绩Grade组成，其中(Sno, Cno)为主码。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">(    Sno <span class="built_in">CHAR</span>(<span class="number">5</span>) ,</span><br><span class="line">     Cno <span class="built_in">CHAR</span>(<span class="number">3</span>) , </span><br><span class="line">     Grade   <span class="built_in">int</span>,</span><br><span class="line">     Primary <span class="keyword">key</span> (Sno, Cno),</span><br><span class="line">     <span class="keyword">Foreign</span> <span class="keyword">key</span> (sno) <span class="keyword">References</span> student (sno),</span><br><span class="line">     <span class="keyword">Foreign</span> <span class="keyword">key</span> (cno) <span class="keyword">References</span> course (cno)  );</span><br></pre></td></tr></table></figure><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="查询全部"><a href="#查询全部" class="headerlink" title="查询全部"></a>查询全部</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> STUDENT</span><br></pre></td></tr></table></figure><h3 id="查询某一列"><a href="#查询某一列" class="headerlink" title="查询某一列"></a>查询某一列</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sno <span class="keyword">FROM</span> STUDENT</span><br></pre></td></tr></table></figure><h3 id="查询经过计算结果"><a href="#查询经过计算结果" class="headerlink" title="查询经过计算结果"></a>查询经过计算结果</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title,</span><br><span class="line">price * <span class="number">50</span> <span class="keyword">AS</span> <span class="number">50</span>price</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film_list</span><br></pre></td></tr></table></figure><h3 id="利用case-when替换查询结果"><a href="#利用case-when替换查询结果" class="headerlink" title="利用case when替换查询结果"></a>利用case when替换查询结果</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title,</span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> price &gt; <span class="number">0.99</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="string">'ex'</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line"><span class="string">'chep'</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">AS</span> price</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film_list</span><br></pre></td></tr></table></figure><h3 id="利用CONCAT连接查询结果，利用cast转化结果"><a href="#利用CONCAT连接查询结果，利用cast转化结果" class="headerlink" title="利用CONCAT连接查询结果，利用cast转化结果"></a>利用CONCAT连接查询结果，利用cast转化结果</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">CONCAT</span>(title,<span class="string">'的票价是'</span>,<span class="keyword">CAST</span>(price <span class="keyword">AS</span> <span class="built_in">char</span>)) <span class="keyword">as</span> 价格说明</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film_list</span><br></pre></td></tr></table></figure><h3 id="查询结果返回大小写，字符串长度"><a href="#查询结果返回大小写，字符串长度" class="headerlink" title="查询结果返回大小写，字符串长度"></a>查询结果返回大小写，字符串长度</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">LOWER</span>(title),</span><br><span class="line"><span class="keyword">UPPER</span>(title),</span><br><span class="line"><span class="keyword">LENGTH</span>(title)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film_list</span><br></pre></td></tr></table></figure><h3 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h3><p>1、left(str,length) 从左边截取length<br>2、right(str,length)从右边截取length<br>3、substring(str,index)当index&gt;0从左边开始截取直到结束  当index&lt;0从右边开始截取直到结束  当index=0返回空<br>4、substring(str,index,len) 截取str,从index开始，截取len长度<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">left</span>(title,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film_list</span><br></pre></td></tr></table></figure></p><h3 id="日期相关函数"><a href="#日期相关函数" class="headerlink" title="日期相关函数"></a>日期相关函数</h3><p>now()获取当前的日期和时间<br>current_timestamp() 获取当前时间戳<br>date_format(date,format), time_format(time,format) 转换时间形式<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">DATE_FORMAT</span>(last_update, <span class="string">'%y%m%d%h%i%s'</span>) <span class="keyword">AS</span> <span class="string">'时间序列'</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br></pre></td></tr></table></figure></p><p>（日期、天数）转换函数：to_days(date), from_days(days)<br>（时间、秒）转换函数：time_to_sec(time), sec_to_time(seconds)<br>拼凑日期、时间函数：makdedate(year,dayofyear), maketime(hour,minute,second)<br>（Unix 时间戳、日期）转换函数</p><h3 id="集合，范围查询"><a href="#集合，范围查询" class="headerlink" title="集合，范围查询"></a>集合，范围查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> rating <span class="keyword">in</span> (<span class="string">'PG'</span>,<span class="string">'R'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">customer_id </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">payment</span><br><span class="line"><span class="keyword">where</span> payment_date <span class="keyword">BETWEEN</span> <span class="string">'2005-06-17 09:19:45'</span> <span class="keyword">and</span> <span class="string">'2005-08-02 18:55:15'</span></span><br></pre></td></tr></table></figure><p>注意 between是左闭右开的</p><h3 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h3><h4 id="Like-匹配"><a href="#Like-匹配" class="headerlink" title="Like 匹配"></a>Like 匹配</h4><p>1.%：表示任意0个或多个字符。可匹配任意类型和长度的字符，有些情况下若是中文，请使用两个百分号（%%）表示<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title <span class="keyword">LIKE</span> <span class="string">'%W%'</span></span><br></pre></td></tr></table></figure></p><p>若是要搜索包含某两个字的<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title <span class="keyword">LIKE</span> <span class="string">'%W%'</span> <span class="keyword">and</span> title <span class="keyword">LIKE</span> <span class="string">'%O%'</span></span><br></pre></td></tr></table></figure></p><p>2._： 表示任意单个字符。匹配单个任意字符<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title <span class="keyword">LIKE</span> <span class="string">'_O%'</span></span><br></pre></td></tr></table></figure></p><h4 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h4><p>^ 匹配字符开始的部分<br>查询以W开头的<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title REGEXP <span class="string">'^W'</span></span><br></pre></td></tr></table></figure></p><p>$ 匹配字符结束的部分<br>查询以S为结尾的部分<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title REGEXP <span class="string">'S$'</span></span><br></pre></td></tr></table></figure></p><p>. 匹配字符串中的任意一个字符，包括回车和换行<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title REGEXP <span class="string">'^W................S$'</span></span><br></pre></td></tr></table></figure></p><p>[字符集合]匹配字符集合中的任意字符<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title REGEXP <span class="string">'^W[OE]'</span></span><br></pre></td></tr></table></figure></p><p>[^字符集合]匹配除了字符集合外的任意字符<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title REGEXP <span class="string">'^W[^B-Z]'</span></span><br></pre></td></tr></table></figure></p><p>s1|s2|s3 匹配s1s2s3中的任意一个<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title REGEXP  <span class="string">'^WA|^WE|^WH'</span></span><br></pre></td></tr></table></figure></p><p>*代表多个该字符前的字符，包括0个或1个<br>+代表多个该字符前的字符，包括1个<br>字符串{N} 字符串出现N次<br>字符串{M，N}字符串最少出现M次，最多出现N次<br>若是查找的就是转义字符本身，最后要加上ESCAPE</p><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>使用GROUP BY 进行分组<br>将查询的结果按某一列或多列的值分组，值相等的<br>为一组<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">rating,<span class="keyword">COUNT</span>(rating)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> rating</span><br></pre></td></tr></table></figure></p><p>使用GROUP BY子句后，SELECT子句的列名列表中只能出现分组属性和集函数<br>若要想要对分完的组做条件筛选，则需要用Having而不是where<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">rating,<span class="keyword">COUNT</span>(rating)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> rating</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(rating)&gt;<span class="number">195</span><span class="string">`sql</span></span><br></pre></td></tr></table></figure></p><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>可以基于关系运算的连接来理解连接查询</p><ul><li><p>广义笛卡尔积（交叉连接）<br>又称非限制连接，它将两个表不加任何约束地组合在一起，也就是将第一个表中的所有记录分别与第二个表的所有记录组成新的记录。（进行广义笛卡尔乘积）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="string">`language`</span>.*,staff.*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line"><span class="string">`language`</span>,staff</span><br></pre></td></tr></table></figure></li><li><p>等值连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  student.Sno,Sname,sex,Cno,Grade</span><br><span class="line"><span class="keyword">FROM</span>     student,sc</span><br><span class="line"><span class="keyword">WHERE</span>  student.sno = sc.sno</span><br></pre></td></tr></table></figure></li></ul><p>任何子句中引用表1和表2中同名属性时，都必须加表名前缀。引用唯一属性名时可以加也可以省略表名前缀<br>也可以用内连接表示等值连接<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">student.Sno,</span><br><span class="line">Sname,</span><br><span class="line">sex,</span><br><span class="line">Cno,</span><br><span class="line">Grade</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> sc <span class="keyword">ON</span> student.sno = sc.sno</span><br></pre></td></tr></table></figure></p><ul><li><p>自然连接<br>是一种特殊的等值链接，在等值连接的基础上，去掉相同的属性</p></li><li><p>自然连接<br>自表的某个属性进行对比<br>例：查一门课的先修课</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  FIRST.Cno，SECOND.Cpno</span><br><span class="line"><span class="keyword">FROM</span>  Course  <span class="keyword">FIRST</span>，Course  <span class="keyword">SECOND</span></span><br><span class="line"><span class="keyword">WHERE</span> FIRST.Cpno = SECOND.Cno；</span><br></pre></td></tr></table></figure></li></ul><p><img src="/upload/pasted-424.png" alt="upload successful"></p><ul><li><p>外连接<br>外连接就是一种不等值连接，相比于等值连接只输出相等部分的连接情况，这种方式会输出所有的情况两边的所有情况，没有的值则用空替代<br>MySQL并不支持</p></li><li><p>左外连接<br>以左边的为基础，除了相等的部分，还会输出左边不符合条件的，空的地方用null装</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">student.Sno,</span><br><span class="line">Sname,</span><br><span class="line">sex,</span><br><span class="line">Cno,</span><br><span class="line">Grade</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student</span><br><span class="line"><span class="keyword">LEFT</span>  <span class="keyword">JOIN</span> sc <span class="keyword">ON</span> student.sno=sc.sno</span><br></pre></td></tr></table></figure></li></ul><p><img src="/upload/pasted-425.png" alt="upload successful"></p><ul><li>右外连接<br>则是以右边的为基础<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">student.Sno,</span><br><span class="line">Sname,</span><br><span class="line">sex,</span><br><span class="line">Cno,</span><br><span class="line">Grade</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student</span><br><span class="line"><span class="keyword">RIGHT</span>  <span class="keyword">JOIN</span> sc <span class="keyword">ON</span> student.sno=sc.sno</span><br></pre></td></tr></table></figure></li></ul><p><img src="/upload/pasted-426.png" alt="upload successful"></p><h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><p>嵌套查询就是把一些“出处”变成查询结果<br>对于MySQL，嵌套的查询结果要有别名<br>例如 查询与刘晨在一个系学习的学生<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sno,</span><br><span class="line">sname,</span><br><span class="line">sdept</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">s</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sdept <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sdept</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">s</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sname = <span class="string">'刘晨'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">s1.sno,</span><br><span class="line">s1.sname,</span><br><span class="line">s1.sdept</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">s s1,</span><br><span class="line">s s2</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">s1.sdept = s2.sdept</span><br><span class="line"><span class="keyword">AND</span> s2.sname = <span class="string">' 刘晨 '</span></span><br></pre></td></tr></table></figure><p>ANY和ALL<br>any是某一个值，all是所有值，可以大于小于不等于<br>例选择编号01同学的成绩中大于04同学所有科目的成绩的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">sname,</span><br><span class="line">cno,</span><br><span class="line">grade</span><br><span class="line">FROM</span><br><span class="line">(</span><br><span class="line">SELECT</span><br><span class="line">student.Sno,</span><br><span class="line">Sname,</span><br><span class="line">sex,</span><br><span class="line">Cno,</span><br><span class="line">Grade</span><br><span class="line">FROM</span><br><span class="line">student</span><br><span class="line">INNER JOIN sc ON student.sno = sc.sno</span><br><span class="line">) AS a</span><br><span class="line">WHERE</span><br><span class="line">grade &gt; ALL (</span><br><span class="line">SELECT</span><br><span class="line">grade</span><br><span class="line">FROM</span><br><span class="line">sc</span><br><span class="line">WHERE</span><br><span class="line">sno = &apos;01&apos;</span><br><span class="line">) </span><br><span class="line">AND sno = &apos;04&apos;</span><br></pre></td></tr></table></figure></p><p>EXISTS<br>首先要理解这个关键词的运行机制<br>例子：选出选了课程1001的人<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student <span class="keyword">as</span> a</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">EXISTS</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">sc</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sno = a.sno</span><br><span class="line"><span class="keyword">AND</span> cno = <span class="string">'1001'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>使用exist，会对where前面的主查询语句进行逐一校验，对于前面的某一条记录，如果能使exist后的查询语句有返回值（不是空），那么此时exist判定就是true，对于主查询，当前这一条就会作为结果，如果不符合，就不会被作为结果</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/upload/pasted-427.png&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>数据库SQL部分复习（1）【关系模型，关系运算】</title>
    <link href="https://www.junglezero.top/2019/07/16/%E5%BA%93SQL%E9%83%A8%E5%88%86%E5%A4%8D%E4%B9%A0/"/>
    <id>https://www.junglezero.top/2019/07/16/库SQL部分复习/</id>
    <published>2019-07-16T01:47:14.000Z</published>
    <updated>2019-07-17T13:56:27.284Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/upload/pasted-429.png" width="70%"></p><a id="more"></a><hr><h1 id="实体联系模型（E-R）"><a href="#实体联系模型（E-R）" class="headerlink" title="实体联系模型（E-R）"></a>实体联系模型（E-R）</h1><p>实体型之间的联系：一对一联系（１：１）、一对多联系（１：N）、   多对多联系（Ｍ：Ｎ）<br>  例： 假设一个学生可选多门课程，而一门课程又有多个学生选修，每个学生每选一门课只有一个成绩， 一个教师只能讲一门课程，一门课程也可有多个教师讲授，一门课使用多本参考书。画出E－R图。</p><p><img src="/upload/pasted-393.png" alt="upload successful"></p><h1 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h1><p>在用户观点下，关系模型中数据的逻辑结构是一张二维表，它由行和列组成。</p><p><img src="/upload/pasted-392.png" alt="upload successful"><br>关系数据模型的数据结构</p><ul><li>关系（Relation）<br>通常指的是一张表</li><li>元组（Tuple）<br>表中的一行即为一个元组</li><li>属性(attribute)<br>一列即为一个属性</li><li>主码（key）<br>表中的某一个属性组，可以唯一确定一个元组</li><li>域（Domain）<br>属性的取值范围</li><li>分量<br>元组中的一个属性值<h1 id="数据库的三级模式结构"><a href="#数据库的三级模式结构" class="headerlink" title="数据库的三级模式结构"></a>数据库的三级模式结构</h1><h2 id="模式（Schema）"><a href="#模式（Schema）" class="headerlink" title="模式（Schema）"></a>模式（Schema）</h2></li></ul><p><img src="/upload/pasted-394.png" alt="upload successful"><br>模式（也称逻辑模式）<br>数据库中全体数据的逻辑结构和特征的描述<br>所有用户的公共数据视图，综合了所有用户的需求<br>一个数据库只有一个模式<br>模式的地位：是数据库系统模式结构的中间层<br>与数据的物理存储细节和硬件环境无关<br>与具体的应用程序、开发工具及高级程序设计语言无关<br>模式的定义：<br>数据的逻辑结构（数据项的名字、类型、取值范围等）<br>数据之间的联系<br>数据有关的安全性、完整性要求</p><h3 id="外模式-External-Schema"><a href="#外模式-External-Schema" class="headerlink" title="外模式(External Schema)"></a>外模式(External Schema)</h3><p>外模式（也称子模式或用户模式）<br>数据库用户（包括应用程序员和最终用户）使用的局部数据的逻辑结构和特征的描述<br>数据库用户的数据视图，是与某一应用有关的数据的逻辑表示<br>模式与外模式的关系：一对多<br>通常是模式的子集；一个数据库可以有多个外模式<br>外模式与应用的关系：一对多<br>同一外模式可以为某一用户的多个应用系统所使用，<br>但一个应用程序只能使用一个外模式<br>外模式是保证数据库安全性的一个有力措施<br>每个用户只能看见和访问所对应的外模式中的数据</p><h3 id="内模式（Internal-Schema）"><a href="#内模式（Internal-Schema）" class="headerlink" title="内模式（Internal Schema）"></a>内模式（Internal Schema）</h3><p>是数据物理结构和存储方式的描述<br>是数据在数据库内部的表示方式<br>记录的存储方式（顺序存储，按照B树结构存储，按hash方法存储）/ 索引的组织方式 / 数据是否压缩存储 / 数据是否加密 / 数据存储记录结构的规定<br>一个数据库只有一个内模式</p><h1 id="关系模型和关系"><a href="#关系模型和关系" class="headerlink" title="关系模型和关系"></a>关系模型和关系</h1><p>关系模型的数据结构非常简单，只包含单一的数据结构—-关系。在关系模型中，实体和实体间的各种联系都用关系表示。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>域（Domain）<br>一组具有相同数据类型的值的集合</li><li>笛卡尔积（Cartesian Product）<br><img src="/upload/pasted-395.png" alt="upload successful"></li></ul><p><img src="/upload/pasted-396.png" alt="upload successful"><br>笛卡尔积的每一个结果(d1,d2,d3,d4)被称为元组（Tuple）;<br>笛卡尔积的每一个结果中的具体的值di叫做一个分量（Component）<br>笛卡尔积做出的结果的元组数是基数（Cardinal number）</p><ul><li>关系<br><img src="/upload/pasted-397.png" alt="upload successful"></li><li>属性<br>每列的名字</li><li>码<ul><li>候选码（Candidate key）<br>若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选码<br>在最简单的情况下，候选码只包含一个属性。<br>在最极端的情况下，关系模式的所有属性组是这个关系模式的候选码，称为全码（All-key）</li><li>主码<br>若一个关系有多个候选码，则选定其中一个为主码（Primary key）<br>侯选码的诸属性称为主属性（Prime attribute）。<br>不包含在任何侯选码中的属性称为非码属性（Non-key attribute） </li></ul></li></ul><h2 id="三类关系"><a href="#三类关系" class="headerlink" title="三类关系"></a>三类关系</h2><p><img src="/upload/pasted-398.png" alt="upload successful"></p><h2 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h2><p><img src="/upload/pasted-399.png" alt="upload successful"></p><p><img src="/upload/pasted-400.png" alt="upload successful"></p><h2 id="关系的基本运算"><a href="#关系的基本运算" class="headerlink" title="关系的基本运算"></a>关系的基本运算</h2><p>设两个关系R,S：有相同的目n，相应的属性取自同一个域</p><ul><li>选择</li></ul><p><img src="/upload/pasted-406.png" alt="upload successful"></p><p><img src="/upload/pasted-407.png" alt="upload successful"></p><ul><li>投影</li></ul><p><img src="/upload/pasted-408.png" alt="upload successful"></p><ul><li>并<br>R∪S = { t|t Î R∨t ÎS }</li></ul><p><img src="/upload/pasted-402.png" alt="upload successful"></p><ul><li>差<br>R -S = { t|tÎR∧tÏS }<br><img src="/upload/pasted-403.png" alt="upload successful"></li><li>笛卡尔积</li></ul><p><img src="/upload/pasted-404.png" alt="upload successful"></p><p><img src="/upload/pasted-405.png" alt="upload successful"></p><ul><li>交<br>R∩S = { t|t Î R∧t ÎS }<br>R∩S = R –(R-S）</li><li>连接<br><img src="/upload/pasted-409.png" alt="upload successful"><br><img src="/upload/pasted-410.png" alt="upload successful"><br>有两类连接，包括等值连接和自然连接<br>等值连接<br><img src="/upload/pasted-411.png" alt="upload successful"><br>自然连接<br><img src="/upload/pasted-412.png" alt="upload successful"><br>相当于是一种合并<br><img src="/upload/pasted-413.png" alt="upload successful"></li></ul><h2 id="实体完整性（Entity-Integrity）"><a href="#实体完整性（Entity-Integrity）" class="headerlink" title="实体完整性（Entity Integrity）"></a>实体完整性（Entity Integrity）</h2><p>若属性A是基本关系R的主属性，则属性A不能取空值</p><h2 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h2><p>设F是基本关系R的一个或一组属性，但不是关系R的码。如果F与基本关系S的主码Ks相对应，则称F是基本关系R的外码，基本关系R称为参照关系（Referencing Relation）<br>基本关系S称为被参照关系（Reference Relation）或目标关系（Target  Relation）<br>若属性（或属性组）F是基本关系R的外码<br>它与基本关系S的主码Ks相对应（基本关<br>系R和S不一定是不同的关系），则对<br>于R中每个元组在F上的值必须为：<br>· 或者取空值（F的每个属性值均为空值）<br>· 或者等于S中某个元组的主码值。</p><p><img src="/upload/pasted-401.png" alt="upload successful"><br>用人话来说，就是外键不能是自己造出来的</p><h2 id="关系代数运算题目实例"><a href="#关系代数运算题目实例" class="headerlink" title="关系代数运算题目实例"></a>关系代数运算题目实例</h2><p>设教学数据库有3个关系<br>学生关系 S（Sno，Sname，age，sex）<br>成绩关系 SC（Sno，Cno，grade）<br>课程关系 C（Cno，Cname，teacher）</p><ol><li>LIU老师所教授课程的课程号，课程名<br>∏CNO,CNAME(σTNAME=‘LIU’ （C））</li><li>检索年龄大于23岁的男学生的学号和姓名<br>∏SNO,SNAME（ σ AGE&gt;23 ∧ SEX=‘M’（S））</li><li>检索学号为S3学生所学课程的课程名与任课老师名<br> ∏CNAME,TNAME（ σ SNO=‘S3’（SC）∞(C)）</li><li>检索至少选修LIU老师所教授课程中一门课的女学生姓名<br>  ∏SNAME(σSEX=‘F’(S)∞SC∞σTNAME=‘LIU’(C))</li><li>检索wang同学不学课程的课程号<br> ∏CNO(C)-∏CNO(σSNAME=‘WANG’(S)∞SC)</li><li>检索至少选修两门课的学生学号<br>∏1(σ1=4 ∧ 2!=5(SC × SC))</li><li>检索全部学生都选修的课程的课程号和课程名<br> ∏CNO,CNAME,SNO(C ∞SC) ÷ ∏SNO(S)</li><li>检索选修课程包含LIU老师所教授课程的学生学号<br>∏CNO,SNO(SC) ÷ ∏CNO(σTNAME=‘LIU’(C))</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/upload/pasted-429.png&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java多线程学习8（线程池，阻塞队列（BlockingQueue）FutureTask,Callable）</title>
    <link href="https://www.junglezero.top/2019/07/12/va-mitple-thread8/"/>
    <id>https://www.junglezero.top/2019/07/12/va-mitple-thread8/</id>
    <published>2019-07-12T12:21:40.000Z</published>
    <updated>2019-07-17T13:54:47.374Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/upload/pasted-428.png" width="70%"></p><a id="more"></a><hr><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2><h3 id="框架简介"><a href="#框架简介" class="headerlink" title="框架简介"></a>框架简介</h3><p><img src="/upload/pasted-367.png" alt="upload successful"><br>而具体说来，Executor是一个接口，对于这个接口，API文档是这样描述的。</p><blockquote><p>An object that executes submitted Runnable tasks. This interface provides a way of decoupling task submission from the mechanics of how each task will be run, including details of thread use, scheduling, etc. An Executor is normally used instead of explicitly creating threads.</p></blockquote><p>第一句话强调了这个的用法就是提交任务，并通过Executor来运行，可以用Executor来替代显示的调用Thread，把实现任务的细节封装。<br>对于该接口，可以直接在调用线程运行任务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirectExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    r.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一般则是另起线程运行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以构造一个组件化的Executor,把任务的执行序列化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前类继承一个Executor</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Queue&lt;Runnable&gt; tasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</span><br><span class="line">   <span class="keyword">final</span> Executor executor;</span><br><span class="line">   Runnable active;</span><br><span class="line"></span><br><span class="line">   SerialExecutor(Executor executor) &#123;</span><br><span class="line">     <span class="keyword">this</span>.executor = executor;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</span><br><span class="line">     tasks.offer(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">           r.run();</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           scheduleNext();</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="keyword">if</span> (active == <span class="keyword">null</span>) &#123;</span><br><span class="line">       scheduleNext();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> ((active = tasks.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">       executor.execute(active);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>说来说去，Executor不过是提供了一个接口，一种线程服务的思路，具体的线程复杂操作还是要看他的各个实现类<br>和继承接口</p><p><img src="/upload/pasted-368.png" alt="upload successful"><br>这才是整个Executor的体系框架</p><h2 id="BlockingQueue（阻塞队列）"><a href="#BlockingQueue（阻塞队列）" class="headerlink" title="BlockingQueue（阻塞队列）"></a>BlockingQueue（阻塞队列）</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>所谓阻塞队列，就是比一般队列多了两个操作的队列</p><p><img src="/upload/pasted-370.png" alt="upload successful"></p><p><img src="/upload/pasted-371.png" alt="upload successful"></p><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><h3 id="七个属性"><a href="#七个属性" class="headerlink" title="七个属性"></a>七个属性</h3><p> 结合自已以前实现的一个<a href="https://www.junglezero.top/2019/04/02/%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/">线程池</a>，对于其大概的属性已经有了初步了解。<br> 从ThreadPoolExecutor的构造函数开始看起，有四个重载的构造函数，找到其中参数最多的那个</p><p><img src="/upload/pasted-369.png" alt="upload successful"><br>和以前自己的实现的思路基本差不多：<br>核心线程数量、最大线程数量、多余线程存活时间（相比于核心线程多出来的线程在空闲时的存活时间）、时间单位、任务队列(阻塞队列)、线程工厂方法、拒绝策略</p><p>可以用以下的测试理解这几个属性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> TestMain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor= (ThreadPoolExecutor) buildThreadPool();</span><br><span class="line">        <span class="keyword">int</span> activeCount=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> queueSize=-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//线程池执行一个任务（Runable）</span></span><br><span class="line">        threadPoolExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                DoingJobs(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程池执行两个任务（Runable）</span></span><br><span class="line">        threadPoolExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                DoingJobs(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//。。。</span></span><br><span class="line">        <span class="comment">//当活跃线程数量发生改变时输出</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (activeCount!=threadPoolExecutor.getActiveCount()||queueSize!=threadPoolExecutor.getQueue().size())&#123;</span><br><span class="line">                System.out.println(<span class="string">"线程池中活跃线程数量："</span>+threadPoolExecutor.getActiveCount());</span><br><span class="line">                System.out.println(<span class="string">"核心线程数量（固定的）："</span>+threadPoolExecutor.getCorePoolSize());</span><br><span class="line">                System.out.println(<span class="string">"任务队列中等待执行的任务数量："</span>+threadPoolExecutor.getQueue().size());</span><br><span class="line">                activeCount=threadPoolExecutor.getActiveCount();</span><br><span class="line">                queueSize=threadPoolExecutor.getQueue().size();</span><br><span class="line">                System.out.println(<span class="string">"================================"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">buildThreadPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//核心线程数为1，最大线程池为2，存活时间为10s，阻塞队列（任务队列）的大小为1</span></span><br><span class="line">        ExecutorService executorService=<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                Thread t=<span class="keyword">new</span> Thread(r);</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">        System.out.println(<span class="string">"线程池创建成功！"</span>);</span><br><span class="line">        <span class="keyword">return</span> executorService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用Sleep来模拟线程运行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoingJobs</span><span class="params">(<span class="keyword">long</span> seconds)</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"正在执行任务"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(seconds);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当任务为1个时</p><p><img src="/upload/pasted-373.png" alt="upload successful"></p><p>当任务为2时</p><p><img src="/upload/pasted-372.png" alt="upload successful"><br>可以发现，当任务为2时，线程池并没有创建新的线程，因为任务可以在队列中等待</p><p>当任务为3时，此时把测试方法中的活跃线程数量改为线程池大小（线程中线程的数量）</p><p><img src="/upload/pasted-374.png" alt="upload successful"><br>可以发现，当任务队列慢的时候，再有新的任务加入，线程池就会根据最大线程数量创建新的线程共同执行任务，当任务队列中没有任务时，过了存回时间，多创建出的线程就会被销毁。</p><p>当任务有4个时</p><p><img src="/upload/pasted-375.png" alt="upload successful"><br>此时多出一个任务，无法进入阻塞队列，也无法执行，拒绝策略生效。</p><h2 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h2><p>线程池的关闭涉及到三个方法</p><p><img src="/upload/pasted-376.png" alt="upload successful"></p><p><img src="/upload/pasted-377.png" alt="upload successful"></p><p><img src="/upload/pasted-378.png" alt="upload successful"><br>通过测试可以发现<br>shutdown方法：平滑的关闭ExecutorService，当此方法被调用时，ExecutorService停止接收新的任务并且等待已经提交的任务（包含提交正在执行和提交未执行）执行完成。<br>当所有已提交任务执行完毕，线程池即被关闭。<br>awaitTermination方法：接收timeout和unit两个参数，用于设定超时时间及单位。当等待超过设定时间时，会监测ExecutorService是否已经关闭，<br>若关闭则返回true，否则返回false。一般情况下会和shutdown方法组合使用。<br>shutdown调用后，不可以再submit新的task，已经submit的将继续执行。<br>shutdownNow试图停止当前正执行的task，并返回尚未执行的task的list</p><p>因此最好的关闭线程池的方式是shutdown+awaitTermination</p><h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><p>Executors是一个工厂类<br>其中包括了许多关于线程池及Executors框架相关的创建方法<br>毕竟拿七个参数创建一个线程池太复杂了<br><img src="/upload/pasted-379.png" alt="upload successful"></p><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><blockquote><p>Creates a thread pool that creates new threads as needed, but will reuse previously constructed threads when they are available. These pools will typically improve the performance of programs that execute many short-lived asynchronous tasks. Calls to execute will reuse previously constructed threads if available. If no existing thread is available, a new thread will be created and added to the pool. Threads that have not been used for sixty seconds are terminated and removed from the cache. Thus, a pool that remains idle for long enough will not consume any resources. Note that pools with similar properties but different details (for example, timeout parameters) may be created using ThreadPoolExecutor constructors.</p></blockquote><p>这种线程池的特点就是按照需求创建线程以处理更多的耗时短的异步任务<br>看其具体实现就可以知道<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，这个线程池一开始核心线程就是0，最大线程数量却相当于没有限制，存活时间为1分钟，这就很好的印证了按需分配创建线程的思路。而关键还是在这个阻塞队列上<br>SynchronousQueue是一种很特殊的阻塞队列，其中每个 put 必须等待一个 take，否则会进入wait状态反之亦然。同步队列没有任何内部容量，甚至连一个队列的容量都没有。<br>使用完成后不需要显示的调用shotdown<br>注意：仅适合周期短的多任务，因为创建线程的数量是没用限制的</p><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顾名思义，这是一种固定线程数量的线程池，不会额外去创建，阻塞队列采用LinkedBlockingQueue,是以链表为内核实现的阻塞队列，默认大小为Integar.Max<br>使用完成后需要shutdown</p><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">    (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                            <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br></pre></td></tr></table></figure><p>这个实际上就是newFixedThreadPool线程数量设置为1的时候</p><h3 id="newWorkStealingPool"><a href="#newWorkStealingPool" class="headerlink" title="newWorkStealingPool"></a>newWorkStealingPool</h3><p>这是在1.8新出的一种线程池服务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">        (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种服务是根据cpu个数创建的ForkJoinPool,根据前面讲的，ForkJoinPool中执行的是ForkJoinTask，Runable是不行的<br>看源码可以知道，传入Runable以后，会执行一个内部的转换</p><p>这种线程数量的确定和创建时是根据电脑根据cpu个数创建的（等于）<br>工作窃取概念：所谓工作窃取，指的是闲置的线程去处理本不属于它的任务。<br>每个处理器核，都有一个队列存储着需要完成的任务。对于多核的机器来说，当一个核对应的任务处理完毕后，就可以去帮助其他的核处理任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    ForkJoinTask&lt;?&gt; job;</span><br><span class="line">    <span class="keyword">if</span> (task <span class="keyword">instanceof</span> ForkJoinTask&lt;?&gt;) <span class="comment">// avoid re-wrap</span></span><br><span class="line">        job = (ForkJoinTask&lt;?&gt;) task;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        job = <span class="keyword">new</span> ForkJoinTask.RunnableExecuteAction(task);</span><br><span class="line">    externalSubmit(job);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在用Callable来执行（线程的第三种实现方法）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorsTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService =Executors.newWorkStealingPool();</span><br><span class="line">        System.out.println(executorService.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">         <span class="comment">//这里可以先把Callable当成是有返回值的Runable</span></span><br><span class="line">        List&lt;Callable&lt;String&gt;&gt; callables=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> ( ;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">            Callable&lt;String&gt; callable=<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="comment">//call方法就相当于Run方法</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                    sleep(<span class="number">2</span>);</span><br><span class="line">                    <span class="comment">//可以有返回值</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"任务被"</span>+Thread.currentThread().getName();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">             callables.add(callable);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//批量运行，且将返回运行结果Future</span></span><br><span class="line">            List&lt;Future&lt;String&gt;&gt; futures=executorService.invokeAll(callables);</span><br><span class="line">            <span class="comment">//若是没有执行完，这里会是堵塞的</span></span><br><span class="line">            <span class="keyword">for</span> (Future f:futures)&#123;</span><br><span class="line">                System.out.println(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> seconds)</span></span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           TimeUnit.SECONDS.sleep(seconds);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><p><img src="/upload/pasted-381.png" alt="upload successful"><br>可以发现，这种线程池服务也是自动退出的</p><h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor。它主要用来在给定的延迟之后运行任务，或者定期执行任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolExecutorDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个实现了Runable的时间任务类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String id;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TimerTask</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        ScheduledExecutorService ses = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//调用scheduleAtFixedRate来进行周期执行，拿第一个来说，开始时延是200ms，周期为1000ms</span></span><br><span class="line">        ScheduledFuture sfa = ses.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask(<span class="string">"a"</span>), <span class="number">200</span>,</span><br><span class="line">                                                    <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        ScheduledFuture sfb = ses.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask(<span class="string">"b"</span>), <span class="number">400</span>, </span><br><span class="line">                                                    <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        ScheduledFuture sfc = ses.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask(<span class="string">"c"</span>), <span class="number">600</span>,</span><br><span class="line">                                                    <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        ScheduledFuture sfd = ses.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask(<span class="string">"d"</span>), <span class="number">800</span>, </span><br><span class="line">                                                    <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        sfa.cancel(<span class="keyword">true</span>);</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        ses.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程运行时发生错误的处理"><a href="#线程运行时发生错误的处理" class="headerlink" title="线程运行时发生错误的处理"></a>线程运行时发生错误的处理</h2><p>一般情况下，可以<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread t=<span class="keyword">new</span> Thread();</span><br><span class="line">t.setUncaughtExceptionHandler(<span class="keyword">new</span> Thread.UncaughtExceptionHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(t.getName()+<span class="string">"运行时发生错误~！"</span>);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>如果线程的实现不是自己定义的<br>如果是=自己定义的，则可以定义内部方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Error</span><span class="params">(Throwable e)</span></span>&#123;</span><br><span class="line">     System.out.println(<span class="string">"当前线程发生错误"</span>);</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="拒绝策略细节"><a href="#拒绝策略细节" class="headerlink" title="拒绝策略细节"></a>拒绝策略细节</h2><h3 id="ThreadPoolExecutor-AbortPolicy"><a href="#ThreadPoolExecutor-AbortPolicy" class="headerlink" title="ThreadPoolExecutor.AbortPolicy()"></a>ThreadPoolExecutor.AbortPolicy()</h3><p>这个策略中，不能执行且不能进入阻塞队列的任务会直接被抛出异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p><img src="/upload/pasted-382.png" alt="upload successful"></p><h3 id="new-ThreadPoolExecutor-DiscardPolicy"><a href="#new-ThreadPoolExecutor-DiscardPolicy" class="headerlink" title="new ThreadPoolExecutor.DiscardPolicy()"></a>new ThreadPoolExecutor.DiscardPolicy()</h3><p>这个拒绝策略则不会做出任何事</p><h3 id="ThreadPoolExecutor-CallerRunsPolicy"><a href="#ThreadPoolExecutor-CallerRunsPolicy" class="headerlink" title="ThreadPoolExecutor.CallerRunsPolicy()"></a>ThreadPoolExecutor.CallerRunsPolicy()</h3><p>这个策略会在execute 方法的调用线程中运行被拒绝的任务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line"></span><br><span class="line">               r.run();</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><p><img src="/upload/pasted-383.png" alt="upload successful"></p><h3 id="ThreadPoolExecutor-DiscardOldestPolicy"><a href="#ThreadPoolExecutor-DiscardOldestPolicy" class="headerlink" title="ThreadPoolExecutor.DiscardOldestPolicy()"></a>ThreadPoolExecutor.DiscardOldestPolicy()</h3><p>这个方法会把阻塞队列的队尾元素去除，然后执行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line"></span><br><span class="line">        e.getQueue().poll();</span><br><span class="line"></span><br><span class="line">        e.execute(r);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="ExecutorService-几个其他方法"><a href="#ExecutorService-几个其他方法" class="headerlink" title="ExecutorService 几个其他方法"></a>ExecutorService 几个其他方法</h2><h3 id="invokeAny"><a href="#invokeAny" class="headerlink" title="invokeAny"></a>invokeAny</h3><p>测试方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">testInvokeAny</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ExecutorService executorService= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    List&lt;Callable&lt;Integer&gt;&gt; callables=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//创建5个Callable</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        Callable&lt;Integer&gt; callable= <span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">//先进入随机的sleep</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>));</span><br><span class="line">                <span class="comment">//输出语句</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//放入集合中</span></span><br><span class="line">        callables.add(callable);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//输出invokeany的结果</span></span><br><span class="line">        System.out.println(executorService.invokeAny(callables));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><p><img src="/upload/pasted-384.png" alt="upload successful"><br>也就是说，运行invokeany，当运行的那一个任务运行完毕后，会取消掉其他正在运行的任务<br>注意：这个方法是一个阻塞方法，也就是说只有选定的某个任务执行完成，才会有返回值，否则会一直陷入阻塞状态<br>另外，该方法的重载方法还可以添加TimeOut,超过TimeOut时间，其他任务取消运行。抛出Timeout异常。</p><h3 id="invokeAll"><a href="#invokeAll" class="headerlink" title="invokeAll"></a>invokeAll</h3><p><img src="/upload/pasted-385.png" alt="upload successful"><br>这个方法也是一个阻塞方法</p><h3 id="submit-Runable"><a href="#submit-Runable" class="headerlink" title="submit(Runable)"></a>submit(Runable)</h3><p><img src="/upload/pasted-386.png" alt="upload successful"><br>这个方法可以返回一个结果值，但是由于Runable没有返回值所以可以手动传入一个值作为返回值（Future）</p><h1 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h1><p>Future是一个接口</p><blockquote><p>A Future represents the result of an asynchronous computation. Methods are provided to check if the computation is complete, to wait for its completion, and to retrieve the result of the computation. The result can only be retrieved using method get when the computation has completed, blocking if necessary until it is ready. Cancellation is performed by the cancel method. Additional methods are provided to determine if the task completed normally or was cancelled. Once a computation has completed, the computation cannot be cancelled. If you would like to use a Future for the sake of cancellability but not provide a usable result, you can declare types of the form Future&lt;?&gt; and return null as a result of the underlying task. </p></blockquote><p>future可以理解为一个票据，表示一个某个任务的结果，我们不是非要等到这个任务执行完毕才能进行别的任务，我们，我们可以在这个任务执行时，先去执行别的任务，等到这个任务执行完毕，再通过future获得任务的结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        Callable&lt;String&gt; longTimeJob=<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"长时工作完成"</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Callable&lt;String&gt; shotTimeJob=<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"短时工作完成"</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Future&lt;String&gt; res1=executorService.submit(longTimeJob);</span><br><span class="line">        Future&lt;String&gt; res2=executorService.submit(shotTimeJob);</span><br><span class="line">        System.out.println(res1);</span><br><span class="line">        System.out.println(res2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Future的方法"><a href="#Future的方法" class="headerlink" title="Future的方法"></a>Future的方法</h2><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p>Waits if necessary for the computation to complete, and then retrieves its result.<br>也就是说，通过票据Future获得线程的运行结果（Callable），会使线程陷入阻塞（会使调用get方法的线程进入阻塞,和线程池执行任务的线程无关）<br>比如(res1是长时任务的结果)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"主线程！！！！"</span>);</span><br><span class="line">    System.out.println(res1.get());</span><br><span class="line">    System.out.println(<span class="string">"&gt;?&gt;&gt;?&gt;&gt;&gt;?&gt;"</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果输出:</p><p><img src="/upload/pasted-387.png" alt="upload successful"><br>重载方法中，有一个TimeOut的参数，若调用get超时，则调用get方法的线程会抛timeout异常，但是未完成的任务仍然会继续进行。</p><h3 id="isDone"><a href="#isDone" class="headerlink" title="isDone"></a>isDone</h3><p><img src="/upload/pasted-389.png" alt="upload successful"><br>任务完成了，返回true；任务没完成，出现了异常，任务不能再继续做了，返回true，任务在做了，返回false</p><h3 id="cancle"><a href="#cancle" class="headerlink" title="cancle"></a>cancle</h3><p><img src="/upload/pasted-390.png" alt="upload successful"><br>如果取消任务成功则返回true，如果取消任务失败则返回false。参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。</p><h1 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h1><p>FutureTask是Runable和Future的实现类（是Future的唯一实现）<br>所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    ExecutorService executorService= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    Thread doingLong=<span class="keyword">null</span>;</span><br><span class="line">    FutureTask&lt;String&gt; futureTask=<span class="keyword">new</span> FutureTask&lt;String&gt;(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"任务任务任务"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    executorService.submit(futureTask);</span><br><span class="line">    System.out.println(futureTask.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h1><p>铺垫了这么多，Callable也就很好理解了，</p><p><img src="/upload/pasted-391.png" alt="upload successful"><br>Callable和Runable类似，但是它却可以有返回值</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/upload/pasted-428.png&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java多线程学习7（Exchanger,StampedLock,Fork/join,Phaser）</title>
    <link href="https://www.junglezero.top/2019/07/09/java-mutiple-threading-7/"/>
    <id>https://www.junglezero.top/2019/07/09/java-mutiple-threading-7/</id>
    <published>2019-07-09T03:36:52.000Z</published>
    <updated>2019-07-12T04:37:33.974Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/upload/pasted-356.png" width="70%"></p><a id="more"></a><hr><h1 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>A synchronization point at which threads can pair and swap elements within pairs. Each thread presents some object on entry to the exchange method, matches with a partner thread, and receives its partner’s object on return. An Exchanger may be viewed as a bidirectional form of a SynchronousQueue. Exchangers may be useful in applications such as genetic algorithms and pipeline designs. </p></blockquote><p>主要内容：提供一个同步点，使一对线程交换数据，可以使用在遗传算法和管道设计上</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><img src="/upload/pasted-351.png" alt="upload successful"><br>简要来说就是调用该方法的线程会进入等待状态，等待其他线程调用，若有其他线程调用，则交换两者数据（把参数中的object传过去，返回传回来的object），注意一个及时性，即使调用该方法后休眠，也不会影响交换，若非特殊情况下的阻断，则调用该方法会一直等下去，<br>若有超过两个线程都调用exchange方法，则先到交换点（先调用方法）的两个线程会交换数据，若第三个线程调用，则会等待第四个线程调用来交换数据</p><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Exchanger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置交换器</span></span><br><span class="line">        <span class="keyword">final</span> Exchanger&lt;String&gt; exchanger=<span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"开始运行。"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//模拟为该线程有的数据</span></span><br><span class="line">                    String myData=<span class="string">"123456789"</span>;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"交换之前的数据:"</span>+myData);</span><br><span class="line">                    <span class="comment">//调用交换器的exchange方法，并返回交换的结果（进入交换点等待另一个线程调用该方法）</span></span><br><span class="line">                    String exchangeResult=exchanger.exchange(myData);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"交换之后的数据:"</span>+exchangeResult);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"结束。"</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"开始运行。"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String myData=<span class="string">"987654321"</span>;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"交换之前的数据:"</span>+myData);</span><br><span class="line">                    String exchangeResult=exchanger.exchange(myData);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"交换之后的数据:"</span>+exchangeResult);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"结束。"</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="/upload/pasted-352.png" alt="upload successful"></p><h1 id="StamperdLock"><a href="#StamperdLock" class="headerlink" title="StamperdLock"></a>StamperdLock</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>这是java1.8新增加的锁（在JUC中），是对ReentrantReadWriteLock锁的一种改进:基于读的乐观锁<br>在Optimistic reading中，即使读线程获取到了读锁，写线程尝试获取写锁也不会阻塞，这相当于对读模式的优化，但是可能会导致数据不一致的问题。所以，当使用Optimistic reading获取到读锁时，必须对获取结果进行校验。<br>注意：StampededLock不支持重入</p><p><img src="/upload/pasted-353.png" alt="upload successful"></p><p>这里有一篇<a href="https://blog.overops.com/java-8-stampedlocks-vs-readwritelocks-and-synchronized/" target="_blank" rel="noopener">文章</a>,在这片文章中，作者讨论了synchronized,StampedLocks,和RWlock的效率对比，可以发现当读线程远多于写线程时，乐观锁的效率是最高的。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>可以使用StampededLock直接替代reentrantreadwritelock<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.StampedLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLockTest</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> StampedLock lock=<span class="keyword">new</span> StampedLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> List&lt;Long&gt; DATA=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ExecutorService executorService= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        Runnable readTask=<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (;;)</span><br><span class="line">                    read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable writeTask =<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (;;)</span><br><span class="line">                    write();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(writeTask);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//悲观式读取</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamped=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamped=lock.readLock();</span><br><span class="line">            <span class="comment">//模拟读取数据</span></span><br><span class="line">            System.out.println(DATA.toString());</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlockRead(stamped);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamp=lock.writeLock();</span><br><span class="line">            DATA.add(System.currentTimeMillis());</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而这个锁的改进就是对读加上乐观锁<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> stamped = lock.tryOptimisticRead();</span><br><span class="line">    <span class="keyword">if</span> (lock.validate(stamped)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamped = lock.readLock();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Fork-join"><a href="#Fork-join" class="headerlink" title="Fork/join"></a>Fork/join</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>Fork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。<br>Fork就是把一个大任务切分为若干子任务并行的执行，Join就是合并这些子任务的执行结果，最后得到这个大任务的结果<br>ForkJoinTask是轻量级的线程形式<br><img src="/upload/pasted-354.png" alt="upload successful"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>一般是使用ForkJoinTask 的继承类RecursiveAction（无返回值）和RecursiveTask（有返回值），并且依附在ForkJoinPool上进行使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分割任务的最大阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_THRSHOLD=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ForkJoinPool forkJoinPool=<span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        <span class="comment">//把ForkJoinTask提交ForkJoinPool进行运行</span></span><br><span class="line">        <span class="comment">//计算范围为0到10</span></span><br><span class="line">        ForkJoinTask&lt;Integer&gt; future=forkJoinPool.submit(<span class="keyword">new</span> ComputeRecursiveTask(<span class="number">0</span>,<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer result=<span class="number">0</span>;</span><br><span class="line">            result=future.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算的Fork/join线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputeRecursiveTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算的起始和终点</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> start;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">ComputeRecursiveTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//当发现起始和终点的相差的小于阈值时</span></span><br><span class="line">            <span class="keyword">if</span> (end-start&lt;=MAX_THRSHOLD)&#123;</span><br><span class="line">                <span class="comment">//直接计算返回结果，这里模拟的的是累加</span></span><br><span class="line">                <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">                    result+=i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//将起始到终点二分，分成两个子部分</span></span><br><span class="line">                <span class="keyword">int</span> middle=(start-end);</span><br><span class="line">                ComputeRecursiveTask leftRecursiveTask=<span class="keyword">new</span> ComputeRecursiveTask(start,middle);</span><br><span class="line">                ComputeRecursiveTask rightRecursiveTask=<span class="keyword">new</span> ComputeRecursiveTask(middle,end);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//调用fork进行执行</span></span><br><span class="line">                leftRecursiveTask.fork();</span><br><span class="line">                rightRecursiveTask.fork();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//最终的结果就是两个join</span></span><br><span class="line">                <span class="keyword">return</span> leftRecursiveTask.join()+rightRecursiveTask.join();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>文档讲到，这是一个可复用的同步器栅栏，可以理解为时CyclicBarrier和CountDownLatch的一个升级版<br>Phaser类机制是在每一步结束的位置对线程进行同步，当所有的线程都完成了这一步，才能进行下一步。<br>用来解决控制多个线程分阶段共同完成任务的情景问题。<br>当有并发任务并且需要分解成几步执行的时候，这种机制就非常适合。<br>CyclicBarrier CountDownLatch 只能在构造时指定参与量，而phaser可以动态的增减参与量<br>且Phaser支持父子结构，可以用在fork/join框架中</p><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><p><img src="/upload/pasted-358.png" alt="upload successful"></p><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>API中给到的几个使用例子<br>可以替代CountDownLatch来执行只需运行一次的线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runTasks</span><span class="params">(List&lt;Runnable&gt; tasks)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Phaser phaser = <span class="keyword">new</span> Phaser(<span class="number">1</span>); <span class="comment">// 参数为1，表示phaser计数为1</span></span><br><span class="line">   <span class="comment">// 创建并开始线程</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">final</span> Runnable task : tasks) &#123;</span><br><span class="line">   <span class="comment">//phaser添加一个新的运行部分</span></span><br><span class="line">     phaser.register();</span><br><span class="line">     <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         phaser.arriveAndAwaitAdvance(); <span class="comment">// await all creation</span></span><br><span class="line">         task.run();</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;.start();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//允许线程开始执行并在运行结束后注销（一次执行），不等着其他线程</span></span><br><span class="line">   phaser.arriveAndDeregister();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>重复执行一系列线程：重写onAdvance方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startTasks</span><span class="params">(List&lt;Runnable&gt; tasks, <span class="keyword">final</span> <span class="keyword">int</span> iterations)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Phaser phaser = <span class="keyword">new</span> Phaser() &#123;</span><br><span class="line">   <span class="comment">//重写该方法，来确定phaser的终止条件（返回true 表示终止）</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> phase &gt;= iterations || registeredParties == <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   phaser.register();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">final</span> Runnable task : tasks) &#123;</span><br><span class="line">     phaser.register();</span><br><span class="line">     <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">do</span> &#123;</span><br><span class="line">           task.run();</span><br><span class="line">           phaser.arriveAndAwaitAdvance();</span><br><span class="line">         &#125; <span class="keyword">while</span> (!phaser.isTerminated());</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;.start();</span><br><span class="line">   &#125;</span><br><span class="line">   phaser.arriveAndDeregister(); <span class="comment">// deregister self, don't wait</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>自己写的例子：模仿CyclicBarrier<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Phaser;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhaserTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Phaser phaser=<span class="keyword">new</span> Phaser();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            Task a=<span class="keyword">new</span> Task(phaser);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将主线程运行块加入phaser</span></span><br><span class="line">        phaser.register();</span><br><span class="line">        phaser.arriveAndAwaitAdvance();</span><br><span class="line">        System.out.println(<span class="string">"全部线程全部完成"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Phaser taskPhaser;</span><br><span class="line">        Task(Phaser phaser)&#123;</span><br><span class="line">            taskPhaser=phaser;</span><br><span class="line">            <span class="comment">//新添加一个运行块</span></span><br><span class="line">            phaser.register();</span><br><span class="line">            <span class="comment">//直接运行</span></span><br><span class="line">            start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"正在工作中》》》》》"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//线程到达并等待运行</span></span><br><span class="line">            taskPhaser.arriveAndAwaitAdvance();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><img src="/upload/pasted-359.png" alt="upload successful"></p><p>多个线程分阶段共同完成任务:完成铁人三项<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Phaser;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhaserTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Phaser phaser=<span class="keyword">new</span> Phaser(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Athletes(i,phaser).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Athletes</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Phaser phaser;</span><br><span class="line"></span><br><span class="line">        Athletes(<span class="keyword">int</span> num,Phaser phaser)&#123;</span><br><span class="line">            <span class="keyword">this</span>.num=num;</span><br><span class="line">            <span class="keyword">this</span>.phaser=phaser;</span><br><span class="line">            <span class="comment">//phaser.register();</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"No."</span>+num+<span class="string">"开始跑了"</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>));</span><br><span class="line">                System.out.println(<span class="string">"No."</span>+num+<span class="string">"跑到头了"</span>);</span><br><span class="line"></span><br><span class="line">                phaser.arriveAndAwaitAdvance();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"No."</span>+num+<span class="string">"开始游泳了"</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>));</span><br><span class="line">                System.out.println(<span class="string">"No."</span>+num+<span class="string">"游泳到头了"</span>);</span><br><span class="line"></span><br><span class="line">                phaser.arriveAndAwaitAdvance();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"No."</span>+num+<span class="string">"开始骑自行车了"</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>));</span><br><span class="line">                System.out.println(<span class="string">"No."</span>+num+<span class="string">"骑自行车到头了"</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><img src="/upload/pasted-360.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/upload/pasted-356.png&quot; width=&quot;70%&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java语言基础知识和其他应该知道的东西</title>
    <link href="https://www.junglezero.top/2019/07/06/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://www.junglezero.top/2019/07/06/Java语言基础知识/</id>
    <published>2019-07-06T02:53:05.000Z</published>
    <updated>2019-08-09T03:04:00.480Z</updated>
    
    <content type="html"><![CDATA[<p># </p><h2 id="ArrayList和Linkedlist区别"><a href="#ArrayList和Linkedlist区别" class="headerlink" title="ArrayList和Linkedlist区别"></a>ArrayList和Linkedlist区别</h2><p>1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。<br>2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。<br>3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。<br>4．对ArrayList和LinkedList而言，在列表末尾增加一个元素所花的开销都是固定的。对ArrayList而言，主要是在内部数组中增加一项，指向所添加的元素，偶尔可能会导致对数组重新进行分配；而对LinkedList而言，这个开销是统一的，分配一个内部Entry对象。<br>5．在ArrayList的中间插入或删除一个元素意味着这个列表中剩余的元素都会被移动；而在LinkedList的中间插入或删除一个元素的开销是固定的。<br>6．LinkedList不支持高效的随机元素访问。<br>7．ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间 </p><h2 id="java方法“值传递”的理解"><a href="#java方法“值传递”的理解" class="headerlink" title="java方法“值传递”的理解"></a>java方法“值传递”的理解</h2><p>java中的数据类型有基本类型和引用类型，他们都是值传递方式。基本类型传递的是它的值，因此方法中的改变参数的值，不会影响方法外。引用类型传递的是一个地址，因为引用类型在生成对象实例时，里面的值是一个地址，指向了对象实例。在传值的时候实际上传的是一个地址，他们指向了同一块地址，所以在方法内的改变会影响方法外的参数。 这里比较乱人心的是包装类型，因为包装类型也是引用类型，这里应该就是和包装类型的实现有关了，在包装类型中，比如Integer a=1，有一个自动装箱的操作。其实a=1，如果现在令a=2，不会令2覆盖1（即1本身是不会变的），真正改变的是a被赋给了一个新地址，这个地址指向了2。因此方法内的改变包装类型的值就相当于改变了形参里面的地址，相当于重新new了一遍。而方法外面的实参仍旧指向含1的那个地址，一次方法内的改变不会影响方法外的实参。 </p><p><img src="/upload/pasted-320.png" alt="upload successful"></p><h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><p>Volatile：与锁相比，Volatile 变量是一种非常简单但同时又非常脆弱的同步机制，它在某些情况下将提供优于锁的性能和伸缩性。如果严格遵循 volatile 的使用条件 —— 即变量真正独立于其他变量和自己以前的值 —— 在某些情况下可以使用 volatile 代替 synchronized 来简化代码。然而，使用 volatile 的代码往往比使用锁的代码更加容易出错。<br>只能在有限的一些情形下使用 volatile 变量替代锁。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：</p><ul><li>（1）对变量的写操作不依赖于当前值。</li><li>（2）该变量没有包含在具有其他变量的不变式中。<br>实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。<br>第一个条件的限制使 volatile 变量不能用作线程安全计数器。虽然增量操作（x++）看上去类似一个单独操作，实际上它是一个由读取－修改－写入操作序列组成的组合操作，必须以原子方式执行，而 volatile 不能提供必须的原子特性。实现正确的操作需要使 x 的值在操作期间保持不变，而 volatile 变量无法实现这点。 </li></ul><h2 id="数组复制"><a href="#数组复制" class="headerlink" title="数组复制"></a>数组复制</h2><p>1.for循环<br>2.System.arraycopy<br>3.Arrays.copyOf<br>4.clone</p><h2 id="类的加载顺序"><a href="#类的加载顺序" class="headerlink" title="类的加载顺序"></a>类的加载顺序</h2><p>(1) 父类静态代码块(包括静态初始化块，静态属性，但不包括静态方法)<br>(2) 子类静态代码块(包括静态初始化块，静态属性，但不包括静态方法 )<br>(3) 父类非静态代码块( 包括非静态初始化块，非静态属性 )<br>(4) 父类构造函数<br>(5) 子类非静态代码块 ( 包括非静态初始化块，非静态属性 )<br>(6) 子类构造函数</p><h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p>1、不管有没有出现异常，finally块中代码都会执行；<br>2、当try和catch中有return时，finally仍然会执行；<br>3、finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，不管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值），所以函数返回值是在finally执行前确定的；<br>4、finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。</p><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="registerNatives"><a href="#registerNatives" class="headerlink" title="registerNatives()"></a>registerNatives()</h3><p>向JVM注册native方法<br>在类初始化的时候，会依次从父类到本类的类变量及类初始化块中的类变量及方法按照定义顺序放到 &lt; clinit&gt;方法中，这样可以保证父类的类变量及方法的初始化一定先于子类。所以当子类调用相应 native方法，比如计算 hashCode时，一定可以保证能够调用到 JVM的 native方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">       registerNatives();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h3 id="getClass"><a href="#getClass" class="headerlink" title="getClass()"></a>getClass()</h3><p>类加载的第一阶段类的加载就是将 .class文件加载到内存，并生成一个 java.lang.Class对象的过程。 getClass()方法就是获取这个对象，这是当前类的对象在运行时类的所有信息的集合。这个方法是反射三种方式之一。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure></p><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><p>这个方法返回一个int类型的hash值<br>在 Java应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改；<br>如果两个对象 x.equals(y) 方法返回 true，则 x、 y这两个对象的 hashCode必须相等。<br>如果两个对象 x.equals(y) 方法返回 false，则 x、 y这两个对象的 hashCode可以相等也可以不等。但是，为不相等的对象生成不同整数结果可以提高哈希表的性能。<br>默认的 hashCode是将内存地址转换为的 hash值，重写过后就是自定义的计算方式；也可以通过 System.identityHashCode(Object)来返回原本的 hashCode。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>计算 hashCode使用了31作为基础乘数，为什么使用31呢？result *31=(result&lt;&lt;5)-result。 JVM底层可以自动做优化为位运算，效率很高；还有因为 31计算的 hashCode冲突较少，利于 hash桶位的分布。</p><h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><p>用于比较当前对象与目标对象是否相等，默认是比较引用是否指向同一对象。为 public方法，子类可重写。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>重写equals的意义：<br>因为如果不重写equals方法，当将自定义对象放到 map或者 set中时；如果这时两个对象的 hashCode相同，就会调用 equals方法进行比较，这个时候会调用 Object中默认的 equals方法，而默认的 equals方法只是比较了两个对象的引用是否指向了同一个对象，显然大多数时候都不会指向，这样就会将重复对象存入 map或者 set中。这就破坏了 map与 set不能存储重复对象的特性，会造成内存溢出。</p><h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><p>这是一个 protected方法，提供给子类重写。但需要实现 Cloneable接口，这是一个标记接口，如果没有实现，当调用 object.clone()方法，会抛出 CloneNotSupportedException<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure></p><p>两个概念——<br>浅拷贝：创建一个新对象，然后将当前对象的非静态字段复制到该对象，如果字段类型是值类型（基本类型）的，那么对该字段进行复制；如果字段是引用类型的，则只复制该字段的引用而不复制引用指向的对象。此时新对象里面的引用类型字段相当于是原始对象里面引用类型字段的一个副本，原始对象与新对象里面的引用字段指向的是同一个对象。<br>说白了就是clone一个对象，将会创建一个新的对象，而对于其内部属性，比如一个String的引用类型，克隆对象和被克隆对象指向的是一个引用。换言之，如果克隆对象的属性发生了改变，则原对象也会发生改变<br>而深拷贝则是一个完全不同的拷贝的方式<br>深拷贝通过序列化(Serializable)实现</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="wait-相关方法"><a href="#wait-相关方法" class="headerlink" title="wait()相关方法"></a>wait()相关方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        timeout++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多线程情况下使用作用是阻塞进程</p><ul><li>此方法只能在当前线程获取到对象的锁监视器之后才能调用，否则会抛出 IllegalMonitorStateException异常。</li><li>调用 wait方法，线程会将锁监视器进行释放；而 Thread.sleep，Thread.yield()并不会释放锁。</li><li>wait方法会一直阻塞，直到其他线程调用当前对象的 notify()/notifyAll()方法将其唤醒；而 wait(long)是等待给定超时时间内（单位毫秒），如果还没有调用 notify()/nofiyAll()会自动唤醒； wait(long,int)如果第二个参数大于 0并且小于 999999，则第一个参数 +1作为超时时间；</li></ul><h3 id="notify-notifyAll"><a href="#notify-notifyAll" class="headerlink" title="notify()/notifyAll()"></a>notify()/notifyAll()</h3><p>如果当前线程获得了当前对象锁，调用 wait方法，将锁释放并阻塞；这时另一个线程获取到了此对象锁，并调用此对象的 notify()/notifyAll()方法将之前的线程唤醒。这些方法都是 publicfinal的，不可被重写。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>要点：<br>调用 notify()后，阻塞线程被唤醒，可以参与锁的竞争，但可能调用 notify()方法的线程还要继续做其他事，锁并未释放，所以我们看到的结果是，无论 notify()是在方法一开始调用，还是最后调用，阻塞线程都要等待当前线程结束才能开始。</p><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h3><p>jvm垃圾回收时进行调用</p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p><img src="/upload/pasted-321.png" alt="upload successful"></p><p><img src="/upload/pasted-380.png" alt="upload successful"></p><h2 id="和equals"><a href="#和equals" class="headerlink" title="==和equals"></a>==和equals</h2><p>==用来判断两个变量是否相等时，如果两个变量是基本类型变量，且都是数值类型(不要求数据类型严格相同)，则只要两个变量的值相等，就返回true；对于两个引用类型变量，必须指向同一个对象，==才会返回true。<br>equals方法用于比较两个独立对象的内容是否相同</p><h2 id="实例变量，局部变量，类变量，final变量"><a href="#实例变量，局部变量，类变量，final变量" class="headerlink" title="实例变量，局部变量，类变量，final变量"></a>实例变量，局部变量，类变量，final变量</h2><ul><li>实例变量：是定义在是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。分配了内存空间后会给所有的成员变量一次初始化，没有赋值的会给成员变量对应类型的值，数据类型不同则默认值不同。</li><li>局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。用的时候是直接入栈的，如果没有赋值，这个变量就没有初始值，也就无法操作，所以局部变量要初始化。</li><li>类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。</li><li>final变量，final 修饰的变量。如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li></ul><h2 id="Integer的赋值问题"><a href="#Integer的赋值问题" class="headerlink" title="Integer的赋值问题"></a>Integer的赋值问题</h2><p>在为Integer赋值的时候，java编译器会将其翻译成调用valueOf()方法。比如Integer i=127翻译为Integer i=Integer.valueOf(127)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//high为127</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= -<span class="number">128</span> &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + <span class="number">128</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，对于-128到127之间的数，Java会对其进行缓存。而超出这个范围则新建一个对象。</p><h2 id="throws和throw"><a href="#throws和throw" class="headerlink" title="throws和throw"></a>throws和throw</h2><p>1、throws出现在方法头，throw出现在方法体 2、throws表示出现异常的一种可能性，并不一定会发生异常；throw则是抛出了异常，执行throw则一定抛出了某种异常。 3、两者都是消极的异常处理方式，只是抛出或者可能抛出异常，是不会由函数处理，真正的处理异常由它的上层调用处理</p><h2 id="接口（Interface）"><a href="#接口（Interface）" class="headerlink" title="接口（Interface）"></a>接口（Interface）</h2><p>接口，比抽象类还要抽象的类。</p><ul><li>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract （只能是 public abstract，其他修饰符都会报错）。</li><li>接口中可以含有变量，但是接口中的变量会被隐式的指定为  public static final   变量（并且只能是 public，用 private 修饰会报编译错误。）</li><li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。 </li></ul><p>注：<br>接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。<br>接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字。<br>接口中的方法都是公有的。public</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>Reflection（反射）是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的內部信息，并能直接操作任意对象的内部属性及方法。</p><p>Java反射机制主要提供了以下功能：</p><ul><li>在运行时构造任意一个类的对象</li><li>在运行时获取任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的方法（属性）</li><li>生成动态代理</li></ul><ol><li><p>Class: 是一个类; 一个描述类的类.<br>　　封装了描述方法的 Method,描述字段的 Filed,描述构造器的 Constructor 等属性.</p><ol start="2"><li><p>如何得到 Class 对象:<br>　　2.1 Person.class<br>　　2.2 person.getClass()<br>　　2.3 Class.forName(“com.atguigu.javase.Person”)</p></li><li><p>关于 Method:<br>　　3.1 如何获取 Method:<br>　　　　1). getDeclaredMethods: 得到 Method 的数组.<br>　　　　2). getDeclaredMethod(String methondName, Class … parameterTypes)</p></li></ol><p>　　3.2 如何调用 Method<br>　　　　1). 如果方法时 private 修饰的, 需要先调用 Method 的　setAccessible(true), 使其变为可访问<br>　　　　2). method.invoke(obj, Object … args);</p><ol start="4"><li><p>关于 Field:<br>　　4.1 如何获取 Field: getField(String fieldName)<br>　　4.2 如何获取 Field 的值:<br>　　　　1). setAccessible(true)<br>　　　　2). field.get(Object obj)<br>　　4.3 如何设置 Field 的值:<br>　　　　field.set(Obejct obj, Object val)</p></li><li><p>了解 Constructor 和 Annotation </p></li><li><p>反射和泛型.<br>　　6.1 getGenericSuperClass: 获取带泛型参数的父类, 返回值为: BaseDao&lt;Employee, String&gt;<br>　　6.2 Type 的子接口: ParameterizedType<br>　　6.3 可以调用 ParameterizedType 的 Type[] getActualTypeArguments() 获取泛型参数的数组.<br><a href="https://www.cnblogs.com/tech-bird/p/3525336.html" target="_blank" rel="noopener">https://www.cnblogs.com/tech-bird/p/3525336.html</a></p></li></ol></li></ol><h2 id="AQS和CAS"><a href="#AQS和CAS" class="headerlink" title="AQS和CAS"></a>AQS和CAS</h2><p>抽象队列同步器AQS ( AbstractQueuedSychronizer ) , 如果说java.util.concurrent的基础是CAS的话,那么AQS就是整个Java并发包的核心了, ReentrantLock、CountDownLatch、Semaphore等都用到了它。AQS实际上以双向队列的形式连接所有的Entry ,比方说ReentrantLock ,所有等待的线程都被放在一个Entry中并连成双向队列,前面一个线程使用 ReentrantLock好了, 则双向队列实际上的第一个Entry开始运行。 AQS定 义了对双向队列所有的操作,而只开放了tryLock和tryRelease方法给开发者使用,开发者可以根据自己的实现重写tryLock和tryRelease方法,以实现自己的并发功能。</p><p>比较并替换CAS(Compare and Swap) ,假设有三个操作数:内存值V、旧的预期值A、要修改的值B ,当且仅当预期值A和内存值V相同时,才桧将内存值修改为B并返回true ,否则什么都不做并返回false ,整个比较并替换的操作是一个原子操作。CAS一定要volatile变量配合,这样才能保证每次拿到的变量是主内中最新的相应值,否则旧的预期值A对某条线程来说,永远是一个不会变的值A,只要某次CAS操作失败，下面永远都不可能成功。</p><p>CAS虽然比较高效的解决了原子操作问题,但仍存在三大问题。</p><ul><li>循环时间开销大</li><li>只能保证一个共享变量的原子操作</li><li>ABA问题</li></ul><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p> Condition是在java 1.5中才出现的，它用来替代传统的Object的wait()、notify()实现线程间的协作，相比使用Object的wait()、notify()，使用Condition1的await()、signal()这种方式实现线程间协作更加安全和高效。因此通常来说比较推荐使用Condition，在阻塞队列那一篇博文中就讲述到了，阻塞队列实际上是使用了Condition来模拟线程间协作。</p><ul><li>Condition是个接口，基本的方法就是await()和signal()方法；</li><li>Condition依赖于Lock接口，生成一个Condition的基本代码是lock.newCondition()</li><li>调用Condition的await()和signal()方法，都必须在lock保护之内，就是说必须在lock.lock()和lock.unlock之间才可以使用Conditon中的await()对应Object的wait()； Condition中的signal()对应Object的notify()； Condition中的signalAll()对应Object的notifyAll()</li></ul><h2 id="序列化Serializable"><a href="#序列化Serializable" class="headerlink" title="序列化Serializable"></a>序列化Serializable</h2><p>**什么是序列化和反序列化</p><p>java序列化是指把java对象转换为字节序列的过程，而java反序列化是指把字节序列恢复为java对象的过程<br>序列化：对象序列化的最主要的用处就是在传递和保存对象的时候，保证对象的完整性和可传递性。序列化是把对象转换成有序字节流，以便在网络上传输或者保存在本地文件中。序列化后的字节流保存的java对象的状态以及相关的描述信息。序列化机制的核心作用就是对象状态的保存与重建。</p><p>反序列化：客户端从文件中或网络上获得序列化后的对象字节流后，根据字节流中所保存的对象状态及描述信息，通过反序列化重建对象。</p><p>序列化就是把实体对象状态按照一定的格式写入到有序字节流，反序列化就是从有序字节流重建对象，恢复对象状态</p><p>**为什么需要序列化与反序列化</p><p>当两个进程进行远程通信时，可以相互发送各种类型的数据，包括文本，图片，音频，视频等，而这些数据都会以二进制的形式在网络上传送。</p><p>当两个java进行进行通信时，要传送对象，怎么传对象，通过序列化与反序列化。</p><p>也就是说，发送方需要把对象转换为字节序列，然后在网络上传送，另一方面，接收方需要从字节序列中恢复出java对象</p><p>**在java中怎么实现序列化</p><p>1.在需要序列化的对象的类实现Serializable接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySerClass</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure></p><p>2.利用ObjectOutStream实现实体序列化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">FlyPig flyPig = <span class="keyword">new</span> FlyPig();</span><br><span class="line">flyPig.setColor(<span class="string">"black"</span>);</span><br><span class="line">flyPig.setName(<span class="string">"naruto"</span>);</span><br><span class="line">flyPig.setCar(<span class="string">"0000"</span>);</span><br><span class="line"><span class="comment">// ObjectOutputStream 对象输出流，将 flyPig 对象存储到E盘的 flyPig.txt 文件中，完成对 flyPig 对象的序列化操作</span></span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"d:/flyPig.txt"</span>)));</span><br><span class="line">oos.writeObject(flyPig);</span><br></pre></td></tr></table></figure></p><p>**序列化时的一些细节</p><p>1、利用transient关键字修饰的属性，不会被序列化<br>2、对于static变量，其值只和当前类中的定义有关，而和是否序列化无关<br>3、具体使用时，应对serialVersionUID 进行赋值</p><h2 id="Spring-mvc执行流程"><a href="#Spring-mvc执行流程" class="headerlink" title="Spring mvc执行流程"></a>Spring mvc执行流程</h2><p><img src="/upload/pasted-323.png" alt="upload successful"><br><a href="https://www.cnblogs.com/jay36/p/7527039.html" target="_blank" rel="noopener">https://www.cnblogs.com/jay36/p/7527039.html</a></p><h2 id="AOP-IOC"><a href="#AOP-IOC" class="headerlink" title="AOP IOC"></a>AOP IOC</h2><p>AOP和IOC是Spring精华部分, AOP可以看做是对OOP的补充,对代码进行横向的扩展,通过代理模式实现,代理模式有静态代理,动态代理, Spring利用的是动态代理,在程序运行过程中将增强代码织入原代码中。IOC是 控制反转,将对象的控制权交给Spring框架,用户需要使用对象无需创建,直接使用即呵。AOP和IOC最可贵的是它们的思想。</p><h2 id="Hibernate-POJO"><a href="#Hibernate-POJO" class="headerlink" title="Hibernate POJO"></a>Hibernate POJO</h2><p>Hibernate Pojo的三态分别为transient（瞬时态）,persistent（持久态）,detached（游离态）</p><p>1、官方给出的三态与Session的关系如下：</p><p>transient: never persistent, not associated with any Session<br>persistent: associated with a unique Session<br>detached: previously persistent, not associated with any Session</p><p>2、三种状态间相互转换关系，及他们在数据库、session中的状态如下：<br>a.当我们new一个pojo时，它处于瞬时态，此时与session、数据库均无任何关联。<br>b.此后，我们获得session并开启hibernate事务，调用save(),persist(),saveOrUpdate()方法，将pojo转变为持久态，此时session中存有这个pojo，但直到transaction.commit()被调用时，sql语句才会执行，此后数据库中也才有此条数据。<br>c.但当commit()并且session.close()执行过后，pojo就变为了游离态，也就是说，数据库中有该记录，但session中不再有。<br>d.持久化状态的实例，也可以重新变成瞬时态，那就是调用delete()方法。<br>e.通过get()或load()方法得到的pojo是持久态的。<br>f.游离态的pojo可以通过update(),saveOrUpdate(),lock()和replicate()方法重新成为持久态。<br>g.调用merge()方法后，pojo维持原态，但内容会被更新到数据库</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>Java通过Executors提供四个静态方法创建四种线程池，分别为：</p><p>newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p><p>newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p><p>newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</p><p>newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</p><p>作用：<br>限定线程的个数，不会导致由于线程过多导致系统运行缓慢或崩溃</p><p>线程池不需要每次都去创建或销毁，节约了资源、</p><p>线程池不需要每次都去创建，响应时间更快。</p><h2 id="javaWeb"><a href="#javaWeb" class="headerlink" title="javaWeb"></a>javaWeb</h2><h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p><img src="/upload/pasted-324.png" alt="upload successful"><br>servlet是运行在服务器端的小应用程序，是接收网络服务的请求和产生响应的一种方式。<br>servlet的功能：接受http请求，产生动态http响应。<br>HttpServlet是GenericServlet的子类。<br>GenericServlet是个抽象类，必须给出子类才能实例化。它给 出了设计servlet的一些骨架，定义了servlet生命周期，还有一些得到名字、配置、初始化参数的方法，其设计的是和应用层协议无关的，也就是说 你有可能用非http协议实现它。<br>HttpServlet是子类，当然就具有GenericServlet的一切特性，还添加了doGet, doPost, doDelete, doPut, doTrace等方法对应处理http协议里的命令的请求响应过程。</p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>servlet有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。这个生存期由javax.servlet.Servlet接口的init,service和destroy方法表达。<br>加载Servlet的class—-&gt;实例化Servlet—–&gt;调用Servlet的init完成初始化—-&gt;响应请求（Servlet的service方法）—–&gt;Servlet容器关闭时(Servlet的destory方法)<br>Servlet启动时，开始加载servlet生命周期开始。Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候(服务器关闭)调用其destroy方法。</p><h4 id="forward-与redirect-的区别"><a href="#forward-与redirect-的区别" class="headerlink" title="forward() 与redirect()的区别"></a>forward() 与redirect()的区别</h4><p>forward是服务器端的转向而redirect是客户端的跳转。</p><p>使用forward浏览器的地址不会发生改变。而redirect会发生改变。</p><p>Forward是一次请求中完成。而redirect是重新发起请求。</p><p>Forward是在服务器端完成，而不用客户端重新发起请求，效率较高<br>一般没有特殊需要，自己写的Servlet都扩展HttpServlet 。</p><h4 id="JSP和Servlet有哪些相同点和不同点"><a href="#JSP和Servlet有哪些相同点和不同点" class="headerlink" title="JSP和Servlet有哪些相同点和不同点"></a>JSP和Servlet有哪些相同点和不同点</h4><p>JSP是Servlet技术的扩展，所有的jsp文件都会被翻译为一个继承HttpServlet的类。也就是jsp最终也是一个Servlet.这个Servlet对外提供服务。</p><p><img src="/upload/pasted-347.png" alt="upload successful"><br>Servlet和JSP最主要的不同点在于JSP侧重于视图，Servlet主要用于控制逻辑。<br>Servlet如果要实现html的功能，必须使用Writer输出对应的html,比较麻烦。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件,做界面展示比较方便而嵌入逻辑比较复杂</p><h4 id="jsp内置对象"><a href="#jsp内置对象" class="headerlink" title="jsp内置对象"></a>jsp内置对象</h4><p>request 用户端请求，此请求会包含来自GET/POST请求的参数</p><p>response 网页传回用户端的回应</p><p>pageContext 网页的属性是在这里管理</p><p>session 与请求有关的会话期</p><p>application servlet正在执行的内容</p><p>out 用来传送回应的输出</p><p>config servlet的构架部件</p><p>page JSP网页本身</p><p>exception 针对错误网页，未捕捉的例外</p><p>四大作用域：pageContext request session application 可以通过jstl从四大作用域中取值.</p><p>Jsp传递值request session application cookie也能传值</p><h3 id="http-get和post请求的区别"><a href="#http-get和post请求的区别" class="headerlink" title="http get和post请求的区别"></a>http get和post请求的区别</h3><p>GET和POST请求都是http的请求方式，用户通过不同的http的请求方式完成对资源（url）的不同操作。GET，POST，PUT，DELETE就对应着对这个资源的查 ，改 ，增 ，删 4个操作,具体点来讲GET一般用于获取/查询资源信息，而POST一般用于更新资源信息<br>1、Get请求提交的数据会在地址栏显示出来，而post请求不会再地址栏显示出来.</p><p>GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&amp;连接；POST提交：把提交的数据放置在是HTTP包的包体中。因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变</p><p>2、传输数据的大小</p><p>http Get请求由于浏览器对地址长度的限制而导致传输的数据有限制。而POST请求不会因为地址长度限制而导致传输数据限制。</p><p>3、安全性,POST的安全性要比GET的安全性高。由于数据是会在地址中呈现，所以可以通过历史记录找到密码等关键信息。</p><h3 id="Session-和-Cookie"><a href="#Session-和-Cookie" class="headerlink" title="Session 和 Cookie"></a>Session 和 Cookie</h3><p>Session和cookie都是会话(Seesion)跟踪技术。Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。但是Session的实现依赖于Cookie,sessionId(session的唯一标识需要存放在客户端).</p><p>cookie 和session 的区别：</p><p>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</p><p>2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗</p><p>   考虑到安全应当使用session。</p><p>3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用COOKIE。</p><p>4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p><p>5、所以个人建议：</p><p>   将登陆信息等重要信息存放为SESSION</p><p>   其他信息如果需要保留，可以放在COOKIE中，比如购物车</p><p>购物车最好使用cookie，但是cookie是可以在客户端禁用的，这时候我们要使用cookie+数据库的方式实现，当从cookie中不能取出数据时，就从数据库获取。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;# &lt;/p&gt;
&lt;h2 id=&quot;ArrayList和Linkedlist区别&quot;&gt;&lt;a href=&quot;#ArrayList和Linkedlist区别&quot; class=&quot;headerlink&quot; title=&quot;ArrayList和Linkedlist区别&quot;&gt;&lt;/a&gt;ArrayList和
      
    
    </summary>
    
    
  </entry>
  
</feed>
