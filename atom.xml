<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>淋中之虹</title>
  
  <subtitle>向来不知道该说些什么</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.junglezero.top/"/>
  <updated>2019-06-18T11:18:36.868Z</updated>
  <id>https://www.junglezero.top/</id>
  
  <author>
    <name>JungleZero</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>栈和队列专题</title>
    <link href="https://www.junglezero.top/2019/06/18/%E5%92%8C%E9%98%9F%E5%88%97%E4%B8%93%E9%A2%98/"/>
    <id>https://www.junglezero.top/2019/06/18/和队列专题/</id>
    <published>2019-06-18T07:33:22.000Z</published>
    <updated>2019-06-18T11:18:36.868Z</updated>
    
    <content type="html"><![CDATA[<h1 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h1><p>栈和队列一个先进后出，一个先进先出，因此应当想办法“逆转”一下，这就是第二个栈的作用<br><img src="/upload/pasted-318.png" alt="upload successful"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">TwoStackToQueue</span></span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; s1=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; s2=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Qoffer</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        s1.push(num);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">pull</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!s2.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> s2.pop();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s1.isEmpty())&#123;</span><br><span class="line">                s2.push(s1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!s2.isEmpty())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"queue is empty"</span>);</span><br><span class="line">            <span class="keyword">return</span> s2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="用两个队列模拟栈"><a href="#用两个队列模拟栈" class="headerlink" title="用两个队列模拟栈"></a>用两个队列模拟栈</h1><p>对于入栈操作，直接加入队列即可。而对于出栈操作，应当知道对于模拟的情况，是删除队尾元素，而队列又是先入先出的，因此，应当先将队列前的元素移到另外一个栈，然后再“弹栈”</p><p><img src="/upload/pasted-319.png" alt="upload successful"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> Integer <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!q1.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (q1.size() != <span class="number">1</span>) &#123;</span><br><span class="line">                q2.offer(q1.poll());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (Integer) q1.poll();</span><br><span class="line">        &#125;<span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">if</span> (!q2.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">while</span> (q2.size()!=<span class="number">1</span>)&#123;</span><br><span class="line">                    q1.offer(q2.poll());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> (Integer) q2.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"栈为空"</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;用两个栈实现队列&quot;&gt;&lt;a href=&quot;#用两个栈实现队列&quot; class=&quot;headerlink&quot; title=&quot;用两个栈实现队列&quot;&gt;&lt;/a&gt;用两个栈实现队列&lt;/h1&gt;&lt;p&gt;栈和队列一个先进后出，一个先进先出，因此应当想办法“逆转”一下，这就是第二个栈的作用&lt;br&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>树（二叉树）专题</title>
    <link href="https://www.junglezero.top/2019/06/17/%E9%A2%98/"/>
    <id>https://www.junglezero.top/2019/06/17/题/</id>
    <published>2019-06-17T09:25:41.000Z</published>
    <updated>2019-06-18T05:58:22.817Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本结构（实现）"><a href="#基本结构（实现）" class="headerlink" title="基本结构（实现）"></a>基本结构（实现）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h1><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p>是一种先访问根结点，再访问左子节点，再访问右子结点的访问方式，用递归方式很容易实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preorderTraverse</span><span class="params">(TreeNode t)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(t!=<span class="keyword">null</span>)&#123;</span><br><span class="line">         System.out.println(t.val+<span class="string">""</span>);</span><br><span class="line">         preorderTraverse(t.left);</span><br><span class="line">         preorderTraverse(t.right);</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环的方法实现：<br>对于当前结点，首先访问，然后访问其左子结点，若其左子结点为空（即“访问到头了”）就要访问其右子结点，这个时候，就需要栈来记录其没有访问右子结点的父结点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderTraverse2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    TreeNode pNode = root;</span><br><span class="line">    <span class="comment">//栈不为空表示还有没有访问右结点的父结点存在</span></span><br><span class="line">    <span class="keyword">while</span> (pNode != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//若结点不为空，直接访问，下一步循环其左结点，并将该结点入栈，以便访问其右结点</span></span><br><span class="line">        <span class="keyword">if</span> (pNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(pNode.val+<span class="string">"  "</span>);</span><br><span class="line">            stack.push(pNode);</span><br><span class="line">            pNode = pNode.left;</span><br><span class="line">            <span class="comment">//左节点为空，即“到头”了，此时要从栈中找出没有访问右结点的父结点，出栈，访问其右结点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//pNode == null &amp;&amp; !stack.isEmpty()</span></span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            pNode = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>先访问左子结点，再访问父结点，再访问右子结点<br>递归方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderTraverse1</span><span class="params">(TreeNode node)</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;  </span><br><span class="line">           inOrderTraverse1(root.left);  </span><br><span class="line">           System.out.print(root.val+<span class="string">"  "</span>);  </span><br><span class="line">           inOrderTraverse1(root.right);  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>非递归方式：和之前差不多，只不过这次是在某个结点出栈的时候进行访问<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderTraverse2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    TreeNode pNode = root;</span><br><span class="line">    <span class="keyword">while</span> (pNode != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(pNode);</span><br><span class="line">            pNode = pNode.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//pNode == null &amp;&amp; !stack.isEmpty()</span></span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            System.out.print(node.val + <span class="string">"  "</span>);</span><br><span class="line">            pNode = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p>先访问左结点，再放问右结点，最后访问根结点<br>递归方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrderTraverse1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        postOrderTraverse1(root.left);</span><br><span class="line">        postOrderTraverse1(root.right);</span><br><span class="line">        System.out.print(root.val+<span class="string">"  "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>非递归方法：<br>初始根结点入栈，对于栈顶结点，如果其有左子结点或者右子结点且没有被访问，则按照右子结点，左子结点的顺序入栈，如果是叶子节点名，则出栈，直接访问，并用标记<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="常见题目"><a href="#常见题目" class="headerlink" title="常见题目"></a>常见题目</h1><h2 id="根据前序和中序遍历构造二叉树（假设不包含重复数字）"><a href="#根据前序和中序遍历构造二叉树（假设不包含重复数字）" class="headerlink" title="根据前序和中序遍历构造二叉树（假设不包含重复数字）"></a>根据前序和中序遍历构造二叉树（假设不包含重复数字）</h2><p>重点：</p><p><img src="/upload/pasted-317.png" alt="upload successful"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本结构（实现）&quot;&gt;&lt;a href=&quot;#基本结构（实现）&quot; class=&quot;headerlink&quot; title=&quot;基本结构（实现）&quot;&gt;&lt;/a&gt;基本结构（实现）&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《算法分析》课程整理</title>
    <link href="https://www.junglezero.top/2019/06/06/%E6%B3%95%E5%88%86%E6%9E%90%E3%80%8B%E8%AF%BE%E7%A8%8B%E6%95%B4%E7%90%86-1/"/>
    <id>https://www.junglezero.top/2019/06/06/法分析》课程整理-1/</id>
    <published>2019-06-06T01:53:55.000Z</published>
    <updated>2019-06-11T05:26:19.302Z</updated>
    
    <content type="html"><![CDATA[<h1 id="递归和分治"><a href="#递归和分治" class="headerlink" title="递归和分治"></a>递归和分治</h1><h2 id="整数划分问题"><a href="#整数划分问题" class="headerlink" title="整数划分问题"></a>整数划分问题</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>任何一个大于1的自然数，总可以拆分为若干个小于n的自然数之和，试求n的所有拆分，将最大拆分数不超过m的划分个数记做去q(n,m)</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>根据n和m的情况，可以分为以下几种情况：<br>根据n和m的关系，考虑以下几种情况： </p><ol><li>当n=1时，不论m的值为多少（m&gt;0)，只有一种划分即{1}; </li><li>当m=1时，不论n的值为多少，只有一种划分即n个1，{1,1,1,…,1}; </li><li>当n=m时，根据划分中是否包含n，可以分为两种情况：<br> (1) 划分中包含n的情况，只有一个即{n}；<br> (2) 划分中不包含n的情况，这时划分中最大的数字也一定比n小，即n的所有(n-1)划分。因此 f(n,n) =1 + f(n,n-1); </li><li>当n&lt;m时，由于划分中不可能出现负数，因此就相当于f(n,n); </li><li>但n&gt;m时，根据划分中是否包含最大值m，可以分为两种情况：<br> (1) 划分中包含m的情况，即{m, {x1,x2,…xi}}, 其中{x1,x2,… xi} 的和为n-m，可能再次出现m，因此是（n-m）的m划分，因此这种划分个数为f(n-m, m);<br> (2) 划分中不包含m的情况，则划分中所有值都比m小，即n的(m-1)划分，个数为f(n,m-1);因此 f(n, m) = f(n-m, m)+f(n,m-1);</li></ol><p>通过以上规律，得到递推公式：</p><ul><li>f(n, m)= 1; (n=1 or m=1)</li><li>f(n, m)=f(n, n); (n&lt;m)</li><li>1+ f(n, m-1); (n=m)</li><li>f(n-m,m)+f(n,m-1); (n&gt;m)</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/函数：q(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span><br><span class="line"><span class="comment">//作用：用来得到正整数n，最大加数不大于m的划分个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">q</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="comment">//若正整数或最大加数小于1，则返回0</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">1</span>||m&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//若正整数或最大加数等于1，则划分个数为1（n个1相加）</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>||m==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//若最大加数实际上不能大于正整数n，若大于则划分个数等于最大加数为n的划分个数</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;m) <span class="keyword">return</span> q(n,n);</span><br><span class="line">    <span class="comment">//若正整数等于最大加数，则划分个数等于</span></span><br><span class="line">    <span class="keyword">if</span> (n==m) <span class="keyword">return</span> <span class="number">1</span>+q(n,n-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> q(n,m-<span class="number">1</span>)+q(n-m,m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Strassen矩阵乘法"><a href="#Strassen矩阵乘法" class="headerlink" title="Strassen矩阵乘法"></a>Strassen矩阵乘法</h2><h3 id="一般的矩阵乘法思路"><a href="#一般的矩阵乘法思路" class="headerlink" title="一般的矩阵乘法思路"></a>一般的矩阵乘法思路</h3><p><img src="/upload/pasted-297.png" alt="upload successful"><br>复杂度为O(n3)</p><h3 id="一种改进方法"><a href="#一种改进方法" class="headerlink" title="一种改进方法"></a>一种改进方法</h3><p><img src="/upload/pasted-298.png" alt="upload successful"></p><h3 id="Strassen方法"><a href="#Strassen方法" class="headerlink" title="Strassen方法"></a>Strassen方法</h3><p><img src="/upload/pasted-299.png" alt="upload successful"></p><p><img src="/upload/pasted-300.png" alt="upload successful"><br>这个方法的特点就是减少了一次乘法，虽然多了14次加法，但是加法计算基本没有成本<br>时间复杂度：</p><p><img src="/upload/pasted-301.png" alt="upload successful"></p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h2><ul><li>动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题。</li><li>但是经分解得到的子问题往往不是互相独立的。不同子问题的数目常常只有多项式量级。在用分治法求解时，有些子问题被重复计算了许多次。</li><li>如果能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，就可以避免大量重复计算，从而得到多项式时间算法。</li></ul><h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><ul><li>找出最优解的性质，并刻划其结构特征。</li><li>递归地定义最优值。</li><li>以自底向上的方式计算出最优值。</li><li>根据计算最优值时得到的信息，构造最优解</li></ul><h2 id="矩阵连乘问题"><a href="#矩阵连乘问题" class="headerlink" title="矩阵连乘问题"></a>矩阵连乘问题</h2><h3 id="基本内容-1"><a href="#基本内容-1" class="headerlink" title="基本内容"></a>基本内容</h3><p>对于一般的矩阵乘法来说，如矩阵A(m,n)与矩阵B(n,p)相乘需要进行的加法次数为m<em>n</em>p次乘法。</p><p>由于矩阵乘法满足结合律，因此矩阵相乘的结合性，会影响整个计算表达式的乘法执行次数。</p><p>如下面的例子，其中A(10,5)、B(5,20)、C(20,3)：</p><p>　　　　(1) ((AB)C) 执行乘法次数为1300次</p><p>　　　　(2) (A(BC)) 执行乘法次数为450次</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>预处理：<br>将矩阵连乘积AiAi+1…Aj简记为A[i:j]，这里i≤j。<br>考察计算A[i:j]的最优计算次序。设这个计算次序在矩阵Ak和Ak+1之间将矩阵链断开，i≤k&lt;j，则其相应完全加括号方式为（AiAi+1… Ak）（Ak+1 Ak+2… Aj ）。<br>计算量：A[i:k]的计算量加上A[k+1:j]的计算量，再加上A[i:k]和A[k+1:j]相乘的计算量。<br>分析最优解的结构<br>特征：计算A[i:j]的最优次序所包含的计算矩阵子链 A[i:k]和A[k+1:j]的次序也是最优的。<br>矩阵连乘计算次序问题的最优解包含着其子问题的最优解。这种性质称为最优子结构性质。问题的最优子结构性质是该问题可用动态规划算法求解的显著特征。<br>设计算A[i:j]，1≤i≤j≤n，所需要的最少数乘次数m[i,j]，则原问题的最优值为m[1,n]。<br>当i=j时，A[i:j]=Ai，因此，m[i,i]=0，i=1,2,…,n。<br>当i&lt;j时，m[i,j]=m[i,k]+m[k+1,j]+pi-1pkpj，这里Ai的维数为pi-1×pi。<br>可以递归地定义m[i,j]为：<br> <img src="/upload/pasted-306.png" alt="upload successful"><br>k的位置只有j-i种可能。</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MatrixChain</span><span class="params">(<span class="keyword">int</span> [] p，<span class="keyword">int</span> n，<span class="keyword">int</span> [] []m，<span class="keyword">int</span> [][]s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//当m[i][j]中i==j时，m[i][j]==0</span></span><br><span class="line">　<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) m[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//从m[1][2],m[2][3],m[3][4]开始计算</span></span><br><span class="line">　<span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">2</span>; r &lt;= n; r++)</span><br><span class="line">　　<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - r+<span class="number">1</span>; i++) &#123;</span><br><span class="line">　　　<span class="keyword">int</span> j=i+r-<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//先将m[i][j]初始化，即当k=i的时候</span></span><br><span class="line">　　　m[i][j] = m[i+<span class="number">1</span>][j]+ p[i-<span class="number">1</span>]*p[i]*p[j];</span><br><span class="line">            <span class="comment">//初始化s[i][j]</span></span><br><span class="line">　　　s[i][j] = i;</span><br><span class="line">            <span class="comment">//依次遍历k的每一个取值，按照递推公式，取最小值作为m[i][j],此时的k作为s[i][j]的值</span></span><br><span class="line">　　　<span class="keyword">for</span> (<span class="keyword">int</span> k = i+<span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">　　　　<span class="keyword">int</span> t = m[i][k] + m[k+<span class="number">1</span>][j] + p[i-<span class="number">1</span>]*p[k]*p[j];</span><br><span class="line">    <span class="comment">//遍历过程中，若发现 当前k的选择拥有最小的m，则记录m和k的值，此时的k即为拆分的位置</span></span><br><span class="line">　　　　<span class="keyword">if</span> (t &lt; m[i][j]) &#123; m[i][j] = t; s[i][j] = k;&#125;</span><br><span class="line">　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><h3 id="基本内容-2"><a href="#基本内容-2" class="headerlink" title="基本内容"></a>基本内容</h3><p>给定两个字符串，求解这两个字符串的最长公共子序列（Longest Common Sequence）。比如字符串1：BDCABA；字符串2：ABCBDAB</p><p>则这两个字符串的最长公共子序列长度为4，最长公共子序列是：BCBA</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>①最优子结构</p><p>设 X=(x1,x2,…..xn) 和 Y={y1,y2,…..ym} 是两个序列，将 X 和 Y 的最长公共子序列记为LCS(X,Y)</p><p>找出LCS(X,Y)就是一个最优化问题。因为，我们需要找到X 和 Y中最长的那个公共子序列。而要找X 和 Y的LCS，首先考虑X的最后一个元素和Y的最后一个元素。</p><p>1）如果 xn=ym，即X的最后一个元素与Y的最后一个元素相同，这说明该元素一定位于公共子序列中。因此，现在只需要找：LCS(Xn-1，Ym-1)<br>LCS(Xn-1，Ym-1)就是原问题的一个子问题。</p><p>2）如果xn != ym，产生了两个子问题：LCS(Xn-1，Ym) 和 LCS(Xn，Ym-1)</p><p>因为序列X 和 序列Y 的最后一个元素不相等嘛，那说明最后一个元素不可能是最长公共子序列中的元素嘛。</p><p>LCS(Xn-1，Ym)表示：最长公共序列可以在(x1,x2,….x(n-1)) 和 (y1,y2,…yn)中找。<br>LCS(Xn，Ym-1)表示：最长公共序列可以在(x1,x2,….xn) 和 (y1,y2,…y(n-1))中找。<br>求解上面两个子问题，得到的公共子序列谁最长，那谁就是 LCS（X,Y）。用数学表示就是：<br>LCS=max{LCS(Xn-1，Ym)，LCS(Xn，Ym-1)}</p><p>由于条件 1)  和  2)  考虑到了所有可能的情况。因此，我们成功地把原问题 转化 成了 三个规模更小的子问题。</p><p>②重叠子问题<br>重叠子问题是啥？就是说原问题 转化 成子问题后，  子问题中有相同的问题。咦？我怎么没有发现上面的三个子问题中有相同的啊？？？？</p><p>OK，来看看，原问题是：LCS(X,Y)。子问题有 ❶LCS(Xn-1，Ym-1)    ❷LCS(Xn-1，Ym)    ❸LCS(Xn，Ym-1)</p><p>初一看，这三个子问题是不重叠的。可本质上它们是重叠的，因为它们只重叠了一大部分。举例：</p><p>第二个子问题：LCS(Xn-1，Ym) 就包含了：问题❶LCS(Xn-1，Ym-1)，为什么？</p><p>因为，当Xn-1 和 Ym 的最后一个元素不相同时，我们又需要将LCS(Xn-1，Ym)进行分解：分解成：LCS(Xn-1，Ym-1) 和 LCS(Xn-2，Ym)</p><p>也就是说：在子问题的继续分解中，有些问题是重叠的。<br>递推公式：</p><p><img src="/upload/pasted-296.png" alt="upload successful"></p><p>c[i,j]表示：(x1,x2….xi) 和 (y1,y2…yj) 的最长公共子序列的长度</p><p>③得到最长公共子序列的具体内容</p><p><img src="/upload/pasted-303.png" alt="upload successful"><br>由问题的分析可知，我们找最长公共子序列，是比较两个字符串的最后一位，若最后一位相等，则这个字符肯定是最长公共子序列的内容，因此此时，按照递推公式的描述，“斜向上”移动，当两个字符不相等时，此时根据前面的分析，可以是第一个字符串前移，也可以是第二个字符串前移，两种方式都可以，规定一种就好</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findLCS</span><span class="params">(String A, <span class="keyword">int</span> n, String B, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            dp[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A.charAt(i - <span class="number">1</span>) == B.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] &gt; dp[i][j - <span class="number">1</span>] ? dp[i - <span class="number">1</span>][j] : dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h2><h3 id="基本内容-3"><a href="#基本内容-3" class="headerlink" title="基本内容"></a>基本内容</h3><p>求一个序列的最大子段和即最大连续子序列之和。例如序列[4, -3, 5, -2, -1, 2, 6, -2]的最大子段和为11=[4+(-3)+5+(-2)+(-1)+(2)+(6)]。</p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>设前边界为1，后边界为i，且C(i)是子序列A[1,..i]必须包含元素A[i]的向前连续延伸的最大子段和：</p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><br>  <mi>C</mi><br>  <mo stretchy="false">[</mo><br>  <mi>i</mi><br>  <mo stretchy="false">]</mo><br>  <mo>=</mo><br>  <munder><br>    <mo form="prefix">max</mo><br>    <mrow class="MJX-TeXAtom-ORD"><br>      <mn>1</mn><br>      <mo>&#x2264;<!-- ≤ --></mo><br>      <mi>k</mi><br>      <mo>&#x2264;<!-- ≤ --></mo><br>      <mi>i</mi><br>    </mrow><br>  </munder><br>  <mo fence="false" stretchy="false">{</mo><br>  <munderover><br>    <mo>&#x2211;<!-- ∑ --></mo><br>    <mrow class="MJX-TeXAtom-ORD"><br>      <mi>j</mi><br>      <mo>=</mo><br>      <mi>k</mi><br>    </mrow><br>    <mi>i</mi><br>  </munderover><br>  <mi>A</mi><br>  <mo stretchy="false">[</mo><br>  <mi>j</mi><br>  <mo stretchy="false">]</mo><br>  <mo fence="false" stretchy="false">}</mo><br></math><br>而C[i]的递推公式为：</p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><br>  <mtable columnalign="right left right left right left right left right left right left" rowspacing="3pt" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" displaystyle="true"><br>    <mtr><br>      <mtd></mtd><br>      <mtd><br>        <mi>C</mi><br>        <mo stretchy="false">[</mo><br>        <mi>i</mi><br>        <mo stretchy="false">]</mo><br>        <mo>=</mo><br>        <mo movablelimits="true" form="prefix">max</mo><br>        <mo fence="false" stretchy="false">{</mo><br>        <mi>C</mi><br>        <mo stretchy="false">[</mo><br>        <mi>i</mi><br>        <mo>&#x2212;<!-- − --></mo><br>        <mn>1</mn><br>        <mo stretchy="false">]</mo><br>        <mo>+</mo><br>        <mi>A</mi><br>        <mo stretchy="false">[</mo><br>        <mi>i</mi><br>        <mo stretchy="false">]</mo><br>        <mo>,</mo><br>        <mtext>&#xA0;</mtext><br>        <mi>A</mi><br>        <mo stretchy="false">[</mo><br>        <mi>i</mi><br>        <mo stretchy="false">]</mo><br>        <mo fence="false" stretchy="false">}</mo><br>        <mspace width="2em"></mspace><br>        <mi>i</mi><br>        <mo>=</mo><br>        <mn>2</mn><br>        <mo>,</mo><br>        <mo>.</mo><br>        <mo>.</mo><br>        <mo>.</mo><br>        <mo>,</mo><br>        <mi>n</mi><br>      </mtd><br>    </mtr><br>    <mtr><br>      <mtd></mtd><br>      <mtd><br>        <mi>C</mi><br>        <mo stretchy="false">[</mo><br>        <mn>1</mn><br>        <mo stretchy="false">]</mo><br>        <mo>=</mo><br>        <mrow><br>          <mo>{</mo><br>          <mtable columnalign="right left right left right left right left right left right left" rowspacing="3pt" columnspacing="0em 2em 0em 2em 0em 2em 0em 2em 0em 2em 0em" displaystyle="true"><br>            <mtr><br>              <mtd><br>                <mi>A</mi><br>                <mo stretchy="false">[</mo><br>                <mn>1</mn><br>                <mo stretchy="false">]</mo><br>                <mtext>&#xA0;</mtext><br>                <mtext>&#xA0;</mtext><br>                <mi>i</mi><br>                <mi>f</mi><br>                <mi>A</mi><br>                <mo stretchy="false">[</mo><br>                <mn>1</mn><br>                <mo stretchy="false">]</mo><br>                <mo>&gt;</mo><br>                <mn>0</mn><br>              </mtd><br>            </mtr><br>            <mtr><br>              <mtd><br>                <mn>0</mn><br>                <mtext>&#xA0;</mtext><br>                <mtext>&#xA0;</mtext><br>                <mtext>&#xA0;</mtext><br>                <mtext>&#xA0;</mtext><br>                <mtext>&#xA0;</mtext><br>                <mi>i</mi><br>                <mi>f</mi><br>                <mi>A</mi><br>                <mo stretchy="false">[</mo><br>                <mn>1</mn><br>                <mo stretchy="false">]</mo><br>                <mo>&lt;</mo><br>                <mn>0</mn><br>              </mtd><br>            </mtr><br>          </mtable><br>          <mo fence="true" stretchy="true" symmetric="true"></mo><br>        </mrow><br>        <mtext>&#xA0;</mtext><br>      </mtd><br>    </mtr><br>  </mtable><br></math><br>遍历所有以i (1≤i≤n)为后边界的最大子段和Ci得出最优解：</p><p><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><br>  <mi>O</mi><br>  <mi>P</mi><br>  <mi>T</mi><br>  <mo stretchy="false">(</mo><br>  <mi>A</mi><br>  <mo stretchy="false">)</mo><br>  <mo>=</mo><br>  <munder><br>    <mo form="prefix">max</mo><br>    <mrow class="MJX-TeXAtom-ORD"><br>      <mn>1</mn><br>      <mo>&#x2264;<!-- ≤ --></mo><br>      <mi>i</mi><br>      <mo>&#x2264;<!-- ≤ --></mo><br>      <mi>n</mi><br>    </mrow><br>  </munder><br>  <mo fence="false" stretchy="false">{</mo><br>  <msub><br>    <mi>C</mi><br>    <mi>i</mi><br>  </msub><br>  <mo fence="false" stretchy="false">}</mo><br></math></p><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSumDyn</span><span class="params">( <span class="keyword">int</span> array[],<span class="keyword">int</span> len )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( b &gt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            b += array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            b = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( b &gt; sum )</span><br><span class="line">        &#123;</span><br><span class="line">            sum = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多边形游戏"><a href="#多边形游戏" class="headerlink" title="多边形游戏"></a>多边形游戏</h2><h3 id="基本内容-4"><a href="#基本内容-4" class="headerlink" title="基本内容"></a>基本内容</h3><h2 id="图像压缩"><a href="#图像压缩" class="headerlink" title="图像压缩"></a>图像压缩</h2><p>在计算机中，常用像素点的灰度值序列{p1,p1,……pn}表示图像。其中整数pi,1&lt;=i&lt;=n，表示像素点i的灰度值。通常灰度值的范围是0~255。因此最多需要8位表示一个像素。</p><p>压缩的原理就是把序列{p1,p1,……pn}进行设断点，将其分割成一段一段的。分段的过程就是要找出断点，让一段里面的像素的最大灰度值比较小，那么这一段像素(本来需要8位)就可以用较少的位(比如7位)来表示，从而减少存储空间。</p><p>b代表bits,l代表length,分段是，b[i]表示每段一个像素点需要的最少存储空间(少于8位才有意义)，l[i]表示每段里面有多少个像素点，s[i]表示从0到i压缩为一共占多少存储空间。</p><p> 如果限制l[i]&lt;=255,则需要8位来表示l[i]。而b[i]&lt;=8，需要3位表示b[i]。所以每段所需的存储空间为l[i]*b[i]+11位。假设将原图像分成m段，那么需要</p><p><img src="/upload/pasted-304.png" alt="upload successful"><br>图像压缩问题的本质就是要确定像素序列{p1,p1,……pn}的最优分段，使得依此分段所需的存储空间最小</p><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>最优子结构<br>设l[i],b[i],1&lt;=i&lt;=m是{p1,p1,……pn}的一个最优分段，则l[1],b[1]是{p1,……,pl[1]}的一个最优分段，且l[i],b[i],2&lt;=i&lt;=m是{pl[1]+1,……,pn}的一个最优分段。即图像压缩问题满足最优子结构性质。<br>动态规划方程<br> 设s[i],1&lt;=i&lt;=n是像素序列{p1,p1,……pi}的最优分段所需的存储位数，则s[i]为前i-k个的存储位数加上后k个的存储空间。由最优子结构性质可得：</p><p><img src="/upload/pasted-307.png" alt="upload successful"></p><p><img src="/upload/pasted-308.png" alt="upload successful"></p><h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Compress</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> p[],<span class="keyword">int</span> s[],<span class="keyword">int</span> l[],<span class="keyword">int</span> b[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> Lmax = <span class="number">256</span>,header = <span class="number">11</span>;  </span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        b[i] = length(p[i]);<span class="comment">//计算像素点p需要的存储位数  </span></span><br><span class="line">        <span class="keyword">int</span> bmax = b[i];  </span><br><span class="line">        s[i] = s[i<span class="number">-1</span>] + bmax;  </span><br><span class="line">        l[i] = <span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>; j&lt;=i &amp;&amp; j&lt;=Lmax;j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span>(bmax&lt;b[i-j+<span class="number">1</span>])  </span><br><span class="line">            &#123;  </span><br><span class="line">                bmax = b[i-j+<span class="number">1</span>];  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span>(s[i]&gt;s[i-j]+j*bmax)  </span><br><span class="line">            &#123;  </span><br><span class="line">                s[i] = s[i-j] + j*bmax;  </span><br><span class="line">                l[i] = j;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        s[i] += header;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">(<span class="keyword">int</span> i)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">1</span>;  </span><br><span class="line">    i = i/<span class="number">2</span>;  </span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        k++;  </span><br><span class="line">        i=i/<span class="number">2</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> k;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Traceback</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span>&amp; i,<span class="keyword">int</span> s[],<span class="keyword">int</span> l[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    Traceback(n-l[n],i,s,l);  </span><br><span class="line">    s[i++]=n-l[n];<span class="comment">//重新为s[]数组赋值，用来存储分段位置  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="电路布线问题"><a href="#电路布线问题" class="headerlink" title="电路布线问题"></a>电路布线问题</h2><h3 id="基本内容-5"><a href="#基本内容-5" class="headerlink" title="基本内容"></a>基本内容</h3><p>在一块电路板的上、下两端分别有n个接线柱。根据电路设计，要求用导线(i,π(i)) 将上端接线柱i与下端接线柱π(i)相连，如下图。其中，π(i),1≤ i ≤n,是｛1,2,…,n｝的一个排列。导线(I, π(i))称为该电路板上的第i条连线。对于任何1 ≤ i ≤ j ≤n,第i条连线和第j条连线相交的充要条件是π(i)&gt; π(j).</p><p><img src="/upload/pasted-309.png" alt="upload successful"><br>在制作电路板时，要求将这n条连线分布到若干绝缘层上。在同一层上的连线不相交。电路布线问题要确定将哪些连线安排在第一层上，使得该层上有尽可能多的连线。换句话说，该问题要求确定导线集Nets = ｛i，π(i)，1 ≤ i ≤ n｝的最大不相交子集。 </p><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>记N(i,j) = {t|(t, π(t)) ∈ Nets,t ≤ i, π(t) ≤ j }. N(i,j)的最大不相交子集为MNS（i,j）Size(i,j)=|MNS(i,j)|。<br>(1)当i = 1时</p><p><img src="/upload/pasted-310.png" alt="upload successful"><br>(2)当i &gt;1时</p><p>① j &lt;π(i)。此时，(i,π(i)) 不属于N(i,j)。故在这种情况下，N(i,j) = N(i-1,j)，从而Size(i,j)=Size(i-1,j)。</p><p>② j ≥π(i)。此时，若(i, π(i))∈MNS(i,j)，则对任意(t, π(t))∈MNS(i,j)有t &lt; i且π(t)&lt; π(i)；否则，(t, π(t))与(i, π(i))相交。在这种情况下MNS(i,j)-{(i, π(i))}是N(i-1, π(i)-1)的最大不相交子集。否则，子集MNS(i-1, π(i)-1)∪{(i, π(i))}包含于N(i,j)是比MNS(i,j)更大的N(i,j)的不相交子集。这与MNS(i,j)的定义相矛盾。</p><p>若(i, π(i))不属于MNS(i,j)，则对任意(t, π(t))∈MNS(i,j)，有t&lt;i。从而MNS(i,j)包含于N(i-1,j)，因此，Size(i,j)≤Size(i-1,j)。<br>另一方面，MNS(i-1,j)包含于N(i,j),故又有Size(i,j) ≥Size(i-1,j)，从而Size（i,j）= Size(i-1,j)。</p><p><img src="/upload/pasted-311.png" alt="upload successful"><br>电路布线问题的最优值为Size(n,n)。由该问题的最优子结构性质可知，子问题最优值的递归关系如下：</p><p><img src="/upload/pasted-312.png" alt="upload successful"></p><p>根据递归方程得到如下二维表</p><p><img src="/upload/pasted-313.png" alt="upload successful"></p><h2 id="0-1背包问题（动态规划）"><a href="#0-1背包问题（动态规划）" class="headerlink" title="0-1背包问题（动态规划）"></a>0-1背包问题（动态规划）</h2><h3 id="基本内容-6"><a href="#基本内容-6" class="headerlink" title="基本内容"></a>基本内容</h3><p>给定种物品和一个容量为的背包，物品的重量是，其价值为，背包问题是如何使选择装入背包内的物品，使得装入背包中的物品的总价值最大。其中，每种物品只有全部装入背包或不装入背包两种选择。</p><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>在解决问题之前，为描述方便，首先定义一些变量：Vi表示第 i 个物品的价值，Wi表示第 i 个物品的体积，定义V(i,j)：当前背包容量 j，前 i 个物品最佳组合对应的价值，同时背包问题抽象化（X1，X2，…，Xn，其中 Xi 取0或1，表示第 i 个物品选或不选）。<br>1、建立模型，即求max(V1X1+V2X2+…+VnXn)；<br>2、寻找约束条件，W1X1+W2X2+…+WnXn&lt;capacity；<br>3、寻找递推关系式，面对当前商品有两种可能性：</p><ul><li>包的容量比该商品体积小，装不下，此时的价值与前i-1个的价值是一样的，即V(i,j)=V(i-1,j)；</li><li>还有足够的容量可以装该商品，但装了也不一定达到当前最优价值，所以在装与不装之间选择最优的一个，即V(i,j)=max｛V(i-1,j)，V(i-1,j-w(i))+v(i)｝。<br>其中V(i-1,j)表示不装，V(i-1,j-w(i))+v(i) 表示装了第i个商品，背包容量减少w(i)，但价值增加了v(i)；<br>由此可以得出递推关系式：</li><li>j&lt;w(i)      V(i,j)=V(i-1,j)</li><li>j&gt;=w(i)     V(i,j)=max｛V(i-1,j)，V(i-1,j-w(i))+v(i)｝</li></ul><p>然后就是填表，根据递推公式，填完如下<br>w(2,3,4,5) v(3,4,5,6) cap=8</p><p>根据动态规划函数，v[4,8]就是最大价值<br><img src="/upload/pasted-314.png" alt="upload successful"><br><img src="/upload/pasted-315.png" alt="upload successful"><br><img src="/upload/pasted-316.png" alt="upload successful"></p><h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h1 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;递归和分治&quot;&gt;&lt;a href=&quot;#递归和分治&quot; class=&quot;headerlink&quot; title=&quot;递归和分治&quot;&gt;&lt;/a&gt;递归和分治&lt;/h1&gt;&lt;h2 id=&quot;整数划分问题&quot;&gt;&lt;a href=&quot;#整数划分问题&quot; class=&quot;headerlink&quot; title=&quot;整
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>无向图</title>
    <link href="https://www.junglezero.top/2019/04/25/%E5%9B%BE/"/>
    <id>https://www.junglezero.top/2019/04/25/图/</id>
    <published>2019-04-25T01:00:24.000Z</published>
    <updated>2019-06-04T04:45:18.998Z</updated>
    
    <content type="html"><![CDATA[<p>…省略掉图在离散数学中的许多定义</p><h1 id="无向图的数据结构"><a href="#无向图的数据结构" class="headerlink" title="无向图的数据结构"></a>无向图的数据结构</h1><p>这里使用邻接表数组表示</p><p><img src="/upload/pasted-295.png" alt="upload successful"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> V; <span class="comment">//定点数目</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> E;       <span class="comment">//边的数目</span></span><br><span class="line">    <span class="keyword">private</span> Bag&lt;Integer&gt;[] adj; <span class="comment">//邻接表</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以V(定点的个数为依据进行初始化)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  V number of vertices</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> V &lt; 0&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> V)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (V &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Number of vertices must be nonnegative"</span>);</span><br><span class="line">        <span class="keyword">this</span>.V = V;</span><br><span class="line">        <span class="keyword">this</span>.E = <span class="number">0</span>;</span><br><span class="line">        adj = (Bag&lt;Integer&gt;[]) <span class="keyword">new</span> Bag[V];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">            adj[v] = <span class="keyword">new</span> Bag&lt;Integer&gt;();<span class="comment">//初始化所有链表为空</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes a new graph that is a deep copy of &#123;<span class="doctag">@code</span> G&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  G the graph to copy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(Graph G)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(G.V());</span><br><span class="line">        <span class="keyword">this</span>.E = G.E();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++) &#123;</span><br><span class="line">            <span class="comment">// reverse so that adjacency list is in same order as original</span></span><br><span class="line">            Stack&lt;Integer&gt; reverse = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : G.adj[v]) &#123;</span><br><span class="line">                reverse.push(w);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : reverse) &#123;</span><br><span class="line">                adj[v].add(w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回图中结点个数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of vertices in this graph</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of edges in this graph.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of edges in this graph</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">E</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// throw an IllegalArgumentException unless &#123;@code 0 &lt;= v &lt; V&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateVertex</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= V)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"vertex "</span> + v + <span class="string">" is not between 0 and "</span> + (V-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向图中加入v-w边</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  v one vertex in the edge</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  w the other vertex in the edge</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless both &#123;<span class="doctag">@code</span> 0 &lt;= v &lt; V&#125; and &#123;<span class="doctag">@code</span> 0 &lt;= w &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        validateVertex(v);</span><br><span class="line">        validateVertex(w);</span><br><span class="line">        E++;</span><br><span class="line">        adj[v].add(w);</span><br><span class="line">        adj[w].add(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回某结点的邻接表集.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  v the vertex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the vertices adjacent to vertex &#123;<span class="doctag">@code</span> v&#125;, as an iterable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= v &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        validateVertex(v);</span><br><span class="line">        <span class="keyword">return</span> adj[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回结点的个数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  v the vertex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the degree of vertex &#123;<span class="doctag">@code</span> v&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= v &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">degree</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        validateVertex(v);</span><br><span class="line">        <span class="keyword">return</span> adj[v].size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a string representation of this graph.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of vertices &lt;em&gt;V&lt;/em&gt;, followed by the number of edges &lt;em&gt;E&lt;/em&gt;,</span></span><br><span class="line"><span class="comment">     *         followed by the &lt;em&gt;V&lt;/em&gt; adjacency lists</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s.append(V + <span class="string">" vertices, "</span> + E + <span class="string">" edges "</span> + NEWLINE);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">            s.append(v + <span class="string">": "</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : adj[v]) &#123;</span><br><span class="line">                s.append(w + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            s.append(NEWLINE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="深度优先搜索-Depth-First-Search"><a href="#深度优先搜索-Depth-First-Search" class="headerlink" title="深度优先搜索(Depth-First Search)"></a>深度优先搜索(Depth-First Search)</h1><p>深度优先搜索可以理解为拿着一根绳子走迷宫，开始选择一条没有走过的路，每到一个路口，就对当前位置进行标记，当再次到达标记位置时，利用绳子回退到上一个路口，如此往复，循环渐进<br>而实现的程序上描述起来就更为简单：在访问一个顶点时，把当前的结点进行标记，然后递归的访问没有标记的顶点</p><p><img src="/upload/DFS.gif" alt="upload successful"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepthFirstPaths</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;    <span class="comment">// 标记顶点是否被标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] edgeTo;        <span class="comment">// edgeTo[v] = s到v的路径上最后一条边的起点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> s;         <span class="comment">// 搜索的起点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始进行广度优先麦搜索</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> G the graph</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s the source vertex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= s &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DepthFirstPaths</span><span class="params">(Graph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        edgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        <span class="comment">//验证s是否合法</span></span><br><span class="line">        validateVertex(s);</span><br><span class="line">        dfs(G, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键递归步骤</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将当前访问的顶点标记为已访问</span></span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//依次递归访问当前结点的所有相邻结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w : G.adj(v)) &#123;</span><br><span class="line">            <span class="comment">//如果未访问，则访问该顶点</span></span><br><span class="line">            <span class="keyword">if</span> (!marked[w]) &#123;</span><br><span class="line">                edgeTo[w] = v;</span><br><span class="line">                dfs(G, w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判定源结点s和当前结点是有通路</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v the vertex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if there is a path, &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= v &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        validateVertex(v);</span><br><span class="line">        <span class="keyword">return</span> marked[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回源结点s和当前结点v的一条通路路径，如果不存在该路径，则返回null</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  v the vertex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the sequence of vertices on a path between the source vertex</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> s&#125; and vertex &#123;<span class="doctag">@code</span> v&#125;, as an Iterable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= v &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        validateVertex(v);</span><br><span class="line">        <span class="keyword">if</span> (!hasPathTo(v)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Stack&lt;Integer&gt; path = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = v; x != s; x = edgeTo[x])</span><br><span class="line">            path.push(x);</span><br><span class="line">        path.push(s);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// throw an IllegalArgumentException unless &#123;@code 0 &lt;= v &lt; V&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateVertex</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> V = marked.length;</span><br><span class="line">        <span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= V)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"vertex "</span> + v + <span class="string">" is not between 0 and "</span> + (V-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h1><h2 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h2><p><img src="/upload/BFS2.gif" alt="upload successful"><br><strong>引入</strong>：单点路径问题，在一个图中，给定两个结点，找出这两点之间是否存在路径，如果存在，找出最短路径<br><strong>分析</strong>：dfs并不能解决这个问题，因为其遍历整个图的顺序和找出最短路径没有关系,而相比之下，广度优先搜索正是为了这个目标而出现的，要找到s到v的最短路径。从s开始，找到距离s为1条边的点，如果找不到，就在距离为2的边中查找直到找到为止，如果把深度优先搜索比作为一个人拿着绳子走迷宫，那么，那么广度优先搜索就好像一群人向着各个方向走<br><strong>实现</strong>：使用一个队列保存已经被标记但是其邻接表还未进行检查的顶点，先将起点放入队列，然后重复以下步骤知道队列为空</p><ul><li>取队列中下一个顶点v并进行访问标记</li><li>将与v相邻的所有未被标记过的顶点</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  The &#123;<span class="doctag">@code</span> BreadthFirstPaths&#125; class represents a data type for finding</span></span><br><span class="line"><span class="comment"> *  shortest paths (number of edges) from a source vertex &lt;em&gt;s&lt;/em&gt;</span></span><br><span class="line"><span class="comment"> *  (or a set of source vertices)</span></span><br><span class="line"><span class="comment"> *  to every other vertex in an undirected graph.</span></span><br><span class="line"><span class="comment"> *  &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *  This implementation uses breadth-first search.</span></span><br><span class="line"><span class="comment"> *  The constructor takes time proportional to &lt;em&gt;V&lt;/em&gt; + &lt;em&gt;E&lt;/em&gt;,</span></span><br><span class="line"><span class="comment"> *  where &lt;em&gt;V&lt;/em&gt; is the number of vertices and &lt;em&gt;E&lt;/em&gt; is the number of edges.</span></span><br><span class="line"><span class="comment"> *  Each call to &#123;<span class="doctag">@link</span> #distTo(int)&#125; and &#123;<span class="doctag">@link</span> #hasPathTo(int)&#125; takes constant time;</span></span><br><span class="line"><span class="comment"> *  each call to &#123;<span class="doctag">@link</span> #pathTo(int)&#125; takes time proportional to the length</span></span><br><span class="line"><span class="comment"> *  of the path.</span></span><br><span class="line"><span class="comment"> *  It uses extra space (not including the graph) proportional to &lt;em&gt;V&lt;/em&gt;.</span></span><br><span class="line"><span class="comment"> *  &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *  For additional documentation,</span></span><br><span class="line"><span class="comment"> *  see &lt;a href="https://algs4.cs.princeton.edu/41graph"&gt;Section 4.1&lt;/a&gt;   </span></span><br><span class="line"><span class="comment"> *  of &lt;i&gt;Algorithms, 4th Edition&lt;/i&gt; by Robert Sedgewick and Kevin Wayne.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span> Robert Sedgewick</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span> Kevin Wayne</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BreadthFirstPaths</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INFINITY = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;  <span class="comment">// marked[v] = 标记s和v之间有通路</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] edgeTo;      <span class="comment">// edgeTo[v] = previous edge on shortest s-v path</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] distTo;      <span class="comment">// distTo[v] = number of edges shortest s-v path</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">     * Computes the shortest path between the source vertex &#123;<span class="doctag">@code</span> s&#125;</span></span><br><span class="line"><span class="comment">     * and every other vertex in the graph &#123;<span class="doctag">@code</span> G&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> G the graph</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s the source vertex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= s &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BreadthFirstPaths</span><span class="params">(Graph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        distTo = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        edgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        validateVertex(s);</span><br><span class="line">        bfs(G, s);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">check</span><span class="params">(G, s)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes the shortest path between any one of the source vertices in &#123;<span class="doctag">@code</span> sources&#125;</span></span><br><span class="line"><span class="comment">     * and every other vertex in graph &#123;<span class="doctag">@code</span> G&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> G the graph</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sources the source vertices</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= s &lt; V&#125; for each vertex</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> s&#125; in &#123;<span class="doctag">@code</span> sources&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BreadthFirstPaths</span><span class="params">(Graph G, Iterable&lt;Integer&gt; sources)</span> </span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        distTo = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        edgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++)</span><br><span class="line">            distTo[v] = INFINITY;</span><br><span class="line">        validateVertices(sources);</span><br><span class="line">        bfs(G, sources);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// breadth-first search from a single source</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Graph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> Queue&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++)</span><br><span class="line">            distTo[v] = INFINITY;</span><br><span class="line">        distTo[s] = <span class="number">0</span>;</span><br><span class="line">        marked[s] = <span class="keyword">true</span>;</span><br><span class="line">        q.enqueue(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = q.dequeue();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : G.adj(v)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!marked[w]) &#123;</span><br><span class="line">                    edgeTo[w] = v;</span><br><span class="line">                    distTo[w] = distTo[v] + <span class="number">1</span>;</span><br><span class="line">                    marked[w] = <span class="keyword">true</span>;</span><br><span class="line">                    q.enqueue(w);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// breadth-first search from multiple sources</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Graph G, Iterable&lt;Integer&gt; sources)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> Queue&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s : sources) &#123;</span><br><span class="line">            marked[s] = <span class="keyword">true</span>;</span><br><span class="line">            distTo[s] = <span class="number">0</span>;</span><br><span class="line">            q.enqueue(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = q.dequeue();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : G.adj(v)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!marked[w]) &#123;</span><br><span class="line">                    edgeTo[w] = v;</span><br><span class="line">                    distTo[w] = distTo[v] + <span class="number">1</span>;</span><br><span class="line">                    marked[w] = <span class="keyword">true</span>;</span><br><span class="line">                    q.enqueue(w);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Is there a path between the source vertex &#123;<span class="doctag">@code</span> s&#125; (or sources) and vertex &#123;<span class="doctag">@code</span> v&#125;?</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v the vertex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if there is a path, and &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= v &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        validateVertex(v);</span><br><span class="line">        <span class="keyword">return</span> marked[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of edges in a shortest path between the source vertex &#123;<span class="doctag">@code</span> s&#125;</span></span><br><span class="line"><span class="comment">     * (or sources) and vertex &#123;<span class="doctag">@code</span> v&#125;?</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v the vertex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of edges in a shortest path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= v &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">distTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        validateVertex(v);</span><br><span class="line">        <span class="keyword">return</span> distTo[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a shortest path between the source vertex &#123;<span class="doctag">@code</span> s&#125; (or sources)</span></span><br><span class="line"><span class="comment">     * and &#123;<span class="doctag">@code</span> v&#125;, or &#123;<span class="doctag">@code</span> null&#125; if no such path.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  v the vertex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the sequence of vertices on a shortest path, as an Iterable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= v &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        validateVertex(v);</span><br><span class="line">        <span class="keyword">if</span> (!hasPathTo(v)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Stack&lt;Integer&gt; path = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">for</span> (x = v; distTo[x] != <span class="number">0</span>; x = edgeTo[x])</span><br><span class="line">            path.push(x);</span><br><span class="line">        path.push(x);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// check optimality conditions for single source</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(Graph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check that the distance of s = 0</span></span><br><span class="line">        <span class="keyword">if</span> (distTo[s] != <span class="number">0</span>) &#123;</span><br><span class="line">            StdOut.println(<span class="string">"distance of source "</span> + s + <span class="string">" to itself = "</span> + distTo[s]);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check that for each edge v-w dist[w] &lt;= dist[v] + 1</span></span><br><span class="line">        <span class="comment">// provided v is reachable from s</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : G.adj(v)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hasPathTo(v) != hasPathTo(w)) &#123;</span><br><span class="line">                    StdOut.println(<span class="string">"edge "</span> + v + <span class="string">"-"</span> + w);</span><br><span class="line">                    StdOut.println(<span class="string">"hasPathTo("</span> + v + <span class="string">") = "</span> + hasPathTo(v));</span><br><span class="line">                    StdOut.println(<span class="string">"hasPathTo("</span> + w + <span class="string">") = "</span> + hasPathTo(w));</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (hasPathTo(v) &amp;&amp; (distTo[w] &gt; distTo[v] + <span class="number">1</span>)) &#123;</span><br><span class="line">                    StdOut.println(<span class="string">"edge "</span> + v + <span class="string">"-"</span> + w);</span><br><span class="line">                    StdOut.println(<span class="string">"distTo["</span> + v + <span class="string">"] = "</span> + distTo[v]);</span><br><span class="line">                    StdOut.println(<span class="string">"distTo["</span> + w + <span class="string">"] = "</span> + distTo[w]);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check that v = edgeTo[w] satisfies distTo[w] = distTo[v] + 1</span></span><br><span class="line">        <span class="comment">// provided v is reachable from s</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; G.V(); w++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasPathTo(w) || w == s) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> v = edgeTo[w];</span><br><span class="line">            <span class="keyword">if</span> (distTo[w] != distTo[v] + <span class="number">1</span>) &#123;</span><br><span class="line">                StdOut.println(<span class="string">"shortest path edge "</span> + v + <span class="string">"-"</span> + w);</span><br><span class="line">                StdOut.println(<span class="string">"distTo["</span> + v + <span class="string">"] = "</span> + distTo[v]);</span><br><span class="line">                StdOut.println(<span class="string">"distTo["</span> + w + <span class="string">"] = "</span> + distTo[w]);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// throw an IllegalArgumentException unless &#123;@code 0 &lt;= v &lt; V&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateVertex</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> V = marked.length;</span><br><span class="line">        <span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= V)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"vertex "</span> + v + <span class="string">" is not between 0 and "</span> + (V-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// throw an IllegalArgumentException unless &#123;@code 0 &lt;= v &lt; V&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateVertices</span><span class="params">(Iterable&lt;Integer&gt; vertices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (vertices == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument is null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> V = marked.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : vertices) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= V) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"vertex "</span> + v + <span class="string">" is not between 0 and "</span> + (V-<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Unit tests the &#123;<span class="doctag">@code</span> BreadthFirstPaths&#125; data type.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args the command-line arguments</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        In in = <span class="keyword">new</span> In(args[<span class="number">0</span>]);</span><br><span class="line">        Graph G = <span class="keyword">new</span> Graph(in);</span><br><span class="line">        <span class="comment">// StdOut.println(G);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> s = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">        BreadthFirstPaths bfs = <span class="keyword">new</span> BreadthFirstPaths(G, s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bfs.hasPathTo(v)) &#123;</span><br><span class="line">                StdOut.printf(<span class="string">"%d to %d (%d):  "</span>, s, v, bfs.distTo(v));</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x : bfs.pathTo(v)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (x == s) StdOut.print(x);</span><br><span class="line">                    <span class="keyword">else</span>        StdOut.print(<span class="string">"-"</span> + x);</span><br><span class="line">                &#125;</span><br><span class="line">                StdOut.println();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                StdOut.printf(<span class="string">"%d to %d (-):  not connected\n"</span>, s, v);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;…省略掉图在离散数学中的许多定义&lt;/p&gt;
&lt;h1 id=&quot;无向图的数据结构&quot;&gt;&lt;a href=&quot;#无向图的数据结构&quot; class=&quot;headerlink&quot; title=&quot;无向图的数据结构&quot;&gt;&lt;/a&gt;无向图的数据结构&lt;/h1&gt;&lt;p&gt;这里使用邻接表数组表示&lt;/p&gt;
&lt;p&gt;&lt;im
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>乐观锁和悲观锁</title>
    <link href="https://www.junglezero.top/2019/04/23/%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81-1/"/>
    <id>https://www.junglezero.top/2019/04/23/锁和悲观锁-1/</id>
    <published>2019-04-23T06:07:00.000Z</published>
    <updated>2019-04-23T06:14:46.260Z</updated>
    
    <content type="html"><![CDATA[<h1 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>当我们要对一个数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。</p><p>这种借助数据库锁机制在修改数据之前先锁定，再修改的方式被称之为悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）。</p><p>之所以叫做悲观锁，是因为这是一种对数据的修改抱有悲观态度的并发控制方式。我们一般认为数据被并发修改的概率比较大，所以需要在修改之前先加锁。</p><p>悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。</p><p>但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，还会降低并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。</p><p><img src="/upload/pasted-285.png" alt="upload successful"></p><p>Java里面的同步原语synchronized关键字的实现也是悲观锁。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>以MySQL为例<br>要使用悲观锁，必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set autocommit=0;<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//0.开始事务</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"></span><br><span class="line">//1.查询出商品库存信息</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> quantity <span class="keyword">from</span> items <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line">//2.修改商品库存为2</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> items <span class="keyword">set</span> quantity=<span class="number">2</span> <span class="keyword">where</span> <span class="keyword">id</span>= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">//3.提交事务</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></p><p>以上，在对id = 1的记录修改前，先通过for update的方式进行加锁，然后再进行修改。这就是比较典型的悲观锁策略。</p><p>如果以上修改库存的代码发生并发，同一时间只有一个线程可以开启事务并获得id=1的锁，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。</p><p>上面我们提到，使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意</p><h1 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p>乐观锁（ Optimistic Locking ） 是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。</p><p>相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。</p><p><img src="/upload/pasted-292.png" alt="upload successful"><br>乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。</p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>使用乐观锁就不需要借助数据库的锁机制了。</p><p>乐观锁的概念中其实已经阐述了他的具体实现细节：主要就是两个步骤：冲突检测和数据更新。其实现方式有一种比较典型的就是Compare and Swap(CAS)。</p><p>CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p><p>比如前面的扣减库存问题，通过乐观锁可以实现如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//查询出商品库存信息，quantity = 3</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> quantity <span class="keyword">from</span> items <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">//修改商品库存为<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> items <span class="keyword">set</span> quantity=<span class="number">2</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">and</span> quantity = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></p><p>以上，我们在更新之前，先查询一下库存表中当前库存数（quantity），然后在做update的时候，以库存数作为一个修改条件。当我们提交更新的时候，判断数据库表对应记录的当前库存数与第一次取出来的库存数进行比对，如果数据库表当前库存数与第一次取出来的库存数相等，则予以更新，否则认为是过期数据。</p><p>以上更新语句存在一个比较重要的问题，即传说中的ABA问题。</p><p>比如说一个线程one从数据库中取出库存数3，这时候另一个线程two也从数据库中库存数3，并且two进行了一些操作变成了2，然后two又将库存数变成3，这时候线程one进行CAS操作发现数据库中仍然是3，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。</p><p><img src="/upload/pasted-293.png" alt="upload successful"><br>有一个比较好的办法可以解决ABA问题，那就是通过一个单独的可以顺序递增的version字段。改为以下方式即可：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//查询出商品信息，version = 1</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">version</span> <span class="keyword">from</span> items <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">//修改商品库存为<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> items <span class="keyword">set</span> quantity=<span class="number">2</span>,<span class="keyword">version</span>= <span class="number">3</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">and</span> <span class="keyword">version</span>= <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p><p>乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现ABA问题，因为版本号只会增加不会减少。</p><p><img src="/upload/pasted-294.png" alt="upload successful"></p><p>以上SQL其实还是有一定的问题的，就是一旦发上高并发的时候，就只有一个线程可以修改成功，那么就会存在大量的失败。</p><p>对于像淘宝这样的电商网站，高并发是常有的事，总让用户感知到失败显然是不合理的。所以，还是要想办法减少乐观锁的粒度的。</p><p>有一条比较好的建议，可以减小乐观锁力度，最大程度的提升吞吐率，提高并发能力！如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//修改商品库存</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> item</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> quantity=quantity - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">and</span> quantity - <span class="number">1</span>&gt; <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>以上SQL语句中，如果用户下单数为1，则通过quantity - 1 &gt; 0的方式进行乐观锁控制。</p><p>以上update语句，在执行过程中，会在一次原子操作中自己查询一遍quantity的值，并将其扣减掉1。</p><h1 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h1><p>在乐观锁与悲观锁的选择上面，主要看下两者的区别以及适用场景就可以了。</p><p>1、乐观锁并未真正加锁，效率高。一旦锁的粒度掌握不好，更新失败的概率就会比较高，容易发生业务失败。</p><p>2、悲观锁依赖数据库锁，效率低。更新失败的概率比较低。</p><p>随着互联网三高架构（高并发、高性能、高可用）的提出，悲观锁已经越来越少的被使用到生产环境中了，尤其是并发量比较大的业务场景。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;悲观锁&quot;&gt;&lt;a href=&quot;#悲观锁&quot; class=&quot;headerlink&quot; title=&quot;悲观锁&quot;&gt;&lt;/a&gt;悲观锁&lt;/h1&gt;&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概
      
    
    </summary>
    
      <category term="数据库相关" scheme="https://www.junglezero.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/"/>
    
      <category term="java多线程学习" scheme="https://www.junglezero.top/categories/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9B%B8%E5%85%B3/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="java多线程" scheme="https://www.junglezero.top/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="数据库" scheme="https://www.junglezero.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>多线程上下文设计模式</title>
    <link href="https://www.junglezero.top/2019/04/22/%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.junglezero.top/2019/04/22/程上下文设计模式/</id>
    <published>2019-04-22T10:17:38.000Z</published>
    <updated>2019-04-22T10:49:02.938Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>上下文是贯穿整个系统或阶段生命周期的对象，其包含了系统全局的一些信息，比如登录之后的用户信息，账号信息以及程序每一个阶段运行时的数据。<br>在有些时候，单个线程执行的任务步骤会非常多，后一个步骤的输入有可能是前一个步骤的输出，比如在单个线程多步骤执行时，为了使得功能单一，有时候我们会采用GOF职责链设计模式。</p><p><img src="/upload/pasted-284.png" alt="upload successful"></p><h1 id="利用ThreadLocal实现"><a href="#利用ThreadLocal实现" class="headerlink" title="利用ThreadLocal实现"></a>利用ThreadLocal实现</h1><p>某个任务，需要分别从数据库和http查询内容<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutionTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> QueryFromDBAction queryAction = <span class="keyword">new</span> QueryFromDBAction();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> QueryFromHttpAction httpAction = <span class="keyword">new</span> QueryFromHttpAction();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接执行不用传参</span></span><br><span class="line">        queryAction.execute();</span><br><span class="line">        System.out.println(<span class="string">"The name query successful"</span>);</span><br><span class="line">        httpAction.execute();</span><br><span class="line">        System.out.println(<span class="string">"The card id query successful"</span>);</span><br><span class="line"></span><br><span class="line">        Context context = ActionContext.getActionContext().getContext();</span><br><span class="line">        System.out.println(<span class="string">"The Name is "</span> + context.getName() + <span class="string">" and CardId "</span> + context.getCardId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上下文类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String cardId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCardId</span><span class="params">(String cardId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cardId = cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCardId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cardId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>全局管理上下文<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Context&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;Context&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Context <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Context();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//嵌套内部类单例模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ActionContext actionContext = <span class="keyword">new</span> ActionContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ActionContext <span class="title">getActionContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ContextHolder.actionContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Context <span class="title">getContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ActionContext</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>任务中具体内容执行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryFromDBAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">            String name = <span class="string">"Alex "</span> + Thread.currentThread().getName();</span><br><span class="line">            <span class="comment">//调用全局context，并直接修改context</span></span><br><span class="line">            ActionContext.getActionContext().getContext().setName(name);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryFromHttpAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个任务就分为两步，首先获取name，从context中，然后再根据name获取cardID，存入context</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Context context = ActionContext.getActionContext().getContext();</span><br><span class="line">        String name = context.getName();</span><br><span class="line">        String cardId = getCardId(name);</span><br><span class="line">        context.setCardId(cardId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getCardId</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"435467523543"</span> + Thread.currentThread().getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;上下文是贯穿整个系统或阶段生命周期的对象，其包含了系统全局的一些信息，比如登录之后的用户信息，账号信息以及程序每一个阶段运行
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ThreadLocal的理解与使用</title>
    <link href="https://www.junglezero.top/2019/04/18/readLocal%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <id>https://www.junglezero.top/2019/04/18/readLocal的理解与使用/</id>
    <published>2019-04-18T03:05:35.000Z</published>
    <updated>2019-04-19T00:47:11.465Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本理解"><a href="#基本理解" class="headerlink" title="基本理解"></a>基本理解</h1><p>ThreadLocal是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。</p><p><img src="/upload/pasted-282.png" alt="upload successful"></p><p>从上面的ThreadLocal结构图中，可以发现</p><ul><li>每个Thread线程内部都有一个Map。</li><li>Map里面存储线程本地对象（key）和线程的变量副本（value）</li><li>但是，Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值。、</li><li>所以对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰。</li></ul><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>在Thread中的ThreadLocalMap由ThreadLocal类维护</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment">     * by the ThreadLocal class. */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal提供的三个核心方法</p><blockquote><p><strong>public T get()</strong></p></blockquote><p>Returns the value in the current thread’s copy of this thread-local variable. If the variable has no value for the current thread, it is first initialized to the value returned by an invocation of the initialValue() method.</p><blockquote></blockquote><p><strong>Returns:</strong><br>    the current thread’s value of this thread-local </p><p>简单来说，该方法就是获得当前线程副本的变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value in the current thread's copy of this</span></span><br><span class="line"><span class="comment"> * thread-local variable.  If the variable has no value for the</span></span><br><span class="line"><span class="comment"> * current thread, it is first initialized to the value returned</span></span><br><span class="line"><span class="comment"> * by an invocation of the &#123;<span class="doctag">@link</span> #initialValue&#125; method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the current thread's value of this thread-local</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> (T)e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本过程：<br>1.获取当前线程的ThreadLocalMap对象threadLocals<br>2.从map中获取线程存储的K-V Entry节点。<br>3.从Entry节点获取存储的Value副本值返回。<br>4.map为空的话返回初始值null，即线程变量副本为null，在使用时需要注意判断NullPointerException。</p><blockquote><p><strong>public void set(T value)</strong></p></blockquote><p>Sets the current thread’s copy of this thread-local variable to the specified value. Most subclasses will have no need to override this method, relying solely on the initialValue() method to set the values of thread-locals.</p><blockquote></blockquote><p><strong>Parameters:</strong><br>    value - the value to be stored in the current thread’s copy of this thread-local.</p><p>set()方法用于保存当前线程的副本变量值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the current thread's copy of this thread-local variable</span></span><br><span class="line"><span class="comment"> * to the specified value.  Most subclasses will have no need to</span></span><br><span class="line"><span class="comment"> * override this method, relying solely on the &#123;<span class="doctag">@link</span> #initialValue&#125;</span></span><br><span class="line"><span class="comment"> * method to set the values of thread-locals.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to be stored in the current thread's copy of</span></span><br><span class="line"><span class="comment"> *        this thread-local.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>remove</strong></p></blockquote><blockquote><p>public void remove()</p></blockquote><p>  Removes the current thread’s value for this thread-local variable. If this thread-local variable is subsequently read by the current thread, its value will be reinitialized by invoking its initialValue() method, unless its value is set by the current thread in the interim. This may result in multiple invocations of the initialValue method in the current thread.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the current thread's value for this thread-local</span></span><br><span class="line"><span class="comment"> * variable.  If this thread-local variable is subsequently</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@linkplain</span> #get read&#125; by the current thread, its value will be</span></span><br><span class="line"><span class="comment"> * reinitialized by invoking its &#123;<span class="doctag">@link</span> #initialValue&#125; method,</span></span><br><span class="line"><span class="comment"> * unless its value is &#123;<span class="doctag">@linkplain</span> #set set&#125; by the current thread</span></span><br><span class="line"><span class="comment"> * in the interim.  This may result in multiple invocations of the</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;initialValue&lt;/tt&gt; method in the current thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line"> <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">     m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadLocalMap的问题"><a href="#ThreadLocalMap的问题" class="headerlink" title="ThreadLocalMap的问题"></a>ThreadLocalMap的问题</h2><p>ThreadLocalMap是ThreadLocal的内部类，没有实现Map接口，用独立的方式实现了Map的功能，其内部的Entry也独立实现。</p><p><img src="/upload/pasted-283.png" alt="upload successful"><br>由于ThreadLocalMap的key是弱引用，而Value是强引用。这就导致了一个问题，ThreadLocal在没有外部对象强引用时，发生GC时弱引用Key会被回收，而Value不会回收，如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露</p><p>避免：<br>既然Key是弱引用，那么我们要做的事，就是在调用ThreadLocal的get()、set()方法时完成后再调用remove方法，将Entry节点和Map的引用关系移除，这样整个Entry对象在GC Roots分析后就变成不可达了，下次GC的时候就可以被回收。<br>如果使用ThreadLocal的set方法之后，没有显示的调用remove方法，就有可能发生内存泄露，所以养成良好的编程习惯十分重要，使用完ThreadLocal之后，记得调用remove方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;Session&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;Session&gt;();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    threadLocal.set(<span class="keyword">new</span> Session(<span class="number">1</span>, <span class="string">"Misout的博客"</span>));</span><br><span class="line">    <span class="comment">// 其它业务逻辑</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    threadLocal.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>数据库连接：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder = <span class="keyword">new</span> ThreadLocal&lt;Connection&gt;() &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">initialValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(DB_URL);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> connectionHolder.get();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Session:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal threadSession = <span class="keyword">new</span> ThreadLocal();  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getSession</span><span class="params">()</span> <span class="keyword">throws</span> InfrastructureException </span>&#123;  </span><br><span class="line">    Session s = (Session) threadSession.get();  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            s = getSessionFactory().openSession();  </span><br><span class="line">            threadSession.set(s);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (HibernateException ex) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InfrastructureException(ex);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> s;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本理解&quot;&gt;&lt;a href=&quot;#基本理解&quot; class=&quot;headerlink&quot; title=&quot;基本理解&quot;&gt;&lt;/a&gt;基本理解&lt;/h1&gt;&lt;p&gt;ThreadLocal是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>确保挂起设计模式（Guarded Suspension）</title>
    <link href="https://www.junglezero.top/2019/04/18/%E6%8C%82%E8%B5%B7%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88Guarded-Suspension-%EF%BC%89/"/>
    <id>https://www.junglezero.top/2019/04/18/挂起设计模式（Guarded-Suspension-）/</id>
    <published>2019-04-18T01:41:00.000Z</published>
    <updated>2019-04-18T02:24:22.470Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本含义"><a href="#基本含义" class="headerlink" title="基本含义"></a>基本含义</h1><p>Guarded Suspension意为保护暂停，其核心思想是仅当服务进程准备好时，才提供服务。设想一种场景，服务器可能会在很短时间内承受大量的客户端请求，客户端请求的数量可能超过服务器本身的即时处理能力，而服务端程序又不能丢弃任何一个客户请求。此时，最佳的处理方案莫过于让客户端要求进行排队，由服务端程序一个接一个处理。这样，既保证了所有的客户端请求均不丢失，同时也避免了服务器由于同时处理太多的请求而崩溃</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>request类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代表可能会有很多的请求类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Request</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>请求队列：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求等待队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Request&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得等待队列的一个request，当没有request时，线程进行等待</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Request <span class="title">getRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Request request = queue.removeFirst();</span><br><span class="line">            <span class="keyword">return</span> request;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在队列中加入新的请求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">            queue.addLast(request);</span><br><span class="line">            <span class="comment">//唤醒等待线程</span></span><br><span class="line">            queue.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端线程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RequestQueue queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Random random;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String sendValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClientThread</span><span class="params">(RequestQueue queue, String sendValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">        <span class="keyword">this</span>.sendValue = sendValue;</span><br><span class="line">        random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//假设是10条请求</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Client -&gt; request "</span> + sendValue);</span><br><span class="line">            queue.putRequest(<span class="keyword">new</span> Request(sendValue));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//模拟花费时间</span></span><br><span class="line">                Thread.sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>服务端线程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RequestQueue queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Random random;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerThread</span><span class="params">(RequestQueue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">        random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!closed) &#123;</span><br><span class="line">            Request request = queue.getRequest();</span><br><span class="line">            <span class="comment">//当请求为空时，跳出本次循环</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == request) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Received the empty request."</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Server -&gt;"</span> + request.getValue());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">//中断时，跳出run方法</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.closed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试线程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuspensionClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> RequestQueue queue = <span class="keyword">new</span> RequestQueue();</span><br><span class="line">        <span class="keyword">new</span> ClientThread(queue, <span class="string">"Alex"</span>).start();</span><br><span class="line">        ServerThread serverThread = <span class="keyword">new</span> ServerThread(queue);</span><br><span class="line">        serverThread.start();</span><br><span class="line">        <span class="comment">//serverThread.join();</span></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        serverThread.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Client -&gt; request Alex</span><br><span class="line">Server -&gt;Alex</span><br><span class="line">Client -&gt; request Alex</span><br><span class="line">Server -&gt;Alex</span><br><span class="line">Client -&gt; request Alex</span><br><span class="line">Server -&gt;Alex</span><br><span class="line">Client -&gt; request Alex</span><br><span class="line">Server -&gt;Alex</span><br><span class="line">Client -&gt; request Alex</span><br><span class="line">Server -&gt;Alex</span><br><span class="line">Client -&gt; request Alex</span><br><span class="line">Server -&gt;Alex</span><br><span class="line">Client -&gt; request Alex</span><br><span class="line">Server -&gt;Alex</span><br><span class="line">Client -&gt; request Alex</span><br><span class="line">Server -&gt;Alex</span><br><span class="line">Client -&gt; request Alex</span><br><span class="line">Server -&gt;Alex</span><br><span class="line">Client -&gt; request Alex</span><br><span class="line">Server -&gt;Alex</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本含义&quot;&gt;&lt;a href=&quot;#基本含义&quot; class=&quot;headerlink&quot; title=&quot;基本含义&quot;&gt;&lt;/a&gt;基本含义&lt;/h1&gt;&lt;p&gt;Guarded Suspension意为保护暂停，其核心思想是仅当服务进程准备好时，才提供服务。设想一种场景，服务器可能会在
      
    
    </summary>
    
      <category term="java多线程学习" scheme="https://www.junglezero.top/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="java多线程" scheme="https://www.junglezero.top/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程future设计模式</title>
    <link href="https://www.junglezero.top/2019/04/17/%E7%A8%8Bfuture%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.junglezero.top/2019/04/17/程future设计模式/</id>
    <published>2019-04-17T02:49:00.000Z</published>
    <updated>2019-04-17T07:56:23.007Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>future设计模式实际上相当一个异步完成任务充分利用本应当的等待时间，有点类似于商品订单。比如在网购时，当看中某一件商品时就可以提交订单，当订单处理完成后，在家里等待商品送货上门即可。或者说更形象的我们发送Ajax请求时，页面是异步进行后台处理，用户无需一直等待请求结果，可以继续浏览或操作其他内容<br>类似于下面的一个商品订单的时序图</p><p><img src="/upload/pasted-280.png" alt="upload successful"><br>客户端发送一个长时间的请求，服务端不需等待该数据处理完成便立即返回一个伪造的代理数据（相当于商品订单，不是商品本身），用户也无需等待，先去执行其他的若干操作后，再去调用服务器已经完成组装的真实数据。该模型充分利用了等待的时间片段。</p><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p><img src="/upload/pasted-281.png" alt="upload successful"><br>Main：启动系统，调用Client发出请求；</p><p>Client：返回Data对象，理解返回FutureData，并开启ClientThread线程装配RealData；</p><p>Data：返回数据的接口；</p><p>FutureData：Future数据，构造很快，但是是一个虚拟的数据，需要装配RealData；</p><p>RealData：真实数据，构造比较慢。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>具体实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Client client = <span class="keyword">new</span> Client();</span><br><span class="line"><span class="comment">//理解返回一个FutureData</span></span><br><span class="line">Data data = client.request(<span class="string">"name"</span>);</span><br><span class="line">System.out.println(<span class="string">"请求完毕！"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理其他业务</span></span><br><span class="line"><span class="comment">//这个过程中，真是数据RealData组装完成，重复利用等待时间</span></span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真实数据</span></span><br><span class="line">System.out.println(<span class="string">"数据 = "</span>+ data.getResult());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>client:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Data <span class="title">request</span><span class="params">(<span class="keyword">final</span> String queryStr)</span></span>&#123;</span><br><span class="line"><span class="keyword">final</span> FutureData future = <span class="keyword">new</span> FutureData();</span><br><span class="line"><span class="comment">//开启一个新的线程来构造真实数据</span></span><br><span class="line"><span class="keyword">new</span> Thread()&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">RealData realData = <span class="keyword">new</span> RealData(queryStr);</span><br><span class="line">future.setRealData(realData);&#125;</span><br><span class="line">&#125;.start();</span><br><span class="line"><span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Data:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span>  String <span class="title">getResult</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>FutureData<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是对RealData的一个包装</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> limin</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureData</span> <span class="keyword">implements</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span> RealData realData =<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> isReady = <span class="keyword">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setRealData</span><span class="params">(RealData realData)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(isReady)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.realData=realData;</span><br><span class="line">isReady=<span class="keyword">true</span>;</span><br><span class="line">notifyAll();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">synchronized</span>  String <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(!isReady)&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">wait();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> realData.result;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>RealData:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealData</span> <span class="keyword">implements</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line"><span class="keyword">protected</span>  String  result;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RealData</span><span class="params">(String para)</span></span>&#123;</span><br><span class="line"> <span class="comment">//构造比较慢</span></span><br><span class="line">StringBuffer sb= <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">sb.append(para);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">result= sb.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;future设计模式实际上相当一个异步完成任务充分利用本应当的等待时间，有点类似于商品订单。比如在网购时，当看中某一件商品时
      
    
    </summary>
    
      <category term="java多线程学习" scheme="https://www.junglezero.top/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="java多线程" scheme="https://www.junglezero.top/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>绘卷水浒传 20周年企划 第六章 翻译</title>
    <link href="https://www.junglezero.top/2019/04/16/%E7%BB%98%E5%8D%B7%E6%B0%B4%E6%B5%92%E4%BC%A0-20%E5%91%A8%E5%B9%B4%E4%BC%81%E5%88%92-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E7%BF%BB%E8%AF%91/"/>
    <id>https://www.junglezero.top/2019/04/16/绘卷水浒传-20周年企划-第六章-翻译/</id>
    <published>2019-04-16T13:47:00.000Z</published>
    <updated>2019-04-26T03:56:17.479Z</updated>
    
    <content type="html"><![CDATA[<hr><p><font color="#FF0000">原文作者 森下翠和插画作者 正子公也 版权所有<br><br>个人翻译<br><br>仅供个人娱乐及同好者欣赏<br></font><br><br><br><a href="http://suikoden.com/" target="_blank" rel="noopener">原文地址</a></p><hr><h1 id="第六章-月下天堂"><a href="#第六章-月下天堂" class="headerlink" title="第六章 月下天堂"></a>第六章 月下天堂</h1><p>史进眺望着对面激扬而起的水花<br>手持长枪，稳稳的站着，这长枪，来自于死在逃亡路上的武器贩子“乌鸦嘴”，这些买卖人到生命的尽头都带着自己兜售的商品<br>史进感觉到了阵阵凉风<br>身旁站着的是金山大师和鲁智深<br>史进回头看了看背后的石窟，然后继续观察着对岸的走向<br>突然跃动起来，背上的龙，呼之欲出<br>（时候未到）<br>史进舔了舔干燥的嘴唇<br>现在，即使是这种等待，也是战斗</p><p>这个时候，石秀却潜伏在对岸<br>黎明之前，他在伊水上游渡河，绕过南岸的岩山<br>这是由石秀，李忠，陈达，杨春以及众亲近弟兄组成的敢死队，总计一百多人，他们留下了在正面战场的史进和鲁智深，只带了善于奇袭的梁山弟兄<br>杨春从岩石后面探出身子，窥视着北面<br>“一半的敌军正在渡河，另一半都在岸边待命”<br>石秀点了点头<br>“剩下的，正是守护林灵素的道士军，共计一万五千人”<br>官军打算躺过伊水，一口气消灭僧众，他们依仗人数上的优势，现在正全神贯注的集中在北岸<br>就趁着这个机会，奇袭敌后<br>因而留在北岸的史进众人也没发起攻击，正在等着恰到好处的机会<br>石秀他们的目标正是官军的统帅——“通真达灵元妙先生”林灵素<br>林灵素才是掀起这场法难的元凶，只要杀掉他，剩下的道士就会做鸟兽散<br>（皇帝也会清醒过来吧，即使没有，杀掉他也是大快人心）<br>昨晚王定六等人已经侦察到了敌人的本阵的帅旗是巨大的“太极旗”，石秀等人确认的在朝霞中飘展的太极旗后，就缓缓的下了岩山<br>他们沿着路一点点的向下，已经看不见敌人的大军了，在岩山脚下，依然徘徊者清晨的气息，石秀等人止住气息，慎重的前行着，依据太阳掌握着大致的方向<br>周围都是岩石和树林，地形错综复杂，穿过这里，不久就会到达本阵，实际上，已经可以感觉到从雾霭的另一端大军的气息<br>但是，不管怎么走，都看不见那太极旗，也无法接近敌军阵地<br>李忠注意到<br>“这地上的脚印可不是官军的，是哪里来的啊”<br>众人自己的脚比划了比划<br>“这不是我们自己的吗？”<br>“还真是”<br>陈达叫了一声<br>“迷路了，不，不对”<br>陈达和杨春认同的点了点头<br>“这是幻术”</p><p><img src="http://10.28.0.10/cache/10/04/suikoden.com/d149518e96e2253cfea93f01e3af74e6/108%20Outlaws-133.jpg" alt="陈达和杨春"><br>石秀并不认同<br>“林灵素就是个徒有虚名的玩意”<br>“话是这么说，事不是这个事啊”<br>陈达郁闷的摸了摸被露水沾湿的络腮胡子，看着周围的杂树林<br>陈达和杨春是“神机军师”朱武的兄弟，朱武擅长布阵，不管是八卦阵还是摩诃兵法，都很精通，当年兄弟几人也和史进在芒砀山和“混世魔王”樊瑞战斗过<br>“这周遭就是当时那股子气息”<br>石秀沉默了，石秀也曾在梁山泊的芦苇荡迷瞪过，当年三打祝家庄时，也勿入了迷宫<br>“他妈的，怎么就这么倒霉”<br>石秀看着地上的纷乱的脚印<br>“史进众兄弟还在等着我们的奇袭”<br>抬头望望天，却被郁郁葱葱的树林遮住了，连太阳也看不见了</p><hr><p>金山大师正在北岸，面对着渡河而来的洛阳军<br>身上法衣已经血迹斑斑，也被刀刃划拨，在风中丝丝缕缕的飘荡着<br>鲁智深脱了光膀。杵着禅杖<br>两位大师站在反射着朝阳的河岸边上<br>鲁智深健壮的脊梁上，正闪耀着一朵盛开的红牡丹，金山大师察觉到了，一手握着般若雷，一手向着那朵牡丹行礼<br>“‘一切众生皆有佛性’——佛在人心”</p><p>鲁智深的禅杖激起一朵巨大的水花<br>战斗已经开始了<br><img src="http://10.28.0.10/cache/12/04/suikoden.com/fd8e6db1a0b60ff46e69fe7e4c755ee9/108%20Outlaws-134.jpg" alt="2"><br>禅杖挥向了冲在前面的官军，毫不费力的将他们打翻在水中，丐帮的众人也怪叫着冲向前去，他们的武器各式各样，有棍子，有斧头，有农具，有扁担，还有不知在哪里捡到了的破败的兵器，虽然他们很瘦弱，但是手脚的力量也不可小觑，这凶猛的气势好像发狂的野狗一般<br>南北少林的武僧们正用精湛的拳法毫不留情的打倒眼前的官军，失去了“白光尊师”的护国禅僧们还有八人幸存，每当他们手持禅杖跃动时，便会有数十敌人应声而倒<br>两军曾在少林寺交过手，最终结果是率领洛阳军的宇文将军战死，半数的士兵失去战斗力，因而正都指挥使出征，然而此时他正在林灵素的本阵待命，实际的指挥则是手下的部将们<br>莫志正专心的射箭，可以说百发百中，毫无例外的穿过敌人的喉咙<br>（人和鸟没什么区别）<br>莫志一支一支的搭着箭，只是轻轻一瞄就出手了，轻快的弓弦音震动着耳膜，莫志不知不觉嘴角露出笑意<br>伊水已经一片血红，横尸遍野<br>岸边的佛像仁慈的微笑着，俯视着一片鲜红的战场<br>鲁智深背对着佛的微笑，在人群中厮杀着<br>人生在世，本是奇迹般的偶然重叠而生<br>“尽管如此，可死起来却这么的容易”<br>鲁智深砍翻眼前的敌人，大喊一声<br>“南无、阿弥陀佛！”</p><p>史进等人坚守在岸边，迎击着渡河而来的官军，背后的岩洞中是负伤者和诵经的僧尼<br>史进面前，有源源不断的官军涌来，枪出，弯折，猛跃，敌倒。史进的耳畔，只有自己的心跳和呼吸的声音<br>敌人众多，把史进团团围住，史进的枪已经断了<br>史进拾起已经倒下的少林武僧的棒子，继续战斗着，折断之后，就又用脚尖挑起一根，从来没有停下来<br>“石秀那边什么情况”<br>敌人还在一个劲的增加着<br>“奇袭还没开始吗？”<br>本想看看对岸的情况，却被袭击而来的敌人打断了<br>敌人包围史进，从四面八方出枪，史进闪身躲了过去，敌人又从身后砍过来，王定六的匕首，又在背后暗杀了袭击的敌人<br>“看来是赶不上了”<br>匕首闪闪发光，杀死了一个又一个敌人，无论倒下多少，都没有到头<br>洛阳军已经上岸了，禁军也正在赶过来，已经看不见河水了，放眼望去，全是敌军<br>王定六观察着这场战斗的去向，身上肩负着回报梁山泊的任务，但是，他也早已把生死抛在了脑后</p><p>官军正在陆陆续续的上岸<br>兵法云“半渡而击之”，可是，因为一直在等着石秀等人发起的奇袭，已经错过了出击的最好机会。已经让不少人上了岸。史进等人正在被逼后退，身后就是石窟，后面是陡峭的岩山，他们已经没有退路了，藏在石窟中的伤员和尼姑拼了命的投掷他们能拿到手的东西，不管是贡品台，还是破败的佛像的头，一道道弧线在空中划过，念经声响彻天地<br>白马寺的高僧们围着圣典《四十二章经》，一心求着佛的救赎，官军不知何时放出火矢，燃起了熊熊烈火，不小心也点燃了佛教传入这个国度最初的经典，顷刻间化为灰烬<br>僧侣们悲叹起来<br>“这就是末世吗？”<br>在这最后时刻，众僧尼已经做好了死的觉悟，但是，金山大师并没有放弃生的希望，舞动的般若雷，正是他的意志。旁边的鲁智深挥舞着禅杖，虽然被团团围住，但是他没在后退，脚就如定在地上一般<br>鲁智深等人站在最前面，承受着大军压境的巨大压力<br>龙门石窟旁卷起惊涛骇浪<br>“禁军已经上岸了！”<br>继先锋五千的洛阳军，一万名禁军登录伊水北岸<br>在对岸，还有一万五千道士军待命<br>莫志为了寻找退路而仰望着山顶，如果有机会爬上山的话大概还有机会逃命，就在这个时候，他好像看到了什么<br>悬崖上出现了“宋”的旗帜<br>“这里还有敌军出现吗？”<br>甚至伊水下游袭来的船队，也打着“宋”的旗帜<br>“敌人的援军！”<br>这回莫志彻底的绝望了，如果是官军的援军到了，那毫无疑问是节度使“药师”徐京和“老风流”王焕的军队——那些节度使终于响应了出征的命令<br>莫志慌了神，赶忙找到作为最后希望支柱的金山大师<br>金山大师沉吟不语，般若雷掷地有声<br>身后的巨大的卢遮那佛，仍然保持着慈悲的微笑<br>（大概就要终结了吧）<br>莫志仰望着卢遮那佛<br>打破不杀生戒的自己，是会得到宽恕还是最终会堕入地狱的轮回，那样的话，金山大师和天穹和尚都一样的<br>最终一起堕入地狱<br>莫志只求一死，手中握着最后一支箭，把箭头抵在脖子上，莫志看了看史进，又看向了鲁智深<br>（都要下地狱了，那个和尚怎么还在笑）<br>鲁智深兴高采烈的战斗着，血的殷红，背上牡丹的鲜红，健壮的肌肉闪耀着耀眼的光芒。他发出响彻四方的呐喊<br>“定能取胜！都爬起来，爬起来打倒他们！！”<br>本打算一死了事的莫志停了下来，一幅震惊的画面映入本要放弃的眼睛中<br>（那是流星吗——）<br><img src="http://10.28.0.10/cache/11/04/suikoden.com/9933f36c14c4de49cb87ecc5b5cb51c0/108%20Outlaws-135.jpg" alt="feijian"><br>苍穹之中，看到了五道闪耀的光芒，他马上意识到那是箭，这五支从天而来的箭，在空中画出五道美丽的银线，五名官兵中箭而倒<br>莫志发现那是从下游杀入的船队射过来的，一个壮年武者精神抖擞的站在船头。秀丽的身姿，华丽的甲胄，还有那手中朱红色的弓<br>（那是！）<br><img src="http://10.28.0.10/cache/2/04/suikoden.com/e7dec8aea56ec6a6b0232e1734330c39/108%20Outlaws-136.jpg" alt="huarong"><br>梁山泊席位第九，绰号“小李广”，正是花荣，爱弓朱雁的弦正在清吟着，花荣再次放箭，又有五个官军倒下。下游的船队一个个的靠岸了，上来的“宋军”，袭击了到达北岸的禁军，冲在最前面的是挥舞着双板斧的黑大汉<br><img src="http://10.28.0.10/cache/5/04/suikoden.com/0bd826d5518146cc56cf2d56f8976dcf/108%20Outlaws-137.jpg" alt="likui"><br>“黑旋风”李逵，梁山泊席位第二十二，是专为杀人而生的天杀之星<br>山上下来的“宋军”也向北岸的洛阳军发起攻击<br>“冲上去！”<br><img src="http://10.28.0.10/cache/7/04/suikoden.com/d30bc494ac015c39b25092476a6db865/108%20Outlaws-138.jpg" alt="wusong"><br>从山上打着“宋”的旗号新加入战场的军队，领头的是“行者”武松，他正是江湖上赫赫有名的在景阳冈打虎的壮士，接下来是清风山的头领，“锦毛虎”燕顺，以及“打虎将”李忠的结拜兄弟，桃花山上的好汉“小霸王”周通，他们向着正在袭击手无寸铁的僧尼的洛阳军发起了冲锋<br>驾船而来的，正是“立地太岁”阮小二，“玉幡竿”孟康，光着膀子的汉子们陆续从船上下来，船头，作为“向导”的“鼓上蚤”时迁挥着胳膊，给同伴发出信号<br>“赶上了！！”<br>原来这些打着“宋”的旗号的军队，正是在山东秘密集结的梁山泊军<br>岩山上也出现了旗帜<br>石窟东面的岩山上，出现了一支骑兵队，一个禁军军官举着剑<br><img src="http://10.28.0.10/cache/6/04/suikoden.com/1874bd111eb51e219230c68cc65cf2c2/108%20Outlaws-139.jpg" alt="yangzhi1"><br>官军的援军——可是鲁智深却制止了打算迎击的武僧们<br>“等一下”<br>鲁智深很熟悉那张脸，覆盖半张脸的青斑是不可能弄错的——“青面兽”杨志<br><img src="http://10.28.0.10/cache/3/04/suikoden.com/6df497cbd875a186fc0efe8774f64b01/108%20Outlaws-140.jpg" alt="yangzhi2"><br>梁山泊席次第十七，正是传说的英雄“杨无敌”杨令公的子孙，手持家传宝剑吹毛剑的无双剑客<br>杨志展现着当年那个“杨制使”的身姿，身边率领的军队脱下官军的伪装<br>而右边站着的，是“金枪手”徐宁<br><img src="http://10.28.0.10/cache/9/04/suikoden.com/6c0b21ed94fa719b6f21e936050f7e8b/108%20Outlaws-141.jpg" alt="xuning"><br>梁山泊席次第十八，本是禁军中金枪班的教头，是钩镰枪的传承者，身着祖传宝铠“賽唐猊”的英豪<br>左边的是梁山泊席位第十五的“风流双枪将”董平，背后挂着书写着“英雄双枪将”，“无双万户侯”的旗子，手持着标志性的双枪<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-142.jpg" alt="dongping"><br>他是一个自负文武双全的英俊<br>二人华丽的甲胄，正在战场上闪耀着<br>他们分散着离开梁山泊，向西行进，途中从官军那里夺走伪装，根据“智多星”吴用料事如神的智谋，又有两山泊完整的情报网，“梁山泊军”就在这个恰当的时候出现了<br>狼藉的战场上空，一只乌鸦正在空中盘旋，“锦豹子”杨林把分散出动的梁山泊同伴们引导到此<br>“看来重要角色已经到齐了，那么好戏就此开场了”</p><p>梁山泊的骑兵从山上冲刺而下<br>这个时候，史进也觉察到了战场上形势的变化<br>“那边，卢员外也到了吗？”<br>殿军的将领，正是坐第二把交椅的“玉麒麟”卢俊义，曾经是大名府的富豪，也被人称作“河北三绝”，本身也是武艺高强，养子“浪子”燕青，正拉着马嘴<br>卢俊义抬头看着由侯健缝制的“宋”的蓝旗<br>本来，宋军的旗帜为红色，相传宋国的本命颜色便是红<br>这里的“宋”指代的是梁山泊头领“及时雨”宋江的“宋”<br>那是比蓝天还有蓝的旗帜<br>“很不巧宋江大哥很忙，准备上吧，燕青！”<br><img src="http://10.28.0.10/cache/8/04/suikoden.com/29c2f72158b1ac58e62f704c8299febe/108%20Outlaws-143.jpg" alt="lujunyi"><br>“交给我吧”<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-144.jpg" alt="yanqing"><br>燕青扛着旗子从山上跑下来</p><hr><p>这个时候，石秀感到视野一片模糊，眼前一片重重叠叠的景象<br>“能看见路了！”<br>如同阳光照在阴暗处一般，道路出现在密集的丛林当中<br>“可以继续前进了”<br>石秀跑了起来，他早已经听见了战场的喧嚣声，心急如焚<br>“等一下”<br>李忠想要阻止他<br>“这是幻想吧”<br>“那也顾不上了！”<br>陈达追着石秀，石秀就在一片晃动的视野中狂奔着<br>突然，眼前出现了几个黑衣道士，众人都手持铜剑<br>“敌人！”<br>石秀挥手就要砍，道士也开始迎击，顿时火花迸溅，视野突然一片晃动，听见了一个老者的声音<br>“你看错了，我们不是敌人”<br>石秀停了下来，道士们也四下散开<br>“看破！”<br>道士们跳向树梢，用剑尖刺穿了贴在树干上的咒符。这是用血写的咒符。一个白胡子老者出现在一脸茫然的石秀众人面前<br>“结界削弱了……这都是幻术，你们不要惊慌了”<br>石秀盯着老者<br>“你是哪里来的？”<br>“贫道来自华山”<br>华山是河南道教的最高峰，他们是山里的无醉长老以及被唤作“华山十子”的众弟子，他们因憎恨林灵素的恶行，特地赶到这里支援<br>无醉长老高举着拂尘，挥去了头上的虚空<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-145.jpg" alt="wuzuizhanglao"><br>只见无数燃烧的符咒纷纷落地，突然间，视野犹如被清洗过一般明亮起来，森林终于有了尽头，道路展开了，远处，可以看见林灵素的太极旗在飘扬<br>石秀情不自禁的笑了<br>“你们也是道士吧？”<br>“‘德不孤，必有邻’——这是儒教的一句话，‘正义’无门”<br>“这样的话就不和你客气了”<br>就这样，石秀等人穿过丛林，向着道士军的背后发起奇袭，林灵素的本阵，被一万五千道士军团守护着，这些人基本都是武者和军人出身的野心家，为了投机，投身于道教<br>他们也发现了北岸事态的变化，但是并没有动摇，只要保护好林灵素，即使洛阳军，禁军全灭，取胜也没什么问题<br>“敌袭，保护‘通真达灵元妙先生’！”<br>金甲道士们迎击石秀众人而上，走在前面的是一个军人出身的壮汉，他出身于军中，手持大刀，看了看石秀众人<br>“就这么些人吗？一口气消灭掉吧”<br>石秀咂了咂舌，本来他们的目标是以少量兵力引起敌方本阵的混乱，然后趁机偷袭林灵素，现在可倒好，周围都很明朗，石秀等人光天化日之下，实力被看的一清二楚<br>为首的壮汉嚎叫着挥着大刀发出进攻，然而，他正在叫唤的头猛的飞在空中<br>石秀一惊，紧接着冷笑起来<br>将此人斩首的是一个面呈菜色的独臂男子<br>梁山泊席位第三十二——石秀的义兄，薊州的“砍头杨雄”，正是“病关索”杨雄<br>“让你久等了，石秀”<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-146.jpg" alt="yangxiong"><br>“我可是一直在等着啊”<br>杨雄和石秀并肩杀入道士中<br>道士们突然乱了起来，这些自称“六甲神兵”的一万五千道士，基本都是“临时道士”，一看对面攻势凶猛，根本就没想过作战，他们不过是借此机会接近林灵素<br>道士们一哄而散，众人也不知道是什么情况，只是感觉一片混乱，觉得被大军奇袭了后方，石秀杨雄等人奋勇作战，再加上华山道士们的支持<br>“这是大军的奇袭！”<br>“我们中出了叛徒！”<br>官军动摇的情况，也传到了北岸作战的金山大师和史进那里<br>金山大师向着陷入迷茫的众僧人大喝一声<br>“勿失战机！”<br>大师鼓舞着众人，进行反击，般若雷轰鸣着，向敌人迈出一步<br>可那一步却未能迈出，有人从背后刺了一剑，“张神剑”大叫起来<br>“是那个混蛋”<br>叛徒满天星混入了信徒当中<br>“赶快把《精武大宝经典》给我交出来”<br>金山大师踢向背后，可是满天星却犹如妖狐一般闪身到了金山大师身前<br>“《精武大宝经典》到手了！！”<br>满天星抓着法衣的领子，正准备砍向金山大师，可他的刀，却被一根棒子止住<br>“我‘九纹龙’当你的对手”<br>“你打不过我的”<br>史进飞快的旋转棒子，向满天星发起攻击，这边满天星也不示弱，挥刀向着史进正面砍去，史进避开了满天星的大刀，向后纵身，虽然紧紧握着棒子，但是由于满天星的大刀挡着，无法发起攻击<br>“你赢不了的！”<br>满天星又使出一层力，突然间，一阵风起，满天星停了下来<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-147.jpg" alt="shijin2"><br>“夕照流星”——史进的棒子贯穿了满天星的胸口<br>就这样，满天星倒在了金山大师脚旁<br>大师从倒下的满天星手中拿走一卷古老的经典<br>“你了解这个吗？”<br>“这是武林宝典……上面写了制霸天下的秘籍？”<br>“正是”<br>大师把秘经按在额头上<br>“这是在敦煌沙漠中发觉的天竺经典，是磨砺灵魂 ，锻炼身体，提升悟性的宝典——那个时候武人还是一无是处”<br>满天星在地上微微呻吟，大师语速平缓，继续说道<br>“无明无尽——没有武力高下，岂有强弱之分？你这么想看，就给你看看吧”<br>“那些最终断绝消息的武者？”<br>“他们最终都选择了落发为僧”<br>满天星用空洞的目光望着史进<br>“梁山泊的‘九纹龙’……受教了，亦无遗憾”<br>金山大师合上了已经断气的年轻人的眼，沉吟道<br>“这世上还没有能领悟《精武大宝藏经》的人啊”<br>般若雷从大师手中脱落，脚下已经鲜血如柱。</p><p>战斗还在继续着<br>史进抓起一匹马，跳上马背，向着伊水河奔去<br>“林灵素现在何处？”<br>踏着水花跃上南岸，就可以看见林灵素的本营，已经受到了石秀等人的袭击，太极旗已经倾斜，可以看见众官军将领正在守着两个道士，一个身着潇洒的道服，另一个头上裹着布<br>史进朝着道士看去<br>“那是林灵素！”<br>就在这时，怪道士从衣服下面投出弯刀，史进躲开弯刀，向着林灵素砍去<br>听到了石秀的声音<br>“史进，注意后面！”<br>可是为时已晚，本来飞出去的弯刀，又折返回来，已经可以感受到刀锋的迫近，却又无法防御，就在史进马上就要被割断喉咙的时候，不知从哪里飞来一只棒子，敲到了弯刀<br>史进看见了那根飞来的棒子<br>（师父！）<br>可是，四下里敌我混杂，找不到那个身影</p><p>太极旗轰然折断<br>林灵素慌乱的叫了起来<br>“这些是什么人，现在什么情况？”<br>只见一个黑大汉双手持板斧，犹如暴风雨一般迫近，林灵素胸中燃起了无名的怒火<br>（这些贱种，又怎么能杀了我！）<br>林灵素手抓着背后安坐在莲花座的怪道士<br>“想些办法吧！！”<br>林灵素双手抓住怪道士的头<br>“把他们杀掉！”<br>在说出这句话的同时，不知哪里来的强大邪恶力量，从林灵素的口中流入体内，一股漆黑的力量萦绕着林灵素的身体，禁锢着灵魂，阻断了自由<br>林灵素呆住了，感受到了某种“存在”，怪道士正充斥着他的身体<br>（你——）<br>林灵素自称道士，但是他深知所谓法术不过是障眼法，但是此时此刻他清楚的感觉到了自己已经成了那个法力的奴隶<br>林灵素头顶生出一道青烟，天空中出现了一个巨大神灵的身影，只见他身着蓝衣，双眸闪烁着群青色的光芒。那是冷酷的杀戮之光。手上握着触天长冰杖，风雪呼啸。道士们胆战心惊地叫出了那个名字。<br>“青华帝君！”<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-148.jpg" alt="qinghuadijun"><br>是拥有无穷神力的万能之神，只要遵循，就无所畏惧<br>只见他默默抬起双眼，那个神的面孔，正是“通真达灵元妙先生”林灵素，身边的六甲神兵突然放出光芒，本来在战场节节败退的他们，突然发起了猛攻<br>而这背后真正的支配者，正站在“青华帝君”的头上，怪道士——“金华魔人”包道乙——终于显现出真正的力量<br><img src="http://10.28.0.10/cache/13/04/suikoden.com/03e886f278bb8b76e6feea2533f6b1f6/108%20Outlaws-149.jpg" alt="baodaoyi"><br>“你不是想成为神吗，那就把身体献给‘力量’吧”</p><hr><p>僧侣们纷纷抛下武器，伏在地上<br>战斗中的僧侣知道自己距离地狱的轮回已经不远了<br>终于来“迎接”他们了<br>不是乘着七彩云彩而来的菩萨，而是踏着火焰的恶鬼<br>“佛法将尽，世界将末”<br>随着“青华帝君”的出现，六甲神兵的大军也渡过伊水<br>他们目睹着卢遮那佛在烈火中燃烧，身体已经崩坏，僧侣们四下奔逃，诵经声已经变成了悲鸣，僧侣们已经走到临头<br>“大师啊，救救我们吧”<br>金山大师是众人最后的希望，用法力和武术来阻止这个恶魔神吧<br>年轻的见习僧人莫志也默念着经文，手中握着弓箭，母亲的希冀，龙门大禅师的教诲都在心中，可是，眼前的生命却无法挽回<br>救济众生的弥勒佛降世，那已经是五十六亿七千万年后的事了<br>【《菩萨处胎经》：“弥勒当知，汝复受记，五十六亿七千万岁于此树王下成无上等正觉。”】<br>莫志咬紧牙关，瞄准“青华帝君”的眼，放了一箭，不过，他只是张了张嘴，箭就像树叶一样被吞没了<br>护卫伤者的“张神剑”，已经被人砍断了腿倒下了<br>“青华帝君”拄着拐杖，向卢遮那佛前进。<br>就在这时，金山大师站了出来，挡在前面<br>“退下，天魔”<br>没有兵器，没有扈从，只是张开手掌，伸出双手<br>“青华帝君”的手杖刺进了他的胸膛<br>史进感觉周围突然变的一片昏暗，鲁智深看着天空，噼里啪啦的迸发出火花<br>一瞬间，所有人的呼吸都止住了<br>所有人所发出的情感——恐惧，已经到了极点<br>突然一个大爆炸，雷声轰鸣<br>什么也听不见了<br>那是覆天盖地，前所未有的轰鸣</p><hr><p>雷鸣撼动了天空<br>林灵素的意识，被包道乙支配着，只知道自己化身“青华帝君”，正向着金山大师发起攻击，不知是谁喊了一句<br>“林灵素杀死了金山大师！”<br>林灵素感到支配自己的包道乙微微一笑，同时，他也感到了无数人的愤怒<br>这些愤怒横穿天空，撕裂了风，化作落雷冲入金山大师的胸膛，金色光芒四散，闪耀在整个龙门<br>光芒在旋涡中回旋，金山大师所释放的光芒，不断流转，竟化身为龙，龙猛的跃起，缠绕在石窟中毘沙门天像上<br>“啊……!”<br>人们屏住呼吸<br>毘沙门天突然睁开了眼睛<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-150.jpg" alt="pishamentian"><br>只见神王双目燃着怒火，龙化作神火，缠绕在剑上，燃起的火直冲天空，毘沙门天正在行进着。【真神仙打架】<br>左手端着宝塔，右手拿着剑，就这么从悬崖上跳了下来，注视着“青华帝君”，“青华帝君”已经准备好逃走，却被从乌云中涌出的黄金魔人挡住了去路<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-151.jpg" alt="sharu"><br>毘沙门天挥舞着剑，向着失去退路的“青华帝君”的头顶砍了一刀，直至鸠尾。<br>“青华帝君”的蓝色身体开始剥落，里面是一片虚无，在这片虚无中，一朵莲花开始绽放<br>莲花向着四周发出金色光芒，茎正在慢慢的延伸，直达天际，伴随清脆的响声花开了，盛开的莲花顶端，出现了一个白眉白须，满面慈爱笑容的老神仙，道士们看着手中的拂尘，七寸的耳朵，额头三道皱纹，不禁叫出声来<br>“道德天尊——太上老君！”<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-152.jpg" alt="taishanglaojun"><br>正是道教的先祖——老子，化身神仙的身影<br>毘沙门天又开始行进，举着宝塔，卢遮那佛崩塌了，从碎石中，浮现出正在安详微笑的圣者释迦的身姿，坐在黄金莲花上，只见他飞向空中，在七彩云彩的伴随下，和老子并排而坐<br><img src="http://10.28.0.10/cache/9/04/suikoden.com/87d37bcb724215de9baeee34c784ecd3/108%20Outlaws-153.jpg" alt="shijia"><br>两人都是圣母诞下，历经凡人的坎坷，最终化身为神的人<br>抬头仰望着被光环包围的二尊的人们，恍惚间听见了仙女和天人演奏的乐曲<br>敌我无言</p><hr><p>“入云龙”公孙胜伫立在云雾缭绕的岩山之巅，虽然双目紧闭，但是脑海中“怪道士”包道乙的身姿却异常清晰<br><img src="http://10.28.0.10/cache/4/04/suikoden.com/46daee42760df523f41608cde06b3e1c/108%20Outlaws-154.jpg" alt="gongsunsheng"><br>（外法道士——已经死了吗？）<br>包道乙被公孙胜猛烈的法力所击倒，吐血而卧<br>公孙胜收起龙杖，转过身去<br>法力在空气中消散，包道乙终于可以活动了<br>他刚才在屏住气息装死<br>（这是二仙山的森罗万象之气）<br>但是，却还有一个气息<br>（暗中做法操控黄金魔人的……）<br>所谓二仙山的法戒，应当是容不下相异的外法的<br>包道乙只觉得自己里力量全部消散了，有人，不，周围的一切夺走了他的气<br>这种力量的真实面目是在金华山修行的老道，因为有着优秀的潜质，为了追求终极的法力，故涉猎了外法，他的力量，并不是天然的气，而是根据人心增幅的力量<br>身旁，觉得“怪道士”的法术更好的林灵素慌了神<br>“跟这种法力相比，你实在算不得什么啊”<br>包道乙匍匐着，混在重叠的尸体中逃走了<br>二仙山的术，才是真正的法术，并不是映照人内心的恐惧，而是实际存在的自然之气，通常可以感觉的到，只不过人们熟视无睹<br>那是只有达到“无我”境地，与世界融为一体才可以驾驭的力量<br>（必须赶紧逃走了，罗真人看不了那么远，向南……然后）<br>怪道士眼中发出怪异的光芒<br>（需要更强大的依附）<br>更加强大的人——</p><hr><p>林灵素清醒过来，站起身来环顾四周<br>（是一场梦吗？）<br>不知不觉，神佛已经消散不见，地上的人们呆立着不知所措<br>大家都莫名其妙的忘了自己要做到事<br>梁山泊的好汉，也莫名其妙的消失了<br>这个时候，石窟的上方，岩山的顶端，出现了色彩鲜艳的旌旗，是皇室的龙旗，举着旗子的仪仗走了过来，郎朗的声音在空中回响<br>“奉天承运，皇帝诏曰——众人下跪受旨”<br>这是一个让人难以相信的声音，压过了战场的喧嚣，响彻四方<br>在场的数万人，无论远近，听得一清二楚<br>岩山上，皇帝的亲卫军排起了长队，那是青年将校曹晟率领的五十轻骑，全是华丽的金吾卫装束，不过，却显得一片灰尘，他们是从东京疾驰而来，赶赴龙门<br><img src="http://10.28.0.10/cache/7/04/suikoden.com/26f0ed771dbb82b3743064b7a1ce8f1e/108%20Outlaws-155.jpg" alt="qinweijun"><br>曹晟身边并排的是金奴公主——银树。史进等人也没能马上认出来，并不是因为扎着头发，穿着公主的装束，而是因为被禁卫军环绕的银树，脸色苍白，一脸刚毅<br>身边白马的侍从，正是发出响彻千里的声音的人<br>“荣德公主殿下！”<br>在众人的注视下，银树在曹将军的帮助下从马上下来，就这样强支撑这身体，向着悬崖边走去<br>她深吸一口气<br>“战争，已经结束了！”</p><p>接着侍从的声音响彻天地<br>“废佛令停止了，赶快放下武器！”<br>银树双手拿着诏书，这是盖有皇帝玉玺的亲笔诏书<br>她的眼睛在战场上徘徊，在数万人中，寻找着那个熟悉的身影，她发现了正在叫唤的太白<br>“薛永，还活着！”<br><img src="http://10.28.0.10/cache/8/04/suikoden.com/0b485f6f0ecf17ce5106c67cff642240/108%20Outlaws-156.jpg" alt="xueyong"><br>银树大声的呼唤着那个名字<br>“薛永！”<br>薛永虽然受了伤，但是听见银树的声音，猛地站起身来<br>那时，他为了守护银树，孤身一人与追兵战斗，就在战斗到极限时，薛永发现自己并不是一个人——铁锹，铁算盘，铁笛，铁棒，保护着薛永<br>“——黄门四怪！”<br><img src="http://10.28.0.10/cache/11/04/suikoden.com/2aba100ebee3c2a8d8c5db4e50dc06c6/108%20Outlaws-157.jpg" alt="huangmensiguai"><br>“九尾龟”陶宗旺、“神算子”蒋敬、“铁笛仙”马麟、以及“摩云金翅”欧鹏，默默无言的战斗着<br>记忆逐渐模糊<br>回过神来，薛永正在陶宗旺的马上，马麟正在给他疗伤，告诉他他们正要前往龙门<br>银树正在招手，一切都不是幻觉！<br>公主身边的侍从，是“铁叫子”乐和，银树的侍从，正是梁山泊——不，应当说是整个大宋嗓子最好的“铁叫子”乐和<br>他受吴用之命接近王都尉，为了解救智真长老而四处奔走<br>一行人中，也有作为传令在东京和梁山泊之间奔走的“神行太保”戴宗<br>（梁山泊的众兄弟救了银树）<br>薛永凝视着彼方的银树，目光如炬<br>公主庄严华丽的打扮，佩戴的珍贵宝石，真的好耀眼，还有那温暖人心的笑容<br>（太好了！）<br>虽然这样想着，却好像看见了幻象，薛永也无法回首</p><p>林灵素只感觉世界一下子崩塌了<br>只觉得一片空虚，脚下隐约有黑暗的深渊张着嘴——明明自己没有施展过法术，却看到了那种幻影<br>郭道士赶到林灵素身边，得知事情有变，他火速赶了过来<br>“‘通真达灵元妙先生’，接下来如何？”<br>“——杀！”<br>林灵素听到了自己心底的声音<br>“公主也好，金吾卫也罢，统统杀掉吧”<br>然后再把责任归结于“叛军”，自己再率军平定他们<br>直到现在，林灵素都还没有认清形势，更没有看透自己。也许耳边慕容贵妃的声音正在回响<br>金吾将军曹晟对林灵素不放心，于是让手下侍卫护卫金奴公主<br>“林元帅，赶快下达撤军的命令”<br>林灵素冷冷的看着曹晟，只有五十护卫，听命林灵素的道士军团“六甲神兵”还残留着数千人<br>这个时候，两个密探赶了过来，一个是催促节度使出兵的使者，另一个是监视慕容贵妃的密探<br>一个使者告诉他<br>“王焕已经离开了宅邸！”<br>“现在才赶过来吗？”<br>“身边的随从都在念着‘南无阿弥陀佛’”<br>“什么？”<br>监视慕容贵妃的密探向困惑的林灵素又低语道<br>“慕容贵妃已经越过国境，到达辽国，辽国大军已经在沙漠中布阵了”<br>面对意想不到的报告，林灵素终于反应过来<br>密探之所以这么迟，是因为慕容贵妃去了辽国<br>（那女人成了辽国的走狗吗？）<br>这下就全都能说通了，猫儿一直催促节度使发兵的理由也能理解了，守卫边境的节度使一旦出动，辽国就有机可乘<br>（大宋若亡，成了国师又有什么意义）<br>林灵素终于做出了正确的选择<br>“——贫道林灵素受旨”<br>他仰望着金奴公主，跪了下来</p><p>战斗已经结束，道士们扔下武器<br>银树把后续事情交给曹将军处理，急忙赶到临终的金山大师身边<br>银树在东京时，她跟随王都尉到了艮岳，银树提到了关于慕容贵妃的事情，王都尉马上意识到还有比“法难”更加严峻的事，他同时收到了辽军在山西边境活动的报告，如果节度使受命镇压“叛乱”，那辽军就要攻过来了——向皇帝进言速做决断<br>皇帝选择相信自己的女儿<br>听闻了金山大师并没有反叛之心，他放心了<br>此时大师正躺在地上，周围有僧侣守护着，银树紧紧地握住金山大师的手，已经冰凉，她靠近大师的耳朵，把一切告诉他<br>“废佛已经停息，马上将在全国范围内下令，智真长老也平安无事”<br>听完银树的话，金山大师也终于走到了生命的尽头<br>没有什么奇迹<br>不见百只翔鹤，也不见七彩祥云<br>只是人们感觉到了河畔吹来的清爽的风，注意到阳光下焕发的生机<br>一只白鸽悠然的飞过天空<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-158.jpg" alt="baige"></p><hr><p>与此同时，山西代州郊外，国境附近<br>天空中一直海东青正在盘旋，那是来自北方的猛禽<br>面对视线南方围堵的长城，辽国大贵族，大将军兀颜光目光锐利<br><img src="http://10.28.0.10/cache/3/04/suikoden.com/e1281a84b654852da0ac1ab6fe167e82/108%20Outlaws-159.jpg" alt="wuyanguang"><br>风沙中行进的那人，是一个金发碧眼的壮汉，身着厚重的盔甲，正在马上等着“回报”<br>正在焦急的等待着狼烟升起<br>他的身后，是契丹的三万精锐骑兵<br>他们计划一看到信号，就攻入雁门关，越过长城，侵入山西，南下方向有五台山，这一带由于智真长老受难，反宋气焰日益高涨，举着“护法”的旗帜，进攻起来应该很容易吧<br>防守的关键，是两个节度使，太原的“药师”徐京和洛阳的“老风流”王焕。辽军是不怕宋军的，虽然数量和装备都占优，但是士兵怯懦，即使百人，也不敌契丹一骑<br>（但是，“节度使”可是不一样的）<br>徐京，王焕两个猛人养出的兵士，一直坚定的阻挡着辽国的进攻<br>现在这两人应该已经发兵龙门了<br>兀颜光所等待的，就是“节度使已经出兵”的回报<br>若是他们不在驻扎地，就立刻发起攻击，打下太原府，然后向西与后续部队会和攻下洛阳，就可以将宋国的西面纳入怀中，周边是西夏，大理，吐蕃等佛教国家，应当会支持“救佛”这个大义名分<br>（宋国的幼稚皇帝是真的愚蠢）<br>当然，辽国也是佛教国家，从皇帝到平民都是虔诚的佛教徒，兀颜光受辽国皇帝之命出征，发起一场救济僧侣和扩张领土一举两得的战争<br>一个探子疾驰而来<br>“报！”<br>探子在兀颜光面向跪下<br>“徐京，王焕两节度使并没有发兵的迹象”<br>探子汇报了侦察的结果，虽然东京方面多次下令出战，但两个节度使却迟迟没有出兵<br>兀颜光一脸沮丧<br>（可惜了，看来那个女人也立不了功了）<br>不久，又有探子回报龙门的战斗已经结束，法难也已经结束的消息<br>兀颜光注视着军队后方，一群青衣侍女护卫的马车，也许是已经察觉到情况有变，正要撤离<br>不知何时，这个女人出现在辽国，凭借其美貌和才能进入宫廷，现在已经上位到出入朝廷的地步，但是她的来历依旧成谜<br>兀颜光回转马头<br>“虽说是场面话，但两国尚有盟约，被宋军盯上了就麻烦了”<br>兀颜光拔出宝剑<br>“全军，撤回燕京”<br>兀颜光率领辽军如风般的撤走了，西北荒野又陷入一片寂静</p><hr><p>老风流”王焕正在骑马奔驰<br>“看我一人斩杀他千名无道道士！”<br>当龙门映入眼帘时，王焕一声吼叫，止住了马<br>“怎么，已经结束了吗？”<br>王焕在马上捋着长长的胡须，手中横着爱用的长枪<br><img src="http://10.28.0.10/cache/11/04/suikoden.com/9da873729199d5184104b07f37cc9fdd/108%20Outlaws-160.jpg" alt="王焕"><br>“真是窝囊，再坚持一下就好了”<br>他的身后是一批同样长须飘飘的老者，他们身着已经褪了色的铠甲，但仍不失英勇的气概，这些人是已经卸甲还乡的老将，有的是和王焕并肩作战的战友，有的是当年他的手下，他们曾在战场并肩杀敌，虽然已经退休，但是仍然保留着当年的情报网，一得知王焕出走的消息，他们纷纷拿出已经多年不穿的战甲，重新披挂上阵，前来支援<br>石窟周边，伊水河畔，无数的尸体，僧侣和尼姑不分敌我的看护着正在呻吟的人们<br>在微笑的卢遮那佛旁边，色彩鲜艳的“宋”的旗帜合着上供的鲜花，毫无疑问，护法军胜利了<br>王焕放声大笑<br>“这是佛罚，是佛罚啊”<br>王焕亡故的爱妻，贺玲玲，是当年洛阳闻名的美女【名妓，嗯】，年轻时，某个清明，两人在白马寺相遇，从此便私定终生，但是却被某个高官阻拦，王焕沦落不得不投身山贼，但他依旧虔诚，总到寺院参拜，坚信两人一定终成眷属，最终实现了愿望<br>【出自元杂剧《逞风流王焕百花亭》】<br>他想起了薄命佳人临终遗言<br>“即使战乱，也不要毁坏佛寺”<br>他拿出爱妻遗留的梳子<br>“我王焕，即使对君不忠，也不会违背和女人的约定”<br>王焕的白须在空中飘扬，哈哈大笑<br>国家无道，便落草为寇，这种念头，从青春之日就不断在王焕心中生长<br>“那么。就回去吧，女人们该担心了”<br>“只要将军一句话，即使奉上白发首级，我等也在所不辞”<br>即使节度使未出兵支援，即使王焕“秘密叛逃”，这次也没有任何人前来问罪<br>之后，王焕命令这些曾经的部下前往那些堆满了金银的道观征收“保护费”，重建被烧毁的诸寺<br>法难结束，害怕寺院报复的道士们，都纷纷表示“合作”</p><p>伊水岸边，孟康的船停泊着，等待着归来的客人<br>“铁叫子”乐和已经上了船<br>在这不算太热的初夏时节，乘船出游大概是一件美事，乐和本想放声歌唱一曲，但是想了想却又作罢<br>龙门的战场，还有无数的生命正在飘忽不定的闪烁，各种各样的想法交错，他不知道应该唱一首什么样的歌<br>取而代之的是，他向着河岸的石秀打了声招呼<br>“石秀大哥还不打算回去吗”<br>“哥，你怎么说”<br>石秀问坐在身边的杨雄<br>“洛阳不是大哥的故乡吗，要不顺道去看看吧”<br>“不，不用了，这一道下来太累了，我已经受够了”<br>“那咱们就回去吧”<br>石秀背着杨雄，猛地跳上了船，水花飞溅，孟康嘟嘟囔囔的发了句牢骚<br>“船夫哥，赶快开船吧”<br>石秀一身疲惫的躺在甲板上<br>船离开龙门<br>风景渐行渐远，但蓝天依旧湛蓝</p><p>史进手持小木龙，仰望着石窟<br>“——那我们就回去了”<br>“张神剑”拄着一把枪，牵着一匹失去主人的军马，手下也有几人幸存，也还带着从达摩堂领来的赏钱<br>“虽然这次很亏本，但想来可以和子孙后代炫耀，也还算不错”<br>“张神剑”举着长剑，那正是他绰号的由来<br>“再见了，‘史进’”</p><p>史进在僧侣和石窟之间寻找着，但是不见木龙行者和王进的身影<br>在一个无人的小石窟中，刚好可以容纳一个木龙，石窟的佛像正在雕刻中，脸还没有刻好<br>“这就是师父”<br>史进相信王进就在龙门<br>“好像又离开了”<br>李忠一脸疲惫的走向史进<br>受伤的脚上缠着布，李忠安慰道<br>“你已经掌握了师父的一切本领，如果没什么可教的了，师父自然会默默离开”<br>“再也见不到他了吗？”<br>“所谓‘恩师’，大抵如此”<br>陈达杨春也过来了，带着从道士和官军那里的战利品，陈达怀里鼓鼓囊囊<br>“给朱大哥带上一份土特产，回去就没那么多说教了”<br>“土特产的话，还有更好的哦”<br>大家朝着伊水岸边望去<br><img src="http://10.28.0.10/cache/10/04/suikoden.com/68be8fd8e1b7950e5b3dae5a3fb275c2/108%20Outlaws-161.jpg" alt="123"><br>蓝天下，两人（一狗）的身影，如画一般</p><hr><p>“父亲已经准许我不用再当尼姑了”<br>银树抓着薛永的手，公主的打扮，楚楚动人<br>“薛永，你也不用当什么艺人了，我已经拜托父亲，让他封你为将军”<br>薛永笑了笑<br>“这个”<br>他解开挂在脖子上的玉护符，挂在了银树脖子上<br>“给我吗？”<br>银树笑靥如花，薛永却转移了视线<br>“看，大家都在等着你呢”<br>银树松开了薛永的手<br>“是啊”<br>她作为“特使”很忙，除了战后的善后工作，还要为彭尼等伤员请来太医，并命令侍从准备金山大师的灵柩，也派遣曹晟将军寻找慕容贵妃<br>但是，不可思议的是，银树已经不那么在乎她了<br>那个坏人，是不可能善终的<br>“薛永，你在这等我，随我回东京”<br>“嗯”<br>“一定”<br>“嗯，一定”<br>银树被众多护卫守卫着离去，回过头了，笑着挥手<br><img src="http://10.28.0.10/cache/2/04/suikoden.com/de31347ab8003e995324af63ef2ed88c/108%20Outlaws-162.jpg" alt="yinshu"><br>“好汉不会说谎的”</p><p>史进呼唤着在岸边发呆的薛永<br>“嘿，美男子”<br>“史进大哥”<br>“你喜欢吧”<br>“不要再拿我开玩笑了，人家可是……”<br>薛永自顾自的说着<br>“可是堂堂的公主”<br>史进抓住薛永的手腕<br>“这样那咱们就绑她上山”<br>“什么？”<br>“赚她上山，然后你娶了她”<br>薛永沉默不语，两人哈哈大笑<br>船正在岸边等着，史进向着船走去，薛永也跟了过来<br>“史进大哥找到师父了吗？”<br>“啊，见到了”<br>史进握着木龙，抬头仰望着龙门的蓝天<br>他看见彭尼被人，手中握着一朵鲜艳的红曼珠沙华<br>史进深吸了一口凉爽的河风<br>“回去了!”<br>阮小二架着船离开了岸边<br>岸边的石佛们微笑着送一行人离去，薛永一直望着龙门，望着已经快要消失的银树的身影<br>声音已经传不到了<br>可是那笑容，却照亮了七里的距离<br>“再见，祝你幸福”</p><hr><p>在混乱的人群中，莫志寻找着史进<br>莫志手中拿着天穹和尚赐予的弓——“破烦恼宝弓”——不管天穹和尚是怎么想的，这个弓至少解开了年轻的莫志的疑惑<br>可是却怎么也找不见史进，死伤者中也不见，叫了名字也没人答应<br>取而代之的是，莫志遇到了以前白马寺的僧侣们，他们是护卫着《四十二章经》一同前来龙门的和尚，虽然白马寺的至宝《四十二章经》已经没了，但是他们都幸存了下来<br>那些和尚盯着莫志手中的弓<br>“莫志啊，你破了杀戒，竟然没用堕入地狱？”<br>“没有”<br>莫志毫不羞涩的回答道，也不打算反驳<br>只是，他清楚的说道<br>“我已经不是‘莫志’了，我有我的志向”<br>莫志昂首挺胸，举着手中的弓<br>“我要和一切不正当战斗，用我的弓消灭一切不公”<br>并且，他也要超越“梁山泊的花荣”，成为大宋第一，不，应该是世界第一的优秀神弓手<br>年轻的射手燃着热血，抛弃了僧衣，手中握着弓，拿着沾着鲜血的《精武大宝藏经》<br>“我要还俗，恢复本名，我的本名是——庞万春”</p><hr><p>岩山之巅，立着两个怪人<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-163.jpg" alt="1"><br>是一个黑衣道士和一个三眼的异形者<br>这是“幻魔君”乔道清和他的弟子“神驹子”马灵——他们是在山西揭竿而起，自封为晋王的田虎麾下重臣，他们建立晋国，企图推翻宋的统治<br>他们混在道士中招募有用的人才，并且依仗林灵素判断打败宋的可能性<br>他们对此相当失望<br>“林灵素什么的真是不够看啊”<br>乔道清咒骂道<br>“不过是一个夸夸其谈的混账玩意，搞了这么一出无聊的闹剧”<br>“师父，方才那个怪人，是什么来历？”<br>“大概是金华山一带的邪教徒吧”<br>“咱们这次帮着宋这一边真的好吗？”<br>阻挡“青华帝君”撤退的金色魔人，正是“幻魔君”乔道清施法召唤的<br>“好不容易跑来一趟，稍微玩一下也没什么问题，话说回来，契丹若是打过来，对我们建国也没好处啊”<br>正是因为辽国窥视着山西的领土，徐京王焕的防守重点在国境，田虎也才能发展起来<br>“妄图以宋国内乱制造机会的想法还是不要再提了，果然，国运只能依靠力量，稳健派的卞祥等人大概会厌恶吧”<br>乔道清觉得，需要更强大的人入伙<br>这样想着，一个名叫包道乙的怪道士，正拖着受伤的身体匆匆离去<br>“回去吧，马灵”<br>马灵看了看天空，已经不见云彩<br>“那个毘沙门天……”<br>马灵的额头抽搐着，第三只眼可以感觉到空气中残留的“气”<br>乔道清也感受到了如此强烈的波动<br>“只怕是二仙山的五雷天心正法，不，不对，应该是公孙一清——‘入云龙’”<br>“一清道人已经入伙梁山了”<br>“即使他们打着‘宋’的旗子，也瞒不过我，那伙人就是梁山的”<br>梁山泊为何会站在僧侣这一边，乔道清也想不明白<br>（那伙人不知在搞什么阴谋）<br>乔道清只感觉后背一阵战栗，可不能惹恼了这伙人啊<br>“‘梁山泊’——还是通报‘龙公’孙安一声吧”<br>不安的风，正围着乔道清的漆黑法衣打转</p><hr><p>东京开封——中心的皇城<br>那棵树至今仍在宫中一角，已经长起来了，只是不受欢迎，被遗忘在庭院中<br>柔软的树干、艳丽的绿叶、星光般的白色花朵。银木犀的甜蜜香味在微风中散发出来。<br>银树——赵金奴，穿着公主的装束，再次站在树下<br>十年前在绝望中离开，十年后又重回起点，也看见了已经长大成人的亲哥哥，可是金奴，永德公主这些称呼，在她看来却相当陌生<br>“公主殿下，圣上有请”<br>“我问你们，有个叫薛永的，来没来”<br>金奴这一天中已经不知道问了多少次<br>“他带着只大狗……约定好回来的”<br>“公主殿下，并没有这样的人”<br>金奴告别了怀念的庭院<br>纵使闭上双眼，也再也见不到儿时的梦幻世界<br>金奴离开了没有了母亲的身影的后宫，在侍女的陪伴下，前往自己的父亲身边，身为太子的哥哥和智真长老也在那里<br>虽然智真长老因为断食而消瘦，但身体还算硬朗<br>在皇帝多次的劝说下，智真长老终于做了上座<br>皇帝为自己被人蒙蔽而道歉，慰问长老，并且安排禁卫护送长老返回五台山<br>金奴走到智真长老面前<br>她还有想要确认的事，关于无法从金山大师那里得知的自己的命运<br>“我真的是个‘不吉之子’吗？”<br>长老拿着念珠，注视着公主的眼睛<br>“‘天有三日，望月辉耀’——公主啊，你的命运，就犹如被三轮太阳一同照射般一样残酷，但是，即使被太阳璀璨的大地，也会有清凉的夜晚降临，云端之上，满月也会闪耀，不管以后发生什么，请公主柔韧，坚强的活下去”<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-164.jpg" alt="1"><br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-165.jpg" alt="2"><br>荣德公主赵金奴在宋国被金国灭亡后，就被掳到了金国，父亲，哥哥几乎所有的皇族，都成了俘虏，境遇相当残酷，在艰难的北上之旅中，不少公主，后妃丧命<br>金奴在二十五岁那年，在这场动乱中活了下来，失去了丈夫左卫将军曹晟，成了金国皇族完颜昌的侧室，但最终却在金国的政变中所杀<br>最终，以皇后的礼遇下葬，终结了波澜的一生</p><hr><p>出征河南的好汉们都回来了，梁山泊又恢复了往日的平静<br>中秋之夜，又是前头领晁盖的忌日，大家聚首聚义厅，举行着大规模的宴会<br>在山中待命的好汉们，都想听听史进这次的遭遇，就都围在史进身边，史进和大家聊着自己的各种遭遇，大家都痛快的开怀畅饮，座位上，还有一个为不在这里的人准备的酒杯<br>史进喝的酩酊大醉，为了醒酒来到外面，月亮正圆<br>湖面上，满月的影子清晰可见，薛永和太白正在那边<br>“好生快活啊”<br>听见一声感叹，薛永回头一笑<br>“的确是啊”<br>宴会仍在继续<br>史进也上前来，望着湖面上浮现的月光<br>想来师父王进，也在某处享受着一时的静谧吧<br>也一定正在享受着一杯酒，和某人一同赏月吧<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-166.jpg" alt="1"><br>宣和年间——那是大宋和梁山泊最后一个安宁的时期</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;&lt;font color=&quot;#FF0000&quot;&gt;原文作者 森下翠和插画作者 正子公也 版权所有&lt;br&gt;&lt;br&gt;个人翻译&lt;br&gt;&lt;br&gt;仅供个人娱乐及同好者欣赏&lt;br&gt;&lt;/font&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;a href=&quot;http://suikoden.com/&quot; t
      
    
    </summary>
    
      <category term="绘卷水浒传" scheme="https://www.junglezero.top/categories/%E7%BB%98%E5%8D%B7%E6%B0%B4%E6%B5%92%E4%BC%A0/"/>
    
    
      <category term="绘卷水浒传 二十周年番外" scheme="https://www.junglezero.top/tags/%E7%BB%98%E5%8D%B7%E6%B0%B4%E6%B5%92%E4%BC%A0-%E4%BA%8C%E5%8D%81%E5%91%A8%E5%B9%B4%E7%95%AA%E5%A4%96/"/>
    
  </entry>
  
  <entry>
    <title>java的String三剑客（String，StringBuilder，StringBuffer）</title>
    <link href="https://www.junglezero.top/2019/04/16/va%E7%9A%84String%E4%B8%89%E5%89%91%E5%AE%A2%EF%BC%88String%EF%BC%8CStringBuilder%EF%BC%8CStringBuffer-%EF%BC%89/"/>
    <id>https://www.junglezero.top/2019/04/16/va的String三剑客（String，StringBuilder，StringBuffer-）/</id>
    <published>2019-04-16T07:53:00.000Z</published>
    <updated>2019-04-16T08:47:27.272Z</updated>
    
    <content type="html"><![CDATA[<p>在有了不可变对象和不可变类的概念以后，就可以分析一下java中String，StringBuilder，StringBuffer三个概念<br>网上有一篇很简单明了的<a href="https://www.cnblogs.com/su-feng/p/6659064.html" target="_blank" rel="noopener">教程</a></p><h1 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h1><p>运行速度，或者说是执行速度，在这方面运行速度快慢为：<strong>StringBuilder &gt; StringBuffer &gt; String</strong><br>而原因就是在于String是不可变的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="string">"abc"</span>;</span><br><span class="line">System.out.println(str);</span><br><span class="line">str=str.replace(<span class="string">"c"</span>,<span class="string">"mn"</span>);</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure><p>有人会说，这样str不是变了吗？<br>要想解释这个问题，首先我们要知道String类属于不可变类，而它的对象属于不可变对象<br>然后看一部分replace方法的源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Replaces each substring of this string that matches the literal target</span></span><br><span class="line"><span class="comment">     * sequence with the specified literal replacement sequence. The</span></span><br><span class="line"><span class="comment">     * replacement proceeds from the beginning of the string to the end, for</span></span><br><span class="line"><span class="comment">     * example, replacing "aa" with "b" in the string "aaa" will result in</span></span><br><span class="line"><span class="comment">     * "ba" rather than "ab".</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  target The sequence of char values to be replaced</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  replacement The replacement sequence of char values</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  The resulting string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span> </span>&#123;</span><br><span class="line">        String tgtStr = target.toString();</span><br><span class="line">        String replStr = replacement.toString();</span><br><span class="line">        <span class="keyword">int</span> j = indexOf(tgtStr);</span><br><span class="line">        <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tgtLen = tgtStr.length();</span><br><span class="line">        <span class="keyword">int</span> tgtLen1 = Math.max(tgtLen, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> thisLen = length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> newLenHint = thisLen - tgtLen + replStr.length();</span><br><span class="line">        <span class="keyword">if</span> (newLenHint &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(newLenHint);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            sb.append(<span class="keyword">this</span>, i, j).append(replStr);</span><br><span class="line">            i = j + tgtLen;</span><br><span class="line">        &#125; <span class="keyword">while</span> (j &lt; thisLen &amp;&amp; (j = indexOf(tgtStr, j + tgtLen1)) &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.append(<span class="keyword">this</span>, i, thisLen).toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>可以发现，底层应用的实际是StringBuilder，而且问题的关键是，由于是不可变对象，所以一切所谓的“改变”，都会创建新的对象<br>而对于StringBuilder和StringBuffer，他们都是可变对象，因而发生改变时不需要额外创建新的对象，所以速度更快</p><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>String自不必说，因为不可变对象一定是线程安全的<br>对于StringBuffer，如果观看源码的话，会发现设计改变的操作都上了锁（synchronized 关键字）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, Object obj)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.insert(offset, String.valueOf(obj));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, String str)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.insert(offset, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而StringBuilder却没有<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(StringBuffer sb)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.append(sb);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(CharSequence s)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.append(s);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>根据其特点，可以总结出具体应用场景:</p><p>String：适用于少量的字符串操作的情况</p><p>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况<br>　　<br>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在有了不可变对象和不可变类的概念以后，就可以分析一下java中String，StringBuilder，StringBuffer三个概念&lt;br&gt;网上有一篇很简单明了的&lt;a href=&quot;https://www.cnblogs.com/su-feng/p/6659064.htm
      
    
    </summary>
    
      <category term="java基础知识" scheme="https://www.junglezero.top/categories/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    
      <category term="java基础" scheme="https://www.junglezero.top/tags/java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="java常用类" scheme="https://www.junglezero.top/tags/java%E5%B8%B8%E7%94%A8%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>多线程不可变对象设计模式</title>
    <link href="https://www.junglezero.top/2019/04/16/%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.junglezero.top/2019/04/16/线程不可变对象设计模式/</id>
    <published>2019-04-16T06:37:00.000Z</published>
    <updated>2019-04-17T02:34:08.958Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>不可变对象(Immutable Objects)</strong>即对象一旦被创建它的状态（对象的数据，也即对象属性值）就不能改变，任何对它的改变都应该产生一个新的对象。<br><strong>可变对象(Mutable Objects)</strong>：相对于不可变类，可变类创建实例后可以改变其成员变量值，开发中创建的大部分类都属于可变类。</p><ul><li>不可变对象一定是线程安全的</li><li>可变对象不一定是线程不安全的</li></ul><h1 id="官方文档对于不可变类和对象的说明"><a href="#官方文档对于不可变类和对象的说明" class="headerlink" title="官方文档对于不可变类和对象的说明"></a>官方文档对于不可变类和对象的说明</h1><ol><li>Don’t provide “setter” methods — methods that modify fields or objects referred to by fields.</li><li>Make all fields final and private.</li><li>Don’t allow subclasses to override methods. The simplest way to do this is to declare the class as final. A more sophisticated approach is to make the constructor private and construct instances in factory methods.</li><li>If the instance fields include references to mutable objects, don’t allow those objects to be changed: <ul><li>Don’t provide methods that modify the mutable objects.</li><li>Don’t share references to the mutable objects. Never store references to external, mutable objects passed to the constructor; if necessary, create copies, and store references to the copies. Similarly, create copies of your internal mutable objects when necessary to avoid returning the originals in your methods</li></ul></li></ol><h1 id="不可变对象的一个例子"><a href="#不可变对象的一个例子" class="headerlink" title="不可变对象的一个例子"></a>不可变对象的一个例子</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类是final的</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableRGB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//所有的属性都是final private的</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">int</span> red;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">int</span> green;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">int</span> blue;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Values must be between 0 and 255.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> red,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> green,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> blue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (red &lt; <span class="number">0</span> || red &gt; <span class="number">255</span></span><br><span class="line">            || green &lt; <span class="number">0</span> || green &gt; <span class="number">255</span></span><br><span class="line">            || blue &lt; <span class="number">0</span> || blue &gt; <span class="number">255</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//没有setter方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImmutableRGB</span><span class="params">(<span class="keyword">int</span> red,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> green,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> blue,</span></span></span><br><span class="line"><span class="function"><span class="params">                        String name)</span> </span>&#123;</span><br><span class="line">        check(red, green, blue);</span><br><span class="line">        <span class="keyword">this</span>.red = red;</span><br><span class="line">        <span class="keyword">this</span>.green = green;</span><br><span class="line">        <span class="keyword">this</span>.blue = blue;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRGB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((red &lt;&lt; <span class="number">16</span>) | (green &lt;&lt; <span class="number">8</span>) | blue);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这种转换的方式实际上产生了一个新的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ImmutableRGB <span class="title">invert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ImmutableRGB(<span class="number">255</span> - red,</span><br><span class="line">                       <span class="number">255</span> - green,</span><br><span class="line">                       <span class="number">255</span> - blue,</span><br><span class="line">                       <span class="string">"Inverse of "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="一些讨论"><a href="#一些讨论" class="headerlink" title="一些讨论"></a>一些讨论</h1><ol><li><p>当不可变类中包含List类型时<br>如果只是单单纯的返回List，是有机会对其进行更改的<br>应当采用以下方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableList(list);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>线程安全<br>不可变对象是线程安全的，适合在多线程的环境下进行同步而不用考虑线程安全的问题</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;不可变对象(Immutable Objects)&lt;/strong&gt;即对象一旦被创建它的状态（对象的数据，也即
      
    
    </summary>
    
      <category term="java多线程学习" scheme="https://www.junglezero.top/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="java多线程" scheme="https://www.junglezero.top/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>多线程读写锁分离</title>
    <link href="https://www.junglezero.top/2019/04/16/%E7%BA%BF%E7%A8%8B%E8%AF%BB%E5%86%99%E9%94%81%E5%88%86%E7%A6%BB/"/>
    <id>https://www.junglezero.top/2019/04/16/线程读写锁分离/</id>
    <published>2019-04-16T05:28:00.000Z</published>
    <updated>2019-04-16T05:38:24.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>顾名思义，就是对于多线程下的读写操作（有进行读操作的线程也有进行写操作的线程），此时设计锁时应注意分离：两个读线程可以并发执行，两个写线程不可，一个读线程和一个写线程也不可，基于这个原则，进行读写锁的设计</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>读写锁类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读写锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//记录当前有多少个线程在进行读操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> readingReaders = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//记录正在等待的读线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> waitingReaders = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//正在进行写操作的线程（只有一个）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> writingWriters = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//等待进行读操作的线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> waitingWriters = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//设置一变量，用来控制写进程的抢锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> preferWriter = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> preferWriter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.preferWriter = preferWriter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读操作的上锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">readLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//首先等待读线程数+1</span></span><br><span class="line">        <span class="keyword">this</span>.waitingReaders++;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//当有线程进行写操作时，当前读操作线程等待，若是偏向于写操作，则也进行等待</span></span><br><span class="line">            <span class="keyword">while</span> (writingWriters &gt; <span class="number">0</span> || (preferWriter &amp;&amp; waitingWriters &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//读进程+1</span></span><br><span class="line">            <span class="keyword">this</span>.readingReaders++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//最终完成操作后-1</span></span><br><span class="line">            <span class="keyword">this</span>.waitingReaders--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读操作的解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">readUnlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.readingReaders--;</span><br><span class="line">        <span class="comment">//唤醒等待线程</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读操作上锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writeLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.waitingWriters++;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//当有进行读操作的线程或者写操作的线程正在运行时，当前线程都要进入等待状态</span></span><br><span class="line">            <span class="keyword">while</span> (readingReaders &gt; <span class="number">0</span> || writingWriters &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.writingWriters++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.waitingWriters--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读操作解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writeUnlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.writingWriters--;</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>共享数据类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">SharedData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//假设为一个数组，读操作在其中读数据，写操作在其中写数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span>[] buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义读写锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span>  ReadWriteLock lock = <span class="keyword">new</span> ReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SharedData</span><span class="params">(<span class="keyword">int</span>  size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.buffer = <span class="keyword">new</span> <span class="keyword">char</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.buffer[i] = <span class="string">'*'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//多线程读操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[] read() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//先上读线程锁</span></span><br><span class="line">            lock.readLock();</span><br><span class="line">            <span class="comment">//具体读操作</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.doRead();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//最终释放掉锁</span></span><br><span class="line">            lock.readUnlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//多线程写操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> c)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//写操作锁</span></span><br><span class="line">            lock.writeLock();</span><br><span class="line">            <span class="comment">//实际的写操作</span></span><br><span class="line">            <span class="keyword">this</span>.doWrite(c);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//放锁</span></span><br><span class="line">            lock.writeUnlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWrite</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.length; i++) &#123;</span><br><span class="line">            buffer[i] = c;</span><br><span class="line">            slowly(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模拟具体读操作：创建一个当前数组的副本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] doRead() &#123;</span><br><span class="line">        <span class="keyword">char</span>[] newBuf = <span class="keyword">new</span> <span class="keyword">char</span>[buffer.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.length; i++)</span><br><span class="line">            newBuf[i] = buffer[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟花费时间</span></span><br><span class="line">        slowly(<span class="number">50</span>);</span><br><span class="line">        <span class="keyword">return</span> newBuf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">slowly</span><span class="params">(<span class="keyword">int</span> ms)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(ms);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>读线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">ReaderWorker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//共享资源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SharedData data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReaderWorker</span><span class="params">(SharedData data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//读取内容</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">char</span>[] readBuf = data.read();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" reads "</span> + String.valueOf(readBuf));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>写线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriterWorker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//共享数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SharedData data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要写的内容</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String filler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对于写的内容的索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WriterWorker</span><span class="params">(SharedData data, String filler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.filler = filler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">//不断的进行写入操作</span></span><br><span class="line">                <span class="keyword">char</span> c = nextChar();</span><br><span class="line">                data.write(c);</span><br><span class="line">                 System.out.println(Thread.currentThread().getName()+<span class="string">" writes "</span>+ c);</span><br><span class="line">                <span class="comment">//随机休眠时间</span></span><br><span class="line">                Thread.sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">char</span> <span class="title">nextChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c = filler.charAt(index);</span><br><span class="line">        index++;</span><br><span class="line">        <span class="comment">//将index重置</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt;= filler.length())</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWritLockClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SharedData sharedData = <span class="keyword">new</span> SharedData(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">new</span> ReaderWorker(sharedData).start();</span><br><span class="line">        <span class="keyword">new</span> ReaderWorker(sharedData).start();</span><br><span class="line">        <span class="keyword">new</span> ReaderWorker(sharedData).start();</span><br><span class="line">        <span class="keyword">new</span> ReaderWorker(sharedData).start();</span><br><span class="line">        <span class="keyword">new</span> ReaderWorker(sharedData).start();</span><br><span class="line">        <span class="keyword">new</span> WriterWorker(sharedData, <span class="string">"qwertyuiopasdfg"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> WriterWorker(sharedData, <span class="string">"QWERTYUIOPASDFG"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread-4 reads **********</span><br><span class="line">Thread-2 reads **********</span><br><span class="line">Thread-1 reads **********</span><br><span class="line">Thread-0 reads **********</span><br><span class="line">Thread-3 reads **********</span><br><span class="line">Thread-5 writes q</span><br><span class="line">Thread-6 writes Q</span><br><span class="line">Thread-4 reads QQQQQQQQQQ</span><br><span class="line">Thread-1 reads QQQQQQQQQQ</span><br><span class="line">Thread-3 reads QQQQQQQQQQ</span><br><span class="line">Thread-2 reads QQQQQQQQQQ</span><br><span class="line">Thread-0 reads QQQQQQQQQQ</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;顾名思义，就是对于多线程下的读写操作（有进行读操作的线程也有进行写操作的线程），此时设计锁时应注意分离：两个读线程可以并发执
      
    
    </summary>
    
      <category term="java多线程学习" scheme="https://www.junglezero.top/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="java多线程" scheme="https://www.junglezero.top/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>GOT第八季第一集观感（就是剧透,就是剧透，大量图片剧透）</title>
    <link href="https://www.junglezero.top/2019/04/15/OT%E7%AC%AC%E5%85%AB%E5%AD%A3%E7%AC%AC%E4%B8%80%E9%9B%86%E8%A7%82%E6%84%9F%EF%BC%88%E5%B0%B1%E6%98%AF%E5%89%A7%E9%80%8F%EF%BC%89/"/>
    <id>https://www.junglezero.top/2019/04/15/OT第八季第一集观感（就是剧透）/</id>
    <published>2019-04-15T13:01:00.000Z</published>
    <updated>2019-04-16T03:32:08.720Z</updated>
    
    <content type="html"><![CDATA[<p>第一集，作为最终季的1/6，我觉得反映的第一个主题就是重逢,顺便回应第一季的第一集</p><p>开头兄弟二人</p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/ptiGwe803RxWS2H1*r6W*GRpUbAnuNkxo1WjhrQytlw!/b/dMEAAAAAAAAA&amp;bo=gAc4BAAAAAADd.k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/rz*nwe0m6GKh2Vtx5NPEHg0szboq2Y0zT.syXTXAg6k!/b/dLYAAAAAAAAA&amp;bo=gAc4BAAAAAADd.k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>第一季第一集开头的回忆杀（为背景板的狼大默哀一分钟）<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/APCXgdffANyQFEb*VljTnRWmCF.j2otHOnbwk0ZT1z4!/b/dLYAAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>北境权利最高层的兄妹二人重逢<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/ET3m1JtaTn.OSp46PTlkW6boB6OeE.l7C1FJvPHqcBA!/b/dLYAAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>当年被夫妻的二人重逢，两人经历了自打乔大帝的婚礼分离后，各自遇上了各种风浪，都已经成长起来<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/zGBfl7FoGE9VExlYnsO0nUsG0SK9R2Pa.qnhrS95Dxo!/b/dL8AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>兄妹二人重逢,兄妹二人的剑代表了他们的成长<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/VGKFxoQGapXZt6Ce.G607r*K.nfKKu7S62DQPR*WXvc!/b/dL8AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/XXe*ky97I3GuGHM0G3KdvDX8MSMZYbXhC0K5jMmFkY0!/b/dD4BAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/hcEk3S580XFudW6HQvOYFrhBXdvfP4HLo5YUnNfO16o!/b/dL4AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>铁民家族兄妹二人，大姐表示你特么救驾来迟了<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/kqlHXDrVq5.AzKLPfojEPgYP7jK8OxRp4WOsrou5ovM!/b/dLYAAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/glAJCz7lqTlraE4fx2iJBdB*d4V1PgHv2bSOpAcWYsk!/b/dL8AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>不太冷的杀手和暗藏杀机的小姑娘重逢，两人心情都很复杂，看见彼此还活着大概也有些高兴<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/dFhUuGHhrxaflO7o6R1ogq46jzu8d4I1VylozH9bDU8!/b/dFQBAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/EeX8eo07oj5A11Gi3u5GGAAD7GqvEc7GlPAyguUlsOQ!/b/dLYAAAAAAAAA&amp;bo=gAc4BAAAAAADd.k!&amp;rf=viewer_4&amp;t=5" alt="猎犬"></p><p>当年的逃亡路上的小伙伴重逢<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/8HySdarX0LpjeoFUbSjasEPHjIwGZfPm8zlFcILs29E!/b/dFQBAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>当年的守夜人好基友重逢<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/Tx2xPhG0iNDuzsB9TE59ncVo9IL.*UgndSNNN9doQAk!/b/dDQBAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>以及在本集末尾弑君者和布兰（还是改叫三眼乌鸦）的重逢，不得不说弑君者是真的帅，两人的心情估计也十分微妙<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/h70VN*XQuWnsOlscEL1i7c*T0BlTwmjkkOpArzma6Yw!/b/dMAAAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/ARjoFO*RUfnb67xyU747GJAbzQaXJeLttpfyqxq.gXg!/b/dDQBAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"><br>想想当年<br>（第一季第一集的结尾）<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/uKbEY2*mcdnHUzTrWVa5PycwWfSbWKWjDCeXTtQa8JM!/b/dL8AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/8uCU.xccrjdexEfYiXc49dZB7CmR.2opr049czppBxM!/b/dL8AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>最终季开篇，肯定要交代背景</p><ul><li>联盟的形成，以及众人不同的看法，此处以傲娇小女王为代表</li></ul><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/Jr8*rHDm3xMNC5SDNisrEJFsFObQVwVGPVUiNNlHHF0!/b/dLYAAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><ul><li>据说很牛逼还有大象的黄金团来袭</li></ul><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/IGyi1wYLKaaqvdyKPZvR6VgOgFZa9ULoDNGYpD9gD2s!/b/dEkBAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/tPTrgCyZAO7Bw4XWHoIVxfZSaoxptbCJ8t9HB7iNNHc!/b/dFMBAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/R5y0wqbsAeo4lmcciqc*inNTlM7t3jY6vjjqPQlRa18!/b/dL8AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><ul><li>一无所知的雪诺终于知道自己到底是个什么神仙</li></ul><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/hmgQhC05JRiiBQJQiROweKfa*uZ36v5Ot3ZYweVJJDQ!/b/dLkAAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><ul><li>夜王又一次用人体行为艺术下了战书</li></ul><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/qKRTpOQzJ83OEmgXV9BDuKn04YP1e5Dip874UurgkxU!/b/dL8AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><ul><li>弑君者代表铁王座率军赶赴抗妖前线的北地</li></ul><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/b9B0JzaHWcsK*DYUyLVssnMGInn6XxjYC0uYuw8sn1k!/b/dDABAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>然后，作为最终季开篇，表明主要登场人物及其立场自然是必不可少的（纯属个人根据情况推测的）<br>一无所知琼恩雪诺：王位什么的不重要，大敌当前，我们要团结———&gt;我特么本是一无所知的二逼小青年，现在全知道了，感觉好复杂<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/7yRourdnruYwAOewG.yLXOTA0i.t16NP4jghvxzkfrE!/b/dLgAAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/XsffEnGX2gUjILAHEts46qJTGGottTJgNkvJcbtyS8I!/b/dEkBAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/NhUt6YMPcq*po3ADxsgDZTIAvFmDBfqQBSTADC1HApc!/b/dL8AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>……(省略一堆头衔)的龙妈：君之所向便是光，并表示好歹我也是有这么多头衔的女王，要是小姑子不给面子……<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/iau195BHlQmZUmo5jVbEuYNzvJxqYwFvQmVMAJ7M1bU!/b/dLkAAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/qT2CVgaTPDZ5rbsep7xt1.XU*aGFvP0dO6ukSUR9V64!/b/dL8AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>临冬女爵三傻：不行不行先把谁当老大这个事搞明白（你个外来的小妮子敢在这里撒泼）<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/Ghl.OR.NZqo.*f.7*YjUju.rG*TR4kP8BetdKxsYXbw!/b/dL4AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>传奇刺客艾莉雅：咱（我们？）这一家子整整齐齐的就好<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/kJT.wblPug3YZZatP8YoEfRzcEmSbDCntJ*KRVlVhFw!/b/dL8AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>同盟的三个顶级谋士<br>小恶魔：先别说别的了，先把那群妖怪干趴再说吧，现在关键是团结人心，毕竟欧尼桑不是个省油的灯……<br>洋葱骑士：最后搞个联合政府也还是不错的，那两位很般配<br>八爪蜘蛛：Nothing lasts（原话）</p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/WG6vhSZyH6qHiaUtFf62BLII.1.U2d4PZ06pXzqfu3M!/b/dDEBAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>“臭佬”（并不）席恩：我还是和我史塔克家的难兄难弟们在一起吧<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/Ap6Gm.2QLfFcHVjdsohhXFQj3Zd4ZicSGmnC80ZM91Y!/b/dL4AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>作者本体：兄弟我挺你，你比那贱货正统的多，况且那贱货还杀了我的爸爸和哥哥<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/5aWkJpntUDKwZsI*eJubgI2u*wqp7GnUJ4eAXccNoiw!/b/dLYAAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>给钱办事的波隆爵士：贵圈真尼玛乱,他妈的兄弟对不住了……(给弩这个细节也表示都知道弑君者是近战高手，尽管你手黑，尽管他废了个胳膊，但估计近战刚也是打不过)<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/jGgfEoEeiW8vC84voj7FRM2mA4jtSuWj*vUu1emwcu4!/b/dFMBAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="波隆"></p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/ExkAWSDL5r46vfJ4wb1yW.WSHTCyvJZtFwOP5OycOI0!/b/dDQBAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>想当年这位仁兄拼了老命在龙焰之下拉了兄弟一把，现在却受命要做掉他<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/OK.Q8thY1WOL6Z3ycxxWbJ37*tdSE7UjNsNFjKeQZjc!/b/dL8AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>舰队司令：我就是个用屌思考的人，我一切的动机就是日您，女王陛下（我觉得这个人是真心有点意思，他在这集里面所有的对话基本离不开日女王）<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/C53FZAZg*MdDSmhv8y0hpfxufjusNB87NhIlGGM0aOM!/b/dLYAAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>坐在铁王座上的色后：都是好事，都是好事啊</p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/qqqeDnHt.DIGPCvzk.u38C3XSiSxP6To.edupw7xTlY!/b/dL4AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>三眼乌鸦：……就这么要凉了吗？！</p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/AFt1o2WZTzvlvTwq3xJIG8K0KTcZrEqJgbO6yKh1HNc!/b/dL8AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"><br>要是仔细看的话，就会发现，整集他多处出现，坐在轮椅上四处观望着这群人，看来这位才是手里有剧本的人</p><p>其实也不用多说什么，看着这些人如何反转吧，毕竟面对选择，谁尼玛都纠结，一纠结就要有人死，毕竟是最终季的开始，好戏马上就要上演了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第一集，作为最终季的1/6，我觉得反映的第一个主题就是重逢,顺便回应第一季的第一集&lt;/p&gt;
&lt;p&gt;开头兄弟二人&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/ptiGwe803RxWS2H1*r6W*GRpUbA
      
    
    </summary>
    
    
      <category term="个人杂谈" scheme="https://www.junglezero.top/tags/%E4%B8%AA%E4%BA%BA%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>单线程执行设计模式（Single Thread Execution）</title>
    <link href="https://www.junglezero.top/2019/04/15/%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.junglezero.top/2019/04/15/线程执行设计模式/</id>
    <published>2019-04-15T09:00:00.000Z</published>
    <updated>2019-04-15T12:55:27.459Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>在多线程的状况下，对于某些共享资源，我们需要在使用的时候确保安全性，因此这种模式下，同一时刻只能有一个线程去访问共享资源，就像独木桥一次通过一个人一样</p><h1 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SharedResource 指代多线程下的共享资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"Nobody"</span>;</span><br><span class="line">    <span class="keyword">private</span> String address = <span class="string">"Nowhere"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 临界值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> address</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">pass</span><span class="params">(String name, String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.counter++;</span><br><span class="line">        <span class="comment">/*race*/</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        verify();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置验证规则：当name和address的首字母不相同时，输出打断</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">verify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.name.charAt(<span class="number">0</span>) != <span class="keyword">this</span>.address.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"*******BROKEN********"</span> + toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"No."</span> + counter + <span class="string">":"</span> + name + <span class="string">","</span> + address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指代操作临界资源的线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String myName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String myAddress;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Gate gate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String myName, String myAddress, Gate gate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myName = myName;</span><br><span class="line">        <span class="keyword">this</span>.myAddress = myAddress;</span><br><span class="line">        <span class="keyword">this</span>.gate = gate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(myName + <span class="string">" BEGIN"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.gate.pass(myName, myAddress);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Gate gate = <span class="keyword">new</span> Gate();</span><br><span class="line">        User bj = <span class="keyword">new</span> User(<span class="string">"Baobao"</span>, <span class="string">"Beijing"</span>, gate);</span><br><span class="line">        User sh = <span class="keyword">new</span> User(<span class="string">"ShangLao"</span>, <span class="string">"ShangHai"</span>, gate);</span><br><span class="line">        User gz = <span class="keyword">new</span> User(<span class="string">"GuangLao"</span>, <span class="string">"GuangZhou"</span>, gate);</span><br><span class="line"></span><br><span class="line">        bj.start();</span><br><span class="line">        sh.start();</span><br><span class="line">        gz.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*******BROKEN********No.111356925:GuangLao,GuangZhou</span><br><span class="line">*******BROKEN********No.111357328:Baobao,Beijing</span><br><span class="line">*******BROKEN********No.111357709:GuangLao,GuangZhou</span><br><span class="line">*******BROKEN********No.111362695:Baobao,Beijing</span><br></pre></td></tr></table></figure></p><p>可以看到，其中有的输出结果name和address不同，尽管初始化线程传入的参数时是相同的。有的是满足验证规则但还是输出打断<br>解释：比如A线程传入参数Beyco和Beijing，当向pass方法传入Beyco时，A线程被B线程打断，B线程传入Shenzhen，此时verify自然就broke；另一种情况是，继前面一种情况之后，此时参数已经是Beyco和Shenzhen，在准备toString时，B线程又将address传入实参Beijing，所以就出现了首字母相同还是broke的情况。<br>解决：对于共享资源，在多线程状态下使用，最好的办法自然是上锁，将pass方法和toString方法加上同步锁即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>   <span class="keyword">void</span> <span class="title">pass</span><span class="params">(String name, String address)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.counter++;</span><br><span class="line">    <span class="comment">/*race*/</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.address = address;</span><br><span class="line">    verify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>   String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"No."</span> + counter + <span class="string">":"</span> + name + <span class="string">","</span> + address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;在多线程的状况下，对于某些共享资源，我们需要在使用的时候确保安全性，因此这种模式下，同一时刻只能有一个线程去访问共享资源，就
      
    
    </summary>
    
      <category term="java多线程学习" scheme="https://www.junglezero.top/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="java多线程" scheme="https://www.junglezero.top/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>观察者模式和线程监控</title>
    <link href="https://www.junglezero.top/2019/04/15/%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9B%91%E6%8E%A7/"/>
    <id>https://www.junglezero.top/2019/04/15/者模式和线程监控/</id>
    <published>2019-04-15T07:28:00.000Z</published>
    <updated>2019-04-15T08:38:53.957Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本理解"><a href="#基本理解" class="headerlink" title="基本理解"></a>基本理解</h1><p><img src="/upload/pasted-278.png" alt="upload successful"><br>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有的观察者对象，使它们能够自动更新自己。</p><p>四个角色</p><ul><li>抽象被观察者角色：也就是一个抽象主题，它把所有对观察者对象的引用保存在一个集合中，每个主题都可以有任意数量的观察者。抽象主题提供一个接口，可以增加和删除观察者角色。一般用一个抽象类和接口来实现。</li><li>抽象观察者角色：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。</li><li>具体被观察者角色：也就是一个具体的主题，在集体主题的内部状态改变时，所有登记过的观察者发出通知。</li><li>具体观察者角色：实现抽象观察者角色所需要的更新接口，一边使本身的状态与制图的状态相协调。</li></ul><h1 id="java实现例子"><a href="#java实现例子" class="headerlink" title="java实现例子"></a>java实现例子</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 抽象被观察者接口</span></span><br><span class="line"><span class="comment"> * 声明了添加、删除、通知观察者方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observerable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 抽象观察者</span></span><br><span class="line"><span class="comment"> * 定义了一个update()方法，当被观察者调用notifyObservers()方法时，观察者的update()方法会被回调。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jstao</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被观察者，也就是微信公众号服务</span></span><br><span class="line"><span class="comment"> * 实现了Observerable接口，对Observerable接口的三个方法进行了具体实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WechatServer</span> <span class="keyword">implements</span> <span class="title">Observerable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意到这个List集合的泛型参数为Observer接口，设计原则：面向接口编程而不是面向实现编程</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; list;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WechatServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        list.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!list.isEmpty())</span><br><span class="line">            list.remove(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            Observer oserver = list.get(i);</span><br><span class="line">            oserver.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfomation</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = s;</span><br><span class="line">        System.out.println(<span class="string">"微信服务更新消息： "</span> + s);</span><br><span class="line">        <span class="comment">//消息更新，通知所有观察者</span></span><br><span class="line">        notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察者</span></span><br><span class="line"><span class="comment"> * 实现了update方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jstao</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        read();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">" 收到推送消息： "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：<br>首先注册了三个用户，ZhangSan、LiSi、WangWu。公众号发布了一条消息”PHP是世界上最好用的语言！”，三个用户都收到了消息。</p><p>用户ZhangSan看到消息后颇为震惊，果断取消订阅，这时公众号又推送了一条消息，此时用户ZhangSan已经收不到消息，其他用户</p><p>还是正常能收到推送消息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WechatServer server = <span class="keyword">new</span> WechatServer();</span><br><span class="line">        </span><br><span class="line">        Observer userZhang = <span class="keyword">new</span> User(<span class="string">"ZhangSan"</span>);</span><br><span class="line">        Observer userLi = <span class="keyword">new</span> User(<span class="string">"LiSi"</span>);</span><br><span class="line">        Observer userWang = <span class="keyword">new</span> User(<span class="string">"WangWu"</span>);</span><br><span class="line">        </span><br><span class="line">        server.registerObserver(userZhang);</span><br><span class="line">        server.registerObserver(userLi);</span><br><span class="line">        server.registerObserver(userWang);</span><br><span class="line">        server.setInfomation(<span class="string">"PHP是世界上最好用的语言！"</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"----------------------------------------------"</span>);</span><br><span class="line">        server.removeObserver(userZhang);</span><br><span class="line">        server.setInfomation(<span class="string">"JAVA是世界上最好用的语言！"</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="利用观察者模式监控线程状态"><a href="#利用观察者模式监控线程状态" class="headerlink" title="利用观察者模式监控线程状态"></a>利用观察者模式监控线程状态</h1><p>观察者抽象类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LifeCycleObserver</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当被观察者（这个例子中是“可被观察线程”）发生改变时，调用该方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(ObservableRunnable.RunnableEvent event)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>被观察者类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单一的被观察者</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">protected</span> LifeCycleObserver observer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableRunnable</span><span class="params">(<span class="keyword">final</span> LifeCycleObserver listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.observer = listener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发生线程事件时，调用该方法提醒观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">notifyChange</span><span class="params">(<span class="keyword">final</span> RunnableEvent event)</span> </span>&#123;</span><br><span class="line">        observer.onEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程状态枚举</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> RunnableState &#123;</span><br><span class="line">        RUNNING, ERROR, DONE</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义状态改变的类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableEvent</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> RunnableState state;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Thread thread;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Throwable cause;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RunnableEvent</span><span class="params">(RunnableState state, Thread thread, Throwable cause)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.state = state;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">            <span class="keyword">this</span>.cause = cause;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> RunnableState <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> state;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">getThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> thread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Throwable <span class="title">getCause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cause;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体观察者的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLifeCycleObserver</span> <span class="keyword">implements</span> <span class="title">LifeCycleObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//多线程加锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object LOCK = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该观察者有一个根据id查询线程的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">concurrentQuery</span><span class="params">(List&lt;String&gt; ids)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ids == <span class="keyword">null</span> || ids.isEmpty())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        ids.stream().forEach(id -&gt; <span class="keyword">new</span> Thread(<span class="keyword">new</span> ObservableRunnable(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//被观察线程是运行态，传Running参数</span></span><br><span class="line">                    notifyChange(<span class="keyword">new</span> RunnableEvent(RunnableState.RUNNING, Thread.currentThread(), <span class="keyword">null</span>));</span><br><span class="line">                    System.out.println(<span class="string">"query for the id "</span> + id);</span><br><span class="line">                    Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">                    <span class="comment">//传递Done参数</span></span><br><span class="line">                    notifyChange(<span class="keyword">new</span> RunnableEvent(RunnableState.DONE, Thread.currentThread(), <span class="keyword">null</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">//发生异常，传递error</span></span><br><span class="line">                    notifyChange(<span class="keyword">new</span> RunnableEvent(RunnableState.ERROR, Thread.currentThread(), e));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, id).start());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 观察者的"反应方法"</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(ObservableRunnable.RunnableEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//多线程加锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            System.out.println(<span class="string">"The runnable ["</span> + event.getThread().getName() + <span class="string">"] data changed and state is ["</span> + event.getState() + <span class="string">"]"</span>);</span><br><span class="line">            <span class="keyword">if</span> (event.getCause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"The runnable ["</span> + event.getThread().getName() + <span class="string">"] process failed."</span>);</span><br><span class="line">                event.getCause().printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLifeCycleClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ThreadLifeCycleObserver().concurrentQuery(Arrays.asList(<span class="string">"1"</span>, <span class="string">"2"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The runnable [1] data changed and state is [RUNNING]</span><br><span class="line">The runnable [2] data changed and state is [RUNNING]</span><br><span class="line">query for the id 2</span><br><span class="line">query for the id 1</span><br><span class="line">The runnable [1] data changed and state is [DONE]</span><br><span class="line">The runnable [2] data changed and state is [DONE]</span><br></pre></td></tr></table></figure></p><p>当运行中有异常时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">The runnable [1] data changed and state is [RUNNING]</span><br><span class="line">The runnable [2] data changed and state is [RUNNING]</span><br><span class="line">query for the id 2</span><br><span class="line">query for the id 1</span><br><span class="line">The runnable [2] data changed and state is [DONE]</span><br><span class="line">The runnable [1] data changed and state is [DONE]</span><br><span class="line">The runnable [1] data changed and state is [ERROR]</span><br><span class="line">The runnable [1] process failed.</span><br><span class="line">java.lang.ArithmeticException: / by zero</span><br><span class="line">at aConcurenty.concurrent2.chapter4.ThreadLifeCycleObserver$1.run(ThreadLifeCycleObserver.java:35)</span><br><span class="line">at java.base/java.lang.Thread.run(Thread.java:844)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本理解&quot;&gt;&lt;a href=&quot;#基本理解&quot; class=&quot;headerlink&quot; title=&quot;基本理解&quot;&gt;&lt;/a&gt;基本理解&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/upload/pasted-278.png&quot; alt=&quot;upload successful&quot;&gt;&lt;br&gt;
      
    
    </summary>
    
      <category term="java多线程学习" scheme="https://www.junglezero.top/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="设计模式" scheme="https://www.junglezero.top/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java多线程" scheme="https://www.junglezero.top/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="https://www.junglezero.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>HashMap和ConcurrentHashMap</title>
    <link href="https://www.junglezero.top/2019/04/11/oncurrentHashMap/"/>
    <id>https://www.junglezero.top/2019/04/11/oncurrentHashMap/</id>
    <published>2019-04-11T01:35:00.000Z</published>
    <updated>2019-04-13T06:04:56.557Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://www.importnew.com/28263.html" target="_blank" rel="noopener">http://www.importnew.com/28263.html</a></p><h1 id="Hashmap"><a href="#Hashmap" class="headerlink" title="Hashmap"></a>Hashmap</h1><h2 id="1-7"><a href="#1-7" class="headerlink" title="1.7"></a>1.7</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。<br>HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。<br>HashMap 的实现不是同步的，这意味着它<strong>不是线程安全</strong>的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。</p><p>HashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。容量 是哈希表中桶的数量，初始容量 只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。<br>通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>在详细介绍HashMap的代码之前，我们需要了解：HashMap就是一个散列表，它是通过“拉链法”解决哈希冲突的。<br>见<a href="散列表">https://www.junglezero.top/2018/02/17/%EF%BC%88%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%89/</a><br>还需要再补充说明的一点是影响HashMap性能的有两个参数：初始容量(initialCapacity) 和加载因子(loadFactor)。容量 是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。</p><p><img src="/upload/pasted-271.png" alt="upload successful"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认的初始容量是16，必须是2的幂。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认加载因子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储数据的Entry数组，长度是2的幂。</span></span><br><span class="line">    <span class="comment">// HashMap是采用拉链法实现的，每一个Entry本质上是一个单向链表</span></span><br><span class="line">    <span class="keyword">transient</span> Entry[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HashMap的大小，它是HashMap保存的键值对的数量</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HashMap的阈值，用于判断是否需要调整HashMap的容量（threshold = 容量*加载因子）</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载因子实际大小</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HashMap被改变的次数</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定“容量大小”和“加载因子”的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="comment">// HashMap的最大容量只能是MAXIMUM_CAPACITY</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找出“大于initialCapacity”的最小的2的幂</span></span><br><span class="line">        <span class="keyword">int</span> capacity = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (capacity &lt; initialCapacity)</span><br><span class="line">            capacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置“加载因子”</span></span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="comment">// 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。</span></span><br><span class="line">        threshold = (<span class="keyword">int</span>)(capacity * loadFactor);</span><br><span class="line">        <span class="comment">// 创建Entry数组，用来保存数据</span></span><br><span class="line">        table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认构造函数。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置“加载因子”</span></span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">        <span class="comment">// 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。</span></span><br><span class="line">        threshold = (<span class="keyword">int</span>)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);</span><br><span class="line">        <span class="comment">// 创建Entry数组，用来保存数据</span></span><br><span class="line">        table = <span class="keyword">new</span> Entry[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 包含“子Map”的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Math.max((<span class="keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>,</span><br><span class="line">                      DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</span><br><span class="line">        <span class="comment">// 将m中的全部元素逐个添加到HashMap中</span></span><br><span class="line">        putAllForCreate(m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">        <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回索引值</span></span><br><span class="line">    <span class="comment">// h &amp; (length-1)保证返回值的小于length</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取key对应的value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> getForNullKey();</span><br><span class="line">        <span class="comment">// 获取key的hash值</span></span><br><span class="line">        <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">        <span class="comment">// 在“该hash值对应的链表”上查找“键值等于key”的元素</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">             e != <span class="keyword">null</span>;</span><br><span class="line">             e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取“key为null”的元素的值</span></span><br><span class="line">    <span class="comment">// HashMap将“key为null”的元素存储在table[0]位置！</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> V <span class="title">getForNullKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.key == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HashMap是否包含key</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getEntry(key) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回“键为key”的键值对</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取哈希值</span></span><br><span class="line">        <span class="comment">// HashMap将“key为null”的元素存储在table[0]位置，“key不为null”的则调用hash()计算哈希值</span></span><br><span class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key.hashCode());</span><br><span class="line">        <span class="comment">// 在“该hash值对应的链表”上查找“键值等于key”的元素</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">             e != <span class="keyword">null</span>;</span><br><span class="line">             e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将“key-value”添加到HashMap中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若“key为null”，则将该键值对添加到table[0]中。</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">        <span class="comment">// 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。</span></span><br><span class="line">        <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="comment">// 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若“该key”对应的键值对不存在，则将“key-value”添加到table中</span></span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// putForNullKey()的作用是将“key为null”键值对添加到table[0]位置</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里的完全不会被执行到!</span></span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建HashMap对应的“添加方法”，</span></span><br><span class="line">    <span class="comment">// 它和put()不同。putForCreate()是内部方法，它被构造函数等调用，用来创建HashMap</span></span><br><span class="line">    <span class="comment">// 而put()是对外提供的往HashMap中添加元素的方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putForCreate</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若该HashMap表中存在“键值等于key”的元素，则替换该元素的value值</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                e.value = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若该HashMap表中不存在“键值等于key”的元素，则将该key-value添加到HashMap中</span></span><br><span class="line">        createEntry(hash, key, value, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将“m”中的全部元素都添加到HashMap中。</span></span><br><span class="line">    <span class="comment">// 该方法被内部的构造HashMap的方法所调用。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putAllForCreate</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 利用迭代器将元素逐个添加到HashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; i = m.entrySet().iterator(); i.hasNext(); ) &#123;</span><br><span class="line">            Map.Entry&lt;? extends K, ? extends V&gt; e = i.next();</span><br><span class="line">            putForCreate(e.getKey(), e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新调整HashMap的大小，newCapacity是调整后的单位</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">        Entry[] oldTable = table;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建一个HashMap，将“旧HashMap”的全部元素添加到“新HashMap”中，</span></span><br><span class="line">        <span class="comment">// 然后，将“新HashMap”赋值给“旧HashMap”。</span></span><br><span class="line">        Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">        transfer(newTable);</span><br><span class="line">        table = newTable;</span><br><span class="line">        threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将HashMap中的全部元素都添加到newTable中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">        Entry[] src = table;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                src[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                    <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">                    e.next = newTable[i];</span><br><span class="line">                    newTable[i] = e;</span><br><span class="line">                    e = next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将"m"的全部元素都添加到HashMap中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 有效性判断</span></span><br><span class="line">        <span class="keyword">int</span> numKeysToBeAdded = m.size();</span><br><span class="line">        <span class="keyword">if</span> (numKeysToBeAdded == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算容量是否足够，</span></span><br><span class="line">        <span class="comment">// 若“当前实际容量 &lt; 需要的容量”，则将容量x2。</span></span><br><span class="line">        <span class="keyword">if</span> (numKeysToBeAdded &gt; threshold) &#123;</span><br><span class="line">            <span class="keyword">int</span> targetCapacity = (<span class="keyword">int</span>)(numKeysToBeAdded / loadFactor + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (targetCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">                targetCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">            <span class="keyword">int</span> newCapacity = table.length;</span><br><span class="line">            <span class="keyword">while</span> (newCapacity &lt; targetCapacity)</span><br><span class="line">                newCapacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (newCapacity &gt; table.length)</span><br><span class="line">                resize(newCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过迭代器，将“m”中的元素逐个添加到HashMap中。</span></span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; i = m.entrySet().iterator(); i.hasNext(); ) &#123;</span><br><span class="line">            Map.Entry&lt;? extends K, ? extends V&gt; e = i.next();</span><br><span class="line">            put(e.getKey(), e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除“键为key”元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = removeEntryForKey(key);</span><br><span class="line">        <span class="keyword">return</span> (e == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除“键为key”的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取哈希值。若key为null，则哈希值为0；否则调用hash()进行计算</span></span><br><span class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">        Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">        Entry&lt;K,V&gt; e = prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除链表中“键为key”的元素</span></span><br><span class="line">        <span class="comment">// 本质是“删除单向链表中的节点”</span></span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                modCount++;</span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">if</span> (prev == e)</span><br><span class="line">                    table[i] = next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    prev.next = next;</span><br><span class="line">                e.recordRemoval(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除“键值对”</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeMapping</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o;</span><br><span class="line">        Object key = entry.getKey();</span><br><span class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">        Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">        Entry&lt;K,V&gt; e = prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除链表中的“键值对e”</span></span><br><span class="line">        <span class="comment">// 本质是“删除单向链表中的节点”</span></span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; e.equals(entry)) &#123;</span><br><span class="line">                modCount++;</span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">if</span> (prev == e)</span><br><span class="line">                    table[i] = next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    prev.next = next;</span><br><span class="line">                e.recordRemoval(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空HashMap，将所有的元素设为null</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; i++)</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否包含“值为value”的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若“value为null”，则调用containsNullValue()查找</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> containsNullValue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若“value不为null”，则查找HashMap中是否有值为value的节点。</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length ; i++)</span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i] ; e != <span class="keyword">null</span> ; e = e.next)</span><br><span class="line">                <span class="keyword">if</span> (value.equals(e.value))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否包含null值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">containsNullValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length ; i++)</span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i] ; e != <span class="keyword">null</span> ; e = e.next)</span><br><span class="line">                <span class="keyword">if</span> (e.value == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 克隆一个HashMap，并返回Object对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashMap&lt;K,V&gt; result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = (HashMap&lt;K,V&gt;)<span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="comment">// assert false;</span></span><br><span class="line">        &#125;</span><br><span class="line">        result.table = <span class="keyword">new</span> Entry[table.length];</span><br><span class="line">        result.entrySet = <span class="keyword">null</span>;</span><br><span class="line">        result.modCount = <span class="number">0</span>;</span><br><span class="line">        result.size = <span class="number">0</span>;</span><br><span class="line">        result.init();</span><br><span class="line">        <span class="comment">// 调用putAllForCreate()将全部元素添加到HashMap中</span></span><br><span class="line">        result.putAllForCreate(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Entry是单向链表。</span></span><br><span class="line">    <span class="comment">// 它是 “HashMap链式存储法”对应的链表。</span></span><br><span class="line">    <span class="comment">// 它实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        <span class="comment">// 指向下一个节点</span></span><br><span class="line">        Entry&lt;K,V&gt; next;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造函数。</span></span><br><span class="line">        <span class="comment">// 输入参数包括"哈希值(h)", "键(k)", "值(v)", "下一节点(n)"</span></span><br><span class="line">        Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">            value = v;</span><br><span class="line">            next = n;</span><br><span class="line">            key = k;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断两个Entry是否相等</span></span><br><span class="line">        <span class="comment">// 若两个Entry的“key”和“value”都相等，则返回true。</span></span><br><span class="line">        <span class="comment">// 否则，返回false</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            Map.Entry e = (Map.Entry)o;</span><br><span class="line">            Object k1 = getKey();</span><br><span class="line">            Object k2 = e.getKey();</span><br><span class="line">            <span class="keyword">if</span> (k1 == k2 || (k1 != <span class="keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;</span><br><span class="line">                Object v1 = getValue();</span><br><span class="line">                Object v2 = e.getValue();</span><br><span class="line">                <span class="keyword">if</span> (v1 == v2 || (v1 != <span class="keyword">null</span> &amp;&amp; v1.equals(v2)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现hashCode()</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (key==<span class="keyword">null</span>   ? <span class="number">0</span> : key.hashCode()) ^</span><br><span class="line">                   (value==<span class="keyword">null</span> ? <span class="number">0</span> : value.hashCode());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getKey() + <span class="string">"="</span> + getValue();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当向HashMap中添加元素时，绘调用recordAccess()。</span></span><br><span class="line">        <span class="comment">// 这里不做任何处理</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当从HashMap中删除元素时，绘调用recordRemoval()。</span></span><br><span class="line">        <span class="comment">// 这里不做任何处理</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">recordRemoval</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保存“bucketIndex”位置的值到“e”中</span></span><br><span class="line">        Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">        <span class="comment">// 设置“bucketIndex”位置的元素为“新Entry”，</span></span><br><span class="line">        <span class="comment">// 设置“e”为“新Entry的下一个节点”</span></span><br><span class="line">        table[bucketIndex] = <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">        <span class="comment">// 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小</span></span><br><span class="line">        <span class="keyword">if</span> (size++ &gt;= threshold)</span><br><span class="line">            resize(<span class="number">2</span> * table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Entry。将“key-value”插入指定位置，bucketIndex是位置索引。</span></span><br><span class="line">    <span class="comment">// 它和addEntry的区别是：</span></span><br><span class="line">    <span class="comment">// (01) addEntry()一般用在 新增Entry可能导致“HashMap的实际容量”超过“阈值”的情况下。</span></span><br><span class="line">    <span class="comment">//   例如，我们新建一个HashMap，然后不断通过put()向HashMap中添加元素；</span></span><br><span class="line">    <span class="comment">// put()是通过addEntry()新增Entry的。</span></span><br><span class="line">    <span class="comment">//   在这种情况下，我们不知道何时“HashMap的实际容量”会超过“阈值”；</span></span><br><span class="line">    <span class="comment">//   因此，需要调用addEntry()</span></span><br><span class="line">    <span class="comment">// (02) createEntry() 一般用在 新增Entry不会导致“HashMap的实际容量”超过“阈值”的情况下。</span></span><br><span class="line">    <span class="comment">//   例如，我们调用HashMap“带有Map”的构造函数，它绘将Map的全部元素添加到HashMap中；</span></span><br><span class="line">    <span class="comment">// 但在添加之前，我们已经计算好“HashMap的容量和阈值”。也就是，可以确定“即使将Map中</span></span><br><span class="line">    <span class="comment">// 的全部元素添加到HashMap中，都不会超过HashMap的阈值”。</span></span><br><span class="line">    <span class="comment">//   此时，调用createEntry()即可。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保存“bucketIndex”位置的值到“e”中</span></span><br><span class="line">        Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">        <span class="comment">// 设置“bucketIndex”位置的元素为“新Entry”，</span></span><br><span class="line">        <span class="comment">// 设置“e”为“新Entry的下一个节点”</span></span><br><span class="line">        table[bucketIndex] = <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HashIterator是HashMap迭代器的抽象出来的父类，实现了公共了函数。</span></span><br><span class="line">    <span class="comment">// 它包含“key迭代器(KeyIterator)”、“Value迭代器(ValueIterator)”和“Entry迭代器(EntryIterator)”3个子类。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 下一个元素</span></span><br><span class="line">        Entry&lt;K,V&gt; next;</span><br><span class="line">        <span class="comment">// expectedModCount用于实现fast-fail机制。</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount;</span><br><span class="line">        <span class="comment">// 当前索引</span></span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        <span class="comment">// 当前元素</span></span><br><span class="line">        Entry&lt;K,V&gt; current;</span><br><span class="line"></span><br><span class="line">        HashIterator() &#123;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">                Entry[] t = table;</span><br><span class="line">                <span class="comment">// 将next指向table中第一个不为null的元素。</span></span><br><span class="line">                <span class="comment">// 这里利用了index的初始值为0，从0开始依次向后遍历，直到找到不为null的元素就退出循环。</span></span><br><span class="line">                <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>)</span><br><span class="line">                    ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取下一个元素</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">nextEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            Entry&lt;K,V&gt; e = next;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注意！！！</span></span><br><span class="line">            <span class="comment">// 一个Entry就是一个单向链表</span></span><br><span class="line">            <span class="comment">// 若该Entry的下一个节点不为空，就将next指向下一个节点;</span></span><br><span class="line">            <span class="comment">// 否则，将next指向下一个链表(也是下一个Entry)的不为null的节点。</span></span><br><span class="line">            <span class="keyword">if</span> ((next = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Entry[] t = table;</span><br><span class="line">                <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>)</span><br><span class="line">                    ;</span><br><span class="line">            &#125;</span><br><span class="line">            current = e;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除当前元素</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            Object k = current.key;</span><br><span class="line">            current = <span class="keyword">null</span>;</span><br><span class="line">            HashMap.<span class="keyword">this</span>.removeEntryForKey(k);</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// value的迭代器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nextEntry().value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// key的迭代器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> K <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nextEntry().getKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Entry的迭代器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nextEntry();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个“key迭代器”</span></span><br><span class="line">    <span class="function">Iterator&lt;K&gt; <span class="title">newKeyIterator</span><span class="params">()</span>   </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回一个“value迭代器”</span></span><br><span class="line">    <span class="function">Iterator&lt;V&gt; <span class="title">newValueIterator</span><span class="params">()</span>   </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ValueIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回一个“entry迭代器”</span></span><br><span class="line">    Iterator&lt;Map.Entry&lt;K,V&gt;&gt; newEntryIterator()   &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HashMap的Entry对应的集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回“key的集合”，实际上返回一个“KeySet对象”</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;K&gt; ks = keySet;</span><br><span class="line">        <span class="keyword">return</span> (ks != <span class="keyword">null</span> ? ks : (keySet = <span class="keyword">new</span> KeySet()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Key对应的集合</span></span><br><span class="line">    <span class="comment">// KeySet继承于AbstractSet，说明该集合中没有重复的Key。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> newKeyIterator();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> containsKey(o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> HashMap.<span class="keyword">this</span>.removeEntryForKey(o) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            HashMap.<span class="keyword">this</span>.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回“value集合”，实际上返回的是一个Values对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collection&lt;V&gt; vs = values;</span><br><span class="line">        <span class="keyword">return</span> (vs != <span class="keyword">null</span> ? vs : (values = <span class="keyword">new</span> Values()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// “value集合”</span></span><br><span class="line">    <span class="comment">// Values继承于AbstractCollection，不同于“KeySet继承于AbstractSet”，</span></span><br><span class="line">    <span class="comment">// Values中的元素能够重复。因为不同的key可以指向相同的value。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Values</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Iterator&lt;V&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> newValueIterator();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> containsValue(o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            HashMap.<span class="keyword">this</span>.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回“HashMap的Entry集合”</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">        <span class="keyword">return</span> entrySet0();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回“HashMap的Entry集合”，它实际是返回一个EntrySet对象</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet0() &#123;</span><br><span class="line">        Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet;</span><br><span class="line">        <span class="keyword">return</span> es != <span class="keyword">null</span> ? es : (entrySet = <span class="keyword">new</span> EntrySet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// EntrySet对应的集合</span></span><br><span class="line">    <span class="comment">// EntrySet继承于AbstractSet，说明该集合中没有重复的EntrySet。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">            <span class="keyword">return</span> newEntryIterator();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            Map.Entry&lt;K,V&gt; e = (Map.Entry&lt;K,V&gt;) o;</span><br><span class="line">            Entry&lt;K,V&gt; candidate = getEntry(e.getKey());</span><br><span class="line">            <span class="keyword">return</span> candidate != <span class="keyword">null</span> &amp;&amp; candidate.equals(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> removeMapping(o) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            HashMap.<span class="keyword">this</span>.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// java.io.Serializable的写入函数</span></span><br><span class="line">    <span class="comment">// 将HashMap的“总的容量，实际容量，所有的Entry”都写入到输出流中</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i =</span><br><span class="line">            (size &gt; <span class="number">0</span>) ? entrySet0().iterator() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out the threshold, loadfactor, and any hidden stuff</span></span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out number of buckets</span></span><br><span class="line">        s.writeInt(table.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out size (number of Mappings)</span></span><br><span class="line">        s.writeInt(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out keys and values (alternating)</span></span><br><span class="line">        <span class="keyword">if</span> (i != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            s.writeObject(e.getKey());</span><br><span class="line">            s.writeObject(e.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// java.io.Serializable的读取函数：根据写入方式读出</span></span><br><span class="line">    <span class="comment">// 将HashMap的“总的容量，实际容量，所有的Entry”依次读出</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> IOException, ClassNotFoundException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Read in the threshold, loadfactor, and any hidden stuff</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in number of buckets and allocate the bucket array;</span></span><br><span class="line">        <span class="keyword">int</span> numBuckets = s.readInt();</span><br><span class="line">        table = <span class="keyword">new</span> Entry[numBuckets];</span><br><span class="line"></span><br><span class="line">        init();  <span class="comment">// Give subclass a chance to do its thing.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in size (number of Mappings)</span></span><br><span class="line">        <span class="keyword">int</span> size = s.readInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            K key = (K) s.readObject();</span><br><span class="line">            V value = (V) s.readObject();</span><br><span class="line">            putForCreate(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回“HashMap总的容量”</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span>   <span class="title">capacity</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> table.length; &#125;</span><br><span class="line">    <span class="comment">// 返回“HashMap的加载因子”</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">loadFactor</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> loadFactor;   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重点方法"><a href="#重点方法" class="headerlink" title="重点方法"></a>重点方法</h3><h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当插入第一个元素的时候，需要先初始化数组大小</span></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 key 为 null，感兴趣的可以往里看，最终会将这个 entry 放到 table[0] 中</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="comment">// 1. 求 key 的 hash 值</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 2. 找到对应的数组下标</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 3. 遍历一下对应下标处的链表，看是否有重复的 key 已经存在，</span></span><br><span class="line">    <span class="comment">//    如果有，直接覆盖，put 方法返回旧值就结束了</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 4. 不存在重复的 key，将此 entry 添加到链表中，细节后面说</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><ul><li>数组初始化<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保证数组大小一定是 2 的 n 次方。</span></span><br><span class="line">    <span class="comment">// 比如这样初始化：new HashMap(20)，那么处理成初始数组大小是 32</span></span><br><span class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line">    <span class="comment">// 计算扩容阈值：capacity * loadFactor</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 算是初始化数组吧</span></span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">    initHashSeedAsNeeded(capacity); <span class="comment">//ignore</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在第一个元素插入 HashMap 的时候做一次数组的初始化，就是先确定初始的数组大小，并计算数组扩容的阈值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保证数组大小一定是 2 的 n 次方。</span></span><br><span class="line">    <span class="comment">// 比如这样初始化：new HashMap(20)，那么处理成初始数组大小是 32</span></span><br><span class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line">    <span class="comment">// 计算扩容阈值：capacity * loadFactor</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 算是初始化数组吧</span></span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">    initHashSeedAsNeeded(capacity); <span class="comment">//ignore</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里有一个将数组大小保持为 2 的 n 次方的做法，Java7 和 Java8 的 HashMap 和 ConcurrentHashMap 都有相应的要求，只不过实现的代码稍微有些不同，后面再看到的时候就知道了。</p><ul><li>计算具体数组位置</li></ul><p>这个简单，我们自己也能 YY 一个：使用 key 的 hash 值对数组长度进行取模就可以了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> hash, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";</span></span><br><span class="line">    <span class="keyword">return</span> hash &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法很简单，简单说就是取 hash 值的低 n 位。如在数组长度为 32 的时候，其实取的就是 key 的 hash 值的低 5 位，作为它在数组中的下标位置。</p><ul><li>添加节点到链表中</li></ul><p>找到数组下标后，会先进行 key 判重，如果没有重复，就准备将新值放入到链表的表头。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前 HashMap 大小已经达到了阈值，并且新值要插入的数组位置已经有元素了，那么要扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        <span class="comment">// 扩容，后面会介绍一下</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        <span class="comment">// 扩容以后，重新计算 hash 值</span></span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 重新计算扩容后的新的下标</span></span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 往下看</span></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个很简单，其实就是将新值放到链表的表头，然后 size++</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法的主要逻辑就是先判断是否需要扩容，需要的话先扩容，然后再将这个新的数据插入到扩容后的数组的相应位置处的链表的表头。</p><ul><li>数组扩容</li></ul><p>前面我们看到，在插入新值的时候，如果当前的 size 已经达到了阈值，并且要插入的数组位置上已经有元素，那么就会触发扩容，扩容后，数组大小为原来的 2 倍。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新的数组</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    <span class="comment">// 将原来数组中的值迁移到新的更大的数组中</span></span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>扩容就是用一个新的大数组替换原来的小数组，并将原来数组中的值迁移到新的数组中。</p><p>由于是双倍扩容，迁移过程中，会将原来 table[i] 中的链表的所有节点，分拆到新的数组的 newTable[i] 和 newTable[i + oldLength] 位置上。如原来数组长度是 16，那么扩容后，原来 table[0] 处的链表中的所有元素会被分配到新数组中 newTable[0] 和 newTable[16] 这两个位置。代码比较简单，这里就不展开了。</p><p>1.对Key求Hash值，然后再计算下标<br>2.如果没有碰撞，直接放入桶中（碰撞的意思是计算得到的Hash值相同，需要放到同一个bucket中）<br>3.如果碰撞了，以链表的方式链接到后面<br>4.如果链表长度超过阀值( TREEIFY THRESHOLD==8)，就把链表转成红黑树，链表长度低于6，就把红黑树转回链表<br>5.如果节点已经存在就替换旧值<br>6.如果桶满了(容量16*加载因子0.75)，就需要 resize（扩容2倍后重排）</p><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>当我们调用 get() 方法，HashMap 会使用键对象的 hashcode 找到 bucket 位置，找到 bucket 位置之后，会调用 keys.equals() 方法去找到链表中正确的节点，最终找到要找的值对象。</p><p><img src="/upload/pasted-273.png" alt="upload successful"></p><h2 id="1-8"><a href="#1-8" class="headerlink" title="1.8"></a>1.8</h2><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。</p><p>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。</p><p>为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。</p><p><img src="/upload/pasted-276.png" alt="upload successful"><br>Java7 中使用 Entry 来代表每个 HashMap 中的数据节点，Java8 中使用 Node，基本没有区别，都是 key，value，hash 和 next 这四个属性，不过，Node 只能用于链表的情况，红黑树的情况需要使用 TreeNode。</p><p>我们根据数组元素中，第一个节点数据类型是 Node 还是 TreeNode 来判断该位置下是链表还是红黑树的。</p><h3 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ublic V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 第三个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作</span></span><br><span class="line"><span class="comment">// 第四个参数 evict 我们这里不关心</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 第一次 put 值的时候，会触发下面的 resize()，类似 java7 的第一次 put 也要初始化数组长度</span></span><br><span class="line">    <span class="comment">// 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置就可以了</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 数组该位置有数据</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是"相等"，如果是，取出这个节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果该节点是代表红黑树的节点，调用红黑树的插值方法，本文不展开说红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 到这里，说明数组该位置上是一个链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 插入到链表的最后面(Java7 是插入到链表的最前面)</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 9 个</span></span><br><span class="line">                    <span class="comment">// 会触发下面的 treeifyBin，也就是将链表转换为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果在该链表中找到了"相等"的 key(== 或 equals)</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 此时 break，那么 e 为链表中[与要插入的新值的 key "相等"]的 node</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// e!=null 说明存在旧值的key与要插入的key"相等"</span></span><br><span class="line">        <span class="comment">// 对于我们分析的put操作，下面这个 if 其实就是进行 "值覆盖"，然后返回旧值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>和 Java7 稍微有点不一样的地方就是，Java7 是先扩容后插入新值的，Java8 先插值再扩容，不过这个不重要。</p><ul><li>数组扩容</li></ul><p>resize() 方法用于初始化数组或数组扩容，每次扩容后，容量为原来的 2 倍，并进行数据迁移。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123; <span class="comment">// 对应数组扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将数组大小扩大一倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 将阈值扩大一倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 对应使用 new HashMap() 初始化后，第一次 put 的时候</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 用新的数组大小初始化新的数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab; <span class="comment">// 如果是初始化数组，到这里就结束了，返回 newTab 即可</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 开始遍历原数组，进行数据迁移。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 如果该数组位置上只有单个元素，那就简单了，简单迁移这个元素就可以了</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果是红黑树，具体我们就不展开了</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; </span><br><span class="line">                    <span class="comment">// 这块是处理链表的情况，</span></span><br><span class="line">                    <span class="comment">// 需要将此链表拆成两个链表，放到新的数组中，并且保留原来的先后顺序</span></span><br><span class="line">                    <span class="comment">// loHead、loTail 对应一条链表，hiHead、hiTail 对应另一条链表，代码还是比较简单的</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 第一条链表</span></span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 第二条链表的新的位置是 j + oldCap，这个很好理解</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>其底层数据与HashMap的数据结构相同，数组+链表+红黑树，桶中的结构可能是链表，也可能是红黑树，红黑树是为了提高查找效率。</p><p><img src="/upload/pasted-274.png" alt="upload successful"></p><h2 id="1-7-1"><a href="#1-7-1" class="headerlink" title="1.7"></a>1.7</h2><p>HashMap的容量由负载因子决定，插入的元素超过了容量的范围就会触发扩容操作，就是rehash。<br>在多线程环境下，若同时存在其他元素进行put操作，如果hash值相同，可能出现在同一数组下用链表表示，出现闭环，导致在get的操作会出现死循环，所以hashmap是线程不安全的。<br>Hashtable是线程安全的，它在所有都涉及到多线程操作时都加了synchronized关键字来锁住整个table，意味着所有线程都在争用一把锁，在多线程的环境下，它是安全的，但效率低下。<br>ConcurrentHashMap采用锁分离技术，将锁的粒度降低，利用多个锁来控制多个小的table。<br>ConcurrentHashMap的数据结构是由一个Segment数组和多个HashEntry组成，如下图所示：</p><p><img src="/upload/pasted-275.png" alt="upload successful"><br>ConcurrentHashMap的初始化是会通过位与运算来初始化Segment的大小，用ssize来表示，如下所示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">    ++sshift;</span><br><span class="line">    ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上所示，因为ssize用位于运算来计算（ssize &lt;&lt;=1），所以Segment的大小取值都是以2的N次方，无关concurrencyLevel的取值，当然concurrencyLevel最大只能用16位的二进制来表示，即65536，换句话说，Segment的大小最多65536个，没有指定concurrencyLevel元素初始化，Segment的大小ssize默认为16。<br>每一个Segment元素下的HashEntry的初始化也是按照位于运算来计算，用cap来表示，如下所示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cap = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">    cap &lt;&lt;= <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><p>如上所示，HashEntry大小的计算也是2的N次方（cap &lt;&lt;=1）， cap的初始值为1，所以HashEntry最小的容量为2。</p><h3 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h3><p>对于ConcurrentHashMap的数据插入，这里要进行两次Hash去定位数据的存储位置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br></pre></td></tr></table></figure></p><p>从上Segment的继承体系可以看出，Segment实现了ReentrantLock,也就带有锁的功能，当执行put操作时，会进行第一次key的hash来定位Segment的位置，如果该Segment还没有初始化，即通过CAS操作进行赋值，然后进行第二次hash操作，找到相应的HashEntry的位置，这里会利用继承过来的锁的特性，在将数据插入指定的HashEntry位置时（链表的尾端），会通过继承ReentrantLock的tryLock（）方法尝试去获取锁，如果获取成功就直接插入相应的位置，如果已经有线程获取该Segment的锁，那当前线程会以自旋的方式去继续的调用tryLock（）方法去获取锁，超过指定次数就挂起，等待唤醒。</p><h3 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h3><p>ConcurrentHashMap的get操作跟HashMap类似，只是首先要判断volatile类型变量count是否不等于0，若不等于0则ConcurrentHashMap第一次需要经过一次hash定位到Segment的位置，然后再hash定位到指定的HashEntry，遍历该HashEntry下的链表进行对比，成功就返回，不成功就返回null。是弱一致性的。</p><p>   因为count是volatile，所以对count的写要happens-before于读操作。写线程 M 对链表做的结构性修改，在读线程 N 读取了同一个 volatile 变量后，对线程 N 也是可见的了。虽然线程 N 是在未加锁的情况下访问链表。Java 的内存模型可以保证：只要之前对链表做结构性修改操作的写线程 M 在退出写方法前写 volatile 型变量 count，读线程 N 在读取这个 volatile 型变量 count 后，就一定能“看到”这些修改。使得在 ConcurrentHashMap 中，读线程在读取散列表时，基本不需要加锁就能成功获得需要的值,不仅减少了请求同一个锁的频率（读操作一般不需要加锁就能够成功获得值），也减少了持有同一个锁的时间（只有读到 value 域的值为 null 时 , 读线程才需要加锁后重读）。</p><h3 id="size操作"><a href="#size操作" class="headerlink" title="size操作"></a>size操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">        &#125;</span><br><span class="line">        sum = <span class="number">0L</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        overflow = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">            Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">            <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123; sum += seg.modCount; <span class="keyword">int</span> c = seg.count; <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">               overflow = <span class="keyword">true</span>;</span><br><span class="line">            &#125; &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum == last) <span class="keyword">break</span>;</span><br><span class="line">        last = sum; &#125; &#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">            segmentAt(segments, j).unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一种方案他会使用不加锁的模式去尝试多次计算ConcurrentHashMap的size，最多三次，比较前后两次计算的结果，结果一致就认为当前没有元素加入，计算的结果是准确的；<br>第二种方案是如果第一种方案不符合，他就会给每个Segment加上锁，然后计算ConcurrentHashMap的size返回。</p><h2 id="1-8-1"><a href="#1-8-1" class="headerlink" title="1.8"></a>1.8</h2><p> JDK1.8的实现已经摒弃了Segment的概念，而是直接用Node数组+链表+红黑树的数据结构来实现，并发控制使用Synchronized和CAS来操作，整个看起来就像是优化过且线程安全的HashMap，虽然在JDK1.8中还能看到Segment的数据结构，但是已经简化了属性，只是为了兼容旧版本，序列化与反序列化的时候会发挥作用。</p><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>Node是ConcurrentHashMap存储结构的基本单元，继承于HashMap中的Entry，用于存储数据，源代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//链表的数据结构</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="comment">//val和next都会在扩容时发生变化，所以加上volatile来保持可见性和禁止重排序</span></span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>       </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> key.hashCode() ^ val.hashCode(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + val; &#125;</span><br><span class="line">    <span class="comment">//不允许更新value  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        Object k, v, u; Map.Entry&lt;?,?&gt; e;</span><br><span class="line">        <span class="keyword">return</span> ((o <span class="keyword">instanceof</span> Map.Entry) &amp;&amp;</span><br><span class="line">                (k = (e = (Map.Entry&lt;?,?&gt;)o).getKey()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (v = e.getValue()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (k == key || k.equals(key)) &amp;&amp;</span><br><span class="line">                (v == (u = val) || v.equals(u)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用于map中的get（）方法，子类重写</span></span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                K ek;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Node数据结构很简单，它与HashMap中的定义很相似，但是但是有一些差别它对value和next属性设置了volatile同步锁，它不允许调用setValue方法直接改变Node的value域，它增加了find方法辅助map.get()方法。</p><h3 id="TreeNode"><a href="#TreeNode" class="headerlink" title="TreeNode"></a>TreeNode</h3><p>TreeNode继承与Node，但是数据结构换成了二叉树结构，它是红黑树的数据的存储结构，用于红黑树中存储数据，当链表的节点数大于8时会转换成红黑树的结构，树节点类，另外一个核心的数据结构。当链表长度过长的时候，会转换为TreeNode。但是与HashMap不相同的是，它并不是直接转换为红黑树，而是把这些结点包装成TreeNode放在TreeBin对象中，由TreeBin完成对红黑树的包装。而且TreeNode在ConcurrentHashMap集成自Node类，而并非HashMap中的集成自LinkedHashMap.Entry&lt;K,V&gt;类，也就是说TreeNode带有next指针，这样做的目的是方便基于TreeBin的访问。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//树形结构的属性定义</span></span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red; <span class="comment">//标志红黑树的红节点</span></span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next,</span><br><span class="line">             TreeNode&lt;K,V&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> findTreeNode(h, k, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据key查找 从根节点开始找出相应的TreeNode，</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">findTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">do</span>  &#123;</span><br><span class="line">                <span class="keyword">int</span> ph, dir; K pk; TreeNode&lt;K,V&gt; q;</span><br><span class="line">                TreeNode&lt;K,V&gt; pl = p.left, pr = p.right;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (pk != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                          (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">                    p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.findTreeNode(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p = pl;</span><br><span class="line">            &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="TreeBin"><a href="#TreeBin" class="headerlink" title="TreeBin"></a>TreeBin</h3><p>TreeBin从字面含义中可以理解为存储树形结构的容器，而树形结构就是指TreeNode，所以TreeBin就是封装TreeNode的容器，它提供转换黑红树的一些条件和锁的控制。这个类并不负责包装用户的key、value信息，而是包装的很多TreeNode节点。它代替了TreeNode的根节点，也就是说在实际的ConcurrentHashMap“数组”中，存放的是TreeBin对象，而不是TreeNode对象，这是与HashMap的区别。另外这个类还带有了读写锁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//指向TreeNode列表和根节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; root;</span><br><span class="line">    <span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> lockState;</span><br><span class="line">    <span class="comment">// 读写锁状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITER = <span class="number">1</span>; <span class="comment">// 获取写锁的状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITER = <span class="number">2</span>; <span class="comment">// 等待写锁的状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER = <span class="number">4</span>; <span class="comment">// 增加数据时读锁的状态</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化红黑树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TreeBin(TreeNode&lt;K,V&gt; b) &#123;</span><br><span class="line">        <span class="keyword">super</span>(TREEBIN, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.first = b;</span><br><span class="line">        TreeNode&lt;K,V&gt; r = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = b, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">            next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">            x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">                x.parent = <span class="keyword">null</span>;</span><br><span class="line">                x.red = <span class="keyword">false</span>;</span><br><span class="line">                r = x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                K k = x.key;</span><br><span class="line">                <span class="keyword">int</span> h = x.hash;</span><br><span class="line">                Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = r;;) &#123;</span><br><span class="line">                    <span class="keyword">int</span> dir, ph;</span><br><span class="line">                    K pk = p.key;</span><br><span class="line">                    <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                        dir = -<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                        dir = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                              (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                             (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                        dir = tieBreakOrder(k, pk);</span><br><span class="line">                        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                    <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        x.parent = xp;</span><br><span class="line">                        <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                            xp.left = x;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            xp.right = x;</span><br><span class="line">                        r = balanceInsertion(r, x);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.root = r;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="ForwardingNode"><a href="#ForwardingNode" class="headerlink" title="ForwardingNode"></a>ForwardingNode</h3><p>一个用于连接两个table的节点类。它包含一个nextTable指针，用于指向下一张表。而且这个节点的key value next指针全部为null，它的hash值为-1. 这里面定义的find的方法是从nextTable里进行查询节点，而不是以自身为头节点进行查找<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">     * A node inserted at head of bins during transfer operations. </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;  </span><br><span class="line">        <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;  </span><br><span class="line">        ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;  </span><br><span class="line">            <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);  </span><br><span class="line">            <span class="keyword">this</span>.nextTable = tab;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;  </span><br><span class="line">            <span class="comment">// loop to avoid arbitrarily deep recursion on forwarding nodes  </span></span><br><span class="line">            outer: <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = nextTable;;) &#123;  </span><br><span class="line">                Node&lt;K,V&gt; e; <span class="keyword">int</span> n;  </span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span> || tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||  </span><br><span class="line">                    (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) == <span class="keyword">null</span>)  </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">                    <span class="keyword">int</span> eh; K ek;  </span><br><span class="line">                    <span class="keyword">if</span> ((eh = e.hash) == h &amp;&amp;  </span><br><span class="line">                        ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))  </span><br><span class="line">                        <span class="keyword">return</span> e;  </span><br><span class="line">                    <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">                        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ForwardingNode) &#123;  </span><br><span class="line">                            tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;  </span><br><span class="line">                            <span class="keyword">continue</span> outer;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        <span class="keyword">else</span>  </span><br><span class="line">                            <span class="keyword">return</span> e.find(h, k);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)  </span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;http://www.importnew.com/28263.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://www.importnew.com/28263.html&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Hashmap&quot;
      
    
    </summary>
    
      <category term="数据结构" scheme="https://www.junglezero.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="java相关" scheme="https://www.junglezero.top/tags/java%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>volatile关键字</title>
    <link href="https://www.junglezero.top/2019/04/09/atile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>https://www.junglezero.top/2019/04/09/atile关键字/</id>
    <published>2019-04-09T07:24:00.000Z</published>
    <updated>2019-04-10T07:22:10.401Z</updated>
    
    <content type="html"><![CDATA[<h1 id="准备概念"><a href="#准备概念" class="headerlink" title="准备概念"></a>准备概念</h1><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p>当一个变量被两个线程同时处理时，由于两个线程处在不同的CPU中（多核CPU），因此对于该变量存在缓存一致性的问题<br>在硬件层面上，有两种解决方式：总线加锁，通过缓存一致性协议</p><p><img src="/upload/pasted-270.png" alt="upload successful"></p><h2 id="并发编程的三个概念"><a href="#并发编程的三个概念" class="headerlink" title="并发编程的三个概念"></a>并发编程的三个概念</h2><ul><li>原子性：<br>即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。<br>Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</li><li>可见性：<br>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。<br>对于可见性，Java提供了volatile关键字来保证可见性。<br>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。<br>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</li><li>有序性：<br>即程序执行的顺序按照代码的先后顺序执行<br>一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。（重排序）<br>在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</li></ul><h2 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a>happens-before原则</h2><p>在java中，有一套“happens-before”原则，满足这个原则，则会顺序执行，不满足则会发生重排序</p><ul><li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li><li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作</li><li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li><li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li><li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</li><li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li><li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li><li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li></ul><h1 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>1.保证了修饰变量的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> INIT_VALUE = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_LIMIT = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> localValue = INIT_VALUE;</span><br><span class="line">            <span class="keyword">while</span> (localValue &lt; MAX_LIMIT) &#123;</span><br><span class="line">                <span class="keyword">if</span> (localValue != INIT_VALUE) &#123;</span><br><span class="line">                    System.out.printf(<span class="string">"The value updated to [%d]\n"</span>, INIT_VALUE);</span><br><span class="line">                    localValue = INIT_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"READER"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> localValue = INIT_VALUE;</span><br><span class="line">            <span class="keyword">while</span> (INIT_VALUE &lt; MAX_LIMIT) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"Update the value to [%d]\n"</span>, ++localValue);</span><br><span class="line">                INIT_VALUE = localValue;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"UPDATER"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Update the value to [1]</span><br><span class="line">The value updated to [1]</span><br><span class="line">Update the value to [2]</span><br><span class="line">The value updated to [2]</span><br><span class="line">Update the value to [3]</span><br><span class="line">The value updated to [3]</span><br><span class="line">Update the value to [4]</span><br><span class="line">The value updated to [4]</span><br><span class="line">Update the value to [5]</span><br><span class="line">The value updated to [5]</span><br></pre></td></tr></table></figure></p><p>当INIT_VALUE没有被volatile修饰时<br>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Update the value to [1]</span><br><span class="line">Update the value to [2]</span><br><span class="line">Update the value to [3]</span><br><span class="line">Update the value to [4]</span><br><span class="line">Update the value to [5]</span><br></pre></td></tr></table></figure></p><p>分析：在没有volatile修饰时，对于第一个读线程，此时判定是两个值是相等的，因此执行完毕后就退出了，而有了volatile修饰后，这个值就是可见的了，而且是立即可见，因此会不断的运行</p><p>2.volatile可以保证有序性<br>volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。<br>volatile关键字禁止指令重排序有两层意思：<br>1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；<br>2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。<br>举例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x、y为非volatile变量</span></span><br><span class="line"><span class="comment">//flag为volatile变量</span></span><br><span class="line"> </span><br><span class="line">x = <span class="number">2</span>;        <span class="comment">//语句1</span></span><br><span class="line">y = <span class="number">0</span>;        <span class="comment">//语句2</span></span><br><span class="line">flag = <span class="keyword">true</span>;  <span class="comment">//语句3</span></span><br><span class="line">x = <span class="number">4</span>;         <span class="comment">//语句4</span></span><br><span class="line">y = -<span class="number">1</span>;       <span class="comment">//语句5</span></span><br></pre></td></tr></table></figure></p><p>　由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。<br>并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</p><p>对于<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">context = loadContext();   <span class="comment">//语句1</span></span><br><span class="line">inited = <span class="keyword">true</span>;             <span class="comment">//语句2</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure></p><p>有可能语句2会在语句1之前执行，那么可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。<br>这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>　synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。<br> 通常来说，使用volatile必须具备以下2个条件：</p><p>　　1）对变量的写操作不依赖于当前值</p><p>　　2）该变量没有包含在具有其他变量的不变式中</p><p>1.状态标记量<br><figure class="highlight plain"><figcaption><span>boolean flag </span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">while(!flag)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public void setFlag() &#123;</span><br><span class="line">    flag = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> inited = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//线程1:</span></span><br><span class="line">context = loadContext();  </span><br><span class="line">inited = <span class="keyword">true</span>;            </span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;</span><br><span class="line">sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure><p>2.单例模式中的doublecheck<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>参考自 <a href="https://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3920373.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;准备概念&quot;&gt;&lt;a href=&quot;#准备概念&quot; class=&quot;headerlink&quot; title=&quot;准备概念&quot;&gt;&lt;/a&gt;准备概念&lt;/h1&gt;&lt;h2 id=&quot;内存模型&quot;&gt;&lt;a href=&quot;#内存模型&quot; class=&quot;headerlink&quot; title=&quot;内存模型&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="java多线程学习" scheme="https://www.junglezero.top/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="java多线程" scheme="https://www.junglezero.top/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="关键字系列" scheme="https://www.junglezero.top/tags/%E5%85%B3%E9%94%AE%E5%AD%97%E7%B3%BB%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>多线程下的单例设计模式</title>
    <link href="https://www.junglezero.top/2019/04/09/%E7%A8%8B%E4%B8%8B%E7%9A%84%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://www.junglezero.top/2019/04/09/程下的单例设计模式/</id>
    <published>2019-04-09T02:14:00.000Z</published>
    <updated>2019-04-15T02:01:42.453Z</updated>
    
    <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>1、单例类只能有一个实例。<br>2、单例类必须自己创建自己的唯一实例。<br>3、单例类必须给所有其他对象提供这一实例。<br>单例模式保证了全局对象的唯一性，比如系统启动读取配置文件就需要单例保证配置的一致性。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>饿汉式单例模式：类加载初始化时就创建好一个静态的对象供外部使用，除非系统重启，这个对象不会改变，所以本身就是线程安全的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObject1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无法进行懒加载：一旦类加载了，就会占用内存空间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonObject1 instance = <span class="keyword">new</span> SingletonObject1();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数私有</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonObject1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//empty</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonObject1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>懒汉式单例（延迟加载方式）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObject2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonObject2 instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonObject2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//empty</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//虽然实现了调用才构造（即懒加载），但是存在线程安全问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonObject2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance)</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonObject2();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> SingletonObject2.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>部分加锁的懒汉式单例，实际上最初的想法是在整个方法上加锁，但实际上虽然解决了多个实例对象问题，但是该方式运行效率却很低下，下一个线程想要获取对象，就必须等待上一个线程释放锁之后，才可以继续运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObject4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonObject4 instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonObject4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//---</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//double check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonObject4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">            <span class="comment">//在创建处加锁，防止多个线程的多次创建</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonObject4.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == instance)</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonObject4();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> SingletonObject4.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类的方法,这种方法巧用类的加载机制，而且也能保证线程安全，在未使用时，不会加载内部类，只有在使用实例时，才会加载内部类，从而初始化实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObject6</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonObject6</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> SingletonObject6 instance = <span class="keyword">new</span> SingletonObject6();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonObject6 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InstanceHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过内部枚举实现：枚举的构造函数只会调用一次<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObject7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonObject7</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> SingletonObject7 instance;</span><br><span class="line"></span><br><span class="line">        Singleton() &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonObject7();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> SingletonObject7 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonObject7 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h1&gt;&lt;p&gt;单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程
      
    
    </summary>
    
      <category term="java多线程学习" scheme="https://www.junglezero.top/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="设计模式" scheme="https://www.junglezero.top/categories/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="java多线程" scheme="https://www.junglezero.top/tags/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="设计模式" scheme="https://www.junglezero.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>从爬楼梯问题所想到的</title>
    <link href="https://www.junglezero.top/2019/04/03/%E6%A5%BC%E6%A2%AF%E9%97%AE%E9%A2%98%E6%89%80%E6%83%B3%E5%88%B0%E7%9A%84/"/>
    <id>https://www.junglezero.top/2019/04/03/楼梯问题所想到的/</id>
    <published>2019-04-03T00:16:00.000Z</published>
    <updated>2019-04-09T07:25:49.090Z</updated>
    
    <content type="html"><![CDATA[<p>一道简单的爬楼梯问题</p><p>You are climbing a stair case. It takes n steps to reach to the top.</p><p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?<br><strong>Note:</strong> Given n will be a positive integer.</p><p><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step</span><br><span class="line">2. 2 steps</span><br></pre></td></tr></table></figure></p><p><strong>Example2</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: There are three ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step + 1 step</span><br><span class="line">2. 1 step + 2 steps</span><br><span class="line">3. 2 steps + 1 step</span><br></pre></td></tr></table></figure></p><p>这是一道DP入门级别的题目，按照自顶向下（TOP to BOTTOM）的思考方式,要向到第n级台阶的话，只需要第n-1阶走一级或者n-2阶走两级，这时问题就又变成了到n-1阶和n-2阶有多少种方法，因此可以得到dp式子：dp(n)=dp(n-1)+dp(n-2)</p><p>因此，自然而然就写出了以下实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d[n] &gt; <span class="number">0</span>) <span class="keyword">return</span> d[n];</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> climbStairs(n - <span class="number">1</span>) + climbStairs(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然而，提交以后就报TLE,细细一想，这种递归方式，虽然写起来简单，而且看上去也很好理解，但是这里有个严重的缺陷：有些计算会重复很多次，比如计算dp(6)，需要算dp(5)和dp(4)，算dp(5)需要算dp(4),dp(3),这个时候，dp(4)就算了两次，求的数越大，重复计算的次数也就愈多</p><p>于是我就想班里的搞竞赛的大佬讨教，大佬首先给出了“记录搜索”<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> d[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d[n] &gt; <span class="number">0</span>) <span class="keyword">return</span> d[n];</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> d[n] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> d[n] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d[n] = climbStairs(n - <span class="number">1</span>) + climbStairs(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所谓“记录搜索”，就是查表，所谓的表，就是把计算的结果存起来，刚才的问题不就是需要重复计算吗，这样一来就没有重复计算的问题</p><p>后来看讨论区，又有种方法就是自底向上，顺序递推的方式，时间复杂度为O(n)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d[n] &gt; <span class="number">0</span>) <span class="keyword">return</span> d[n];</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> N_1=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> N_2=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">        ans=N_1+N_2;</span><br><span class="line">        N_1=N_2;</span><br><span class="line">        N_2=ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然而，现在又有一个新的问题，假设需要算1e8的情况，那么即使是O(n),也会超时，这时候就需要一种更快的方式<br>这里就有一种新的处理方式：<strong>矩阵快速幂</strong>（感谢大佬特地跑过来给我讲，要不然都没地方去知道）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一道简单的爬楼梯问题&lt;/p&gt;
&lt;p&gt;You are climbing a stair case. It takes n steps to reach to the top.&lt;/p&gt;
&lt;p&gt;Each time you can either climb 1 or 2 steps
      
    
    </summary>
    
      <category term="刷算法题" scheme="https://www.junglezero.top/categories/%E5%88%B7%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="算法题目" scheme="https://www.junglezero.top/tags/%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE/"/>
    
  </entry>
  
</feed>
