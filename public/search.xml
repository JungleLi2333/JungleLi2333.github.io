<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>设计模式总结（3）【】</title>
      <link href="/2019/07/26/%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2019/07/26/%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img.3dmgame.com/uploads/images/news/20190331/1554021622_367580.jpg" width="70%"></p><a id="more"></a><h1 id="模板方法设计模式"><a href="#模板方法设计模式" class="headerlink" title="模板方法设计模式"></a>模板方法设计模式</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p><strong>模板方法模式是类的行为模式。准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。这就是模板方法模式的用意。</strong></p><blockquote><p>例如: 在现实生活中，完成某件事情是需要 n 个固定步骤的。如”在淘宝进行购物”这件事情的完成一般需要三个步骤: <strong>登录网站、挑选商品、 付款</strong>。但对于登录网站与付款这两步，每个人几乎都是相同的操作。但不同的地方是，每个人所挑选的商品是不同的。<br>在软件开发过程中同样存在这样的情况。某类的某个方法的实现，需要几个固定步骤。在这些固定步骤中,对于该类的不同对象， 有些步骤的实现是固定不变的，有些步骤的实现是大相径庭的，有些步骤的实现是可变可不变的。对于这种情况，就适合使用模板方法设计模式编程。</p></blockquote><h2 id="二、结构"><a href="#二、结构" class="headerlink" title="二、结构"></a>二、结构</h2><p>基本结构:</p><p>在模板方法设计模式中，存在一个<strong>父类</strong>(一般是<strong>抽象</strong>的)。其中包含 两类方法:  模板方法 和 3 种步骤方法；</p><ul><li>模板方法: 即实现某种算法的方法步骤。这些步骤都是调用的步骤方法实现的。</li><li>步骤方法:即完成模板方法的每个阶段性方法。<ul><li>抽象方法: 子类必须实现的方法。即子类的个性化定义；</li><li>最终方法(固定方法): 子类不能重写的方法，即所有子类都要做的步骤；</li><li>钩子方法: 父类给了默认实现，子类可以重写，也可以不重写的方法；</li></ul></li></ul><p>结构:</p><p><img src="/images/09_template_02.png" alt="09_template_02.png"></p><h2 id="三、案例"><a href="#三、案例" class="headerlink" title="三、案例"></a>三、案例</h2><blockquote><p>实现在网站上购物的案例。</p></blockquote><p>基本逻辑图:</p><p><img src="/images/09_template_01.png" alt="09_template_01.png"></p><p>代码:</p><p>首先看<code>Shopping</code>类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Shopping</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模板方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyGoods</span><span class="params">()</span></span>&#123;</span><br><span class="line">        useLogin(); <span class="comment">//固定的方法，子类不能重写</span></span><br><span class="line">        buy();      <span class="comment">//抽象方法，子类必须实现</span></span><br><span class="line">        pay();      <span class="comment">//钩子方法(hook)，子类可以重写</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 固定方法(最终方法)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">useLogin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用户登录"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抽象方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 钩子方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用银联支付"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是两个子类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShoesShopping</span> <span class="keyword">extends</span> <span class="title">Shopping</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"购买Nike鞋子!!!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClothesShopping</span> <span class="keyword">extends</span> <span class="title">Shopping</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"购买海澜之家男装!!!!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写了钩子方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用支付宝支付"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Shopping shoesShopping = <span class="keyword">new</span> ShoesShopping();</span><br><span class="line">        shoesShopping.buyGoods();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">        Shopping clothesShopping = <span class="keyword">new</span> ClothesShopping();</span><br><span class="line">        clothesShopping.buyGoods();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">用户登录</span><br><span class="line">购买Nike鞋子!!!!</span><br><span class="line">使用银联支付</span><br><span class="line">-----------------------</span><br><span class="line">用户登录</span><br><span class="line">购买海澜之家男装!!!!!</span><br><span class="line">使用支付宝支付</span><br></pre></td></tr></table></figure><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>有时候为了防止恶意操作，模板方法也会加上 <code>final</code> 关键词。</p><h2 id="五、实际使用"><a href="#五、实际使用" class="headerlink" title="五、实际使用"></a>五、实际使用</h2><p>Spring对数据库的操作在jdbc上面做了深层次的封装，使用spring的注入功能，可以把DataSource注册到JdbcTemplate之中。<br>这个JdbcTemplate用的是一种更高级的模板思想，具体说来，它引入了一种回调模式<br>对于JdbcTemplate，它是个抽象类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplate</span> </span>&#123;  </span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">final</span> Object execute（String sql）&#123;  </span><br><span class="line">        Connection con=<span class="keyword">null</span>;  </span><br><span class="line">        Statement stmt=<span class="keyword">null</span>;  </span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            con=getConnection（）;  </span><br><span class="line">            stmt=con.createStatement（）;  </span><br><span class="line">            Object retValue=executeWithStatement（stmt,sql）;  </span><br><span class="line">            <span class="keyword">return</span> retValue;  </span><br><span class="line">        &#125;<span class="keyword">catch</span>（SQLException e）&#123;  </span><br><span class="line">             ...  </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;  </span><br><span class="line">            closeStatement（stmt）;  </span><br><span class="line">            releaseConnection（con）;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">abstract</span> Object executeWithStatement（Statement   stmt, String sql）;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>要是想使用，就必须要实现，但是其中的方法太多<br>因此就引出了中间态的回调<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StatementCallback</span></span>&#123;  </span><br><span class="line">    Object doWithStatement（Statement stmt）;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后在进行具体的实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplate</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Object execute（StatementCallback callback）&#123;  </span><br><span class="line">        Connection con=<span class="keyword">null</span>;  </span><br><span class="line">        Statement stmt=<span class="keyword">null</span>;  </span><br><span class="line">        <span class="keyword">try</span>&#123;  </span><br><span class="line">            con=getConnection（）;  </span><br><span class="line">            stmt=con.createStatement（）;  </span><br><span class="line">            Object retValue=callback.doWithStatement（stmt）;  </span><br><span class="line">            <span class="keyword">return</span> retValue;  </span><br><span class="line">        &#125;<span class="keyword">catch</span>（SQLException e）&#123;  </span><br><span class="line">            ...  </span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;  </span><br><span class="line">            closeStatement（stmt）;  </span><br><span class="line">            releaseConnection（con）;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    ...<span class="comment">//其它方法定义  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><h2 id="一、基本概念-1"><a href="#一、基本概念-1" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>迭代器模式属于行为型模式。</p><p>这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。</p><p>如果我们需要统一遍历不同的集合(容器)，也可以利用迭代器模式解决(下面的案例就是解决这个问题)。</p><h2 id="二、结构-1"><a href="#二、结构-1" class="headerlink" title="二、结构"></a>二、结构</h2><p>结构:</p><p><img src="/images/10_iterator_01.png" alt="10_iterator_01.png"></p><ul><li><code>Container</code> 是聚合类，其中 <code>getIterator()</code> 方法可以产生一个 <code>Iterator</code>；</li><li><code>Iterator</code> 主要定义了 <code>hasNext()</code> 和 <code>next()</code> 方法；</li><li>每一个<code>Container</code>的实现类都会有一个具体的<code>Iterator</code>实现类来帮助实现迭代；</li></ul><h2 id="三、案例-1"><a href="#三、案例-1" class="headerlink" title="三、案例"></a>三、案例</h2><blockquote><p>实现两个容器能够统一遍历。(或者两个以上)</p></blockquote><p>先看代码结构: (<strong>这里我将两个迭代器实现类写在两个容器内部</strong>)</p><p><img src="/images/10_iterator_02.png" alt="10_iterator_02.png"></p><p>代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line">    <span class="function">Iterator <span class="title">getIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个容器类，他们内部的容器不同，内部有自带不同的迭代器:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteContainer1</span> <span class="keyword">implements</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteContainer1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> Integer[<span class="number">10</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) arr[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteIterator1&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator1</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(index &lt; arr.length)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(hasNext())</span><br><span class="line">                <span class="keyword">return</span> arr[index++];</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteContainer2</span> <span class="keyword">implements</span> <span class="title">Container</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ArrayList arr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteContainer2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        arr = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) arr.add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">getIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteIterator1&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator1</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(index &lt; arr.size())</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(hasNext())</span><br><span class="line">                <span class="keyword">return</span> arr.get(index++);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果不这么做，需要区分c1和c2的遍历方式, 一个是数组，一个是List</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Container c1 = <span class="keyword">new</span> ConcreteContainer1();</span><br><span class="line">        Container c2 = <span class="keyword">new</span> ConcreteContainer2();</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Iterator&gt;its = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        its.add(c1.getIterator()); <span class="comment">// 将c1迭代器加入its</span></span><br><span class="line">        its.add(c2.getIterator()); <span class="comment">// 将c1迭代器加入its</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现了统一遍历, 只需要将迭代器加入到 its中即可</span></span><br><span class="line">        <span class="keyword">for</span>(Iterator it : its) &#123;</span><br><span class="line">            <span class="keyword">while</span>(it.hasNext())</span><br><span class="line">                System.out.print( it.next() + <span class="string">" "</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> </span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span></span><br></pre></td></tr></table></figure><h2 id="四、总结-1"><a href="#四、总结-1" class="headerlink" title="四、总结"></a>四、总结</h2><p>优点:</p><ul><li>在同一个聚合上可以有多个遍历；</li><li>在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码；</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式总结（2）【策略模式、观察者模式、装饰者模式，适配器模式】</title>
      <link href="/2019/07/25/signpattern2/"/>
      <url>/2019/07/25/signpattern2/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img.3dmgame.com/uploads/images/thumbpicfirst/20190219/1550567116_731464.jpg" width="70%"></p><a id="more"></a><h1 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>策略模式是<strong>行为型</strong>设计模式。</p><p>其用意是针对一组算法，<strong>将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换</strong>。</p><p>策略模式使得算法可以在不影响到客户端的情况下发生变化。</p><h2 id="二、结构"><a href="#二、结构" class="headerlink" title="二、结构"></a>二、结构</h2><p>下面是基本结构:</p><p><img src="/images/01_stratgy_01.png" alt></p><p>三类角色:</p><ul><li><strong>环境(Context)角色</strong>：持有一个<code>Strategy</code>的引用。</li><li><strong>抽象策略(Strategy)角色</strong>：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</li><li><strong>具体策略(ConcreteStrategy)角色</strong>：包装了相关的算法或行为。</li></ul><h2 id="三、案例"><a href="#三、案例" class="headerlink" title="三、案例"></a>三、案例</h2><p>案例实现:</p><blockquote><p>定义一族算法，可以实现对两个数的操作，例如<code>+、-、*、/</code>等。</p></blockquote><p>实现代码整体框架图:</p><p><img src="/images/01_stratgy_02.png" alt="pic"></p><p>具体代码实现:</p><p><code>Context</code>类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Context 是一个使用了某种策略的类。 实现了 Strategy 接口的实体策略类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Strategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">executeStrategy</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strategy.doOperation(num1, num2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Strategy</code>接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**策略的公共接口*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三种对应的算法实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 算法１: 实现加法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationAdd</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 + num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 算法2：实现减法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationSubstract</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 - num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 算法3: 实现乘法 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OperationMultiply</span> <span class="keyword">implements</span> <span class="title">Strategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">doOperation</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num1 * num2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Context context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationAdd());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"10 + 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationSubstract());</span><br><span class="line">        System.out.println(<span class="string">"10 - 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">        context = <span class="keyword">new</span> Context(<span class="keyword">new</span> OperationMultiply());</span><br><span class="line">        System.out.println(<span class="string">"10 * 5 = "</span> + context.executeStrategy(<span class="number">10</span>, <span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> + <span class="number">5</span> = <span class="number">15</span></span><br><span class="line"><span class="number">10</span> - <span class="number">5</span> = <span class="number">5</span></span><br><span class="line"><span class="number">10</span> * <span class="number">5</span> = <span class="number">50</span></span><br></pre></td></tr></table></figure><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><ul><li>策略模式的重心不是如何实现算法，而是如何组织、调用这些算法；</li><li>策略模式一个很大的特点就是各个策略算法的平等性。对于一系列具体的策略算法，大家的地位是完全一样的，正因为这个平等性，才能实现算法之间可以相互替换；</li><li>使用策略模式可以避免使用多重条件(if-else)语句；</li></ul><h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="一、基本概念-1"><a href="#一、基本概念-1" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>观察者模式是行为型设计模式。</p><ul><li><strong>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新</strong>；</li><li>被依赖的对象为<code>Subject</code>(被观察者)，依赖的对象为<code>Observer</code>，<code>Subject</code>通知<code>Observer</code>变化；</li><li><code>Subject</code> : 登记注册<code>register/attach</code>、移除<code>remove</code>、通知<code>notify</code>；</li><li><code>Observer</code> : 接收变化<code>update</code>； </li><li>可以把观察者模式想象成订报纸一样，<strong>出版者+订阅者 = 观察者模式</strong>；</li></ul><h2 id="二、结构-1"><a href="#二、结构-1" class="headerlink" title="二、结构"></a>二、结构</h2><p>观察者模式所涉及的角色有：</p><p>　　● <strong>抽象主题(Subject)角色：</strong>抽象主题角色把所有对<strong>观察者对象</strong>的引用保存在一个聚集（比如<code>List</code>对象）里。抽象主题提供一个接口，可以增加和删除观察者对象，抽象主题角色又叫做抽象被观察者(Observable)角色；</p><p>　　● <strong>具体主题(ConcreteSubject)角色</strong>：将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色；</p><p>　　● <strong>抽象观察者(Observer)角色</strong>：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。</p><p>　　● <strong>具体观察者(ConcreteObserver)角色</strong>：存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。如果需要，具体观察者角色可以保持一个指向具体主题对象(Concrete Subject)的引用；</p><p><img src="/images/02_observer_02.png" alt="02_observer_02.png"></p><h2 id="三、案例-1"><a href="#三、案例-1" class="headerlink" title="三、案例"></a>三、案例</h2><p>案例：</p><blockquote><p>实现的功能是气象站的管理，给你一个<code>WeatherData</code>类(<strong>被观察者</strong>)，提供了获取温度，湿度，和气压的函数，要你设计类并添加一些公告板(<strong>观察者</strong>)，可以显示相关的信息；</p></blockquote><p>基本结构图:</p><p><img src="/images/02_observer_01.png" alt="02_observer_01.png"></p><p><strong>下面使用自定义的观察者和Java内置观察者实现</strong>。</p><h3 id="1、自定义的观察者实现"><a href="#1、自定义的观察者实现" class="headerlink" title="1、自定义的观察者实现"></a>1、自定义的观察者实现</h3><p>基本代码结构组织图:</p><p><img src="/images/02_observer_03.png" alt="02_observer_03.png"></p><p>先看被观察者包<code>subjects</code>里面的两个:</p><p><code>Subject</code>接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**被观察者接口*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerObservers</span><span class="params">(Observer o)</span></span>;<span class="comment">//注册</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeObservers</span><span class="params">(Observer o)</span></span>; <span class="comment">//移除</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span>; <span class="comment">//通知</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>WeatherData</code>类 (被观察者的实现):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被观察者的实现</span></span><br><span class="line"><span class="comment"> * 里面有:</span></span><br><span class="line"><span class="comment"> *   1、观察者接口的集合数据结构</span></span><br><span class="line"><span class="comment"> * 　2、实现添加观察者方法(registerObservers)</span></span><br><span class="line"><span class="comment"> *   3、移除观察者方法(removeObservers)</span></span><br><span class="line"><span class="comment"> *   4、通知所有观察者的方法(notifyObservers)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> pressure;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 可以提供getter()方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Observer&gt;observers;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">double</span> temperature, <span class="keyword">double</span> humidity, <span class="keyword">double</span> pressure)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line"></span><br><span class="line">        dataChanged();<span class="comment">//更新完信息就马上通知观察者</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据改变之后就通知观察者(从气象站得到更新的观测值之后，通知观察者)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">()</span></span>&#123;</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObservers</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        observers.add(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObservers</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = observers.indexOf(o);</span><br><span class="line">        <span class="keyword">if</span>(index &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            observers.remove(o);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; observers.size(); i++)&#123;</span><br><span class="line">            Observer observer = observers.get(i);</span><br><span class="line">            observer.update(temperature, humidity, pressure);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 然后再看<code>observers</code>包的接口和实现类:</p><p><code>Observer</code>接口:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 观察者 接口*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">double</span> temperature, <span class="keyword">double</span> humidity, <span class="keyword">double</span> pressure)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两个实现类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 观察者1 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentConditionDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> pressure;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">double</span> temperature, <span class="keyword">double</span> humidity, <span class="keyword">double</span> pressure)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"CurrentDisplay : "</span> +</span><br><span class="line">                <span class="string">"["</span> + temperature  +</span><br><span class="line">                <span class="string">", "</span> + humidity  +</span><br><span class="line">                <span class="string">", "</span> + pressure + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 观察者2  明天的天气展示 : Math.random * 当前设置值, 主要是为了展示和上一个观察者的不同*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TomorrowConditionDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> pressure;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">double</span> temperature, <span class="keyword">double</span> humidity, <span class="keyword">double</span> pressure)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ( (int)(10 * Math.random())/2 + 1)  生成 [1,5]的随机数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"TomorrowDisplay : "</span> +</span><br><span class="line">                <span class="string">"["</span> + temperature * ( (<span class="keyword">int</span>)(<span class="number">10</span> * Math.random())/<span class="number">2</span> + <span class="number">1</span>) +</span><br><span class="line">                <span class="string">", "</span> + humidity * ( (<span class="keyword">int</span>)(<span class="number">10</span> * Math.random())/<span class="number">2</span> + <span class="number">1</span>) +</span><br><span class="line">                <span class="string">", "</span> + pressure * ( (<span class="keyword">int</span>)(<span class="number">10</span> * Math.random())/<span class="number">2</span> + <span class="number">1</span>) + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WeatherData weatherData = <span class="keyword">new</span> WeatherData(); <span class="comment">// 创建一个被观察者(Subject的实现类)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建两个观察者 (Observer的实现类)</span></span><br><span class="line">        CurrentConditionDisplay current = <span class="keyword">new</span> CurrentConditionDisplay();</span><br><span class="line">        TomorrowConditionDisplay tomorrow = <span class="keyword">new</span> TomorrowConditionDisplay();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 在被观察者的List中注册两个观察者</span></span><br><span class="line">        weatherData.registerObservers(current);</span><br><span class="line">        weatherData.registerObservers(tomorrow);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置完(天气更新)就会自动通知两个观察者</span></span><br><span class="line">        weatherData.setData(<span class="number">10</span>,<span class="number">100</span>,<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"----------移除Tomorrow公告板----------"</span>);</span><br><span class="line">        weatherData.removeObservers(tomorrow);</span><br><span class="line"></span><br><span class="line">        weatherData.setData(<span class="number">20</span>,<span class="number">200</span>,<span class="number">25</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CurrentDisplay : [<span class="number">10.0</span>, <span class="number">100.0</span>, <span class="number">50.0</span>]</span><br><span class="line">TomorrowDisplay : [<span class="number">10.0</span>, <span class="number">100.0</span>, <span class="number">150.0</span>]</span><br><span class="line">----------移除Tomorrow公告板----------</span><br><span class="line">CurrentDisplay : [<span class="number">20.0</span>, <span class="number">200.0</span>, <span class="number">25.0</span>]</span><br></pre></td></tr></table></figure><h3 id="2、Java内置观察者实现"><a href="#2、Java内置观察者实现" class="headerlink" title="2、Java内置观察者实现"></a>2、Java内置观察者实现</h3><p>被观察者继承自<code>Observable</code>类，观察者实现<code>Observer</code>接口:</p><ul><li><code>Observable</code>类中有<code>addObserver()</code>方法，类似于我们的<code>registerObserver()</code>；</li><li><code>Observable</code>类中有<code>deleteObserver()</code>方法，类似与我们的<code>removeObserver()</code>；</li><li>此外<code>Observable</code>类中还有两个<code>notifyObservers()</code>方法。为什么两个呢?<ul><li>Java内置的被观察者更新的方法有两种，一种是推，一种是拉；</li><li><code>public void notifyObservers(Object arg)</code>对应的是”推”；意思就是推送给观察者；</li><li><code>public void notifyObservers()</code>对应的是”拉”；意思就是需要观察者自己拉取数据；</li></ul></li><li>内置的和自己定义的在更新的时候有一个很大的不同就是: Java内置观察者在更新的时候，需要先调用一个<code>setChanged()</code>方法，标记状态已经被改变的事实。这个可以更加灵活的使用观察者模式(在调用<code>setChanged()</code>之前添加一些条件)；</li></ul><p>基本代码结构组织图:</p><p><img src="/images/02_observer_04.png" alt="02_observer_04.png"></p><p>代码如下:</p><p>首先看被观察者: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里需要继承Java的Observable类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> pressure;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTemperature</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> temperature;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getHumidity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> humidity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPressure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pressure;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">double</span> temperature, <span class="keyword">double</span> humidity, <span class="keyword">double</span> pressure)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">        <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">        <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">        dataChanged();<span class="comment">//更新完信息就马上通知观察者</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数据改变之后就通知观察者(从气象站得到更新的观测值之后，通知观察者)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dataChanged</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setChanged(); <span class="comment">//这个很重要，一定要设置这个，java底层有一个boolean值 changed = true; , 可以不那么灵活 (可以设置一些条件然后调用setChanged()方法)</span></span><br><span class="line">        notifyObservers(<span class="keyword">new</span> Data(temperature, humidity, pressure)); <span class="comment">//这个是 "推" 数据</span></span><br><span class="line"><span class="comment">//        notifyObservers();  // 靠观察者自己 "拉" 数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个类的作用就是为了 适应Observable里面的这个方法(推数据) : public void notifyObservers(Object arg)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Data</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span> temperature;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span> humidity;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">double</span> pressure;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Data</span><span class="params">(<span class="keyword">double</span> temperature, <span class="keyword">double</span> humidity, <span class="keyword">double</span> pressure)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.temperature = temperature;</span><br><span class="line">            <span class="keyword">this</span>.humidity = humidity;</span><br><span class="line">            <span class="keyword">this</span>.pressure = pressure;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTemperature</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> temperature;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getHumidity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> humidity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPressure</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> pressure;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是两个观察者:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentConditionDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> pressure;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里表示的是直接接受　被观察者的数据("推"　过来的数据　)　　--&gt;  也可以自己获取("拉")数据</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object data)</span> </span>&#123; <span class="comment">//注意这里还有被观察者的引用</span></span><br><span class="line">        <span class="keyword">this</span>.temperature = ((WeatherData.Data)data).getTemperature(); <span class="comment">//强制类型转换一下</span></span><br><span class="line">        <span class="keyword">this</span>.humidity = ((WeatherData.Data)data).getHumidity();</span><br><span class="line">        <span class="keyword">this</span>.pressure = ((WeatherData.Data)data).getPressure();</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"CurrentDisplay : "</span> +</span><br><span class="line">                <span class="string">"["</span> + temperature  +</span><br><span class="line">                <span class="string">", "</span> + humidity  +</span><br><span class="line">                <span class="string">", "</span> + pressure + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TomorrowConditionDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> temperature;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> humidity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> pressure;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个就是</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable observable, Object data)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 两种设值方式  "推" | "拉"</span></span><br><span class="line">        <span class="comment">// "推"　过来的</span></span><br><span class="line"><span class="comment">//        this.temperature = ((WeatherData.Data)data).getTemperature();</span></span><br><span class="line"><span class="comment">//        this.humidity = ((WeatherData.Data)data).getHumidity();</span></span><br><span class="line"><span class="comment">//        this.pressure = ((WeatherData.Data)data).getPressure();</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 自己 "拉" 过来的</span></span><br><span class="line">        <span class="keyword">this</span>.temperature = ((WeatherData)observable).getTemperature();</span><br><span class="line">        <span class="keyword">this</span>.humidity = ((WeatherData)observable).getHumidity();</span><br><span class="line">        <span class="keyword">this</span>.pressure = ((WeatherData)observable).getPressure();</span><br><span class="line">        display();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ( (int)(10 * Math.random())/2 + 1)  生成 [1,5]的随机数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"TomorrowDisplay : "</span> +</span><br><span class="line">                <span class="string">"["</span> + temperature * ( (<span class="keyword">int</span>)(<span class="number">10</span> * Math.random())/<span class="number">2</span> + <span class="number">1</span>) +</span><br><span class="line">                <span class="string">", "</span> + humidity * ( (<span class="keyword">int</span>)(<span class="number">10</span> * Math.random())/<span class="number">2</span> + <span class="number">1</span>) +</span><br><span class="line">                <span class="string">", "</span> + pressure * ( (<span class="keyword">int</span>)(<span class="number">10</span> * Math.random())/<span class="number">2</span> + <span class="number">1</span>) + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WeatherData weatherData = <span class="keyword">new</span> WeatherData();<span class="comment">// 创建被观察者</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建两个观察者</span></span><br><span class="line">        CurrentConditionDisplay current = <span class="keyword">new</span> CurrentConditionDisplay();</span><br><span class="line">        TomorrowConditionDisplay tomorrow = <span class="keyword">new</span> TomorrowConditionDisplay();</span><br><span class="line"></span><br><span class="line">        weatherData.addObserver(current);</span><br><span class="line">        weatherData.addObserver(tomorrow);</span><br><span class="line"></span><br><span class="line">        weatherData.setData(<span class="number">11</span>,<span class="number">222</span>,<span class="number">33</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"----------移除Tomorrow公告板----------"</span>);</span><br><span class="line">        weatherData.deleteObserver(tomorrow);</span><br><span class="line">        weatherData.setData(<span class="number">22</span>,<span class="number">444</span>,<span class="number">66</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TomorrowDisplay : [<span class="number">33.0</span>, <span class="number">666.0</span>, <span class="number">33.0</span>]</span><br><span class="line">CurrentDisplay : [<span class="number">11.0</span>, <span class="number">222.0</span>, <span class="number">33.0</span>]</span><br><span class="line">----------移除Tomorrow公告板----------</span><br><span class="line">CurrentDisplay : [<span class="number">22.0</span>, <span class="number">444.0</span>, <span class="number">66.0</span>]</span><br></pre></td></tr></table></figure><h2 id="四、总结-1"><a href="#四、总结-1" class="headerlink" title="四、总结"></a>四、总结</h2><p><strong>使用场景</strong></p><ul><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li><li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li><li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li><li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li></ul><h2 id="五、实际应用"><a href="#五、实际应用" class="headerlink" title="五、实际应用"></a>五、实际应用</h2><p>在spring中，通过ApplicationEvent类和ApplicationListener接口，可以实现ApplicationContext事件处理，这种机制就是利用的观察者模式<br>spring有一些内置的事件，当完成某种操作时会发出某些事件动作。比如监听ContextRefreshedEvent事件，当所有的bean都初始化完成并被成功装载后会触发该事件，实现ApplicationListener<contextrefreshedevent>接口可以收到监听动作，然后可以写自己的逻辑。<br>使用时实现 ApplicationListener接口并传入ContextRefreshedEvent参数</contextrefreshedevent></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestApplicationListener</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">ContextRefreshedEvent</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(ContextRefreshedEvent contextRefreshedEvent)</span> </span>&#123;</span><br><span class="line">        System.out.println(contextRefreshedEvent);</span><br><span class="line">        System.out.println(<span class="string">"TestApplicationListener............................"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，jdk中的诸多listener都是用的这种设计模式<br>java.util.EventListener<br>javax.servlet.http.HttpSessionBindingListener<br>javax.servlet.http.HttpSessionAttributeListener<br>javax.faces.event.PhaseListener </p><h1 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h1><h2 id="一、基本概念-2"><a href="#一、基本概念-2" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>装饰者模式是结构型设计模式。</p><p>装饰模式以<strong>对客户端透明的方式扩展对象的功能</strong>，是继承关系的一个替代方案。</p><p>允许向一个现有的对象添加新的功能。同时又不改变其结构，它是作为现有的类的一个包装。</p><p>主要解决的问题: 一般我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，<strong>子类会很膨胀</strong>。</p><h2 id="二、结构-2"><a href="#二、结构-2" class="headerlink" title="二、结构"></a>二、结构</h2><p>结构：</p><ul><li>装饰者（Decorator）和具体组件（ConcreteComponent）都继承自组件（Component）；</li><li>所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能；</li><li>装饰者的方法有一部分是自己的，这属于它的功能(<strong>半透明的装饰者模式</strong>)。然后调用被装饰者的方法实现，从而也保留了被装饰者的功能；</li></ul><p><img src="/images/03_decorator_02.png" alt="03_decorator_02.png"></p><h2 id="三、案例-2"><a href="#三、案例-2" class="headerlink" title="三、案例"></a>三、案例</h2><h3 id="1、装饰者模式案例"><a href="#1、装饰者模式案例" class="headerlink" title="1、装饰者模式案例"></a>1、装饰者模式案例</h3><blockquote><p>模拟在餐馆点饮料，我们可以点咖啡，而咖啡有<code>Decaf</code>咖啡和<code>Espresso</code>咖啡，而这两种咖啡都可以加牛奶和巧克力进去。</p></blockquote><p>具体的代码组织结构图:</p><p><img src="/images/03_decorator_01.png" alt="03_decorator_01.png"></p><p>具体代码:</p><p>先看最高的<code>component</code>包下的<code>Drink</code>类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Component的超类</span></span><br><span class="line"><span class="comment"> * 单品和装饰者都要继承自这个类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String description = <span class="string">""</span>; <span class="comment">//一开始没有描述</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> price = <span class="number">0</span>; <span class="comment">//一开始价格为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 抽象方法</span></span><br><span class="line"><span class="comment">     *  1、如果是单品的话就直接是自己的价格</span></span><br><span class="line"><span class="comment">     *  2、如果是装饰者的话就还要加上装饰品自己的价格</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// setter getter</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> description;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDescription</span><span class="params">(String description)</span> </span>&#123; <span class="comment">//描述的时候顺便把价格描述一下</span></span><br><span class="line">        <span class="keyword">this</span>.description = description;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">double</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看两个具体的<code>Component</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** ConcreteComponent 1*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decaf</span> <span class="keyword">extends</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decaf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setDescription(<span class="string">"Decaf"</span>);</span><br><span class="line">        <span class="keyword">super</span>.setPrice(<span class="number">3</span>); <span class="comment">//3块钱</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice();<span class="comment">//super.getPrice()//这个就是父类的价格(自己什么也没加 (没有被装饰))</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重写getter 后面加上自己的花费</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getDescription() + <span class="string">"-"</span> + cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** ConcreteComponent 2</span></span><br><span class="line"><span class="comment"> *  也可以在ConcreteComponent和Drink类有一个过渡的类)  (比如Coffee类)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Espresso</span> <span class="keyword">extends</span> <span class="title">Drink</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Espresso</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.setDescription(<span class="string">"Espresso"</span>);</span><br><span class="line">        <span class="keyword">super</span>.setPrice(<span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getPrice();<span class="comment">//super.getPrice()//这个就是父类的价格(自己什么也没加)</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getDescription() + <span class="string">"-"</span> + cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面看<code>decorator</code>下的三个类:</p><p>第一个是装饰者的超类，继承自<code>Drink</code>类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Drink</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个引用很重要，可以是单品，也可以是被包装过的类型，所以使用的是超类的对象</span></span><br><span class="line"><span class="comment">     * 这个就是要被包装的单品(被装饰的对象)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Drink drink; <span class="comment">//这里要拿到父类的引用，因为要控制另一个分支(具体的组件)</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Drink drink)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.drink = drink;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果drink是已经被装包过的，那么就会产生递归调用　　最终到单品</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cost</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getPrice() + drink.cost(); <span class="comment">// 自己的价格和被包装单品的价格</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDescription</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getDescription() + <span class="string">"-"</span> + <span class="keyword">super</span>.getPrice()</span><br><span class="line">                + <span class="string">" &amp;&amp; "</span> + drink.getDescription();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是两个装饰者:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个是具体的装饰者() --&gt; 继承自中间的装饰着Decorator</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chocolate</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chocolate</span><span class="params">(Drink drink)</span> </span>&#123; <span class="comment">//如果父类搞了一个　带参数的构造函数，子类必须显示的使用super调用</span></span><br><span class="line">        <span class="keyword">super</span>(drink);</span><br><span class="line">        <span class="keyword">super</span>.setDescription(<span class="string">"Chocolate"</span>);</span><br><span class="line">        <span class="keyword">super</span>.setPrice(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Milk</span> <span class="keyword">extends</span> <span class="title">Decorator</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Milk</span><span class="params">(Drink drink)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(drink); <span class="comment">//调用父类的构造函数</span></span><br><span class="line">        <span class="keyword">super</span>.setDescription(<span class="string">"Milk"</span>);</span><br><span class="line">        <span class="keyword">super</span>.setPrice(<span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//只点一个单品 (Decaf 咖啡)</span></span><br><span class="line">        Drink order = <span class="keyword">new</span> Decaf();</span><br><span class="line">        System.out.println(<span class="string">"order description : "</span> + order.getDescription());</span><br><span class="line">        System.out.println(<span class="string">"order price : "</span> + order.cost());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"---------------加了调料的----------------"</span>);</span><br><span class="line"></span><br><span class="line">        order = <span class="keyword">new</span> Milk(order);<span class="comment">// 加了牛奶</span></span><br><span class="line">        order = <span class="keyword">new</span> Chocolate(order);</span><br><span class="line">        order = <span class="keyword">new</span> Chocolate(order); <span class="comment">// 加了两个巧克力</span></span><br><span class="line">        System.out.println(<span class="string">"order description : "</span> + order.getDescription());</span><br><span class="line">        System.out.println(<span class="string">"order price : "</span> + order.cost());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序输出:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">order description : Decaf-<span class="number">3.0</span></span><br><span class="line">order price : <span class="number">3.0</span></span><br><span class="line">---------------加了调料的----------------</span><br><span class="line">order description : Chocolate-<span class="number">1.0</span> &amp;&amp; Chocolate-<span class="number">1.0</span> &amp;&amp; Milk-<span class="number">3.0</span> &amp;&amp; Decaf-<span class="number">3.0</span></span><br><span class="line">order price : <span class="number">8.0</span></span><br></pre></td></tr></table></figure><h3 id="2、JavaIO中使用装饰者模式"><a href="#2、JavaIO中使用装饰者模式" class="headerlink" title="2、JavaIO中使用装饰者模式"></a>2、JavaIO中使用装饰者模式</h3><p>由于Java I/O库需要很多性能的各种组合，如果这些性能都是用继承的方法实现的，那么每一种组合都需要一个类，这样就会造成大量性能重复的类出现，所以Java IO使用的是装饰者设计模式。</p><p><img src="/images/03_decorator_03.png" alt></p><p>所以我们可以定义自己的装饰者。</p><blockquote><p> 这里我们定义一个流，这个流将读入的小写字母转换成大写字母。</p></blockquote><p><code>UpperCaseInputStream</code>代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自己定义的输入流　　</span></span><br><span class="line"><span class="comment"> * 扩展FilterInputStream(这个类就是我们的Decorator) 中间装饰者　　</span></span><br><span class="line"><span class="comment"> * 所以我们只要继承这个就可以扩展自己的输入流装饰者　</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UpperCaseInputStream</span> <span class="keyword">extends</span> <span class="title">FilterInputStream</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">UpperCaseInputStream</span><span class="params">(InputStream in)</span> </span>&#123;  <span class="comment">//这个InputStream就是我们的Drink 类(超类)</span></span><br><span class="line">        <span class="keyword">super</span>(in);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实现两个read()方法，将大写转化成小写的读入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//重写　相当于cost和description</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="keyword">super</span>.read(); <span class="comment">//读取一个字节</span></span><br><span class="line">        <span class="keyword">return</span> index == -<span class="number">1</span> ? index : Character.toUpperCase((<span class="keyword">char</span>)(index));  <span class="comment">//小写转换成大写</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//字节数组</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="keyword">super</span>.read(b, off, len);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">            b[i] = (<span class="keyword">byte</span>)Character.toUpperCase((<span class="keyword">char</span>)(b[i]));</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试一下使用这个类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        InputStream in = <span class="keyword">new</span> UpperCaseInputStream(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"/home/zxzxin/Java_Maven/DesignPatterns/src/main/java/decorator/java/in.txt"</span>)));<span class="comment">// 将这个in.txt文件读入的内容转换成大写</span></span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = in.read()) &gt;= <span class="number">0</span>)</span><br><span class="line">            System.out.print((<span class="keyword">char</span>)(len));</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果演示:</p><p><img src="/images/03_decorator_04.png" alt="03_decorator_04.png"></p><h2 id="四、总结-2"><a href="#四、总结-2" class="headerlink" title="四、总结"></a>四、总结</h2><p>优缺点:</p><ul><li><strong>优点</strong> : 装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</li><li><strong>缺点</strong> : 多层装饰比较复杂。</li></ul><p>实际应用: 　<strong>大多数情况下，装饰模式的实现都要比上面给出的示意性例子要简单。</strong></p><ul><li>如果只有一个ConcreteComponent类，那么可以考虑去掉抽象的Component类（接口），把Decorator作为一个ConcreteComponent子类；</li><li>　如果只有一个ConcreteDecorator类，那么就没有必要建立一个单独的Decorator类，而可以把Decorator和ConcreteDecorator的责任合并成一个类。</li></ul><p>可以把装饰模式理解为不需要实现接口就可以扩展某些实例的功能<br>更加详细的解释具体可以看<a href="http://www.cnblogs.com/java-my-life/archive/2012/04/20/2455726.html" target="_blank" rel="noopener"><strong>这篇博客</strong></a>。</p><h1 id="适配器模式-一"><a href="#适配器模式-一" class="headerlink" title="适配器模式(一)"></a>适配器模式(一)</h1><h2 id="一、基本概念-3"><a href="#一、基本概念-3" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。</p><p>可以将适配器理解为我们日常用的电脑充电器: 家庭电压为<code>220V</code>，而电脑充电频率是<code>20V</code>左右，所以需要适配。</p><h2 id="二、结构-3"><a href="#二、结构-3" class="headerlink" title="二、结构"></a>二、结构</h2><p>适配器可以分为两种: 对象适配器和类适配器。</p><p><strong>对象适配器</strong>:</p><p><img src="/images/07_adapter_01.png" alt="07_adapter_01.png"></p><p>从用户的角度看不到<strong>被适配者</strong>。</p><p>用户调用适配器转换出来的目标接口方法。适配器再调用被适配者的相关接口方法。</p><p>用户收到反馈结果，感觉只是和目标接口交互。</p><p><strong>类适配器</strong>:</p><p><img src="/images/07_adapter_05.png" alt="07_adapter_05.png"></p><p>通过多重继承目标接口和被适配者类方式来实现适配。</p><h2 id="三、案例-3"><a href="#三、案例-3" class="headerlink" title="三、案例"></a>三、案例</h2><blockquote><p>案例: 将火鸡冒充成鸭子。</p></blockquote><h3 id="1、对象适配器模式"><a href="#1、对象适配器模式" class="headerlink" title="1、对象适配器模式"></a>1、对象适配器模式</h3><p>逻辑图:</p><p><img src="/images/07_adapter_03.png" alt="07_adapter_03.png"></p><p>代码组织结构图:</p><p><img src="/images/07_adapter_02.png" alt="07_adapter_02.png"></p><p>被适配者火鸡<code>Turkey</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Turkey</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">gobble</span><span class="params">()</span></span>; <span class="comment">// 火鸡叫声</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 野火鸡 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WildTurkey</span> <span class="keyword">implements</span> <span class="title">Turkey</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gobble</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Go Go!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I am Flying a short distance!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>目标对象<code>Duck</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 鸭子的接口 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Duck</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span></span>;<span class="comment">//鸭子叫声</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>适配器<code>TurkeyAdapter</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在外面表现是 鸭子(目标)，但是实质是火鸡(被适配者)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TurkeyAdapter</span> <span class="keyword">implements</span> <span class="title">Duck</span> </span>&#123; <span class="comment">//实现目标的接口</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Turkey turkey; <span class="comment">//这种对象型适配器必须要组合  被适配者，也就是要有适配者的引用</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TurkeyAdapter</span><span class="params">(Turkey turkey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.turkey = turkey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实际是火鸡在叫</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        turkey.gobble();<span class="comment">//外面表现是quack,但是内部是turkey.gobble()</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//由于火鸡飞的短，所以多飞几次，让火鸡更像鸭子</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">            turkey.fly();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WildTurkey turkey = <span class="keyword">new</span> WildTurkey();</span><br><span class="line">        Duck duck = <span class="keyword">new</span> TurkeyAdapter(turkey);</span><br><span class="line">        duck.quack(); <span class="comment">//看似是鸭子，其实内置是火鸡</span></span><br><span class="line">        duck.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Go Go!</span><br><span class="line">I am Flying a <span class="keyword">short</span> distance!</span><br><span class="line">I am Flying a <span class="keyword">short</span> distance!</span><br><span class="line">I am Flying a <span class="keyword">short</span> distance!</span><br><span class="line">I am Flying a <span class="keyword">short</span> distance!</span><br><span class="line">I am Flying a <span class="keyword">short</span> distance!</span><br><span class="line">I am Flying a <span class="keyword">short</span> distance!</span><br></pre></td></tr></table></figure><h3 id="2、类适配器模式"><a href="#2、类适配器模式" class="headerlink" title="2、类适配器模式"></a>2、类适配器模式</h3><p>基本结构图:</p><p><img src="/images/07_adapter_04.png" alt="07_adapter_04.png"></p><p>虽然Java不支持多继承，但是可以实现的同时继承。</p><p>只有<code>TurkeyAdapter</code>有一些代码变动，其他不变:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 和 对象适配器模式唯一的不同就是  : 适配器直接继承 被适配者 (而不是组合)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TurkeyAdapter</span> <span class="keyword">extends</span> <span class="title">WildTurkey</span> <span class="keyword">implements</span>  <span class="title">Duck</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.gobble(); <span class="comment">//直接继承 被适配者</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//让火鸡飞6次，飞的像鸭子</span></span><br><span class="line">        <span class="keyword">super</span>.fly();</span><br><span class="line">        <span class="keyword">super</span>.fly();</span><br><span class="line">        <span class="keyword">super</span>.fly();</span><br><span class="line">        <span class="keyword">super</span>.fly();</span><br><span class="line">        <span class="keyword">super</span>.fly();</span><br><span class="line">        <span class="keyword">super</span>.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TurkeyAdapter duck = <span class="keyword">new</span> TurkeyAdapter();<span class="comment">//直接new即可</span></span><br><span class="line">        duck.quack();</span><br><span class="line">        duck.fly();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出和上面对象适配器一样。</p><h3 id="3、Java中从以前枚举器Enumeration到迭代器Iterator的适配"><a href="#3、Java中从以前枚举器Enumeration到迭代器Iterator的适配" class="headerlink" title="3、Java中从以前枚举器Enumeration到迭代器Iterator的适配"></a>3、Java中从以前枚举器Enumeration到迭代器Iterator的适配</h3><p>从<code>Enumeration</code>到<code>Iterator</code>适配的结构图:</p><p><img src="/images/07_adapter_06.png" alt="07_adapter_06.png"></p><p>一个实例代码:(下面<code>EnumerationIterator</code>就是一个适配器)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 对象适配器的举例 java中的枚举到迭代器 */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumerationIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Enumeration enumeration; <span class="comment">//枚举 : 被适配者</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EnumerationIterator</span><span class="params">(Enumeration enumeration)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.enumeration = enumeration;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> enumeration.hasMoreElements(); <span class="comment">//实际调用的是 被适配者 的方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> enumeration.nextElement();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个可以说是适配器的缺点， 有些不能适配，比如两个插孔的插头不能适配为三个插孔的插头</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、总结-3"><a href="#四、总结-3" class="headerlink" title="四、总结"></a>四、总结</h2><p>对象适配器和类适配器使用了不同的方法实现适配，<strong>对象适配器使用组合，类适配器使用继承</strong>。<br>总的来说，这种模式的思想就是把不能使用在特定环境的对象或类，通过适配器类，转换为可以用在该环境下的类或对象。</p><h2 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h2><p>除了上面提到的使用外，在springmvc中，这种模式也有使用<br>Spring MVC中的Controller种类众多，不同类型的Controller通过不同的方法来对请求进行处理。如果不利用适配器模式的话，DispatcherServlet直接获取对应类型的Controller，需要的自行来判断，每增加一个controller，就会多一层判断<br>为了实现适配器模式，首先定义一个接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerAdapter</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span></span>;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function">ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>supports()方法传入处理器（宽泛的概念Controller，以及HttpRequestHandler，Servlet，等等）判断是否与当前适配器支持如果支持则从DispatcherServlet中的HandlerAdapter实现类中返回支持的适配器实现类。handler方法就是代理Controller来执行请求的方法并返回结果。</p><p>在DispatchServlert中的doDispatch方法中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br></pre></td></tr></table></figure></p><p>此代码通过调用DispatchServlert 中getHandlerAdapter传入Controller（宽泛的概念Controller，以及HttpRequestHandler，Servlet，等等），来获取对应的HandlerAdapter 的实现子类，从而做到使得每一种Controller有一种对应的适配器实现类</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>设计模式总结（1）【单例模式，三种工厂模式】</title>
      <link href="/2019/07/25/sign-pattern/"/>
      <url>/2019/07/25/sign-pattern/</url>
      
        <content type="html"><![CDATA[<p><img src="/upload/pasted-433.png" width="70%"></p><a id="more"></a><hr><h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>单例模式属于创建型设计模式。</p><p>确保一个类只有一个实例，并提供该实例的全局访问点。</p><p>实现: <strong>使用一个私有构造函数、一个私有静态变量以及一个公有静态函数来实现</strong>。</p><h2 id="二、结构"><a href="#二、结构" class="headerlink" title="二、结构"></a>二、结构</h2><p>类图:</p><p><img src="/upload/14_singleton.png" alt="14_singleton.png"></p><p><strong>私有构造函数保证了不能通过构造函数来创建对象实例，只能通过公有静态函数返回唯一的私有静态变量</strong>。</p><h2 id="三、几类经典单例模式实现"><a href="#三、几类经典单例模式实现" class="headerlink" title="三、几类经典单例模式实现"></a>三、几类经典单例模式实现</h2><h3 id="1、懒汉式-线程不安全"><a href="#1、懒汉式-线程不安全" class="headerlink" title="1、懒汉式-线程不安全"></a>1、懒汉式-线程不安全</h3><p>所谓懒汉式，就是说等到用的时候再进行创建</p><p>这种实现方法线程不安全，如果多个线程能够同时进入 <code>if (uniqueInstance == null)</code> ，并且此时 <code>uniqueInstance == null</code>，那么会有多个线程执行 <code>uniqueInstance = new Singleton();</code> 语句，这将导致实例化多次 <code>uniqueInstance</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式: 线程不安全</span></span><br><span class="line"><span class="comment">// 有延迟加载: 不是在类加载的时候就创建了，而是在调用newStance()的时候才会创建</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//私有静态实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、懒汉式-线程安全-性能不好"><a href="#2、懒汉式-线程安全-性能不好" class="headerlink" title="2、懒汉式-线程安全-性能不好"></a>2、懒汉式-线程安全-性能不好</h3><p>解决上面线程不安全的最直接方法就是上锁</p><p>但是当一个线程进入该方法之后，其它试图进入该方法的线程都必须等待，即使 <code>uniqueInstance</code> 已经被实例化了。这会让线程阻塞时间过长，因此该方法有性能问题<br><strong>不推荐使用</strong>。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">newInstance</span><span class="params">()</span></span>&#123;<span class="comment">//在上面的基础上加了synchronized</span></span><br><span class="line">    <span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)</span><br><span class="line">        uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、饿汉式-线程安全-无延迟加载"><a href="#3、饿汉式-线程安全-无延迟加载" class="headerlink" title="3、饿汉式-线程安全-无延迟加载"></a>3、饿汉式-线程安全-无延迟加载</h3><p>饿汉式：类一初始化就进行实例的创建（等不及了）</p><p>这种方式比较常用，但容易产生垃圾对象(丢失了延迟实例化(<code>lazy loading</code>)带来的节约资源的好处)。</p><p>它基于 <strong>classloader机制</strong>避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， <strong>但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazyloading 的效果</strong>。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、双重校验锁-线程安全"><a href="#4、双重校验锁-线程安全" class="headerlink" title="4、双重校验锁-线程安全"></a>4、双重校验锁-线程安全</h3><p><code>uniqueInstance</code> 只需要被实例化一次，之后就可以直接使用了。这种线程安全的优化方式就是缩小加锁的范围，只有当<code>uniqueInstance</code> 没有被实例化时，才需要进行加锁。</p><p>双重校锁：<br><strong>第一次校验：</strong>由于单例模式只需要创建一次实例，如果后面再次调用getInstance方法时，则直接返回之前创建的实例，因此大部分时间不需要执行同步方法里面的代码，大大提高了性能。如果不加第一次校验的话，那跟上面的懒汉模式没什么区别，每次都要去竞争锁。<br><strong>第二次校验：</strong>如果没有第二次校验，假设线程t1执行了第一次校验后，判断为null，这时t2也获取了CPU执行权，也执行了第一次校验，判断也为null。接下来t2获得锁，创建实例。这时t1又获得CPU执行权，由于之前已经进行了第一次校验，结果为null（不会再次判断），获得锁后，直接创建实例。结果就会导致创建多个实例。所以需要在同步代码里面进行第二次校验，如果实例为空，则进行创建。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 双重加锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不需要先实例化</span></span><br><span class="line">    <span class="comment">// 使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一次校验</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// //第二次校验</span></span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p><ul><li>1)、为 <code>uniqueInstance</code> 分配内存空间；</li><li>2)、初始化 <code>uniqueInstance</code>；</li><li>3)、将 <code>uniqueInstance</code> 指向分配的内存地址；</li></ul><p>但是由于 JVM 具有<strong>指令重排</strong>的特性，执行顺序有可能变成 <code>1&gt;3&gt;2</code>。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 <code>T1</code> 执行了 1 和 3，此时 <code>T2</code>调用 <code>newInstance()</code> 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code>，但此时 <code>uniqueInstance</code> 还未被初始化。</p><p><strong>使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行</strong>。</p><h3 id="5、静态内部类实现"><a href="#5、静态内部类实现" class="headerlink" title="5、静态内部类实现"></a>5、静态内部类实现</h3><p>当 <code>Singleton</code> 类加载时，<strong>静态内部类 Holder 没有被加载进内存</strong>。只有当调用 <code>newInstance()</code> 方法从而触发 <code>Holder.uniqueInstance</code> 时 <code>Holder</code>才会被加载，此时初始化<code>uniqueInstance</code> 实例，并且 JVM 能确保 <code>uniqueInstance</code> 只被实例化一次。</p><p>这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。</p><blockquote><p>这种方式是 Singleton 类被装载了，<code>uniqueInstance</code> 不一定被初始化。因为 <code>Holder</code>s 类没有被主动使用，只有通过显式调用 <code>newInstance()</code>方法时，才会显式装载 Holder 类，从而实例化<code>uniqueInstance</code>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6、枚举实现"><a href="#6、枚举实现" class="headerlink" title="6、枚举实现"></a>6、枚举实现</h3><p>这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。</p><p>该实现在多次序列化再进行反序列化之后，不会得到多个实例。而其它实现需要使用 <code>transient</code> 修饰所有字段，并且实现序列化和反序列化的方法。</p><p>枚举实现单例 (+测试):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Sing.INSTANCE.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> Sing &#123;</span><br><span class="line"></span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//jvm guarantee only run once</span></span><br><span class="line">        Sing() &#123;</span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Singleton <span class="title">newInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> singleton;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> clientTotal = <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> threadTotal = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(threadTotal);</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(clientTotal);</span><br><span class="line"></span><br><span class="line">        Set&lt;Singleton&gt;set = Collections.synchronizedSet(<span class="keyword">new</span> HashSet&lt;&gt;());<span class="comment">//注意set也要加锁</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clientTotal; i++) &#123;</span><br><span class="line">            executorService.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    semaphore.acquire();</span><br><span class="line"></span><br><span class="line">                    set.add(Singleton.newInstance());</span><br><span class="line"></span><br><span class="line">                    semaphore.release();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">        System.out.println(set.size());<span class="comment">//1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于序列化和反序列化:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 单例测试</span></span><br><span class="line">        Singleton s1 = Singleton.INSTANCE;</span><br><span class="line">        s1.setName(<span class="string">"firstName"</span>);</span><br><span class="line">        System.out.println(<span class="string">"s1.getName(): "</span> + s1.getName());</span><br><span class="line"></span><br><span class="line">        Singleton s2 = Singleton.INSTANCE;</span><br><span class="line">        s2.setName(<span class="string">"secondName"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注意我这里输出s1 ，但是已经变成了 secondName</span></span><br><span class="line">        System.out.println(<span class="string">"s1.getName(): "</span> + s1.getName());</span><br><span class="line">        System.out.println(<span class="string">"s2.getName(): "</span> + s2.getName());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"-----------------"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 反射获取实例测试</span></span><br><span class="line">        Singleton[] enumConstants = Singleton.class.getEnumConstants();</span><br><span class="line">        <span class="keyword">for</span> (Singleton enumConstant : enumConstants)</span><br><span class="line">            System.out.println(enumConstant.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1.getName(): firstName</span><br><span class="line">s1.getName(): secondName</span><br><span class="line">s2.getName(): secondName</span><br><span class="line">-----------------</span><br><span class="line">secondName</span><br></pre></td></tr></table></figure><blockquote><p>该实现可以防止反射攻击。在其它实现中，通过 <code>setAccessible()</code>(反射中的强制访问私有属性方法) 方法可以将私有构造函数的访问级别设置为 public，然后调用构造函数从而实例化对象，如果要防止这种攻击，需要在构造函数中添加防止多次实例化的代码。该实现是由 JVM 保证只会实例化一次，因此不会出现上述的反射攻击。</p></blockquote><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>一般情况下，<strong>不建议使用懒汉方式</strong>，建议使用饿汉方式。</p><p>只有在要明确实现 <code>lazy loading</code> 效果时，才会使用<strong>静态内部类方式</strong>。</p><p>如果涉及到<strong>反序列化创建对象</strong>时，可以尝试使用枚举方式。</p><p>如果有其他特殊的需求，可以考虑使用双检锁方式。</p><h2 id="五、应用实例"><a href="#五、应用实例" class="headerlink" title="五、应用实例"></a>五、应用实例</h2><p>Spring下默认的bean均为singleton，可以通过singleton=“true|false” 或者 scope=“？”来指定<br>这样做可以减少cpu内存的浪费。可能有人觉得多用户走多线程只运行一个实例肯定会引发线程安全问题，但在这里应当理解线程安全问题的本质：全局变量，公共变量被多个线程同时操作。虽然spring对象是单例的，但类里面方法对每个线程来说都是独立运行的，不存在多线程问题，只有成员变量有多线程问题，所以方法里面如果有用到成员变量就要考虑用安全的数据结构。对于有着特殊状态值（一定意义上的全局变量）的单例对象，spring使用ThreadLocal维护线程安全，不过这是另一个问题了。<br><a href="https://blog.csdn.net/zengdeqing2012/article/details/77098994" target="_blank" rel="noopener">https://blog.csdn.net/zengdeqing2012/article/details/77098994</a><br>在java JDK中</p><p>java.lang.Runtime#getRuntime()<br>java.awt.Desktop#getDesktop()<br>java.lang.System#getSecurityManager()<br>使用的都是单例模式，为什么？因为只要一个就够了。</p><h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><h2 id="一、基本概念-1"><a href="#一、基本概念-1" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p><strong>简单工厂模式是类的创建模式，又叫做静态工厂方法（Static Factory Method）模式。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例</strong>。</p><p>在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口。<br>这个模式严格来讲是下面工厂方法模式的一个特例</p><h2 id="二、结构-1"><a href="#二、结构-1" class="headerlink" title="二、结构"></a>二、结构</h2><p>简单工厂把实例化的操作单独放到一个类中，这个类就是简单工厂类(Simple Factory)，<strong>让简单工厂类来决定应该用哪个具体子类来实例化 (而不是在客户端中决定)</strong>。</p><p>这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。</p><p>客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。</p><p>结构:</p><p><img src="/upload/04_simple_01.png" alt="04_simple_01.png"></p><h2 id="三、案例"><a href="#三、案例" class="headerlink" title="三、案例"></a>三、案例</h2><blockquote><p>模拟在<code>type == 1</code>的时候创建<code>ConcreteProduct1</code>、在<code>type == 2</code>的时候创建<code>ConcreteProduct2</code>、其他时候创建<code>ConcreteProduct</code>。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct1</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteProduct2</span> <span class="keyword">implements</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们按照下面的方式创建，则我们在客户端包含了这些需要判断条件的实例化代码，则可以将这些实例化代码放到简单工厂中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不好的设计</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> type = <span class="number">1</span>;</span><br><span class="line">        Product product;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">            product = <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">            product = <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            product = <span class="keyword">new</span> ConcreteProduct();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// do something with the product</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是我们可以增加一个简单工厂类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也可以将createProduct写成静态的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">createProduct</span><span class="params">(<span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct1();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct2();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们的测试类可以写成下面的样子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SimpleFactory simpleFactory = <span class="keyword">new</span> SimpleFactory();</span><br><span class="line">        Product product = simpleFactory.createProduct(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// do something with product</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样既让客户端和具体类解耦，而且在客户端也看不到具体的繁杂的实例化代码。</p><h2 id="四、总结-1"><a href="#四、总结-1" class="headerlink" title="四、总结"></a>四、总结</h2><p>缺点 : 这个工厂类集中了所有的创建逻辑，当有复杂的多层次等级结构时，所有的业务逻辑都在这个工厂类中实现。什么时候它不能工作了，整个系统都会受到影响。</p><p>我们强调<strong>职责单一</strong>原则，一个类只提供一种功能。</p><h2 id="五、应用实例-1"><a href="#五、应用实例-1" class="headerlink" title="五、应用实例"></a>五、应用实例</h2><p>spring中的BeanFactory就是简单工厂模式的体现，根据传入一个唯一的标识来获得bean对象，但是否是在传入参数后创建还是传入参数前创建这个要根据具体情况来定。如下配置，就是在 HelloItxxz 类中创建一个 itxxzBean。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"singletonBean"</span> <span class="attr">class</span>=<span class="string">"com.itxxz.HelloItxxz"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>Hello! 这是singletonBean!value&gt;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/ <span class="attr">bean</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"itxxzBean"</span> <span class="attr">class</span>=<span class="string">"com.itxxz.HelloItxxz"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">singleton</span>=<span class="string">"false"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>Hello! 这是itxxzBean! value&gt;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>在juc中，类Executors就是一个典型的简单工厂方法类，在这类下，提供了创建多种ExecutorService的静态方法，在使用时直接调用这个类的静态方法创建不同的ExecutorService即可，而不需要再在客户端创建不同的实例</p><h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><h2 id="一、基本概念-2"><a href="#一、基本概念-2" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p><strong>工厂方法模式是类的创建模式，又叫做虚拟构造子(Virtual Constructor)模式或者多态性工厂（Polymorphic Factory）模式</strong>。<br>工厂方法模式的用意是<strong>定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中</strong>。</p><p>或者说引入工厂模式的目的就是我们需要多个工厂，但是每个工厂内部又要划分情况，如果只用一个工厂的话，会产生多种复合的情况。</p><p>比如说我们有两个工厂，每个工厂有3种情况，如果用简单工厂模式，要分为 <code>3 * 2 = 6</code>种情况，所以可以用工厂方法模式解决。</p><h2 id="二、结构-2"><a href="#二、结构-2" class="headerlink" title="二、结构"></a>二、结构</h2><p>在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由大工厂的子类(或者实现类)来创建对象。</p><p>即上面有一个大工厂，下面是分类的工厂。</p><p><img src="/upload/05_method_03.png" alt="05_method_03.png"></p><h2 id="三、案例-1"><a href="#三、案例-1" class="headerlink" title="三、案例"></a>三、案例</h2><blockquote><p>案例，模拟需要生成中国食物A，中国食物B，美国食物A，美国食物B。</p></blockquote><p>代码逻辑结构图:</p><p><img src="/upload/05_method_01.png" alt="05_method_01.png"></p><p>基本结构图:</p><p><img src="/upload/04_method_02.png" alt="04_method_02.png"></p><p>先给出这些食物(<code>Product</code>):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmericanFoodA</span> <span class="keyword">implements</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmericanFoodB</span> <span class="keyword">implements</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChineseFoodA</span> <span class="keyword">implements</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChineseFoodB</span> <span class="keyword">implements</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是抽象工厂:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FoodFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Food <span class="title">makeFood</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是两个子工厂:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChineseFoodFactory</span> <span class="keyword">implements</span> <span class="title">FoodFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">makeFood</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">"A"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ChineseFoodA();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">"B"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ChineseFoodB();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmericanFoodFactory</span> <span class="keyword">implements</span> <span class="title">FoodFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Food <span class="title">makeFood</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (name.equals(<span class="string">"A"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AmericanFoodA();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.equals(<span class="string">"B"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AmericanFoodB();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后测试:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先选择一个具体的工厂</span></span><br><span class="line">        FoodFactory factory = <span class="keyword">new</span> ChineseFoodFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由第一步的工厂产生具体的对象，不同的工厂造出不一样的对象</span></span><br><span class="line">        Food food = factory.makeFood(<span class="string">"A"</span>); <span class="comment">//  chineseFood * A</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四、总结-2"><a href="#四、总结-2" class="headerlink" title="四、总结"></a>四、总结</h2><p>工厂方法模式和简单工厂模式在结构上的不同很明显。</p><p><strong>工厂方法模式的核心是一个抽象工厂类，而简单工厂模式把核心放在一个具体类上</strong>。</p><p>工厂方法模式退化后可以变得很像简单工厂模式。设想如果非常确定一个系统只需要一个具体工厂类，那么不妨把抽象工厂类合并到具体工厂类中去。由于只有一个具体工厂类，所以不妨将工厂方法改为静态方法，这时候就得到了简单工厂模式。</p><h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><h2 id="一、基本概念-3"><a href="#一、基本概念-3" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p>当涉及到<strong>产品族</strong>的时候，就需要引入抽象工厂模式了。</p><p>每一个模式都是针对一定问题的解决方案。抽象工厂模式与工厂方法模式的最大区别就在于，<strong>工厂方法模式针对的是一个产品等级结构；而抽象工厂模式则需要面对多个产品等级结构</strong>。</p><p>在学习抽象工厂具体实例之前，应该明白两个重要的概念：产品族和产品等级。</p><p>所谓产品族，是指位于不同产品等级结构中，功能相关联的产品组成的家族。比如AMD的主板、芯片组、CPU组成一个家族，Intel的主板、芯片组、CPU组成一个家族。而这两个家族都来自于三个产品等级：主板、芯片组、CPU。一个等级结构是由相同的结构的产品组成，示意图如下：</p><p><img src="/upload/06_abstract_06.png" alt="06_abstract_06.png"></p><h2 id="二、案例"><a href="#二、案例" class="headerlink" title="二、案例"></a>二、案例</h2><p>一个经典的例子是造一台电脑。我们先不引入抽象工厂模式，看看怎么实现。</p><p>因为电脑是由许多的构件组成的，我们将 CPU 和主板进行抽象，然后 CPU 由 CPUFactory 生产，主板由 MainBoardFactory 生产，然后，我们再将 CPU 和主板搭配起来组合在一起，如下:</p><p><img src="/upload/06_abstract_01.png" alt="06_abstract_01.png"></p><p>代码组织结构:</p><p><img src="/upload/06_abstract_02.png" alt="06_abstract_02.png"></p><p>这个时候的客户端调用是这样的（测试类）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 得到 Intel 的 CPU</span></span><br><span class="line">        CPUFactory intelCPUFactory = <span class="keyword">new</span> IntelCPUFactory();</span><br><span class="line">        CPU cpu = intelCPUFactory.makeCPU();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到 AMD 的主板</span></span><br><span class="line">        MainBoardFactory mainBoardFactory = <span class="keyword">new</span> AmdMainBoardFactory();</span><br><span class="line">        MainBoard mainBoard = mainBoardFactory.makeMB();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 组装 CPU 和主板</span></span><br><span class="line">        Computer computer = <span class="keyword">new</span> Computer(cpu, mainBoard);</span><br><span class="line">        System.out.println(computer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>具体的完整代码可以看<a href="https://github.com/ZXZxin/ZXNotes/tree/master/%E6%9D%82%E9%A1%B9/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/factory" target="_blank" rel="noopener">这里</a></strong></p><p>单独看 CPU 工厂和主板工厂，它们分别是前面我们说的<strong>工厂模式</strong>。</p><p>这种方式也容易扩展，因为要给电脑加硬盘的话，只需要加一个 HardDiskFactory 和相应的实现即可，不需要修改现有的工厂。</p><p>但是，这种方式有一个问题，那就是如果 <strong>Intel 家产的 CPU 和 AMD 产的主板不能兼容使用</strong>，那么这代码就容易出错，因为客户端并不知道它们不兼容，也就会错误地出现随意组合。</p><p>下面就是我们要说的<strong>产品族</strong>的概念，它代表了组成某个产品的一系列附件的集合：</p><p><img src="/upload/06_abstract_03.png" alt="06_abstract_03.png"></p><p>当涉及到这种产品族的问题的时候，就需要抽象工厂模式来支持了。我们不再定义 CPU 工厂、主板工厂、硬盘工厂、显示屏工厂等等，<strong>我们直接定义电脑工厂，每个电脑工厂负责生产所有的设备，这样能保证肯定不存在兼容问题</strong>。</p><p><img src="/upload/06_abstract_04.png" alt="06_abstract_04.png"></p><p>这个时候，对于客户端来说，不再需要单独挑选 CPU厂商、主板厂商、硬盘厂商等，直接选择一家品牌工厂，品牌工厂会负责生产所有的东西，而且能保证肯定是兼容可用的。</p><p>改装的抽象工厂模式代码组织结构如下:</p><p><img src="/upload/06_abstract_05.png" alt="06_abstract_05.png"></p><p>主要的代码:</p><p>三个工厂:(一个超类工厂<code>PCFactory</code>，两个大厂工厂<code>AmdFactory</code>、<code>InterFactory</code>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PCFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">CPU <span class="title">makeCPU</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">MainBoard <span class="title">makeMB</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// HardDisk makeHD();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AmdFactory</span> <span class="keyword">implements</span> <span class="title">PCFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CPU <span class="title">makeCPU</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AmdCPU();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MainBoard <span class="title">makeMB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> AmdMainBoard();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntelFactory</span> <span class="keyword">implements</span> <span class="title">PCFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CPU <span class="title">makeCPU</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IntelCPU();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MainBoard <span class="title">makeMB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> IntelMainBoard();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的测试类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 第一步就要选定一个“大厂”</span></span><br><span class="line">        PCFactory cf = <span class="keyword">new</span> AmdFactory();</span><br><span class="line">        <span class="comment">// 从这个大厂造 CPU</span></span><br><span class="line">        CPU cpu = cf.makeCPU();</span><br><span class="line">        <span class="comment">// 从这个大厂造主板</span></span><br><span class="line">        MainBoard board = cf.makeMB();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//... 从这个大厂造硬盘。等等</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将同一个厂子出来的 CPU、主板、硬盘组装在一起</span></span><br><span class="line">        Computer computer = <span class="keyword">new</span> Computer(cpu, board);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h2><p>当然，抽象工厂的问题也是显而易见的，比如我们要加个显示器，就需要修改所有的工厂，给所有的工厂都加上制造显示器的方法。这有点违反了<strong>对修改关闭，对扩展开放</strong>这个设计原则。</p><h1 id="三种工厂方法对比"><a href="#三种工厂方法对比" class="headerlink" title="三种工厂方法对比"></a>三种工厂方法对比</h1><p><img src="/upload/pasted-470.png" alt="06_abstract_03.png"><br><img src="/upload/pasted-472.png" alt="06_abstract_03.png"><br><img src="/upload/pasted-473.png" alt="06_abstract_03.png"><br><img src="/upload/pasted-474.png" alt="06_abstract_03.png"><br><img src="/upload/pasted-475.png" alt="06_abstract_03.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL深入学习（3）【ID策略，横向扩展】</title>
      <link href="/2019/07/23/SQLDeepLearn3/"/>
      <url>/2019/07/23/SQLDeepLearn3/</url>
      
        <content type="html"><![CDATA[<p><img src="http://img2.ali213.net/picfile/News/2015/05/14/2015051494057329.jpg" width="70%"><br><a id="more"></a></p><h1 id="ID策略"><a href="#ID策略" class="headerlink" title="ID策略"></a>ID策略</h1><ol><li><p>利用数据库自增ID<br>优点：最简单。 缺点：单点风险、单机性能瓶颈。</p></li><li><p>利用数据库集群并设置相应的步长（Flickr方案）<br>优点：高可用、ID较简洁。 缺点：需要单独的数据库集群。</p></li><li><p>Twitter Snowflake<br>优点：高性能高可用、易拓展。 缺点：需要独立的集群以及ZK。</p></li><li><p>一大波GUID、Random算法<br>优点：简单。 缺点：生成ID较长，有重复几率。</p></li></ol><h1 id="横向扩展MySQL服务器"><a href="#横向扩展MySQL服务器" class="headerlink" title="横向扩展MySQL服务器"></a>横向扩展MySQL服务器</h1><p>由多台MySQL服务器，提供数据存储服务器。<br>横向扩展是根本提升数据库服务器性能的手段！受限于单台计算机的硬件处理能力，去使用多台计算机完成同一个服务的支持。<br>比较典型的概念：<br>读写分离，负载均衡。<br>需要用到的技术，MySQL复制技术，负载均衡中间件。</p><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。</p><ul><li>binlog 线程 ：负责将主服务器上的数据更改写入二进制文件（binlog）中。</li><li>I/O 线程 ：负责从主服务器上读取二进制日志文件，并写入从服务器的中继日志中。</li><li>SQL 线程 ：负责读取中继日志并重放其中的 SQL 语句。</li></ul><p><img src="/upload/pasted-453.png" alt="upload successful"></p><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p>主服务器用来处理写操作以及实时性要求比较高的读操作，而从服务器用来处理读操作。<br>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个<br>服务器。<br>MySQL 读写分离能提高性能的原因在于：<br>主从服务器负责各自的读和写，极大程度缓解了锁的争用；<br>从服务器可以配置 MyISAM 引擎，提升查询性能以及节约系统开销；<br>增加冗余，提高可用性。</p><p><img src="/upload/pasted-452.png" alt="upload successful"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL深入研究（2）【查询优化，分区，分表】</title>
      <link href="/2019/07/21/QLDeepLearn/"/>
      <url>/2019/07/21/QLDeepLearn/</url>
      
        <content type="html"><![CDATA[<p><img src="http://images.ali213.net/picfile/pic/2017/10/27/927_2017102712122202.jpg" width="70%"><br><a id="more"></a></p><h1 id="查询优化"><a href="#查询优化" class="headerlink" title="查询优化"></a>查询优化</h1><h2 id="减少请求的数据量"><a href="#减少请求的数据量" class="headerlink" title="减少请求的数据量"></a>减少请求的数据量</h2><p>（一）只返回必要的列<br>最好不要使用 SELECT * 语句。<br>（二）只返回必要的行<br>使用 WHERE 语句进行查询过滤，有时候也需要使用 LIMIT 语句来限制返回的数据。<br>（三）缓存重复查询的数据<br>使用缓存可以避免在数据库中进行查询，特别要查询的数据经常被重复查询，缓存可以带来的查询性能提升将会是非常明显的。<br>若想要应用缓存，首先在my.ini或者my.cnf中配置query_cache_type，1表示默认缓存，需要sql_no_cache提示为不缓存，2表示默认不缓存，需要sql_cache主动缓存，0表示不缓存 。query_cache_size配置缓存大小<br>对于配置为2选项，若要进行缓存<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">SQL_CACHE</span> *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student</span><br></pre></td></tr></table></figure></p><p>调用reset query cache 可以清空缓存<br>当数据表改动时，基于整个表的缓存就会被删除<br>动态数据无法缓存</p><h2 id="重构查询方式"><a href="#重构查询方式" class="headerlink" title="重构查询方式"></a>重构查询方式</h2><h3 id="切分大查询"><a href="#切分大查询" class="headerlink" title="切分大查询"></a>切分大查询</h3><p>一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。因此，可以把一个大范围操作切分为一个小范围操作<br>一个全范围的删除操作，可以切分为多个小段删除操作<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">messages</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">CREATE</span> &lt; <span class="keyword">DATE_SUB</span>(<span class="keyword">NOW</span>(), <span class="built_in">INTERVAL</span> <span class="number">3</span> <span class="keyword">MONTH</span>);</span><br></pre></td></tr></table></figure></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rows_affected = 0</span><br><span class="line"><span class="keyword">DO</span></span><br><span class="line">&#123; rows_affected = do_query (</span><br><span class="line"><span class="string">"DELETE FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 M</span></span><br><span class="line"><span class="string">ONTH) LIMIT 10000"</span></span><br><span class="line">) &#125;</span><br><span class="line"><span class="keyword">WHILE</span> rows_affected &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="分解大的连接查询"><a href="#分解大的连接查询" class="headerlink" title="分解大的连接查询"></a>分解大的连接查询</h3><ol start="2"><li>分解大连接查询<br>将一个大连接查询（JOIN）分解成对每一个表进行一次单表查询，然后将结果在应用程序中<br>进行关联，这样做的好处有：</li></ol><ul><li>让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。</li><li>分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。</li><li>减少锁竞争；</li><li>在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可扩展。</li><li>查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">tab</span><br><span class="line"><span class="keyword">JOIN</span> tag_post <span class="keyword">ON</span> tag_post.tag_id = tag.id</span><br><span class="line"><span class="keyword">JOIN</span> post <span class="keyword">ON</span> tag_post.post_id = post.id</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">tag.tag = <span class="string">'mysql'</span>;</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag <span class="keyword">WHERE</span> tag=<span class="string">'mysql'</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> tag_post <span class="keyword">WHERE</span> tag_id=<span class="number">1234</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> post <span class="keyword">WHERE</span> post.id <span class="keyword">IN</span> (<span class="number">123</span>,<span class="number">456</span>,<span class="number">567</span>,<span class="number">9098</span>,<span class="number">8904</span>);</span><br></pre></td></tr></table></figure><h1 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>将一个表中的数据和索引，分散到不同的文件中进行存储，称之为分区操作，划分出来到文件就是不同的分区<br>分区的意义是将一个具有大量数据的表，将其分散到不同的数据和索引文件中进行储存<br>对于Innodb来说，相当于一个表对应对个ibd文件<br>分散之后，每个文件对应的数据量显著减少，保证单个文件的执行速度<br>一般情况就是根据id主键字段进行分区，或者为主键，唯一键的一个子集，在创建表时，利用partition进行设定<br>例如下面，就是利用id字段，使用hash算法，将数据分布在10个分区中<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t2 (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> auto_increment promary <span class="keyword">key</span>,</span><br><span class="line">col2 <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">col3 <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">col4 <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (col1),</span><br><span class="line"><span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> (col3)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">HASH</span>(<span class="keyword">id</span>)</span><br><span class="line"><span class="keyword">PARTITIONS</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure></p><p>分区完成后，客户端看上去还是一张表。</p><h2 id="分区算法"><a href="#分区算法" class="headerlink" title="分区算法"></a>分区算法</h2><p>range分区：基于一个给定的连续区间范围(区间要求连续并且不能重叠)，把数据分配到不同的分区<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t2 (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> auto_increment promary <span class="keyword">key</span>,</span><br><span class="line">col2 <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">col3 <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">pubtime <span class="built_in">INT</span> ,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>,pubtime),</span><br><span class="line"><span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> (col3)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>(pubtime)(</span><br><span class="line"><span class="keyword">PARTITION</span> p201907 <span class="keyword">VALUES</span> <span class="keyword">less</span> <span class="keyword">than</span> (<span class="number">1509665599</span>) <span class="comment">-- 某个时间的时间戳</span></span><br><span class="line"><span class="keyword">PARTITION</span> p201907 <span class="keyword">VALUES</span> <span class="keyword">less</span> <span class="keyword">than</span> (<span class="number">1512355599</span>) <span class="comment">-- 某个时间的时间戳</span></span><br><span class="line"><span class="keyword">PARTITION</span> p201907 <span class="keyword">VALUES</span> <span class="keyword">less</span> <span class="keyword">than</span> (<span class="number">1540765599</span>) <span class="comment">-- 某个时间的时间戳</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>条件只能用小于，更小的时间戳要放在前面<br>list分区：类似于range分区，区别在于list分区是居于枚举出的值列表分区，range是基于给定的连续区间范围分区，使用 in(值列表)<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t2 (</span><br><span class="line"><span class="keyword">id</span> <span class="built_in">INT</span> auto_increment promary <span class="keyword">key</span>,</span><br><span class="line">col2 <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">col3 <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">status</span> <span class="built_in">INT</span> ,</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>,pubtime),</span><br><span class="line"><span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> (col3)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span>(<span class="keyword">status</span>)(</span><br><span class="line"><span class="keyword">PARTITION</span> p1 <span class="keyword">VALUES</span> <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>),</span><br><span class="line"><span class="keyword">PARTITION</span> p2 <span class="keyword">VALUES</span> <span class="keyword">in</span> (<span class="number">3</span>,<span class="number">4</span>),</span><br><span class="line"><span class="keyword">PARTITION</span> p3 <span class="keyword">VALUES</span> <span class="keyword">in</span> (<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p><p>hash分区：基于给定的分区个数，把数据分配到不同的分区，采取的是求余方案，所谓hash算法，就是对于输入，得到某个特定的输出，要求如果输入相同的值应当得到相同的输出。这种算法在业务逻辑上表现为均匀分配<br>key分区：类似于hash分区，在hash中，只能对整数进行分区，但是key可以使用非整数类型进行分区（如字符串）</p><h2 id="分区管理"><a href="#分区管理" class="headerlink" title="分区管理"></a>分区管理</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除list或者range分区(同时删除分区对应的数据)</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> &lt;<span class="keyword">table</span>&gt; <span class="keyword">drop</span> <span class="keyword">partition</span> &lt;分区名称&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 新增分区</span></span><br><span class="line"><span class="comment">-- range添加新分区</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> &lt;<span class="keyword">table</span>&gt; <span class="keyword">add</span> <span class="keyword">partition</span>(<span class="keyword">partition</span> p4 <span class="keyword">values</span> <span class="keyword">less</span> <span class="keyword">than</span> MAXVALUE);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- list添加新分区</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> &lt;<span class="keyword">table</span>&gt; <span class="keyword">add</span> <span class="keyword">partition</span>(<span class="keyword">partition</span> p4 <span class="keyword">values</span> <span class="keyword">in</span> (<span class="number">25</span>,<span class="number">26</span>,<span class="number">28</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">-- hash重新分区</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> &lt;<span class="keyword">table</span>&gt; <span class="keyword">add</span> <span class="keyword">partition</span> <span class="keyword">partitions</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- key重新分区</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> &lt;<span class="keyword">table</span>&gt; <span class="keyword">add</span> <span class="keyword">partition</span> <span class="keyword">partitions</span> <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 子分区添加新分区，虽然我没有指定子分区，但是系统会给子分区命名的</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> &lt;<span class="keyword">table</span>&gt; <span class="keyword">add</span> <span class="keyword">partition</span>(<span class="keyword">partition</span> p3 <span class="keyword">values</span> <span class="keyword">less</span> <span class="keyword">than</span> MAXVALUE);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- range重新分区</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="keyword">user</span> REORGANIZE <span class="keyword">PARTITION</span> p0,p1,p2,p3,p4 <span class="keyword">INTO</span> (<span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> <span class="keyword">LESS</span> <span class="keyword">THAN</span> MAXVALUE);</span><br><span class="line"></span><br><span class="line"><span class="comment">-- list重新分区</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> &lt;<span class="keyword">table</span>&gt; REORGANIZE <span class="keyword">PARTITION</span> p0,p1,p2,p3,p4 <span class="keyword">INTO</span> (<span class="keyword">PARTITION</span> p0 <span class="keyword">VALUES</span> <span class="keyword">in</span> (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>));</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在客户端程序不变的情况下，将服务器端的数据分布到不同的物理文件中，进而提供数据表的处理能力<br>当数据量比较大时，分区可以提升效率<br>且只有检索字段为分区字段时，分区效率才会明显提高</p><h1 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h1><p>如果一个表的每条记录的内容很大，那么就需要更多的IO操作，如果字段值比较大，而使用频率相对比较低，可以将大字段移到另一张表中，当查询不查大字段的时候，这样就减少了I/O操作<br>如果一个表的数据量很少，那么查询就很快；如果表的数据量非常非常大，那么查询就变的比较慢；也就是表的数据量影响这查询的性能。<br>表中的数据本来就有独立性，例如分别记录各个地区的数据或者不同时期的数据，特别是有些数据常用，而另外一些数据不常用。</p><p>通过应用程序，把数据划分到不同的表中存储，分表的操作会在客户端出现多张表<br>水平切分：<br><img src="/upload/pasted-450.png" alt="upload successful"><br>水平切分类似于分区，但是它是实实在在的把一个大表分成两个小表，可以根据某个查询值分块来把表水平切分</p><p>垂直切分：<br><img src="/upload/pasted-451.png" alt="upload successful"><br>简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。 垂直分割一般用于拆分大字段和访问频率低的字段，分离冷热数据。</p><p>垂直分割适用于记录不是非常多的，但是字段却很多，这样占用空间比较大，检索时需要执行大量的I/O，严重降低了性能，这个时候需要把大的自读那拆分到另一个表中，并且该表与源表时一对一关系。<br>垂直拆分的优点： 可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。<br>垂直拆分的缺点： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL深入研究（1）【字段设计，存储引擎介绍，锁机制，索引】</title>
      <link href="/2019/07/20/MySQLDeepLearn/"/>
      <url>/2019/07/20/MySQLDeepLearn/</url>
      
        <content type="html"><![CDATA[<p><img src="https://www.3dmgame.com/uploads/images/thumbpicfirst/20180830/1535616414_320863.jpg" width="70%"><br><a id="more"></a></p><h1 id="字段的设计"><a href="#字段的设计" class="headerlink" title="字段的设计"></a>字段的设计</h1><h2 id="优先使用符合业务需要的最小的数据类型"><a href="#优先使用符合业务需要的最小的数据类型" class="headerlink" title="优先使用符合业务需要的最小的数据类型"></a>优先使用符合业务需要的最小的数据类型</h2><p>1.比如ip地址，可以用无符号整型数直接储存（MySQL内置函数INET_ATON(字符串)和INTE_NTOA(整数)分别是把ip地址转换为整型和把整型转换为字符串）<br>2.对于非负数的存储，就没必要用一般的int形，用无符号就可以解决<br>3.不要用TEXT，BLOB，或者把他们都分离到单独的扩展表中<br>4.对于一些选择项，可以用数字代替原来的字符串</p><h2 id="用关联表替代枚举"><a href="#用关联表替代枚举" class="headerlink" title="用关联表替代枚举"></a>用关联表替代枚举</h2><p>枚举若发生改变，可能会对整张表造成影响，修改的思路是把性别抽离出来单独成一张关联表</p><h2 id="金额类型的存储"><a href="#金额类型的存储" class="headerlink" title="金额类型的存储"></a>金额类型的存储</h2><p>涉及到对精度的要求，应当用Decimal，另外的思路就是小金额大数据，用一个bigint存，这个思路就是消除小数点，消除关于精度的问题</p><h2 id="not-null"><a href="#not-null" class="headerlink" title="not null"></a>not null</h2><p>对于任何字段，应当尽量使其存储内容不为null，应当用数据域不会出现的某个值来替代。</p><h2 id="表中字段数量不宜过多"><a href="#表中字段数量不宜过多" class="headerlink" title="表中字段数量不宜过多"></a>表中字段数量不宜过多</h2><p>利用第三范式将表细化，减少表中字段数量</p><h2 id="表间关系设计"><a href="#表间关系设计" class="headerlink" title="表间关系设计"></a>表间关系设计</h2><p>利用合理的外键将表串联</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>只有很大内容上的需求采用text<br>字符串列的最大长度比平均长度大很多;列的更新很少（所以碎片不是问题）;使用了像UTF8这样的字符集（每个字符都使用不同的字节数进行存储）这个时候用varchar<br>很短，或者所有值都接近同一个长度（如MD5）;列经常变更，这个时候用char</p><h2 id="日期时间注意"><a href="#日期时间注意" class="headerlink" title="日期时间注意"></a>日期时间注意</h2><p>不要用字符串存储日期型数据，浪费空间<br>DATE能保存从1001到9999年，精度为秒，他把日期和时间封装到格式为YYYYMMDDHHMMSS的整数中，使用8字节<br>TIMESTAMP保存了从1970年以来的秒数，和Unix时间戳相同，只能保存1970到2038,使用4字节<br>FROM_UNIXTIME()和UNIX_TIMESTAMP()两个函数转换日期和Unix时间戳<br>通常用TIMESTAMP，空间效率高<br>MYSQL没有提供比秒更小粒度的日期和时间值，如果需要，可以用BIGINT存储微妙级别的时间戳，或用DOUBLE存储秒之后的小数部分</p><h1 id="数据引擎"><a href="#数据引擎" class="headerlink" title="数据引擎"></a>数据引擎</h1><h2 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h2><p>MyISAM 设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操<br>作，则依然可以使用 MyISAM。<br>MyISAM 提供了大量的特性，包括压缩表、空间数据索引等。<br>不支持事务。<br>不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加<br>排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入<br>（CONCURRENT INSERT）。<br>可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数<br>据丢失，而且修复操作是非常慢的。<br>如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据<br>写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应<br>的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成<br>索引损坏，需要执行修复操作</p><h2 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h2><p>InnoDB 是 MySQL 默认的事务型存储引擎，只有在需要 InnoDB 不支持的特性时，才考虑使<br>用其它存储引擎。<br>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离<br>级别下，通过多版本并发控制（MVCC）+ 间隙锁（next-key locking）防止幻影读。<br>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的<br>提升。<br>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建<br>的自适应哈希索引、能够加速插入操作的插入缓冲区等。支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有<br>表的写入，而在读写混合场景中，停止写入可能也意味着停止读取</p><h1 id="MySQL的锁"><a href="#MySQL的锁" class="headerlink" title="MySQL的锁"></a>MySQL的锁</h1><p>MySQL的锁的初衷和java中的锁出发点是一样的，是计算机协调多个进程或线程并发访问某一资源的机制<br>在数据库中，除传统的 计算资源（如CPU、RAM、I/O等）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一 个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。</p><h2 id="一般描述"><a href="#一般描述" class="headerlink" title="一般描述"></a>一般描述</h2><p>MySQL不同的存储引擎所使用的锁的情况不太一样，但是大体分为三类：</p><ul><li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。 </li><li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。 </li><li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般<h2 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3>MyISAM主要采用的就是表锁，有两种模式：表共享读锁（Table Read Lock）和表独占写锁（Table Write Lock）。<br>对于这种读写锁分离设计，可以结合java的读写锁来进行理解<br>举例：当一个上了写锁时,其他读和写都会被阻塞<br><img src="/upload/pasted-431.png" alt="upload successful"></li></ul><p>当一个上了读锁时，和java中的有些区别：一个session使用LOCK TABLE命令给表film_text加了读锁，这个session可以查询锁定表中的记录，但更新或访问其他表都会提示错误；同时，另外一个session可以查询表中的记录，但更新就会出现锁等待。 </p><p><img src="/upload/pasted-436.png" alt="upload successful"></p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>MyISAM在执行查询语句（SELECT）前，会自动给涉及的所有表加读锁，在执行更新操作 （UPDATE、DELETE、INSERT等）前，会自动给涉及的表加写锁，这个过程并不需要用户干预，因此，用户一般不需要直接用LOCK TABLE命令给MyISAM表显式加锁</p><h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>MyISAM存储引擎有一个系统变量concurrent_insert，专门用以控制其并发插入的行为，其值分别可以为0、1或2。<br>当concurrent_insert设置为0时，不允许并发插入。<br>当concurrent_insert设置为1时，如果MyISAM表中没有空洞（即表的中间没有被删除的行），MyISAM允许在一个进程读表的同时，另一个进程从表尾插入记录。这也是MySQL的默认设置。<br>当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录。</p><p><img src="/upload/pasted-440.png" alt="upload successful"></p><h2 id="InnoDB锁"><a href="#InnoDB锁" class="headerlink" title="InnoDB锁"></a>InnoDB锁</h2><p>众所周知，Innodb支持事务<br>因此先了解下事务</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><p>事务是由一组sql语句组成的逻辑处理单元，具有ACID属性</p><p><img src="/upload/pasted-437.png" alt="upload successful"></p><ul><li>原子性（Actomicity）：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。</li><li>一致性（Consistent）：在事务开始和完成时，数据都必须保持一致状态。这意味着所有相关的数据规则都必须应用于事务的修改，以操持完整性；事务结束时，所有的内部数据结构（如B树索引或双向链表）也都必须是正确的。</li><li>隔离性（Isolation）：数据库系统提供一定的隔离机制，保证事务在不受外部并发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是不可见的，反之亦然。</li><li>持久性（Durable）：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。<br>实际上，这些特性并不是一种同级关系</li><li>只有满足一致性，事务的执行结果才是正确的。</li><li>在无并发的情况下，事务串行执行，隔离性一定能够满足。此时要只要能满足原子性，就</li><li>一定能满足一致性。</li><li>在并发的情况下，多个事务并发执行，事务不仅要满足原子性，还需要满足隔离性，才能</li><li>满足一致性。事务满足持久化是为了能应对数据库奔溃的情况</li></ul><p><img src="/upload/pasted-438.png" alt="upload successful"></p><h3 id="事务并发的问题"><a href="#事务并发的问题" class="headerlink" title="事务并发的问题"></a>事务并发的问题</h3><p>和java中的并发一样，事务的并发也会带来读写的问题</p><ul><li>丢失更新(Lost Update)<br>由于事务之间是不知道彼此的存在的，因此当两个事务同时对同一个数据进行修改时，可能会发生先修改的数据被后修改的所覆盖的问题<br><img src="/upload/pasted-441.png" alt="upload successful"></li><li>脏读（Dirty Reads）：<br>一个事务正在对一条记录做修改，在这个事务并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”的数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做“脏读”。<br><img src="/upload/pasted-442.png" alt="upload successful"></li><li>不可重复读（Non-Repeatable Reads）：<br>一个事务在读取某些数据已经发生了改变、或某些记录已经被删除了！这种现象叫做“不可重复读”。<br><img src="/upload/pasted-443.png" alt="upload successful"></li><li>幻读（Phantom Reads）：<br>一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”</li></ul><p><img src="/upload/pasted-444.png" alt="upload successful"></p><h3 id="问题的解决"><a href="#问题的解决" class="headerlink" title="问题的解决"></a>问题的解决</h3><p>在并发事务处理带来的问题中，“更新丢失”通常应该是完全避免的。但防止更新丢失，并不能单靠数据库事务控制器来解决，需要应用程序对要更新的数据加必要的锁来解决，因此，防止更新丢失应该是应用的责任。</p><p>“脏读”、“不可重复读”和“幻读”，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。数据库实现事务隔离的方式，基本可以分为以下两种。</p><p>一种是在读取数据前，对其加锁，阻止其他事务对数据进行修改。<br>另一种是不用加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot），并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户的角度，好像是数据库可以提供同一数据的多个版本，因此，这种技术叫做数据多版本并发控制（ＭultiVersion Concurrency Control，简称MVCC或MCC），也经常称为多版本数据库。</p><p>在MVCC并发控制中，读操作可以分成两类：快照读 (snapshot read)与当前读 (current read)。快照读，读取的是记录的可见版本 (有可能是历史版本)，不用加锁。当前读，读取的是记录的最新版本，并且，当前读返回的记录，都会加上锁，保证其他事务不会再并发修改这条记录。<br>在一个支持MVCC并发控制的系统中，哪些读操作是快照读？哪些操作又是当前读呢？以MySQL InnoDB为例：</p><ul><li><p>快照读：<br>简单的select操作，属于快照读，不加锁。(当然，也有例外)</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ?;</span><br></pre></td></tr></table></figure></li><li><p>当前读：<br>特殊的读操作，插入/更新/删除操作，属于当前读，需要加锁。<br>下面语句都属于当前读，读取记录的最新版本。并且，读取之后，还需要保证其他并发事务不能修改当前记录，对读取记录加锁。其中，除了第一条语句，对读取记录加S锁 (共享锁)外，其他的操作，都加的是X锁 (排它锁)。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">lock</span> <span class="keyword">in</span> <span class="keyword">share</span> <span class="keyword">mode</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ? <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> <span class="keyword">values</span> (…);</span><br><span class="line"><span class="keyword">update</span> <span class="keyword">table</span> <span class="keyword">set</span> ? <span class="keyword">where</span> ?;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> ?;</span><br></pre></td></tr></table></figure></li></ul><p>为了解决“隔离”与“并发”的矛盾，ISO/ANSI SQL92定义了4个事务隔离级别，每个级别的隔离程度不同，允许出现的副作用也不同，应用可以根据自己的业务逻辑要求，通过选择不同的隔离级别来平衡 “隔离”与“并发”的矛盾。下表很好地概括了这4个隔离级别的特性</p><p><img src="/upload/pasted-445.png" alt="upload successful"></p><h3 id="InnoDB的行级锁"><a href="#InnoDB的行级锁" class="headerlink" title="InnoDB的行级锁"></a>InnoDB的行级锁</h3><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><ul><li>排它锁（Exclusive），简写为 X 锁，又称写锁。<br>一个事务对数据对象 A 加了 X 锁，就可以对 A 进行读取和更新。加锁期间其它事务不能对 A 加任何锁。</li><li>共享锁（Shared），简写为 S 锁，又称读锁。<br>一个事务对数据对象 A 加了 S 锁，可以对 A 进行读取操作，但是不能进行更新操作。加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁</li></ul><h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>使用意向锁（Intention Locks）可以更容易地支持多粒度封锁。</p><ul><li>意向共享锁（IS）：事务打算给数据行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。</li><li>意向排他锁（IX）：事务打算给数据行加排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。</li></ul><p>在存在行级锁和表级锁的情况下，事务 T 想要对表 A 加 X 锁，就需要先检测是否有其它事务<br>对表 A 或者表 A 中的任意一行加了锁，那么就需要对表 A 的每一行都检测一次，这是非常耗时的。<br>意向锁在原来的 X/S 锁之上引入了 IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的<br>某个数据行上加 X 锁或 S 锁。有以下两个规定：</p><ul><li>一个事务在获得某个数据行对象的 S 锁之前，必须先获得表的 IS 锁或者更强的锁；</li><li>一个事务在获得某个数据行对象的 X 锁之前，必须先获得表的 IX 锁。<br>通过引入意向锁，事务 T 想要对表 A 加 X 锁，只需要先检测是否有其它事务对表 A 加了<br>X/IX/S/IS 锁，如果加了就表示有其它事务正在使用这个表或者表中某一行的锁，因此事务 T<br>加 X 锁失败。<h4 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h4>当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的 索引项加锁；对于键值在条件范围内但并不存在的记录，叫做“间隙（GAP)”，InnoDB也会对这个“间隙”加锁，这种锁机制就是所谓的间隙锁 （Next-Key锁）。<br>利用这种锁可以解决幻读的问题，但是对于频繁插入的业务会造成严重的阻塞<br>比如以下例子</li></ul><p><img src="/upload/pasted-449.png" alt="upload successful"></p><h4 id="锁的使用"><a href="#锁的使用" class="headerlink" title="锁的使用"></a>锁的使用</h4><p>意向锁是InnoDB自动加的，不需用户干预。对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁。<br>事务可以通过以下语句显式给记录集加共享锁或排他锁：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ... <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> table_name <span class="keyword">WHERE</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br></pre></td></tr></table></figure></p><h4 id="具体情况"><a href="#具体情况" class="headerlink" title="具体情况"></a>具体情况</h4><p>只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！<br>对一个没有创建索引的表进行查询</p><p><img src="/upload/pasted-446.png" alt="upload successful"><br>在上面的例子中，看起来session_1只给一行加了排他锁，但session_2在请求其他行的排他锁时，却出现了锁等待！原因就是在没有索引的情况下，InnoDB只能使用表锁</p><p>创建索引后<br><img src="/upload/pasted-447.png" alt="upload successful"></p><p>访问相同的索引并加锁就会阻塞</p><p><img src="/upload/pasted-448.png" alt="upload successful"></p><h1 id="MySQL的索引"><a href="#MySQL的索引" class="headerlink" title="MySQL的索引"></a>MySQL的索引</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>索引是一种可以加快数据查询速度的一种数据结构<br>虽然索引可以加快查询速度，提高 MySQL 的处理性能，但是过多地使用索引也会造成以下弊端：</p><ul><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li><li>除了数据表占数据空间之外，每一个索引还要占一定的物理空间。如果要建立聚簇索引，那么需要的空间就会更大。</li><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，这样就降低了数据的维护速度。<br>因此，索引的不能随便创建，应当结合具体情况具体分析</li></ul><p>根据数据结构划分，可以把索引划分为B树索引以及哈希索引</p><h2 id="B树索引"><a href="#B树索引" class="headerlink" title="B树索引"></a>B树索引</h2><p>这是比较常见的索引形式，是基于B树的数据结构，需要注意的就是这种索引遵循左边前缀原则，即索引的查找要从被选定为索引的最左边一列查询。<br>可以根据索引选择性判断是否需要创建索引<br>所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值：<br>Index Selectivity = Cardinality / #T<br>显然选择性的取值范围为(0, 1]，选择性越高的索引价值越大，这是由B+Tree的性质决定的。<br>有一种与索引选择性有关的索引优化策略叫做前缀索引，就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。<br>在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。(基于Innodb的聚集索引)</p><p><a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">http://blog.codinglabs.org/articles/theory-of-mysql-index.html</a><br>这篇文章讲的非常好</p><h2 id="哈希索引"><a href="#哈希索引" class="headerlink" title="哈希索引"></a>哈希索引</h2><p>哈希索引也称为散列索引或 HASH 索引。MySQL 目前仅有 MEMORY 存储引擎和 HEAP 存储引擎支持这类索引。其中，MEMORY 存储引擎可以支持 B- 树索引和 HASH 索引，且将 HASH 当成默认索引。<br>HASH 索引不是基于树形的数据结构查找数据，而是根据索引列对应的哈希值的方法获取表的记录行。哈希索引的最大特点是访问速度快，但也存在下面的一些缺点：</p><ul><li>MySQL 需要读取表中索引列的值来参与散列计算，散列计算是一个比较耗时的操作。也就是说，相对于 B- 树索引来说，建立哈希索引会耗费更多的时间。</li><li>不能使用 HASH 索引排序。</li><li>HASH 索引只支持等值比较，如“=”“IN()”或“&lt;=&gt;”。</li><li>HASH 索引不支持键的部分匹配，因为在计算 HASH 值的时候是通过整个索引值来计算的。</li></ul><h2 id="全文索引"><a href="#全文索引" class="headerlink" title="全文索引"></a>全文索引</h2><p>MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查<br>找条件使用 MATCH AGAINST，而不是普通的 WHERE。<br>全文索引一般使用倒排索引实现，它记录着关键词到其所在文档的映射。<br>InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。</p><h2 id="空间数据索引（R-tree）"><a href="#空间数据索引（R-tree）" class="headerlink" title="空间数据索引（R-tree）"></a>空间数据索引（R-tree）</h2><p>MyISAM 存储引擎支持空间数据索引，可以用于地理数据存储。空间数据索引会从所有维度<br>来索引数据，可以有效地使用任意维度来进行组合查询。<br>必须使用 GIS 相关的函数来维护数据。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库SQL部分复习（4）【自定义函数，存储过程，触发器，依赖和三范式】</title>
      <link href="/2019/07/18/tabasereview4/"/>
      <url>/2019/07/18/tabasereview4/</url>
      
        <content type="html"><![CDATA[<p><img src="/upload/pasted-279.png" width="70%"><br><a id="more"></a></p><h1 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>函数由一系列sql语句组成，调用函数就是一次性执行这些语句。所以函数可以降低语句重复。【但注意的是函数注重返回值，不注重执行过程，所以一些语句无法执行。所以函数并不是单纯的sql语句集合。】<br>函数只能返回单个值而不能返回一整个结果集。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> selectMAXgrade (sub <span class="built_in">VARCHAR</span>(<span class="number">10</span>)) <span class="keyword">RETURNS</span> <span class="built_in">INT</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DECLARE</span> c <span class="built_in">INT</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">MAX</span>(grade)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">sc</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">cno = sub <span class="keyword">INTO</span> c;</span><br><span class="line"></span><br><span class="line">RETURN c;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">selectMAXgrade (<span class="string">'1001'</span>);</span><br></pre></td></tr></table></figure><h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p>存储过程是一组为了完成特定功能的 SQL 语句集合。使用存储过程的目的是将常用或复杂的工作预先用 SQL 语句写好并用一个指定名称存储起来，这个过程经编译和优化后存储在数据库服务器中，因此称为存储过程。当以后需要数据库提供与已定义好的存储过程的功能相同的服务时，只需调用“CALL存储过程名字”即可自动完成<br>存储过程有如下优点：<br>1) 封装性<br>存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的 SQL 语句，并且数据库专业人员可以随时对存储过程进行修改，而不会影响到调用它的应用程序源代码。<br>2) 可增强 SQL 语句的功能和灵活性<br>存储过程可以用流程控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。<br>3) 可减少网络流量<br>由于存储过程是在服务器端运行的，且执行速度快，因此当客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而可降低网络负载。<br>4) 高性能<br>存储过程执行一次后，产生的二进制代码就驻留在缓冲区，在以后的调用中，只需要从缓冲区中执行二进制代码即可，从而提高了系统的效率和性能。<br>5) 提高数据库的安全性和数据的完整性<br>使用存储过程可以完成所有数据库操作，并且可以通过编程的方式控制数据库信息访问的权限。</p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>找出给定的学科编号的考的90分以上的学生姓名<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">delimiter //</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> showOver90Stu (sub <span class="built_in">VARCHAR</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sno <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sno</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">sc</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">cno = sub</span><br><span class="line"><span class="keyword">AND</span> grade &gt; <span class="number">90</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">END</span> //</span><br><span class="line">    </span><br><span class="line"><span class="keyword">call</span> showOver90Stu(<span class="string">'1001'</span>)</span><br></pre></td></tr></table></figure></p><p>需要注意的是，在begin和end之间定义的sql结尾要加；，但是为了让语句不会提前运行，需要自定义终止字符，调用delimiter //，//表示希望作为终止符的符号。</p><h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><h2 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h2><p>MySQL 数据库中触发器是一个特殊的存储过程，不同的是执行存储过程要使用 CALL 语句来调用，而触发器的执行不需要使用 CALL 语句来调用，也不需要手工启动，只要一个预定义的事件发生就会被 MySQL自动调用</p><p>在实际使用中，MySQL 所支持的触发器有三种：INSERT 触发器、UPDATE 触发器和 DELETE 触发器。<br>1) INSERT 触发器<br>在 INSERT 语句执行之前或之后响应的触发器。<br>使用 INSERT 触发器需要注意以下几点：</p><ul><li>在 INSERT 触发器代码内，可引用一个名为 NEW（不区分大小写）的虚拟表来访问被插入的行。</li><li>在 BEFORE INSERT 触发器中，NEW 中的值也可以被更新，即允许更改被插入的值（只要具有对应的操作权限）。</li><li>对于 AUTO_INCREMENT 列，NEW 在 INSERT 执行之前包含的值是 0，在 INSERT 执行之后将包含新的自动生成值。</li></ul><p>2) UPDATE 触发器<br>在 UPDATE 语句执行之前或之后响应的触发器。<br>使用 UPDATE 触发器需要注意以下几点：</p><ul><li>在 UPDATE 触发器代码内，可引用一个名为 NEW（不区分大小写）的虚拟表来访问更新的值。</li><li>在 UPDATE 触发器代码内，可引用一个名为 OLD（不区分大小写）的虚拟表来访问 UPDATE 语句执行前的值。</li><li>在 BEFORE UPDATE 触发器中，NEW 中的值可能也被更新，即允许更改将要用于 UPDATE 语句中的值（只要具有对应的操作权限）。</li><li>OLD 中的值全部是只读的，不能被更新。</li></ul><p>3) DELETE 触发器<br>在 DELETE 语句执行之前或之后响应的触发器。<br>使用 DELETE 触发器需要注意以下几点：</p><ul><li>在 DELETE 触发器代码内，可以引用一个名为 OLD（不区分大小写）的虚拟表来访问被删除的行。</li><li>OLD 中的值全部是只读的，不能被更新。</li></ul><h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><p>当删除某个学生时，同时删除他的成绩等<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">delimiter $$</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> deleteSc <span class="keyword">AFTER</span> <span class="keyword">DELETE</span> <span class="keyword">ON</span> student <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">sc</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sno = old.sno ;</span><br><span class="line"><span class="keyword">END</span> $$</span><br></pre></td></tr></table></figure></p><h1 id="依赖和三范式"><a href="#依赖和三范式" class="headerlink" title="依赖和三范式"></a>依赖和三范式</h1><h2 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>设R(U)是一个属性集U上的关系模式，X和Y是U的子集。<br>若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等， 而在Y上的属性值不等， 则称 “X函数确定Y” 或  “Y函数依赖于X”。记作X→Y。<br>对于这个概念，可以这么理解：要是学号定了，确定了某个人，那么性别，姓名就都确定了</p><ul><li><p>平凡依赖和非平凡依赖<br><img src="/upload/pasted-432.png" alt="upload successful"><br>例如在sc中，<br>平凡函数依赖：(Sno, Cno) → Sno<br>非平凡依赖：(Sno, Cno) → Grade</p></li><li><p>完全依赖和部分依赖：<br><img src="/upload/pasted-434.png" alt="upload successful"><br>可以这么理解：只有全部的关系才能决定下一个属性，这就是完全依赖，如果其中一个就可以决定下一个属性，那么就是部分依赖<br>例如grade完全依赖于sno和cno，而由于sname依赖于sno，则sname部分依赖于sno和cno</p></li><li><p>传递依赖<br><img src="/upload/pasted-435.png" alt="upload successful"><br>比如对于关系，Std(Sno, Sdept, Mname)<br>sno决定sdept,sdept决定Mname,则相当于Mname传递依赖于sno</p></li></ul><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><h3 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h3><p>如果一个关系模式R的所有属性都是不可分的基本数据项，则R∈1NF。<br>意思是对于任意一个数据项，都能没有歧义存入数据库，比如说一个关系学生（学生信息），这就不满足第一范式</p><h3 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h3><p>若关系模式R∈1NF，并且每一个非主属性都完全函数依赖于R的码，则R∈2NF。<br>就是说只要主键确定了，别的数据项就都能确定了<br>对于关系scn(sno,cno,sname,grade)<br>grade对于主键(sno,cno)是完全依赖的，而sname对于（sno,cno）是部分依赖的，因此若要满足第二范式，则需要将原表拆成sc(sno,cno,grade),s(sno,sname)</p><h3 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h3><p><img src="/upload/pasted-439.png" alt="upload successful"><br>如S1（SNO，SNAME，DNO，DNAME，LOCATION） 各属性分别代表学号，姓名，所在系，系名称，系地址。<br>关系中存在传递依赖。即SNO -&gt; DNO。 而DNO -&gt; SNO却不存在，DNO -&gt; LOCATION, 因此关键字 SNO 对 LOCATION 函数决定是通过传递依赖 DNO -&gt; LOCATION 实现的。也就是说，SNO不直接决定非主属性LOCATION。<br>因此需要拆成两个关系<br>S（SNO，SNAME，DNO），D（DNO，DNAME，LOCATION）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库SQL部分复习（3）【数据更新，视图，查询练习】</title>
      <link href="/2019/07/17/tabasereview/"/>
      <url>/2019/07/17/tabasereview/</url>
      
        <content type="html"><![CDATA[<p><img src="/upload/pasted-430.png" width="70%"></p><a id="more"></a><h1 id="数据更新"><a href="#数据更新" class="headerlink" title="数据更新"></a>数据更新</h1><h2 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h2><p>一般的插入<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SC (Sno,Cno)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">' 200215128 '</span> , <span class="string">' 1 '</span>)</span><br></pre></td></tr></table></figure></p><p>插入查询结果<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> Deptage (Sdept, Avgage) <span class="keyword">SELECT</span></span><br><span class="line">Sdept,</span><br><span class="line"><span class="keyword">AVG</span>(Sage)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">Student</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">Sdept</span><br></pre></td></tr></table></figure></p><p>插入多条结果<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">INSERTINTO table_name (col_one, col_two)</span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">(<span class="string">'c1'</span>, <span class="string">'c2'</span>),</span><br><span class="line">(<span class="string">'c3'</span>, <span class="string">'c4'</span>)</span><br></pre></td></tr></table></figure></p><p>这种方式只能在mysql里面写</p><h2 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h2><p>一般修改<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> Student</span><br><span class="line"><span class="keyword">SET</span> Sage = <span class="number">22</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">Sno = <span class="string">' 200215121 '</span></span><br></pre></td></tr></table></figure></p><p>批量修改<br>若不设置条件，则是针对全部<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> sc</span><br><span class="line"><span class="keyword">SET</span> grade = grade + <span class="number">1</span></span><br></pre></td></tr></table></figure></p><h2 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">S</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">Sno = <span class="string">'200215125'</span></span><br></pre></td></tr></table></figure><h1 id="视图（View）"><a href="#视图（View）" class="headerlink" title="视图（View）"></a>视图（View）</h1><p>视图是一个虚拟表，其内容由查询定义。同真实表一样，视图包含一系列带有名称的列和行数据，但视图并不是数据库真实存储的数据表。<br>视图是从一个、多个表或者视图中导出的表，包含一系列带有名称的数据列和若干条数据行。<br>视图并不同于数据表，它们的区别在于以下几点：</p><ul><li>视图不是数据库中真实的表，而是一张虚拟表，其结构和数据是建立在对数据中真实表的查询基础上的。</li><li>存储在数据库中的查询操作 SQL 语句定义了视图的内容，列数据和行数据来自于视图查询所引用的实际表，引用视图时动态生成这些数据。</li><li>视图没有实际的物理记录，不是以数据集的形式存储在数据库中的，它所对应的数据实际上是存储在视图所引用的真实表中的。</li><li>视图是数据的窗口，而表是内容。表是实际数据的存放单位，而视图只是以不同的显示方式展示数据，其数据来源还是实际表。</li><li>视图是查看数据表的一种方法，可以查询数据表中某些字段构成的数据，只是一些 SQL 语句的集合。从安全的角度来看，视图的数据安全性更高，使用视图的用户不接触数据表，不知道表结构。</li><li>视图的建立和删除只影响视图本身，不影响对应的基本表。</li></ul><h1 id="查询题目练习"><a href="#查询题目练习" class="headerlink" title="查询题目练习"></a>查询题目练习</h1><p>设有三个关系：<br>S(sno,sname,sex,age)<br>SC(sno,cno,grade)<br>C(cno,cname,teacher)</p><ol><li><p>查询LIU老师所授课程的课程号和课程名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">cno,</span><br><span class="line">cname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">C</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">teacher = <span class="string">'LIU'</span></span><br></pre></td></tr></table></figure></li><li><p>查询年龄大于23岁的男学生的学号和姓名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sno,</span><br><span class="line">sname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">S</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">age &gt; <span class="number">23</span></span><br><span class="line"><span class="keyword">AND</span> sex = <span class="string">'M'</span></span><br></pre></td></tr></table></figure></li><li><p>查询学号为S3学生所学课程的课程名与任课教师名<br>连接查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">cname,</span><br><span class="line">teacher</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">SC,</span><br><span class="line">C</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">SC.cno = C.cno</span><br><span class="line"><span class="keyword">AND</span> sno = <span class="string">'S3'</span></span><br></pre></td></tr></table></figure></li></ol><p>嵌套查询<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">cname,</span><br><span class="line">teacher</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">C</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">cno <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">cno</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">SC</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sno = <span class="string">'S3'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><ol start="4"><li>查询至少选修LIU老师所授课程中一门课程的女学生姓名<br>连接查询<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">S,</span><br><span class="line">SC,</span><br><span class="line">C</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">S.sno = SC.sno</span><br><span class="line"><span class="keyword">AND</span> SC.cno = C.cno</span><br><span class="line"><span class="keyword">AND</span> sex = <span class="string">'F'</span></span><br><span class="line"><span class="keyword">AND</span> teacher = <span class="string">'LIU'</span></span><br></pre></td></tr></table></figure></li></ol><p>嵌套查询<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">S</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sex = ‘F’</span><br><span class="line"><span class="keyword">AND</span> sno <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sno</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">SC</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">cno <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">cno</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">C</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">teacher = ‘LIU’</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><ol start="5"><li><p>查询WANG同学不学的课程的课程号<br>NOT EXISTS嵌套查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">cno</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">C</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">NOT</span> <span class="keyword">EXISTS</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">S,</span><br><span class="line">SC</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">S.sno = SC.sno</span><br><span class="line"><span class="keyword">AND</span> SC.cno = C.cno</span><br><span class="line"><span class="keyword">AND</span> sname = ‘WANG’</span><br><span class="line">)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>查询至少选修两门课的学生学号</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sno</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">sno</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line"><span class="keyword">count</span>(*) &gt;= <span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>统计每门课程的学生选修人数（超过10人的课程才统计）。要求显示课程号和人数，查询结果按人数降序排列，若人数相同，按课程号升序排列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">cno,</span><br><span class="line"><span class="keyword">count</span>(sno)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">SC</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">cno</span><br><span class="line"><span class="keyword">HAVING</span></span><br><span class="line"><span class="keyword">count</span>(*) &gt; <span class="number">10</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line"><span class="keyword">count</span>(sno) <span class="keyword">DESC</span>,</span><br><span class="line">cno</span><br></pre></td></tr></table></figure></li><li><p>求LIU老师所授课程的每门课程的平均成绩</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Select</span> C.cno,<span class="keyword">avg</span>(grade) </span><br><span class="line"><span class="keyword">from</span> SC,C</span><br><span class="line"><span class="keyword">where</span> SC.cno=C.cno </span><br><span class="line">    <span class="keyword">and</span> teacher=‘LIU’ </span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> C.cno</span><br></pre></td></tr></table></figure></li><li><p>检索姓名以L打头的所有学生的姓名和年龄</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sname,</span><br><span class="line">age</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">S</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sname <span class="keyword">LIKE</span> <span class="string">'L%'</span></span><br></pre></td></tr></table></figure></li><li><p>求年龄大于所有女同学年龄的男学生姓名和年龄</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sname,</span><br><span class="line">age</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">S</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sex = ‘M’</span><br><span class="line"><span class="keyword">AND</span> age &gt; <span class="keyword">ALL</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">age</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">S</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sex = ‘F’</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库SQL部分复习(2)【约束，数据类型，查询，连接查询，嵌套查询】</title>
      <link href="/2019/07/16/tabaseSQLReview-2/"/>
      <url>/2019/07/16/tabaseSQLReview-2/</url>
      
        <content type="html"><![CDATA[<p><img src="/upload/pasted-427.png" width="70%"></p><a id="more"></a><hr><h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><h2 id="模式（SCHEMA）-数据库（DATABASE）相关"><a href="#模式（SCHEMA）-数据库（DATABASE）相关" class="headerlink" title="模式（SCHEMA）,数据库（DATABASE）相关"></a>模式（SCHEMA）,数据库（DATABASE）相关</h2><p>MySQL官方文档指出，从概念上讲，模式是一组相互关联的数据库对象，如表，表列，列的数据类型，索引，外键等等。但是从物理层面上来说，模式与数据库是同义的。你可以在MySQL的SQL语法中用关键字SCHEMA替代DATABASE，例如使用CREATE SCHEMA来代替CREATE DATABASE。<br>也就是说，一个SCHEMA就是一套关系<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">SCHEMA</span> <span class="number">123</span></span><br></pre></td></tr></table></figure></p><p>就可以创建出一个新的数据库（DATABASE）</p><h2 id="表（TABLE）相关"><a href="#表（TABLE）相关" class="headerlink" title="表（TABLE）相关"></a>表（TABLE）相关</h2><h3 id="完整性约束"><a href="#完整性约束" class="headerlink" title="完整性约束"></a>完整性约束</h3><ul><li>主键约束（PRIMARY KEY)<br>主键约束是用来保证表中记录唯一可区分的列。一个表可以通过一列或列组合的数据来唯一标识表中的每一条记录。</li><li>唯一约束（UNIQUE)<br>规定一条记录的一个字段值或几个字段的组合值不得与其他记录的相同字段或字段组合的值重复，将这种限制成为“唯一约束”。</li><li>外键约束 (FOREIGN KEY)<br>1）外键列可以由是一个列或多个列组成。<br>2）外键列的取值可以为空，可以有重复值，但必须是它所引用列的列值之一。引用列必须是创建了主键约束或唯一约束的列。</li><li><p>检查约束 （CHECK)<br>检查约束是用来检查一个字段或多个字段的输入值是否满足指定的约束条件。</p></li><li><p>默认值约束（DEFAULT)<br>在用户定义数据类型的情况下，如果使用默认值约束，则默认值被插入到使用这个自定义数据的所有字段中。</p></li><li><p>空值约束（NULL)<br>空值约束就是指尚不知道或不确定的数据值，它不等同于0或空格。</p></li></ul><h3 id="数据库的基本数据类型（以MySQL为标准）"><a href="#数据库的基本数据类型（以MySQL为标准）" class="headerlink" title="数据库的基本数据类型（以MySQL为标准）"></a>数据库的基本数据类型（以MySQL为标准）</h3><h4 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h4><p>MySQL中提供了以下几种整数类型，可以设置自增约束</p><p><img src="/upload/pasted-414.png" alt="upload successful"><br>各个整数类型范围如下<br><img src="/upload/pasted-415.png" alt="upload successful"></p><h4 id="小数类型"><a href="#小数类型" class="headerlink" title="小数类型"></a>小数类型</h4><p>MySQL 中使用浮点数和定点数来表示小数。<br>浮点类型有两种，分别是单精度浮点数（FLOAT）和双精度浮点数（DOUBLE）；定点类型只有一种，就是 DECIMAL<br>两种类型都可以用（M,D）表示，其中M称为精度，表示总共的位数；D称为标度，表示小数的位数。<br>浮点数类型的取值范围为 M（1～255）和 D（1～30，且不能大于 M-2）DECIMAL 的默认 D 值为 0、M 值为 10<br> FLOAT 和 DOUBLE 在不指定精度时，默认会按照实际的精度（由计算机硬件和操作系统决定），DECIMAL 如果不指定精度，默认为（10，0）。<br> 不论是定点还是浮点类型，如果用户指定的精度超出精度范围，则会四舍五入进行处理。</p><p><img src="/upload/pasted-416.png" alt="upload successful"><br> 在 MySQL 中，定点数以字符串形式存储，在对精度要求比较高的时候（如货币、科学数据），使用 DECIMAL 的类型比较好，另外两个浮点数进行减法和比较运算时也容易出问题，所以在使用浮点数时需要注意，并尽量避免做浮点数比较。</p><h4 id="日期和时间类型"><a href="#日期和时间类型" class="headerlink" title="日期和时间类型"></a>日期和时间类型</h4><p>MySQL 中表示日期的数据类型：YEAR、TIME、DATE、DTAETIME、TIMESTAMP。当只记录年信息的时候，可以只使用 YEAR 类型。<br>当指定确定不合法的值时，系统将“零”值插入数据库中</p><p><img src="/upload/pasted-417.png" alt="upload successful"><br>对于YEAR,除了整数外也可以匹配形如YYYY的四位字符串或者两位字符串，对于两位的数字和字符串，0-69回转化为2001-2069，而70-99会转化为1970-1999<br>对于TIME,小时部分之所以会大出一部分的原因是可以用TIME表示某件事发展的时长，除了给定的格式外，可以用HHMMSS表示，但是对于这种输入，MySQL是从秒开始处理的。对于非法的输入，则储存0时间<br>对于DATE基本和上面有相似的规则，可以调用CURRENT_DATE 或者 NOW()，插入当前系统日期</p><p>DATETIME 在存储日期数据时，按实际输入的格式存储，即输入什么就存储什么，与时区无关；<br>TIMESTAMP 值的存储是以 UTC（世界标准时间）格式保存的，存储时对当前时区进行转换，检索时再转换回当前时区。即查询时，根据当前时区的不同，显示的时间值是不同的。</p><h4 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h4><p>MySQL 中的字符串类型有 CHAR、VARCHAR、TINYTEXT、TEXT、MEDIUMTEXT、LONGTEXT、ENUM、SET 等。</p><p><img src="/upload/pasted-418.png" alt="upload successful"><br>char是定长字符串类型，即不管要储存的字符串多长，它只储存规定的长度，不管多短，会用空格补齐剩下的，而varchar是变长的，只能规定最大长度，其实际的储存空间为字符串占的空间+1（字符串结束标识）</p><p><img src="/upload/pasted-419.png" alt="upload successful"><br>ENUM是MySQL内的枚举类型，每个具体字符串对应一个索引值，ENUM 类型的字段在取值时，能在指定的枚举列表中获取，而且一次只能取一个。如果创建的成员中有空格，尾部的空格将自动被删除。ENUM 列总有一个默认值。如果将 ENUM 列声明为 NULL，NULL 值则为该列的一个有效值，并且默认值为 NULL。如果 ENUM 列被声明为 NOT NULL，其默认值为允许的值列表的第 1 个元素。<br>SET是一个加强版的枚举，可以选择多个值加入</p><h4 id="二进制类型"><a href="#二进制类型" class="headerlink" title="二进制类型"></a>二进制类型</h4><p>MySQL 中的二进制字符串有 BIT、BINARY、VARBINARY、TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。</p><p><img src="/upload/pasted-420.png" alt="upload successful"></p><h3 id="表的创建"><a href="#表的创建" class="headerlink" title="表的创建"></a>表的创建</h3><p>建立一个“学生选课”表SC，它由学号Sno、课程号Cno，修课成绩Grade组成，其中(Sno, Cno)为主码。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> SC</span><br><span class="line">(    Sno <span class="built_in">CHAR</span>(<span class="number">5</span>) ,</span><br><span class="line">     Cno <span class="built_in">CHAR</span>(<span class="number">3</span>) , </span><br><span class="line">     Grade   <span class="built_in">int</span>,</span><br><span class="line">     Primary <span class="keyword">key</span> (Sno, Cno),</span><br><span class="line">     <span class="keyword">Foreign</span> <span class="keyword">key</span> (sno) <span class="keyword">References</span> student (sno),</span><br><span class="line">     <span class="keyword">Foreign</span> <span class="keyword">key</span> (cno) <span class="keyword">References</span> course (cno)  );</span><br></pre></td></tr></table></figure><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="查询全部"><a href="#查询全部" class="headerlink" title="查询全部"></a>查询全部</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> STUDENT</span><br></pre></td></tr></table></figure><h3 id="查询某一列"><a href="#查询某一列" class="headerlink" title="查询某一列"></a>查询某一列</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sno <span class="keyword">FROM</span> STUDENT</span><br></pre></td></tr></table></figure><h3 id="查询经过计算结果"><a href="#查询经过计算结果" class="headerlink" title="查询经过计算结果"></a>查询经过计算结果</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title,</span><br><span class="line">price * <span class="number">50</span> <span class="keyword">AS</span> <span class="number">50</span>price</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film_list</span><br></pre></td></tr></table></figure><h3 id="利用case-when替换查询结果"><a href="#利用case-when替换查询结果" class="headerlink" title="利用case when替换查询结果"></a>利用case when替换查询结果</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title,</span><br><span class="line"><span class="keyword">CASE</span></span><br><span class="line"><span class="keyword">WHEN</span> price &gt; <span class="number">0.99</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="string">'ex'</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line"><span class="string">'chep'</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">AS</span> price</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film_list</span><br></pre></td></tr></table></figure><h3 id="利用CONCAT连接查询结果，利用cast转化结果"><a href="#利用CONCAT连接查询结果，利用cast转化结果" class="headerlink" title="利用CONCAT连接查询结果，利用cast转化结果"></a>利用CONCAT连接查询结果，利用cast转化结果</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">CONCAT</span>(title,<span class="string">'的票价是'</span>,<span class="keyword">CAST</span>(price <span class="keyword">AS</span> <span class="built_in">char</span>)) <span class="keyword">as</span> 价格说明</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film_list</span><br></pre></td></tr></table></figure><h3 id="查询结果返回大小写，字符串长度"><a href="#查询结果返回大小写，字符串长度" class="headerlink" title="查询结果返回大小写，字符串长度"></a>查询结果返回大小写，字符串长度</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">LOWER</span>(title),</span><br><span class="line"><span class="keyword">UPPER</span>(title),</span><br><span class="line"><span class="keyword">LENGTH</span>(title)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film_list</span><br></pre></td></tr></table></figure><h3 id="字符串截取"><a href="#字符串截取" class="headerlink" title="字符串截取"></a>字符串截取</h3><p>1、left(str,length) 从左边截取length<br>2、right(str,length)从右边截取length<br>3、substring(str,index)当index&gt;0从左边开始截取直到结束  当index&lt;0从右边开始截取直到结束  当index=0返回空<br>4、substring(str,index,len) 截取str,从index开始，截取len长度<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">left</span>(title,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film_list</span><br></pre></td></tr></table></figure></p><h3 id="日期相关函数"><a href="#日期相关函数" class="headerlink" title="日期相关函数"></a>日期相关函数</h3><p>now()获取当前的日期和时间<br>current_timestamp() 获取当前时间戳<br>date_format(date,format), time_format(time,format) 转换时间形式<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">DATE_FORMAT</span>(last_update, <span class="string">'%y%m%d%h%i%s'</span>) <span class="keyword">AS</span> <span class="string">'时间序列'</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br></pre></td></tr></table></figure></p><p>（日期、天数）转换函数：to_days(date), from_days(days)<br>（时间、秒）转换函数：time_to_sec(time), sec_to_time(seconds)<br>拼凑日期、时间函数：makdedate(year,dayofyear), maketime(hour,minute,second)<br>（Unix 时间戳、日期）转换函数</p><h3 id="集合，范围查询"><a href="#集合，范围查询" class="headerlink" title="集合，范围查询"></a>集合，范围查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> rating <span class="keyword">in</span> (<span class="string">'PG'</span>,<span class="string">'R'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">customer_id </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">payment</span><br><span class="line"><span class="keyword">where</span> payment_date <span class="keyword">BETWEEN</span> <span class="string">'2005-06-17 09:19:45'</span> <span class="keyword">and</span> <span class="string">'2005-08-02 18:55:15'</span></span><br></pre></td></tr></table></figure><p>注意 between是左闭右开的</p><h3 id="字符串匹配"><a href="#字符串匹配" class="headerlink" title="字符串匹配"></a>字符串匹配</h3><h4 id="Like-匹配"><a href="#Like-匹配" class="headerlink" title="Like 匹配"></a>Like 匹配</h4><p>1.%：表示任意0个或多个字符。可匹配任意类型和长度的字符，有些情况下若是中文，请使用两个百分号（%%）表示<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title <span class="keyword">LIKE</span> <span class="string">'%W%'</span></span><br></pre></td></tr></table></figure></p><p>若是要搜索包含某两个字的<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title <span class="keyword">LIKE</span> <span class="string">'%W%'</span> <span class="keyword">and</span> title <span class="keyword">LIKE</span> <span class="string">'%O%'</span></span><br></pre></td></tr></table></figure></p><p>2._： 表示任意单个字符。匹配单个任意字符<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title <span class="keyword">LIKE</span> <span class="string">'_O%'</span></span><br></pre></td></tr></table></figure></p><h4 id="正则匹配"><a href="#正则匹配" class="headerlink" title="正则匹配"></a>正则匹配</h4><p>^ 匹配字符开始的部分<br>查询以W开头的<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title REGEXP <span class="string">'^W'</span></span><br></pre></td></tr></table></figure></p><p>$ 匹配字符结束的部分<br>查询以S为结尾的部分<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title REGEXP <span class="string">'S$'</span></span><br></pre></td></tr></table></figure></p><p>. 匹配字符串中的任意一个字符，包括回车和换行<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title REGEXP <span class="string">'^W................S$'</span></span><br></pre></td></tr></table></figure></p><p>[字符集合]匹配字符集合中的任意字符<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title REGEXP <span class="string">'^W[OE]'</span></span><br></pre></td></tr></table></figure></p><p>[^字符集合]匹配除了字符集合外的任意字符<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title REGEXP <span class="string">'^W[^B-Z]'</span></span><br></pre></td></tr></table></figure></p><p>s1|s2|s3 匹配s1s2s3中的任意一个<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">title</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">where</span> title REGEXP  <span class="string">'^WA|^WE|^WH'</span></span><br></pre></td></tr></table></figure></p><p>*代表多个该字符前的字符，包括0个或1个<br>+代表多个该字符前的字符，包括1个<br>字符串{N} 字符串出现N次<br>字符串{M，N}字符串最少出现M次，最多出现N次<br>若是查找的就是转义字符本身，最后要加上ESCAPE</p><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>使用GROUP BY 进行分组<br>将查询的结果按某一列或多列的值分组，值相等的<br>为一组<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">rating,<span class="keyword">COUNT</span>(rating)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> rating</span><br></pre></td></tr></table></figure></p><p>使用GROUP BY子句后，SELECT子句的列名列表中只能出现分组属性和集函数<br>若要想要对分完的组做条件筛选，则需要用Having而不是where<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">rating,<span class="keyword">COUNT</span>(rating)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">film</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> rating</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(rating)&gt;<span class="number">195</span><span class="string">`sql</span></span><br></pre></td></tr></table></figure></p><h3 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h3><p>可以基于关系运算的连接来理解连接查询</p><ul><li><p>广义笛卡尔积（交叉连接）<br>又称非限制连接，它将两个表不加任何约束地组合在一起，也就是将第一个表中的所有记录分别与第二个表的所有记录组成新的记录。（进行广义笛卡尔乘积）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="string">`language`</span>.*,staff.*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line"><span class="string">`language`</span>,staff</span><br></pre></td></tr></table></figure></li><li><p>等值连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  student.Sno,Sname,sex,Cno,Grade</span><br><span class="line"><span class="keyword">FROM</span>     student,sc</span><br><span class="line"><span class="keyword">WHERE</span>  student.sno = sc.sno</span><br></pre></td></tr></table></figure></li></ul><p>任何子句中引用表1和表2中同名属性时，都必须加表名前缀。引用唯一属性名时可以加也可以省略表名前缀<br>也可以用内连接表示等值连接<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">student.Sno,</span><br><span class="line">Sname,</span><br><span class="line">sex,</span><br><span class="line">Cno,</span><br><span class="line">Grade</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> sc <span class="keyword">ON</span> student.sno = sc.sno</span><br></pre></td></tr></table></figure></p><ul><li><p>自然连接<br>是一种特殊的等值链接，在等值连接的基础上，去掉相同的属性</p></li><li><p>自然连接<br>自表的某个属性进行对比<br>例：查一门课的先修课</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  FIRST.Cno，SECOND.Cpno</span><br><span class="line"><span class="keyword">FROM</span>  Course  <span class="keyword">FIRST</span>，Course  <span class="keyword">SECOND</span></span><br><span class="line"><span class="keyword">WHERE</span> FIRST.Cpno = SECOND.Cno；</span><br></pre></td></tr></table></figure></li></ul><p><img src="/upload/pasted-424.png" alt="upload successful"></p><ul><li><p>外连接<br>外连接就是一种不等值连接，相比于等值连接只输出相等部分的连接情况，这种方式会输出所有的情况两边的所有情况，没有的值则用空替代<br>MySQL并不支持</p></li><li><p>左外连接<br>以左边的为基础，除了相等的部分，还会输出左边不符合条件的，空的地方用null装</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">student.Sno,</span><br><span class="line">Sname,</span><br><span class="line">sex,</span><br><span class="line">Cno,</span><br><span class="line">Grade</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student</span><br><span class="line"><span class="keyword">LEFT</span>  <span class="keyword">JOIN</span> sc <span class="keyword">ON</span> student.sno=sc.sno</span><br></pre></td></tr></table></figure></li></ul><p><img src="/upload/pasted-425.png" alt="upload successful"></p><ul><li>右外连接<br>则是以右边的为基础<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">student.Sno,</span><br><span class="line">Sname,</span><br><span class="line">sex,</span><br><span class="line">Cno,</span><br><span class="line">Grade</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student</span><br><span class="line"><span class="keyword">RIGHT</span>  <span class="keyword">JOIN</span> sc <span class="keyword">ON</span> student.sno=sc.sno</span><br></pre></td></tr></table></figure></li></ul><p><img src="/upload/pasted-426.png" alt="upload successful"></p><h3 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h3><p>嵌套查询就是把一些“出处”变成查询结果<br>对于MySQL，嵌套的查询结果要有别名<br>例如 查询与刘晨在一个系学习的学生<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sno,</span><br><span class="line">sname,</span><br><span class="line">sdept</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">s</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sdept <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sdept</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">s</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sname = <span class="string">'刘晨'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">s1.sno,</span><br><span class="line">s1.sname,</span><br><span class="line">s1.sdept</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">s s1,</span><br><span class="line">s s2</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">s1.sdept = s2.sdept</span><br><span class="line"><span class="keyword">AND</span> s2.sname = <span class="string">' 刘晨 '</span></span><br></pre></td></tr></table></figure><p>ANY和ALL<br>any是某一个值，all是所有值，可以大于小于不等于<br>例选择编号01同学的成绩中大于04同学所有科目的成绩的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">SELECT</span><br><span class="line">sname,</span><br><span class="line">cno,</span><br><span class="line">grade</span><br><span class="line">FROM</span><br><span class="line">(</span><br><span class="line">SELECT</span><br><span class="line">student.Sno,</span><br><span class="line">Sname,</span><br><span class="line">sex,</span><br><span class="line">Cno,</span><br><span class="line">Grade</span><br><span class="line">FROM</span><br><span class="line">student</span><br><span class="line">INNER JOIN sc ON student.sno = sc.sno</span><br><span class="line">) AS a</span><br><span class="line">WHERE</span><br><span class="line">grade &gt; ALL (</span><br><span class="line">SELECT</span><br><span class="line">grade</span><br><span class="line">FROM</span><br><span class="line">sc</span><br><span class="line">WHERE</span><br><span class="line">sno = &apos;01&apos;</span><br><span class="line">) </span><br><span class="line">AND sno = &apos;04&apos;</span><br></pre></td></tr></table></figure></p><p>EXISTS<br>首先要理解这个关键词的运行机制<br>例子：选出选了课程1001的人<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">student <span class="keyword">as</span> a</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">EXISTS</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">sc</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sno = a.sno</span><br><span class="line"><span class="keyword">AND</span> cno = <span class="string">'1001'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>使用exist，会对where前面的主查询语句进行逐一校验，对于前面的某一条记录，如果能使exist后的查询语句有返回值（不是空），那么此时exist判定就是true，对于主查询，当前这一条就会作为结果，如果不符合，就不会被作为结果</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据库SQL部分复习（1）【关系模型，关系运算】</title>
      <link href="/2019/07/16/%E5%BA%93SQL%E9%83%A8%E5%88%86%E5%A4%8D%E4%B9%A0/"/>
      <url>/2019/07/16/%E5%BA%93SQL%E9%83%A8%E5%88%86%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p><img src="/upload/pasted-429.png" width="70%"></p><a id="more"></a><hr><h1 id="实体联系模型（E-R）"><a href="#实体联系模型（E-R）" class="headerlink" title="实体联系模型（E-R）"></a>实体联系模型（E-R）</h1><p>实体型之间的联系：一对一联系（１：１）、一对多联系（１：N）、   多对多联系（Ｍ：Ｎ）<br>  例： 假设一个学生可选多门课程，而一门课程又有多个学生选修，每个学生每选一门课只有一个成绩， 一个教师只能讲一门课程，一门课程也可有多个教师讲授，一门课使用多本参考书。画出E－R图。</p><p><img src="/upload/pasted-393.png" alt="upload successful"></p><h1 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h1><p>在用户观点下，关系模型中数据的逻辑结构是一张二维表，它由行和列组成。</p><p><img src="/upload/pasted-392.png" alt="upload successful"><br>关系数据模型的数据结构</p><ul><li>关系（Relation）<br>通常指的是一张表</li><li>元组（Tuple）<br>表中的一行即为一个元组</li><li>属性(attribute)<br>一列即为一个属性</li><li>主码（key）<br>表中的某一个属性组，可以唯一确定一个元组</li><li>域（Domain）<br>属性的取值范围</li><li>分量<br>元组中的一个属性值<h1 id="数据库的三级模式结构"><a href="#数据库的三级模式结构" class="headerlink" title="数据库的三级模式结构"></a>数据库的三级模式结构</h1><h2 id="模式（Schema）"><a href="#模式（Schema）" class="headerlink" title="模式（Schema）"></a>模式（Schema）</h2></li></ul><p><img src="/upload/pasted-394.png" alt="upload successful"><br>模式（也称逻辑模式）<br>数据库中全体数据的逻辑结构和特征的描述<br>所有用户的公共数据视图，综合了所有用户的需求<br>一个数据库只有一个模式<br>模式的地位：是数据库系统模式结构的中间层<br>与数据的物理存储细节和硬件环境无关<br>与具体的应用程序、开发工具及高级程序设计语言无关<br>模式的定义：<br>数据的逻辑结构（数据项的名字、类型、取值范围等）<br>数据之间的联系<br>数据有关的安全性、完整性要求</p><h3 id="外模式-External-Schema"><a href="#外模式-External-Schema" class="headerlink" title="外模式(External Schema)"></a>外模式(External Schema)</h3><p>外模式（也称子模式或用户模式）<br>数据库用户（包括应用程序员和最终用户）使用的局部数据的逻辑结构和特征的描述<br>数据库用户的数据视图，是与某一应用有关的数据的逻辑表示<br>模式与外模式的关系：一对多<br>通常是模式的子集；一个数据库可以有多个外模式<br>外模式与应用的关系：一对多<br>同一外模式可以为某一用户的多个应用系统所使用，<br>但一个应用程序只能使用一个外模式<br>外模式是保证数据库安全性的一个有力措施<br>每个用户只能看见和访问所对应的外模式中的数据</p><h3 id="内模式（Internal-Schema）"><a href="#内模式（Internal-Schema）" class="headerlink" title="内模式（Internal Schema）"></a>内模式（Internal Schema）</h3><p>是数据物理结构和存储方式的描述<br>是数据在数据库内部的表示方式<br>记录的存储方式（顺序存储，按照B树结构存储，按hash方法存储）/ 索引的组织方式 / 数据是否压缩存储 / 数据是否加密 / 数据存储记录结构的规定<br>一个数据库只有一个内模式</p><h1 id="关系模型和关系"><a href="#关系模型和关系" class="headerlink" title="关系模型和关系"></a>关系模型和关系</h1><p>关系模型的数据结构非常简单，只包含单一的数据结构—-关系。在关系模型中，实体和实体间的各种联系都用关系表示。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li>域（Domain）<br>一组具有相同数据类型的值的集合</li><li>笛卡尔积（Cartesian Product）<br><img src="/upload/pasted-395.png" alt="upload successful"></li></ul><p><img src="/upload/pasted-396.png" alt="upload successful"><br>笛卡尔积的每一个结果(d1,d2,d3,d4)被称为元组（Tuple）;<br>笛卡尔积的每一个结果中的具体的值di叫做一个分量（Component）<br>笛卡尔积做出的结果的元组数是基数（Cardinal number）</p><ul><li>关系<br><img src="/upload/pasted-397.png" alt="upload successful"></li><li>属性<br>每列的名字</li><li>码<ul><li>候选码（Candidate key）<br>若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选码<br>在最简单的情况下，候选码只包含一个属性。<br>在最极端的情况下，关系模式的所有属性组是这个关系模式的候选码，称为全码（All-key）</li><li>主码<br>若一个关系有多个候选码，则选定其中一个为主码（Primary key）<br>侯选码的诸属性称为主属性（Prime attribute）。<br>不包含在任何侯选码中的属性称为非码属性（Non-key attribute） </li></ul></li></ul><h2 id="三类关系"><a href="#三类关系" class="headerlink" title="三类关系"></a>三类关系</h2><p><img src="/upload/pasted-398.png" alt="upload successful"></p><h2 id="关系模式"><a href="#关系模式" class="headerlink" title="关系模式"></a>关系模式</h2><p><img src="/upload/pasted-399.png" alt="upload successful"></p><p><img src="/upload/pasted-400.png" alt="upload successful"></p><h2 id="关系的基本运算"><a href="#关系的基本运算" class="headerlink" title="关系的基本运算"></a>关系的基本运算</h2><p>设两个关系R,S：有相同的目n，相应的属性取自同一个域</p><ul><li>选择</li></ul><p><img src="/upload/pasted-406.png" alt="upload successful"></p><p><img src="/upload/pasted-407.png" alt="upload successful"></p><ul><li>投影</li></ul><p><img src="/upload/pasted-408.png" alt="upload successful"></p><ul><li>并<br>R∪S = { t|t Î R∨t ÎS }</li></ul><p><img src="/upload/pasted-402.png" alt="upload successful"></p><ul><li>差<br>R -S = { t|tÎR∧tÏS }<br><img src="/upload/pasted-403.png" alt="upload successful"></li><li>笛卡尔积</li></ul><p><img src="/upload/pasted-404.png" alt="upload successful"></p><p><img src="/upload/pasted-405.png" alt="upload successful"></p><ul><li>交<br>R∩S = { t|t Î R∧t ÎS }<br>R∩S = R –(R-S）</li><li>连接<br><img src="/upload/pasted-409.png" alt="upload successful"><br><img src="/upload/pasted-410.png" alt="upload successful"><br>有两类连接，包括等值连接和自然连接<br>等值连接<br><img src="/upload/pasted-411.png" alt="upload successful"><br>自然连接<br><img src="/upload/pasted-412.png" alt="upload successful"><br>相当于是一种合并<br><img src="/upload/pasted-413.png" alt="upload successful"></li></ul><h2 id="实体完整性（Entity-Integrity）"><a href="#实体完整性（Entity-Integrity）" class="headerlink" title="实体完整性（Entity Integrity）"></a>实体完整性（Entity Integrity）</h2><p>若属性A是基本关系R的主属性，则属性A不能取空值</p><h2 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h2><p>设F是基本关系R的一个或一组属性，但不是关系R的码。如果F与基本关系S的主码Ks相对应，则称F是基本关系R的外码，基本关系R称为参照关系（Referencing Relation）<br>基本关系S称为被参照关系（Reference Relation）或目标关系（Target  Relation）<br>若属性（或属性组）F是基本关系R的外码<br>它与基本关系S的主码Ks相对应（基本关<br>系R和S不一定是不同的关系），则对<br>于R中每个元组在F上的值必须为：<br>· 或者取空值（F的每个属性值均为空值）<br>· 或者等于S中某个元组的主码值。</p><p><img src="/upload/pasted-401.png" alt="upload successful"><br>用人话来说，就是外键不能是自己造出来的</p><h2 id="关系代数运算题目实例"><a href="#关系代数运算题目实例" class="headerlink" title="关系代数运算题目实例"></a>关系代数运算题目实例</h2><p>设教学数据库有3个关系<br>学生关系 S（Sno，Sname，age，sex）<br>成绩关系 SC（Sno，Cno，grade）<br>课程关系 C（Cno，Cname，teacher）</p><ol><li>LIU老师所教授课程的课程号，课程名<br>∏CNO,CNAME(σTNAME=‘LIU’ （C））</li><li>检索年龄大于23岁的男学生的学号和姓名<br>∏SNO,SNAME（ σ AGE&gt;23 ∧ SEX=‘M’（S））</li><li>检索学号为S3学生所学课程的课程名与任课老师名<br> ∏CNAME,TNAME（ σ SNO=‘S3’（SC）∞(C)）</li><li>检索至少选修LIU老师所教授课程中一门课的女学生姓名<br>  ∏SNAME(σSEX=‘F’(S)∞SC∞σTNAME=‘LIU’(C))</li><li>检索wang同学不学课程的课程号<br> ∏CNO(C)-∏CNO(σSNAME=‘WANG’(S)∞SC)</li><li>检索至少选修两门课的学生学号<br>∏1(σ1=4 ∧ 2!=5(SC × SC))</li><li>检索全部学生都选修的课程的课程号和课程名<br> ∏CNO,CNAME,SNO(C ∞SC) ÷ ∏SNO(S)</li><li>检索选修课程包含LIU老师所教授课程的学生学号<br>∏CNO,SNO(SC) ÷ ∏CNO(σTNAME=‘LIU’(C))</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java多线程学习8（线程池，阻塞队列（BlockingQueue）FutureTask,Callable）</title>
      <link href="/2019/07/12/va-mitple-thread8/"/>
      <url>/2019/07/12/va-mitple-thread8/</url>
      
        <content type="html"><![CDATA[<p><img src="/upload/pasted-428.png" width="70%"></p><a id="more"></a><hr><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2><h3 id="框架简介"><a href="#框架简介" class="headerlink" title="框架简介"></a>框架简介</h3><p><img src="/upload/pasted-367.png" alt="upload successful"><br>而具体说来，Executor是一个接口，对于这个接口，API文档是这样描述的。</p><blockquote><p>An object that executes submitted Runnable tasks. This interface provides a way of decoupling task submission from the mechanics of how each task will be run, including details of thread use, scheduling, etc. An Executor is normally used instead of explicitly creating threads.</p></blockquote><p>第一句话强调了这个的用法就是提交任务，并通过Executor来运行，可以用Executor来替代显示的调用Thread，把实现任务的细节封装。<br>对于该接口，可以直接在调用线程运行任务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DirectExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    r.run();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一般则是另起线程运行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPerTaskExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也可以构造一个组件化的Executor,把任务的执行序列化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前类继承一个Executor</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">SerialExecutor</span> <span class="keyword">implements</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Queue&lt;Runnable&gt; tasks = <span class="keyword">new</span> ArrayDeque&lt;Runnable&gt;();</span><br><span class="line">   <span class="keyword">final</span> Executor executor;</span><br><span class="line">   Runnable active;</span><br><span class="line"></span><br><span class="line">   SerialExecutor(Executor executor) &#123;</span><br><span class="line">     <span class="keyword">this</span>.executor = executor;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(<span class="keyword">final</span> Runnable r)</span> </span>&#123;</span><br><span class="line">     tasks.offer(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">           r.run();</span><br><span class="line">         &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           scheduleNext();</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="keyword">if</span> (active == <span class="keyword">null</span>) &#123;</span><br><span class="line">       scheduleNext();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">scheduleNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> ((active = tasks.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">       executor.execute(active);</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>说来说去，Executor不过是提供了一个接口，一种线程服务的思路，具体的线程复杂操作还是要看他的各个实现类<br>和继承接口</p><p><img src="/upload/pasted-368.png" alt="upload successful"><br>这才是整个Executor的体系框架</p><h2 id="BlockingQueue（阻塞队列）"><a href="#BlockingQueue（阻塞队列）" class="headerlink" title="BlockingQueue（阻塞队列）"></a>BlockingQueue（阻塞队列）</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>所谓阻塞队列，就是比一般队列多了两个操作的队列</p><p><img src="/upload/pasted-370.png" alt="upload successful"></p><p><img src="/upload/pasted-371.png" alt="upload successful"></p><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><h3 id="七个属性"><a href="#七个属性" class="headerlink" title="七个属性"></a>七个属性</h3><p> 结合自已以前实现的一个<a href="https://www.junglezero.top/2019/04/02/%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/">线程池</a>，对于其大概的属性已经有了初步了解。<br> 从ThreadPoolExecutor的构造函数开始看起，有四个重载的构造函数，找到其中参数最多的那个</p><p><img src="/upload/pasted-369.png" alt="upload successful"><br>和以前自己的实现的思路基本差不多：<br>核心线程数量、最大线程数量、多余线程存活时间（相比于核心线程多出来的线程在空闲时的存活时间）、时间单位、任务队列(阻塞队列)、线程工厂方法、拒绝策略</p><p>可以用以下的测试理解这几个属性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> TestMain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor= (ThreadPoolExecutor) buildThreadPool();</span><br><span class="line">        <span class="keyword">int</span> activeCount=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> queueSize=-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//线程池执行一个任务（Runable）</span></span><br><span class="line">        threadPoolExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                DoingJobs(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程池执行两个任务（Runable）</span></span><br><span class="line">        threadPoolExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                DoingJobs(<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//。。。</span></span><br><span class="line">        <span class="comment">//当活跃线程数量发生改变时输出</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (activeCount!=threadPoolExecutor.getActiveCount()||queueSize!=threadPoolExecutor.getQueue().size())&#123;</span><br><span class="line">                System.out.println(<span class="string">"线程池中活跃线程数量："</span>+threadPoolExecutor.getActiveCount());</span><br><span class="line">                System.out.println(<span class="string">"核心线程数量（固定的）："</span>+threadPoolExecutor.getCorePoolSize());</span><br><span class="line">                System.out.println(<span class="string">"任务队列中等待执行的任务数量："</span>+threadPoolExecutor.getQueue().size());</span><br><span class="line">                activeCount=threadPoolExecutor.getActiveCount();</span><br><span class="line">                queueSize=threadPoolExecutor.getQueue().size();</span><br><span class="line">                System.out.println(<span class="string">"================================"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">buildThreadPool</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//核心线程数为1，最大线程池为2，存活时间为10s，阻塞队列（任务队列）的大小为1</span></span><br><span class="line">        ExecutorService executorService=<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">1</span>), <span class="keyword">new</span> ThreadFactory() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">                Thread t=<span class="keyword">new</span> Thread(r);</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,<span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy());</span><br><span class="line">        System.out.println(<span class="string">"线程池创建成功！"</span>);</span><br><span class="line">        <span class="keyword">return</span> executorService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用Sleep来模拟线程运行</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">DoingJobs</span><span class="params">(<span class="keyword">long</span> seconds)</span></span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"正在执行任务"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(seconds);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当任务为1个时</p><p><img src="/upload/pasted-373.png" alt="upload successful"></p><p>当任务为2时</p><p><img src="/upload/pasted-372.png" alt="upload successful"><br>可以发现，当任务为2时，线程池并没有创建新的线程，因为任务可以在队列中等待</p><p>当任务为3时，此时把测试方法中的活跃线程数量改为线程池大小（线程中线程的数量）</p><p><img src="/upload/pasted-374.png" alt="upload successful"><br>可以发现，当任务队列慢的时候，再有新的任务加入，线程池就会根据最大线程数量创建新的线程共同执行任务，当任务队列中没有任务时，过了存回时间，多创建出的线程就会被销毁。</p><p>当任务有4个时</p><p><img src="/upload/pasted-375.png" alt="upload successful"><br>此时多出一个任务，无法进入阻塞队列，也无法执行，拒绝策略生效。</p><h2 id="线程池的关闭"><a href="#线程池的关闭" class="headerlink" title="线程池的关闭"></a>线程池的关闭</h2><p>线程池的关闭涉及到三个方法</p><p><img src="/upload/pasted-376.png" alt="upload successful"></p><p><img src="/upload/pasted-377.png" alt="upload successful"></p><p><img src="/upload/pasted-378.png" alt="upload successful"><br>通过测试可以发现<br>shutdown方法：平滑的关闭ExecutorService，当此方法被调用时，ExecutorService停止接收新的任务并且等待已经提交的任务（包含提交正在执行和提交未执行）执行完成。<br>当所有已提交任务执行完毕，线程池即被关闭。<br>awaitTermination方法：接收timeout和unit两个参数，用于设定超时时间及单位。当等待超过设定时间时，会监测ExecutorService是否已经关闭，<br>若关闭则返回true，否则返回false。一般情况下会和shutdown方法组合使用。<br>shutdown调用后，不可以再submit新的task，已经submit的将继续执行。<br>shutdownNow试图停止当前正执行的task，并返回尚未执行的task的list</p><p>因此最好的关闭线程池的方式是shutdown+awaitTermination</p><h2 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h2><p>Executors是一个工厂类<br>其中包括了许多关于线程池及Executors框架相关的创建方法<br>毕竟拿七个参数创建一个线程池太复杂了<br><img src="/upload/pasted-379.png" alt="upload successful"></p><h3 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h3><blockquote><p>Creates a thread pool that creates new threads as needed, but will reuse previously constructed threads when they are available. These pools will typically improve the performance of programs that execute many short-lived asynchronous tasks. Calls to execute will reuse previously constructed threads if available. If no existing thread is available, a new thread will be created and added to the pool. Threads that have not been used for sixty seconds are terminated and removed from the cache. Thus, a pool that remains idle for long enough will not consume any resources. Note that pools with similar properties but different details (for example, timeout parameters) may be created using ThreadPoolExecutor constructors.</p></blockquote><p>这种线程池的特点就是按照需求创建线程以处理更多的耗时短的异步任务<br>看其具体实现就可以知道<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                  <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，这个线程池一开始核心线程就是0，最大线程数量却相当于没有限制，存活时间为1分钟，这就很好的印证了按需分配创建线程的思路。而关键还是在这个阻塞队列上<br>SynchronousQueue是一种很特殊的阻塞队列，其中每个 put 必须等待一个 take，否则会进入wait状态反之亦然。同步队列没有任何内部容量，甚至连一个队列的容量都没有。<br>使用完成后不需要显示的调用shotdown<br>注意：仅适合周期短的多任务，因为创建线程的数量是没用限制的</p><h3 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                  <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顾名思义，这是一种固定线程数量的线程池，不会额外去创建，阻塞队列采用LinkedBlockingQueue,是以链表为内核实现的阻塞队列，默认大小为Integar.Max<br>使用完成后需要shutdown</p><h3 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">    (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                            <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                            <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br></pre></td></tr></table></figure><p>这个实际上就是newFixedThreadPool线程数量设置为1的时候</p><h3 id="newWorkStealingPool"><a href="#newWorkStealingPool" class="headerlink" title="newWorkStealingPool"></a>newWorkStealingPool</h3><p>这是在1.8新出的一种线程池服务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">        (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种服务是根据cpu个数创建的ForkJoinPool,根据前面讲的，ForkJoinPool中执行的是ForkJoinTask，Runable是不行的<br>看源码可以知道，传入Runable以后，会执行一个内部的转换</p><p>这种线程数量的确定和创建时是根据电脑根据cpu个数创建的（等于）<br>工作窃取概念：所谓工作窃取，指的是闲置的线程去处理本不属于它的任务。<br>每个处理器核，都有一个队列存储着需要完成的任务。对于多核的机器来说，当一个核对应的任务处理完毕后，就可以去帮助其他的核处理任务。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    ForkJoinTask&lt;?&gt; job;</span><br><span class="line">    <span class="keyword">if</span> (task <span class="keyword">instanceof</span> ForkJoinTask&lt;?&gt;) <span class="comment">// avoid re-wrap</span></span><br><span class="line">        job = (ForkJoinTask&lt;?&gt;) task;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        job = <span class="keyword">new</span> ForkJoinTask.RunnableExecuteAction(task);</span><br><span class="line">    externalSubmit(job);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在用Callable来执行（线程的第三种实现方法）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorsTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService =Executors.newWorkStealingPool();</span><br><span class="line">        System.out.println(executorService.toString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">         <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">         <span class="comment">//这里可以先把Callable当成是有返回值的Runable</span></span><br><span class="line">        List&lt;Callable&lt;String&gt;&gt; callables=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> ( ;i&lt;<span class="number">20</span>;i++)&#123;</span><br><span class="line">            Callable&lt;String&gt; callable=<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="comment">//call方法就相当于Run方法</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName());</span><br><span class="line">                    sleep(<span class="number">2</span>);</span><br><span class="line">                    <span class="comment">//可以有返回值</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"任务被"</span>+Thread.currentThread().getName();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">             callables.add(callable);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//批量运行，且将返回运行结果Future</span></span><br><span class="line">            List&lt;Future&lt;String&gt;&gt; futures=executorService.invokeAll(callables);</span><br><span class="line">            <span class="comment">//若是没有执行完，这里会是堵塞的</span></span><br><span class="line">            <span class="keyword">for</span> (Future f:futures)&#123;</span><br><span class="line">                System.out.println(f);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> seconds)</span></span>&#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           TimeUnit.SECONDS.sleep(seconds);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><p><img src="/upload/pasted-381.png" alt="upload successful"><br>可以发现，这种线程池服务也是自动退出的</p><h3 id="newScheduledThreadPool"><a href="#newScheduledThreadPool" class="headerlink" title="newScheduledThreadPool"></a>newScheduledThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE,</span><br><span class="line">          DEFAULT_KEEPALIVE_MILLIS, MILLISECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor。它主要用来在给定的延迟之后运行任务，或者定期执行任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledFuture;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledThreadPoolExecutorDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个实现了Runable的时间任务类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String id;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TimerTask</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        ScheduledExecutorService ses = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//调用scheduleAtFixedRate来进行周期执行，拿第一个来说，开始时延是200ms，周期为1000ms</span></span><br><span class="line">        ScheduledFuture sfa = ses.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask(<span class="string">"a"</span>), <span class="number">200</span>,</span><br><span class="line">                                                    <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        ScheduledFuture sfb = ses.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask(<span class="string">"b"</span>), <span class="number">400</span>, </span><br><span class="line">                                                    <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        ScheduledFuture sfc = ses.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask(<span class="string">"c"</span>), <span class="number">600</span>,</span><br><span class="line">                                                    <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        ScheduledFuture sfd = ses.scheduleAtFixedRate(<span class="keyword">new</span> TimerTask(<span class="string">"d"</span>), <span class="number">800</span>, </span><br><span class="line">                                                    <span class="number">1000</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        sfa.cancel(<span class="keyword">true</span>);</span><br><span class="line">        Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        ses.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="线程运行时发生错误的处理"><a href="#线程运行时发生错误的处理" class="headerlink" title="线程运行时发生错误的处理"></a>线程运行时发生错误的处理</h2><p>一般情况下，可以<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread t=<span class="keyword">new</span> Thread();</span><br><span class="line">t.setUncaughtExceptionHandler(<span class="keyword">new</span> Thread.UncaughtExceptionHandler() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uncaughtException</span><span class="params">(Thread t, Throwable e)</span> </span>&#123;</span><br><span class="line">        System.out.println(t.getName()+<span class="string">"运行时发生错误~！"</span>);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>如果线程的实现不是自己定义的<br>如果是=自己定义的，则可以定义内部方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Error</span><span class="params">(Throwable e)</span></span>&#123;</span><br><span class="line">     System.out.println(<span class="string">"当前线程发生错误"</span>);</span><br><span class="line">     e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="拒绝策略细节"><a href="#拒绝策略细节" class="headerlink" title="拒绝策略细节"></a>拒绝策略细节</h2><h3 id="ThreadPoolExecutor-AbortPolicy"><a href="#ThreadPoolExecutor-AbortPolicy" class="headerlink" title="ThreadPoolExecutor.AbortPolicy()"></a>ThreadPoolExecutor.AbortPolicy()</h3><p>这个策略中，不能执行且不能进入阻塞队列的任务会直接被抛出异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p><img src="/upload/pasted-382.png" alt="upload successful"></p><h3 id="new-ThreadPoolExecutor-DiscardPolicy"><a href="#new-ThreadPoolExecutor-DiscardPolicy" class="headerlink" title="new ThreadPoolExecutor.DiscardPolicy()"></a>new ThreadPoolExecutor.DiscardPolicy()</h3><p>这个拒绝策略则不会做出任何事</p><h3 id="ThreadPoolExecutor-CallerRunsPolicy"><a href="#ThreadPoolExecutor-CallerRunsPolicy" class="headerlink" title="ThreadPoolExecutor.CallerRunsPolicy()"></a>ThreadPoolExecutor.CallerRunsPolicy()</h3><p>这个策略会在execute 方法的调用线程中运行被拒绝的任务<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line"></span><br><span class="line">               r.run();</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><p><img src="/upload/pasted-383.png" alt="upload successful"></p><h3 id="ThreadPoolExecutor-DiscardOldestPolicy"><a href="#ThreadPoolExecutor-DiscardOldestPolicy" class="headerlink" title="ThreadPoolExecutor.DiscardOldestPolicy()"></a>ThreadPoolExecutor.DiscardOldestPolicy()</h3><p>这个方法会把阻塞队列的队尾元素去除，然后执行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line"></span><br><span class="line">        e.getQueue().poll();</span><br><span class="line"></span><br><span class="line">        e.execute(r);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="ExecutorService-几个其他方法"><a href="#ExecutorService-几个其他方法" class="headerlink" title="ExecutorService 几个其他方法"></a>ExecutorService 几个其他方法</h2><h3 id="invokeAny"><a href="#invokeAny" class="headerlink" title="invokeAny"></a>invokeAny</h3><p>测试方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">testInvokeAny</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ExecutorService executorService= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    List&lt;Callable&lt;Integer&gt;&gt; callables=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">//创建5个Callable</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">        Callable&lt;Integer&gt; callable= <span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="comment">//先进入随机的sleep</span></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>));</span><br><span class="line">                <span class="comment">//输出语句</span></span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Random().nextInt(<span class="number">3</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//放入集合中</span></span><br><span class="line">        callables.add(callable);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//输出invokeany的结果</span></span><br><span class="line">        System.out.println(executorService.invokeAny(callables));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><p><img src="/upload/pasted-384.png" alt="upload successful"><br>也就是说，运行invokeany，当运行的那一个任务运行完毕后，会取消掉其他正在运行的任务<br>注意：这个方法是一个阻塞方法，也就是说只有选定的某个任务执行完成，才会有返回值，否则会一直陷入阻塞状态<br>另外，该方法的重载方法还可以添加TimeOut,超过TimeOut时间，其他任务取消运行。抛出Timeout异常。</p><h3 id="invokeAll"><a href="#invokeAll" class="headerlink" title="invokeAll"></a>invokeAll</h3><p><img src="/upload/pasted-385.png" alt="upload successful"><br>这个方法也是一个阻塞方法</p><h3 id="submit-Runable"><a href="#submit-Runable" class="headerlink" title="submit(Runable)"></a>submit(Runable)</h3><p><img src="/upload/pasted-386.png" alt="upload successful"><br>这个方法可以返回一个结果值，但是由于Runable没有返回值所以可以手动传入一个值作为返回值（Future）</p><h1 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h1><p>Future是一个接口</p><blockquote><p>A Future represents the result of an asynchronous computation. Methods are provided to check if the computation is complete, to wait for its completion, and to retrieve the result of the computation. The result can only be retrieved using method get when the computation has completed, blocking if necessary until it is ready. Cancellation is performed by the cancel method. Additional methods are provided to determine if the task completed normally or was cancelled. Once a computation has completed, the computation cannot be cancelled. If you would like to use a Future for the sake of cancellability but not provide a usable result, you can declare types of the form Future&lt;?&gt; and return null as a result of the underlying task. </p></blockquote><p>future可以理解为一个票据，表示一个某个任务的结果，我们不是非要等到这个任务执行完毕才能进行别的任务，我们，我们可以在这个任务执行时，先去执行别的任务，等到这个任务执行完毕，再通过future获得任务的结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        Callable&lt;String&gt; longTimeJob=<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"长时工作完成"</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        Callable&lt;String&gt; shotTimeJob=<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"短时工作完成"</span>;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Future&lt;String&gt; res1=executorService.submit(longTimeJob);</span><br><span class="line">        Future&lt;String&gt; res2=executorService.submit(shotTimeJob);</span><br><span class="line">        System.out.println(res1);</span><br><span class="line">        System.out.println(res2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Future的方法"><a href="#Future的方法" class="headerlink" title="Future的方法"></a>Future的方法</h2><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p>Waits if necessary for the computation to complete, and then retrieves its result.<br>也就是说，通过票据Future获得线程的运行结果（Callable），会使线程陷入阻塞（会使调用get方法的线程进入阻塞,和线程池执行任务的线程无关）<br>比如(res1是长时任务的结果)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"主线程！！！！"</span>);</span><br><span class="line">    System.out.println(res1.get());</span><br><span class="line">    System.out.println(<span class="string">"&gt;?&gt;&gt;?&gt;&gt;&gt;?&gt;"</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果输出:</p><p><img src="/upload/pasted-387.png" alt="upload successful"><br>重载方法中，有一个TimeOut的参数，若调用get超时，则调用get方法的线程会抛timeout异常，但是未完成的任务仍然会继续进行。</p><h3 id="isDone"><a href="#isDone" class="headerlink" title="isDone"></a>isDone</h3><p><img src="/upload/pasted-389.png" alt="upload successful"><br>任务完成了，返回true；任务没完成，出现了异常，任务不能再继续做了，返回true，任务在做了，返回false</p><h3 id="cancle"><a href="#cancle" class="headerlink" title="cancle"></a>cancle</h3><p><img src="/upload/pasted-390.png" alt="upload successful"><br>如果取消任务成功则返回true，如果取消任务失败则返回false。参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。</p><h1 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h1><p>FutureTask是Runable和Future的实现类（是Future的唯一实现）<br>所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    ExecutorService executorService= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">    Thread doingLong=<span class="keyword">null</span>;</span><br><span class="line">    FutureTask&lt;String&gt; futureTask=<span class="keyword">new</span> FutureTask&lt;String&gt;(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"任务任务任务"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    executorService.submit(futureTask);</span><br><span class="line">    System.out.println(futureTask.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h1><p>铺垫了这么多，Callable也就很好理解了，</p><p><img src="/upload/pasted-391.png" alt="upload successful"><br>Callable和Runable类似，但是它却可以有返回值</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java多线程学习7（Exchanger,StampedLock,Fork/join,Phaser）</title>
      <link href="/2019/07/09/java-mutiple-threading-7/"/>
      <url>/2019/07/09/java-mutiple-threading-7/</url>
      
        <content type="html"><![CDATA[<p><img src="/upload/pasted-356.png" width="70%"></p><a id="more"></a><hr><h1 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>A synchronization point at which threads can pair and swap elements within pairs. Each thread presents some object on entry to the exchange method, matches with a partner thread, and receives its partner’s object on return. An Exchanger may be viewed as a bidirectional form of a SynchronousQueue. Exchangers may be useful in applications such as genetic algorithms and pipeline designs. </p></blockquote><p>主要内容：提供一个同步点，使一对线程交换数据，可以使用在遗传算法和管道设计上</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><img src="/upload/pasted-351.png" alt="upload successful"><br>简要来说就是调用该方法的线程会进入等待状态，等待其他线程调用，若有其他线程调用，则交换两者数据（把参数中的object传过去，返回传回来的object），注意一个及时性，即使调用该方法后休眠，也不会影响交换，若非特殊情况下的阻断，则调用该方法会一直等下去，<br>若有超过两个线程都调用exchange方法，则先到交换点（先调用方法）的两个线程会交换数据，若第三个线程调用，则会等待第四个线程调用来交换数据</p><h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Exchanger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置交换器</span></span><br><span class="line">        <span class="keyword">final</span> Exchanger&lt;String&gt; exchanger=<span class="keyword">new</span> Exchanger&lt;&gt;();</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"开始运行。"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//模拟为该线程有的数据</span></span><br><span class="line">                    String myData=<span class="string">"123456789"</span>;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"交换之前的数据:"</span>+myData);</span><br><span class="line">                    <span class="comment">//调用交换器的exchange方法，并返回交换的结果（进入交换点等待另一个线程调用该方法）</span></span><br><span class="line">                    String exchangeResult=exchanger.exchange(myData);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"交换之后的数据:"</span>+exchangeResult);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"结束。"</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"开始运行。"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String myData=<span class="string">"987654321"</span>;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"交换之前的数据:"</span>+myData);</span><br><span class="line">                    String exchangeResult=exchanger.exchange(myData);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"交换之后的数据:"</span>+exchangeResult);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"结束。"</span>);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p><img src="/upload/pasted-352.png" alt="upload successful"></p><h1 id="StamperdLock"><a href="#StamperdLock" class="headerlink" title="StamperdLock"></a>StamperdLock</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>这是java1.8新增加的锁（在JUC中），是对ReentrantReadWriteLock锁的一种改进:基于读的乐观锁<br>在Optimistic reading中，即使读线程获取到了读锁，写线程尝试获取写锁也不会阻塞，这相当于对读模式的优化，但是可能会导致数据不一致的问题。所以，当使用Optimistic reading获取到读锁时，必须对获取结果进行校验。<br>注意：StampededLock不支持重入</p><p><img src="/upload/pasted-353.png" alt="upload successful"></p><p>这里有一篇<a href="https://blog.overops.com/java-8-stampedlocks-vs-readwritelocks-and-synchronized/" target="_blank" rel="noopener">文章</a>,在这片文章中，作者讨论了synchronized,StampedLocks,和RWlock的效率对比，可以发现当读线程远多于写线程时，乐观锁的效率是最高的。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>可以使用StampededLock直接替代reentrantreadwritelock<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.StampedLock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StampedLockTest</span>  </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> StampedLock lock=<span class="keyword">new</span> StampedLock();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> List&lt;Long&gt; DATA=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ExecutorService executorService= Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        Runnable readTask=<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (;;)</span><br><span class="line">                    read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Runnable writeTask =<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (;;)</span><br><span class="line">                    write();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(readTask);</span><br><span class="line">        executorService.submit(writeTask);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//悲观式读取</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamped=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamped=lock.readLock();</span><br><span class="line">            <span class="comment">//模拟读取数据</span></span><br><span class="line">            System.out.println(DATA.toString());</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlockRead(stamped);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">long</span> stamp=-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamp=lock.writeLock();</span><br><span class="line">            DATA.add(System.currentTimeMillis());</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而这个锁的改进就是对读加上乐观锁<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> stamped = lock.tryOptimisticRead();</span><br><span class="line">    <span class="keyword">if</span> (lock.validate(stamped)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamped = lock.readLock();</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Fork-join"><a href="#Fork-join" class="headerlink" title="Fork/join"></a>Fork/join</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>Fork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。<br>Fork就是把一个大任务切分为若干子任务并行的执行，Join就是合并这些子任务的执行结果，最后得到这个大任务的结果<br>ForkJoinTask是轻量级的线程形式<br><img src="/upload/pasted-354.png" alt="upload successful"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>一般是使用ForkJoinTask 的继承类RecursiveAction（无返回值）和RecursiveTask（有返回值），并且依附在ForkJoinPool上进行使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForkJoinTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分割任务的最大阈值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_THRSHOLD=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ForkJoinPool forkJoinPool=<span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        <span class="comment">//把ForkJoinTask提交ForkJoinPool进行运行</span></span><br><span class="line">        <span class="comment">//计算范围为0到10</span></span><br><span class="line">        ForkJoinTask&lt;Integer&gt; future=forkJoinPool.submit(<span class="keyword">new</span> ComputeRecursiveTask(<span class="number">0</span>,<span class="number">10</span>));</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer result=<span class="number">0</span>;</span><br><span class="line">            result=future.get();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算的Fork/join线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputeRecursiveTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算的起始和终点</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> start;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> end;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">ComputeRecursiveTask</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Integer <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//当发现起始和终点的相差的小于阈值时</span></span><br><span class="line">            <span class="keyword">if</span> (end-start&lt;=MAX_THRSHOLD)&#123;</span><br><span class="line">                <span class="comment">//直接计算返回结果，这里模拟的的是累加</span></span><br><span class="line">                <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;=end;i++)&#123;</span><br><span class="line">                    result+=i;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//将起始到终点二分，分成两个子部分</span></span><br><span class="line">                <span class="keyword">int</span> middle=(start-end);</span><br><span class="line">                ComputeRecursiveTask leftRecursiveTask=<span class="keyword">new</span> ComputeRecursiveTask(start,middle);</span><br><span class="line">                ComputeRecursiveTask rightRecursiveTask=<span class="keyword">new</span> ComputeRecursiveTask(middle,end);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//调用fork进行执行</span></span><br><span class="line">                leftRecursiveTask.fork();</span><br><span class="line">                rightRecursiveTask.fork();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//最终的结果就是两个join</span></span><br><span class="line">                <span class="keyword">return</span> leftRecursiveTask.join()+rightRecursiveTask.join();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h1><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>文档讲到，这是一个可复用的同步器栅栏，可以理解为时CyclicBarrier和CountDownLatch的一个升级版<br>Phaser类机制是在每一步结束的位置对线程进行同步，当所有的线程都完成了这一步，才能进行下一步。<br>用来解决控制多个线程分阶段共同完成任务的情景问题。<br>当有并发任务并且需要分解成几步执行的时候，这种机制就非常适合。<br>CyclicBarrier CountDownLatch 只能在构造时指定参与量，而phaser可以动态的增减参与量<br>且Phaser支持父子结构，可以用在fork/join框架中</p><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><p><img src="/upload/pasted-358.png" alt="upload successful"></p><h2 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h2><p>API中给到的几个使用例子<br>可以替代CountDownLatch来执行只需运行一次的线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">runTasks</span><span class="params">(List&lt;Runnable&gt; tasks)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Phaser phaser = <span class="keyword">new</span> Phaser(<span class="number">1</span>); <span class="comment">// 参数为1，表示phaser计数为1</span></span><br><span class="line">   <span class="comment">// 创建并开始线程</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">final</span> Runnable task : tasks) &#123;</span><br><span class="line">   <span class="comment">//phaser添加一个新的运行部分</span></span><br><span class="line">     phaser.register();</span><br><span class="line">     <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         phaser.arriveAndAwaitAdvance(); <span class="comment">// await all creation</span></span><br><span class="line">         task.run();</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;.start();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//允许线程开始执行并在运行结束后注销（一次执行），不等着其他线程</span></span><br><span class="line">   phaser.arriveAndDeregister();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>重复执行一系列线程：重写onAdvance方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startTasks</span><span class="params">(List&lt;Runnable&gt; tasks, <span class="keyword">final</span> <span class="keyword">int</span> iterations)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Phaser phaser = <span class="keyword">new</span> Phaser() &#123;</span><br><span class="line">   <span class="comment">//重写该方法，来确定phaser的终止条件（返回true 表示终止）</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onAdvance</span><span class="params">(<span class="keyword">int</span> phase, <span class="keyword">int</span> registeredParties)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> phase &gt;= iterations || registeredParties == <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">   phaser.register();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">final</span> Runnable task : tasks) &#123;</span><br><span class="line">     phaser.register();</span><br><span class="line">     <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         <span class="keyword">do</span> &#123;</span><br><span class="line">           task.run();</span><br><span class="line">           phaser.arriveAndAwaitAdvance();</span><br><span class="line">         &#125; <span class="keyword">while</span> (!phaser.isTerminated());</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;.start();</span><br><span class="line">   &#125;</span><br><span class="line">   phaser.arriveAndDeregister(); <span class="comment">// deregister self, don't wait</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>自己写的例子：模仿CyclicBarrier<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Phaser;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhaserTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Phaser phaser=<span class="keyword">new</span> Phaser();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            Task a=<span class="keyword">new</span> Task(phaser);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将主线程运行块加入phaser</span></span><br><span class="line">        phaser.register();</span><br><span class="line">        phaser.arriveAndAwaitAdvance();</span><br><span class="line">        System.out.println(<span class="string">"全部线程全部完成"</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Phaser taskPhaser;</span><br><span class="line">        Task(Phaser phaser)&#123;</span><br><span class="line">            taskPhaser=phaser;</span><br><span class="line">            <span class="comment">//新添加一个运行块</span></span><br><span class="line">            phaser.register();</span><br><span class="line">            <span class="comment">//直接运行</span></span><br><span class="line">            start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"正在工作中》》》》》"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//线程到达并等待运行</span></span><br><span class="line">            taskPhaser.arriveAndAwaitAdvance();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><img src="/upload/pasted-359.png" alt="upload successful"></p><p>多个线程分阶段共同完成任务:完成铁人三项<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Phaser;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhaserTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Phaser phaser=<span class="keyword">new</span> Phaser(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Athletes(i,phaser).start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Athletes</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> num;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Phaser phaser;</span><br><span class="line"></span><br><span class="line">        Athletes(<span class="keyword">int</span> num,Phaser phaser)&#123;</span><br><span class="line">            <span class="keyword">this</span>.num=num;</span><br><span class="line">            <span class="keyword">this</span>.phaser=phaser;</span><br><span class="line">            <span class="comment">//phaser.register();</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"No."</span>+num+<span class="string">"开始跑了"</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>));</span><br><span class="line">                System.out.println(<span class="string">"No."</span>+num+<span class="string">"跑到头了"</span>);</span><br><span class="line"></span><br><span class="line">                phaser.arriveAndAwaitAdvance();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"No."</span>+num+<span class="string">"开始游泳了"</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>));</span><br><span class="line">                System.out.println(<span class="string">"No."</span>+num+<span class="string">"游泳到头了"</span>);</span><br><span class="line"></span><br><span class="line">                phaser.arriveAndAwaitAdvance();</span><br><span class="line"></span><br><span class="line">                System.out.println(<span class="string">"No."</span>+num+<span class="string">"开始骑自行车了"</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">5</span>));</span><br><span class="line">                System.out.println(<span class="string">"No."</span>+num+<span class="string">"骑自行车到头了"</span>);</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p><img src="/upload/pasted-360.png" alt="upload successful"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java语言基础知识和其他应该知道的东西</title>
      <link href="/2019/07/06/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2019/07/06/Java%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<p># </p><h2 id="ArrayList和Linkedlist区别"><a href="#ArrayList和Linkedlist区别" class="headerlink" title="ArrayList和Linkedlist区别"></a>ArrayList和Linkedlist区别</h2><p>1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。<br>2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。<br>3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。<br>4．对ArrayList和LinkedList而言，在列表末尾增加一个元素所花的开销都是固定的。对ArrayList而言，主要是在内部数组中增加一项，指向所添加的元素，偶尔可能会导致对数组重新进行分配；而对LinkedList而言，这个开销是统一的，分配一个内部Entry对象。<br>5．在ArrayList的中间插入或删除一个元素意味着这个列表中剩余的元素都会被移动；而在LinkedList的中间插入或删除一个元素的开销是固定的。<br>6．LinkedList不支持高效的随机元素访问。<br>7．ArrayList的空间浪费主要体现在在list列表的结尾预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗相当的空间 </p><h2 id="java方法“值传递”的理解"><a href="#java方法“值传递”的理解" class="headerlink" title="java方法“值传递”的理解"></a>java方法“值传递”的理解</h2><p>java中的数据类型有基本类型和引用类型，他们都是值传递方式。基本类型传递的是它的值，因此方法中的改变参数的值，不会影响方法外。引用类型传递的是一个地址，因为引用类型在生成对象实例时，里面的值是一个地址，指向了对象实例。在传值的时候实际上传的是一个地址，他们指向了同一块地址，所以在方法内的改变会影响方法外的参数。 这里比较乱人心的是包装类型，因为包装类型也是引用类型，这里应该就是和包装类型的实现有关了，在包装类型中，比如Integer a=1，有一个自动装箱的操作。其实a=1，如果现在令a=2，不会令2覆盖1（即1本身是不会变的），真正改变的是a被赋给了一个新地址，这个地址指向了2。因此方法内的改变包装类型的值就相当于改变了形参里面的地址，相当于重新new了一遍。而方法外面的实参仍旧指向含1的那个地址，一次方法内的改变不会影响方法外的实参。 </p><p><img src="/upload/pasted-320.png" alt="upload successful"></p><h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><p>Volatile：与锁相比，Volatile 变量是一种非常简单但同时又非常脆弱的同步机制，它在某些情况下将提供优于锁的性能和伸缩性。如果严格遵循 volatile 的使用条件 —— 即变量真正独立于其他变量和自己以前的值 —— 在某些情况下可以使用 volatile 代替 synchronized 来简化代码。然而，使用 volatile 的代码往往比使用锁的代码更加容易出错。<br>只能在有限的一些情形下使用 volatile 变量替代锁。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：</p><ul><li>（1）对变量的写操作不依赖于当前值。</li><li>（2）该变量没有包含在具有其他变量的不变式中。<br>实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。<br>第一个条件的限制使 volatile 变量不能用作线程安全计数器。虽然增量操作（x++）看上去类似一个单独操作，实际上它是一个由读取－修改－写入操作序列组成的组合操作，必须以原子方式执行，而 volatile 不能提供必须的原子特性。实现正确的操作需要使 x 的值在操作期间保持不变，而 volatile 变量无法实现这点。 </li></ul><h2 id="数组复制"><a href="#数组复制" class="headerlink" title="数组复制"></a>数组复制</h2><p>1.for循环<br>2.System.arraycopy<br>3.Arrays.copyOf<br>4.clone</p><h2 id="类的加载顺序"><a href="#类的加载顺序" class="headerlink" title="类的加载顺序"></a>类的加载顺序</h2><p>(1) 父类静态代码块(包括静态初始化块，静态属性，但不包括静态方法)<br>(2) 子类静态代码块(包括静态初始化块，静态属性，但不包括静态方法 )<br>(3) 父类非静态代码块( 包括非静态初始化块，非静态属性 )<br>(4) 父类构造函数<br>(5) 子类非静态代码块 ( 包括非静态初始化块，非静态属性 )<br>(6) 子类构造函数</p><h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p>1、不管有没有出现异常，finally块中代码都会执行；<br>2、当try和catch中有return时，finally仍然会执行；<br>3、finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的值保存起来，不管finally中的代码怎么样，返回的值都不会改变，仍然是之前保存的值），所以函数返回值是在finally执行前确定的；<br>4、finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。</p><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="registerNatives"><a href="#registerNatives" class="headerlink" title="registerNatives()"></a>registerNatives()</h3><p>向JVM注册native方法<br>在类初始化的时候，会依次从父类到本类的类变量及类初始化块中的类变量及方法按照定义顺序放到 &lt; clinit&gt;方法中，这样可以保证父类的类变量及方法的初始化一定先于子类。所以当子类调用相应 native方法，比如计算 hashCode时，一定可以保证能够调用到 JVM的 native方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">registerNatives</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="keyword">static</span> &#123;</span><br><span class="line">       registerNatives();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h3 id="getClass"><a href="#getClass" class="headerlink" title="getClass()"></a>getClass()</h3><p>类加载的第一阶段类的加载就是将 .class文件加载到内存，并生成一个 java.lang.Class对象的过程。 getClass()方法就是获取这个对象，这是当前类的对象在运行时类的所有信息的集合。这个方法是反射三种方式之一。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> Class&lt;?&gt; getClass();</span><br></pre></td></tr></table></figure></p><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h3><p>这个方法返回一个int类型的hash值<br>在 Java应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改；<br>如果两个对象 x.equals(y) 方法返回 true，则 x、 y这两个对象的 hashCode必须相等。<br>如果两个对象 x.equals(y) 方法返回 false，则 x、 y这两个对象的 hashCode可以相等也可以不等。但是，为不相等的对象生成不同整数结果可以提高哈希表的性能。<br>默认的 hashCode是将内存地址转换为的 hash值，重写过后就是自定义的计算方式；也可以通过 System.identityHashCode(Object)来返回原本的 hashCode。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>计算 hashCode使用了31作为基础乘数，为什么使用31呢？result *31=(result&lt;&lt;5)-result。 JVM底层可以自动做优化为位运算，效率很高；还有因为 31计算的 hashCode冲突较少，利于 hash桶位的分布。</p><h3 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h3><p>用于比较当前对象与目标对象是否相等，默认是比较引用是否指向同一对象。为 public方法，子类可重写。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>重写equals的意义：<br>因为如果不重写equals方法，当将自定义对象放到 map或者 set中时；如果这时两个对象的 hashCode相同，就会调用 equals方法进行比较，这个时候会调用 Object中默认的 equals方法，而默认的 equals方法只是比较了两个对象的引用是否指向了同一个对象，显然大多数时候都不会指向，这样就会将重复对象存入 map或者 set中。这就破坏了 map与 set不能存储重复对象的特性，会造成内存溢出。</p><h3 id="clone"><a href="#clone" class="headerlink" title="clone()"></a>clone()</h3><p>这是一个 protected方法，提供给子类重写。但需要实现 Cloneable接口，这是一个标记接口，如果没有实现，当调用 object.clone()方法，会抛出 CloneNotSupportedException<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">native</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException</span>;</span><br></pre></td></tr></table></figure></p><p>两个概念——<br>浅拷贝：创建一个新对象，然后将当前对象的非静态字段复制到该对象，如果字段类型是值类型（基本类型）的，那么对该字段进行复制；如果字段是引用类型的，则只复制该字段的引用而不复制引用指向的对象。此时新对象里面的引用类型字段相当于是原始对象里面引用类型字段的一个副本，原始对象与新对象里面的引用字段指向的是同一个对象。<br>说白了就是clone一个对象，将会创建一个新的对象，而对于其内部属性，比如一个String的引用类型，克隆对象和被克隆对象指向的是一个引用。换言之，如果克隆对象的属性发生了改变，则原对象也会发生改变<br>而深拷贝则是一个完全不同的拷贝的方式<br>深拷贝通过序列化(Serializable)实现</p><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getClass().getName() + <span class="string">"@"</span> + Integer.toHexString(hashCode());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="wait-相关方法"><a href="#wait-相关方法" class="headerlink" title="wait()相关方法"></a>wait()相关方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout, <span class="keyword">int</span> nanos)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &lt; <span class="number">0</span> || nanos &gt; <span class="number">999999</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">"nanosecond timeout value out of range"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (nanos &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        timeout++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    wait(timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多线程情况下使用作用是阻塞进程</p><ul><li>此方法只能在当前线程获取到对象的锁监视器之后才能调用，否则会抛出 IllegalMonitorStateException异常。</li><li>调用 wait方法，线程会将锁监视器进行释放；而 Thread.sleep，Thread.yield()并不会释放锁。</li><li>wait方法会一直阻塞，直到其他线程调用当前对象的 notify()/notifyAll()方法将其唤醒；而 wait(long)是等待给定超时时间内（单位毫秒），如果还没有调用 notify()/nofiyAll()会自动唤醒； wait(long,int)如果第二个参数大于 0并且小于 999999，则第一个参数 +1作为超时时间；</li></ul><h3 id="notify-notifyAll"><a href="#notify-notifyAll" class="headerlink" title="notify()/notifyAll()"></a>notify()/notifyAll()</h3><p>如果当前线程获得了当前对象锁，调用 wait方法，将锁释放并阻塞；这时另一个线程获取到了此对象锁，并调用此对象的 notify()/notifyAll()方法将之前的线程唤醒。这些方法都是 publicfinal的，不可被重写。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>要点：<br>调用 notify()后，阻塞线程被唤醒，可以参与锁的竞争，但可能调用 notify()方法的线程还要继续做其他事，锁并未释放，所以我们看到的结果是，无论 notify()是在方法一开始调用，还是最后调用，阻塞线程都要等待当前线程结束才能开始。</p><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize()"></a>finalize()</h3><p>jvm垃圾回收时进行调用</p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><p><img src="/upload/pasted-321.png" alt="upload successful"></p><p><img src="/upload/pasted-380.png" alt="upload successful"></p><h2 id="和equals"><a href="#和equals" class="headerlink" title="==和equals"></a>==和equals</h2><p>==用来判断两个变量是否相等时，如果两个变量是基本类型变量，且都是数值类型(不要求数据类型严格相同)，则只要两个变量的值相等，就返回true；对于两个引用类型变量，必须指向同一个对象，==才会返回true。<br>equals方法用于比较两个独立对象的内容是否相同</p><h2 id="实例变量，局部变量，类变量，final变量"><a href="#实例变量，局部变量，类变量，final变量" class="headerlink" title="实例变量，局部变量，类变量，final变量"></a>实例变量，局部变量，类变量，final变量</h2><ul><li>实例变量：是定义在是定义在类中，方法体之外的变量。这种变量在创建对象的时候实例化。成员变量可以被类中方法、构造方法和特定类的语句块访问。分配了内存空间后会给所有的成员变量一次初始化，没有赋值的会给成员变量对应类型的值，数据类型不同则默认值不同。</li><li>局部变量：在方法、构造方法或者语句块中定义的变量被称为局部变量。变量声明和初始化都是在方法中，方法结束后，变量就会自动销毁。用的时候是直接入栈的，如果没有赋值，这个变量就没有初始值，也就无法操作，所以局部变量要初始化。</li><li>类变量：类变量也声明在类中，方法体之外，但必须声明为static类型。</li><li>final变量，final 修饰的变量。如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li></ul><h2 id="Integer的赋值问题"><a href="#Integer的赋值问题" class="headerlink" title="Integer的赋值问题"></a>Integer的赋值问题</h2><p>在为Integer赋值的时候，java编译器会将其翻译成调用valueOf()方法。比如Integer i=127翻译为Integer i=Integer.valueOf(127)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//high为127</span></span><br><span class="line">        <span class="keyword">if</span>(i &gt;= -<span class="number">128</span> &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + <span class="number">128</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>可以看出，对于-128到127之间的数，Java会对其进行缓存。而超出这个范围则新建一个对象。</p><h2 id="throws和throw"><a href="#throws和throw" class="headerlink" title="throws和throw"></a>throws和throw</h2><p>1、throws出现在方法头，throw出现在方法体 2、throws表示出现异常的一种可能性，并不一定会发生异常；throw则是抛出了异常，执行throw则一定抛出了某种异常。 3、两者都是消极的异常处理方式，只是抛出或者可能抛出异常，是不会由函数处理，真正的处理异常由它的上层调用处理</p><h2 id="接口（Interface）"><a href="#接口（Interface）" class="headerlink" title="接口（Interface）"></a>接口（Interface）</h2><p>接口，比抽象类还要抽象的类。</p><ul><li>接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract （只能是 public abstract，其他修饰符都会报错）。</li><li>接口中可以含有变量，但是接口中的变量会被隐式的指定为  public static final   变量（并且只能是 public，用 private 修饰会报编译错误。）</li><li>接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。 </li></ul><p>注：<br>接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。<br>接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键字。<br>接口中的方法都是公有的。public</p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>Reflection（反射）是Java被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的內部信息，并能直接操作任意对象的内部属性及方法。</p><p>Java反射机制主要提供了以下功能：</p><ul><li>在运行时构造任意一个类的对象</li><li>在运行时获取任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的方法（属性）</li><li>生成动态代理</li></ul><ol><li><p>Class: 是一个类; 一个描述类的类.<br>　　封装了描述方法的 Method,描述字段的 Filed,描述构造器的 Constructor 等属性.</p><ol start="2"><li><p>如何得到 Class 对象:<br>　　2.1 Person.class<br>　　2.2 person.getClass()<br>　　2.3 Class.forName(“com.atguigu.javase.Person”)</p></li><li><p>关于 Method:<br>　　3.1 如何获取 Method:<br>　　　　1). getDeclaredMethods: 得到 Method 的数组.<br>　　　　2). getDeclaredMethod(String methondName, Class … parameterTypes)</p></li></ol><p>　　3.2 如何调用 Method<br>　　　　1). 如果方法时 private 修饰的, 需要先调用 Method 的　setAccessible(true), 使其变为可访问<br>　　　　2). method.invoke(obj, Object … args);</p><ol start="4"><li><p>关于 Field:<br>　　4.1 如何获取 Field: getField(String fieldName)<br>　　4.2 如何获取 Field 的值:<br>　　　　1). setAccessible(true)<br>　　　　2). field.get(Object obj)<br>　　4.3 如何设置 Field 的值:<br>　　　　field.set(Obejct obj, Object val)</p></li><li><p>了解 Constructor 和 Annotation </p></li><li><p>反射和泛型.<br>　　6.1 getGenericSuperClass: 获取带泛型参数的父类, 返回值为: BaseDao&lt;Employee, String&gt;<br>　　6.2 Type 的子接口: ParameterizedType<br>　　6.3 可以调用 ParameterizedType 的 Type[] getActualTypeArguments() 获取泛型参数的数组.<br><a href="https://www.cnblogs.com/tech-bird/p/3525336.html" target="_blank" rel="noopener">https://www.cnblogs.com/tech-bird/p/3525336.html</a></p></li></ol></li></ol><h2 id="AQS和CAS"><a href="#AQS和CAS" class="headerlink" title="AQS和CAS"></a>AQS和CAS</h2><p>抽象队列同步器AQS ( AbstractQueuedSychronizer ) , 如果说java.util.concurrent的基础是CAS的话,那么AQS就是整个Java并发包的核心了, ReentrantLock、CountDownLatch、Semaphore等都用到了它。AQS实际上以双向队列的形式连接所有的Entry ,比方说ReentrantLock ,所有等待的线程都被放在一个Entry中并连成双向队列,前面一个线程使用 ReentrantLock好了, 则双向队列实际上的第一个Entry开始运行。 AQS定 义了对双向队列所有的操作,而只开放了tryLock和tryRelease方法给开发者使用,开发者可以根据自己的实现重写tryLock和tryRelease方法,以实现自己的并发功能。</p><p>比较并替换CAS(Compare and Swap) ,假设有三个操作数:内存值V、旧的预期值A、要修改的值B ,当且仅当预期值A和内存值V相同时,才桧将内存值修改为B并返回true ,否则什么都不做并返回false ,整个比较并替换的操作是一个原子操作。CAS一定要volatile变量配合,这样才能保证每次拿到的变量是主内中最新的相应值,否则旧的预期值A对某条线程来说,永远是一个不会变的值A,只要某次CAS操作失败，下面永远都不可能成功。</p><p>CAS虽然比较高效的解决了原子操作问题,但仍存在三大问题。</p><ul><li>循环时间开销大</li><li>只能保证一个共享变量的原子操作</li><li>ABA问题</li></ul><h2 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h2><p> Condition是在java 1.5中才出现的，它用来替代传统的Object的wait()、notify()实现线程间的协作，相比使用Object的wait()、notify()，使用Condition1的await()、signal()这种方式实现线程间协作更加安全和高效。因此通常来说比较推荐使用Condition，在阻塞队列那一篇博文中就讲述到了，阻塞队列实际上是使用了Condition来模拟线程间协作。</p><ul><li>Condition是个接口，基本的方法就是await()和signal()方法；</li><li>Condition依赖于Lock接口，生成一个Condition的基本代码是lock.newCondition()</li><li>调用Condition的await()和signal()方法，都必须在lock保护之内，就是说必须在lock.lock()和lock.unlock之间才可以使用Conditon中的await()对应Object的wait()； Condition中的signal()对应Object的notify()； Condition中的signalAll()对应Object的notifyAll() </li></ul><h2 id="Spring-mvc执行流程"><a href="#Spring-mvc执行流程" class="headerlink" title="Spring mvc执行流程"></a>Spring mvc执行流程</h2><p><img src="/upload/pasted-323.png" alt="upload successful"><br><a href="https://www.cnblogs.com/jay36/p/7527039.html" target="_blank" rel="noopener">https://www.cnblogs.com/jay36/p/7527039.html</a></p><h2 id="AOP-IOC"><a href="#AOP-IOC" class="headerlink" title="AOP IOC"></a>AOP IOC</h2><p>AOP和IOC是Spring精华部分, AOP可以看做是对OOP的补充,对代码进行横向的扩展,通过代理模式实现,代理模式有静态代理,动态代理, Spring利用的是动态代理,在程序运行过程中将增强代码织入原代码中。IOC是 控制反转,将对象的控制权交给Spring框架,用户需要使用对象无需创建,直接使用即呵。AOP和IOC最可贵的是它们的思想。</p><h2 id="Hibernate-POJO"><a href="#Hibernate-POJO" class="headerlink" title="Hibernate POJO"></a>Hibernate POJO</h2><p>Hibernate Pojo的三态分别为transient（瞬时态）,persistent（持久态）,detached（游离态）</p><p>1、官方给出的三态与Session的关系如下：</p><p>transient: never persistent, not associated with any Session<br>persistent: associated with a unique Session<br>detached: previously persistent, not associated with any Session</p><p>2、三种状态间相互转换关系，及他们在数据库、session中的状态如下：<br>a.当我们new一个pojo时，它处于瞬时态，此时与session、数据库均无任何关联。<br>b.此后，我们获得session并开启hibernate事务，调用save(),persist(),saveOrUpdate()方法，将pojo转变为持久态，此时session中存有这个pojo，但直到transaction.commit()被调用时，sql语句才会执行，此后数据库中也才有此条数据。<br>c.但当commit()并且session.close()执行过后，pojo就变为了游离态，也就是说，数据库中有该记录，但session中不再有。<br>d.持久化状态的实例，也可以重新变成瞬时态，那就是调用delete()方法。<br>e.通过get()或load()方法得到的pojo是持久态的。<br>f.游离态的pojo可以通过update(),saveOrUpdate(),lock()和replicate()方法重新成为持久态。<br>g.调用merge()方法后，pojo维持原态，但内容会被更新到数据库</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>Java通过Executors提供四个静态方法创建四种线程池，分别为：</p><p>newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</p><p>newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</p><p>newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。</p><p>newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行</p><p>作用：<br>限定线程的个数，不会导致由于线程过多导致系统运行缓慢或崩溃</p><p>线程池不需要每次都去创建或销毁，节约了资源、</p><p>线程池不需要每次都去创建，响应时间更快。</p><h2 id="javaWeb"><a href="#javaWeb" class="headerlink" title="javaWeb"></a>javaWeb</h2><h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p><img src="/upload/pasted-324.png" alt="upload successful"><br>servlet是运行在服务器端的小应用程序，是接收网络服务的请求和产生响应的一种方式。<br>servlet的功能：接受http请求，产生动态http响应。<br>HttpServlet是GenericServlet的子类。<br>GenericServlet是个抽象类，必须给出子类才能实例化。它给 出了设计servlet的一些骨架，定义了servlet生命周期，还有一些得到名字、配置、初始化参数的方法，其设计的是和应用层协议无关的，也就是说 你有可能用非http协议实现它。<br>HttpServlet是子类，当然就具有GenericServlet的一切特性，还添加了doGet, doPost, doDelete, doPut, doTrace等方法对应处理http协议里的命令的请求响应过程。</p><h4 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h4><p>servlet有良好的生存期的定义，包括加载和实例化、初始化、处理请求以及服务结束。这个生存期由javax.servlet.Servlet接口的init,service和destroy方法表达。<br>加载Servlet的class—-&gt;实例化Servlet—–&gt;调用Servlet的init完成初始化—-&gt;响应请求（Servlet的service方法）—–&gt;Servlet容器关闭时(Servlet的destory方法)<br>Servlet启动时，开始加载servlet生命周期开始。Servlet被服务器实例化后，容器运行其init方法，请求到达时运行其service方法，service方法自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候(服务器关闭)调用其destroy方法。</p><h4 id="forward-与redirect-的区别"><a href="#forward-与redirect-的区别" class="headerlink" title="forward() 与redirect()的区别"></a>forward() 与redirect()的区别</h4><p>forward是服务器端的转向而redirect是客户端的跳转。</p><p>使用forward浏览器的地址不会发生改变。而redirect会发生改变。</p><p>Forward是一次请求中完成。而redirect是重新发起请求。</p><p>Forward是在服务器端完成，而不用客户端重新发起请求，效率较高<br>一般没有特殊需要，自己写的Servlet都扩展HttpServlet 。</p><h4 id="JSP和Servlet有哪些相同点和不同点"><a href="#JSP和Servlet有哪些相同点和不同点" class="headerlink" title="JSP和Servlet有哪些相同点和不同点"></a>JSP和Servlet有哪些相同点和不同点</h4><p>JSP是Servlet技术的扩展，所有的jsp文件都会被翻译为一个继承HttpServlet的类。也就是jsp最终也是一个Servlet.这个Servlet对外提供服务。</p><p><img src="/upload/pasted-347.png" alt="upload successful"><br>Servlet和JSP最主要的不同点在于JSP侧重于视图，Servlet主要用于控制逻辑。<br>Servlet如果要实现html的功能，必须使用Writer输出对应的html,比较麻烦。而JSP的情况是Java和HTML可以组合成一个扩展名为.jsp的文件,做界面展示比较方便而嵌入逻辑比较复杂</p><h4 id="jsp内置对象"><a href="#jsp内置对象" class="headerlink" title="jsp内置对象"></a>jsp内置对象</h4><p>request 用户端请求，此请求会包含来自GET/POST请求的参数</p><p>response 网页传回用户端的回应</p><p>pageContext 网页的属性是在这里管理</p><p>session 与请求有关的会话期</p><p>application servlet正在执行的内容</p><p>out 用来传送回应的输出</p><p>config servlet的构架部件</p><p>page JSP网页本身</p><p>exception 针对错误网页，未捕捉的例外</p><p>四大作用域：pageContext request session application 可以通过jstl从四大作用域中取值.</p><p>Jsp传递值request session application cookie也能传值</p><h3 id="http-get和post请求的区别"><a href="#http-get和post请求的区别" class="headerlink" title="http get和post请求的区别"></a>http get和post请求的区别</h3><p>GET和POST请求都是http的请求方式，用户通过不同的http的请求方式完成对资源（url）的不同操作。GET，POST，PUT，DELETE就对应着对这个资源的查 ，改 ，增 ，删 4个操作,具体点来讲GET一般用于获取/查询资源信息，而POST一般用于更新资源信息<br>1、Get请求提交的数据会在地址栏显示出来，而post请求不会再地址栏显示出来.</p><p>GET提交，请求的数据会附在URL之后（就是把数据放置在HTTP协议头中），以?分割URL和传输数据，多个参数用&amp;连接；POST提交：把提交的数据放置在是HTTP包的包体中。因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变</p><p>2、传输数据的大小</p><p>http Get请求由于浏览器对地址长度的限制而导致传输的数据有限制。而POST请求不会因为地址长度限制而导致传输数据限制。</p><p>3、安全性,POST的安全性要比GET的安全性高。由于数据是会在地址中呈现，所以可以通过历史记录找到密码等关键信息。</p><h3 id="Session-和-Cookie"><a href="#Session-和-Cookie" class="headerlink" title="Session 和 Cookie"></a>Session 和 Cookie</h3><p>Session和cookie都是会话(Seesion)跟踪技术。Cookie通过在客户端记录信息确定用户身份，Session通过在服务器端记录信息确定用户身份。但是Session的实现依赖于Cookie,sessionId(session的唯一标识需要存放在客户端).</p><p>cookie 和session 的区别：</p><p>1、cookie数据存放在客户的浏览器上，session数据放在服务器上。</p><p>2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗</p><p>   考虑到安全应当使用session。</p><p>3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用COOKIE。</p><p>4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</p><p>5、所以个人建议：</p><p>   将登陆信息等重要信息存放为SESSION</p><p>   其他信息如果需要保留，可以放在COOKIE中，比如购物车</p><p>购物车最好使用cookie，但是cookie是可以在客户端禁用的，这时候我们要使用cookie+数据库的方式实现，当从cookie中不能取出数据时，就从数据库获取。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>结束是另一个开始</title>
      <link href="/2019/07/05/mething-Ends-Something-Begins-translate-cn/"/>
      <url>/2019/07/05/mething-Ends-Something-Begins-translate-cn/</url>
      
        <content type="html"><![CDATA[<p><img src="/upload/pasted-357.png"><br>《猎魔人》原著作者送给其朋友的结婚礼物，和正传发生的故事有些矛盾，但问题不大<br>高甜预警！！！<br><a id="more"></a></p><hr><p>翻译自外国的某个热心粉丝Something Ends, Something Begins <a href="https://witcher.fandom.com/wiki/Something_Ends,_Something_Begins_(unofficial_translation)" target="_blank" rel="noopener">https://witcher.fandom.com/wiki/Something_Ends,_Something_Begins_(unofficial_translation)</a><br>意思跑偏太正常了，这哥们把波兰语翻译成英语要跑偏一部分，我再把英语翻译成汉语又会跑偏一部分。对于这里面出现的一些人物，已经在第一次出现的地方链接到了猎魔人的wiki,有兴趣的朋友可以看一看。</p><hr><h1 id="I"><a href="#I" class="headerlink" title="I"></a>I</h1><p>   太阳炽热的触须透过百叶窗的缝隙伸展开来，倾斜的阳光把房间横断开来，飞悬的尘埃在光线中跃动着，落在地板的熊皮上，在叶妮芙皮带扣炫目的闪光中渐渐消散。叶妮芙的腰带挂在高跟鞋上，高跟鞋在白色蕾丝内衣上，而内衣在黑色的裙子上。一只黑色长筒袜挂在雕刻成烟囱状的扶手椅上，另一只袜子和另一只高跟鞋却四处不见，杰洛特叹了口气。叶妮芙喜欢利索优雅的脱掉衣服，他必须开始习惯起来，他没别的选择。<br>他站起身来，打开窗子向外看去，湖面光滑如镜，迷迷蒙蒙中，岸边的桦树和赤杨的叶子上闪着露珠，远处的草地上覆盖着厚重的雾，沉默的压下来，犹如蛛网一般悬在草地之上</p><p>   叶妮芙在毯子下嘟囔着什么，含糊不清。杰洛特叹了口气<br>   “今天天气真好，叶。”<br>   “嗯？你说什么？”<br>   “今天天气很好，尤为的好”<br>   她还是让他吃了一惊，女术士并没有像往常一样讽刺挖苦，也没有把头压在枕头下，而是坐起身来。用手梳理着头发，然后在床上找睡衣，杰洛特知道睡衣就在床头下面，就在她昨晚脱掉的地方，但是他一句话也没说，因为他知道，叶妮芙讨厌这种话。<br>   女术士突然咒骂起来，她踢了踢毯子，举起手咬住手指，睡袍就从床前飞来，摆动着荷叶边，犹如一个可怕的幽灵，然后落在她的手上。杰洛特叹了口气。叶妮芙站起身来走到他跟前，抱住了他，咬了他的胳膊，杰洛特叹了口气，他不得不习惯的事似乎多的数不清。<br>   “你没什么想说的吗？”，女术士眯着眼睛，问道<br>   “并没有。”<br>   “很好，今天的确很好，干的不错。”<br>   “什么意思？”<br>   叶妮芙还没来得及回答，就听见远处传来一声又高又长的叫喊声和喘息声。湖边，希瑞骑着一匹黑色的母马溅起一阵水花，这是一匹纯种马，长得很漂亮。杰洛特还记得它的上一个主人是个半精灵，这个半精灵轻率的凭第一印象错误的判断了这个白发的猎魔女，最终犯下大错。希瑞将这匹母马命名为“卡尔比”，在史凯利杰岛民的口中，这个意思是一种可怕的，胆大妄为的海的神灵，有时也会化身为马。这名字非常适合这匹母马。不久之前，有个半身人就因为某种艰难的方式了解到了，当他尝试偷走这匹马时，被这匹马猛地给了一脚，正中脸上，这半身人以前叫桑迪·弗洛莫顿，但自此以后人们就叫他“花椰菜”了。<br>   “总有一天她会摔断脖子的”，叶妮芙叫喊道，看着希瑞在溅起的水花中飞奔，弯腰，牢牢的踩着马镫。“总有一天你这疯女儿会摔断脖子的。”<br>   杰洛特转过头来，也不说话，就这么静静的看着女术士那双紫罗兰色的眼眸。<br>   “好吧好吧，”叶妮芙目不转睛的微笑着，“对不起，我们的女儿。”<br>   她又抱住他，紧紧地靠在他身上，又咬了下他的胳膊，然后亲吻她，接着又咬了下，杰洛特嘴唇触碰着她的头发，小心翼翼的把睡袍来到她的肩上。<br>   然后最终他们还是又上了床，散乱的毯子，尚有余温，仍旧沉浸在梦中。他们开始互相寻找彼此，寻找的时间很长，也很耐心，他们都深知最终会找到彼此，充满欢喜的彼此，他们所做的一切都是欢愉的，尽管他们之间尚有很大的差异，他们也和往常一样想着，这种差异并不是将他们分割开来，而是紧紧的绑在一起的差异，就犹如房梁和屋脊，那才是房屋的诞生所在。这也犹如第一次，当他被她赤裸而强烈的欲望所迷住，而她被他的巧妙和感性所迷住，就像她第一次本想告诉他，但是他却只用了一个吻和一个安抚让她安宁下来，消除了其他的所有感觉，后来，当他想要告诉她时，他却一点声音也发不出来，再后来，欢愉被一块巨石压倒，他们的眼中只有那一刻的闪光，听到的只是无声的呼喊，世界犹如静止一般，结束了，开始了，然后是沉默，宁静的沉默【本段见小说第一本《白狼崛起》的“最后的愿望”】<br>   还有无限的魅力。<br>   世界又重新回到它的轨道上，这里还是一张充满梦幻和光亮的床，然后是一天，那样的一天……<br>   “叶…”<br>   “嗯？”<br>   “当你说今天天气不错时，还说了句‘干得不错’，该不是……”<br>   “是的”她承认道，伸展着双臂握紧毯子的边，使她的胸部在那一刻以这种方式展现出来，这使得猎魔人的下半身一阵颤动<br>   “看啊，杰洛特，是我们打造出这样的天气，昨晚，我，<a href="http://witcher.huijiwiki.com/wiki/%E5%8D%97%E5%B0%BC%E5%85%8B" target="_blank" rel="noopener">南尼克</a>,特莉丝和<a href="http://witcher.huijiwiki.com/wiki/%E5%A4%9A%E7%91%9E%E5%8A%A0%E9%9B%B7" target="_blank" rel="noopener">多瑞加雷</a>,我不能冒险，今天必须是美好的一天……”<br>她一声不吭的用膝盖猛击了杰洛特一下。<br>   “为什么？因为这是你生命中最重要的一天，傻东西。”【叶妮芙设定上会读心术，专读杰洛特的】</p><hr><h1 id="II"><a href="#II" class="headerlink" title="II"></a>II</h1><p>   洛史洛格城堡矗立在湖中凸起的地带，亟需进行全面的修缮工作，绝对不仅仅是现在。说的好听一点，洛史洛格就是一片废墟，一个不规整的石头堆，铺满了常青藤，野葡萄，地衣和苔藓，说来说去也不过是这片烂沼泽地中的一个遗迹，四处满是蛤蟆，蝾螈和乌龟，当年这片土地给赫维格国王时，这已经就是一片废墟了，这个城堡以及周边的沼泽，更像是一份毕生的礼物，一份送给赫维格告别礼物。赫维格于12年前退位，以支持他的侄子“友善者”布伦南，杰洛特曾通过丹德里恩结识了这位前国王，因为赫维格国王为人和蔼，也喜好招待宾客，所以这位吟游诗人经常出入城堡。<br>   当女术士排除了猎魔人所提供的所有地点参考时，丹德里恩就把赫维格国王的洛史洛格城堡提了上来，诡异的是，女术士马上就同意了这个提议，甚至连鼻子也没抽一下。<br>于是，杰洛特和叶妮芙的婚礼将在洛史洛格城堡举行</p><hr><h1 id="III"><a href="#III" class="headerlink" title="III"></a>III</h1><p>   一开始，这场婚礼设定上是小型的，不那么引人注目的婚礼，可是因为各种原因，这是不可能实现的，所以很有必要找一个擅长组织的人。自然，叶妮芙是拒绝的，她不想张罗她自己的婚礼，杰洛特和希瑞，还有丹德里恩，那就不用说了，他们就没组织这个概念，于是他们向艾尔兰德的梅里泰莉神庙的大祭司南尼克求助，南尼克二话不说就来了，带着两个年轻的女祭司小爱若拉和尤妮德。<br>   于是各种问题开始接踵而至。</p><hr><h1 id="IV"><a href="#IV" class="headerlink" title="IV"></a>IV</h1><p>   “这可不行，杰洛特，”南尼克怒吼道，跺了跺脚，“婚礼和宴会要是出了什么岔子我可不负责。那片废墟，有些傻瓜竟然称之为一座城堡，那可是一点用也没有，那里的厨房都要塌了，舞厅也就能用来做个马厩，那个礼拜堂……那就不是个礼拜堂，至少你能告诉我那个瘸子赫维格信奉哪位神灵吗？”<br>“据我所知，他谁也不信奉，他还声称宗教不过是大众的精神毒品”<br>“哼，我就知道，”女祭司说道，丝毫没有掩饰自己的轻蔑，“那个礼拜堂里没有一座雕像，除了老鼠粪以外，就没有别的东西了，最重要的是，那个地方不过是一摊死水，杰洛特，你怎么不想在一个文明的国家举行婚礼呢，比如温格堡？”<br>   “你知道的，叶是一个混血儿，你们的那些文明国家可不准许这种混合的婚姻”<br>“梅里泰莉女神在上！不过是四分之一的精灵血统，有什么问题吗？谁都或多或少的带点上古民族的血统，这只是个愚蠢的偏见！”<br>   “那也不是我编出来的。”</p><hr><h1 id="V"><a href="#V" class="headerlink" title="V"></a>V</h1><p>   邀请的客人名单实际上并不长，夫妇两人把名单汇总交给了丹德里恩，让他去发放邀请函，结果是这个吟游诗人还没来得及读完就给弄丢了，因为他羞于承认，于是他就耍了些花招：尽可能的邀请他所能邀请的任何人，当然，他对叶妮芙和杰洛特都很了解，所以没有落下任何一个重要的人，但是要是没有趁机邀请到更多的乱七八糟的形形色色的人的话，那他也就不是丹德里恩了。<br>   于是，杰洛特的导师，来自凯尔莫罕的老维瑟米尔和杰洛特的童年伙伴，猎魔人艾斯卡尔就过来了<br>   德鲁伊<a href="http://witcher.huijiwiki.com/wiki/%E8%8E%AB%E6%96%AF%E8%90%A8%E5%85%8B" target="_blank" rel="noopener">莫斯萨克</a>带着一个名叫芙蕾雅的金发女郎来了，芙蕾雅比他高一头，但是可比他年轻上百岁。来的还有<a href="http://witcher.huijiwiki.com/wiki/%E5%85%8B%E6%8B%89%E8%8C%A8%C2%B7%E5%AE%89%C2%B7%E5%85%8B%E8%8E%B1%E7%89%B9" target="_blank" rel="noopener">克拉茨·安·克莱特</a>,史凯利杰群岛的伯爵，带着他的两个儿子拉格纳和洛基，拉格纳骑马时，脚都快碰到地了，而洛基则像个精灵，也难怪他们兄弟两个，但是他们有着不同的母亲<br>   来自布拉维坎的里夫·凯尔迪米恩和他女儿阿妮卡到了【出自《白狼崛起》的“勿以恶小”，布拉维坎屠夫的称号就是从这个地方得来的】，阿妮卡很有魅力但生性害羞。矮人<a href="http://witcher.huijiwiki.com/wiki/%E4%BA%9A%E5%B0%94%E6%BD%98%C2%B7%E9%BD%90%E6%A0%BC%E6%9E%97" target="_blank" rel="noopener">亚尔潘·齐格林</a>出现了，没有带着其他人，这很有意思，他一般都是带着他的长胡子同伙的。他是在半路上碰上了精灵<a href="http://witcher.huijiwiki.com/wiki/%E5%87%AF%E7%91%9E%E5%B0%94%E4%B8%B9" target="_blank" rel="noopener">凯瑞尔丹</a>一起来的，可见凯瑞尔丹在精灵中还是有些地位的，身边有几个默默无闻的精灵，无人知晓。<br>又来了一队吵吵嚷嚷的半身人，这群人里杰洛特只认识<a href="http://witcher.huijiwiki.com/wiki/%E4%B8%B9%E8%BF%AA%C2%B7%E6%AF%94%E4%BC%AF%E5%A8%81%E7%89%B9" target="_blank" rel="noopener">丹迪·比伯威特</a>，蓼草牧场的商人和牧马人,还有只是有所耳闻的，因好斗而出名的老婆加德尼娅·比伯威特，领头的还有一个不是半身人的半身人——著名的商人特里科·朗格瑞文克·勒托特，一个异形怪，伪装成名为“<a href="http://witcher.huijiwiki.com/wiki/%E5%98%9F%E5%98%9F" target="_blank" rel="noopener">嘟嘟</a>”的半身人。【见《宿命之剑》的“永恒之火”】<br>   来自布洛克莱昂的<a href="http://witcher.huijiwiki.com/wiki/%E8%8F%B2%E6%96%AF%E5%A5%88%E7%89%B9" target="_blank" rel="noopener">菲斯奈特</a>男爵到了，带着他的妻子，高贵的树精布蕾恩，以及他们的五个女儿莫丽恩、希瑞菈、莫娜、艾思娜和卡什卡，莫丽恩15岁的样子，而卡什卡看上去只有五岁。她们都是一头红发，尽管菲斯奈特是黑发，布蕾恩是金发、布蕾恩明显怀有身孕。他的一群红发树精女儿彼此咯咯的笑着，菲斯奈特信誓旦旦的说，这次一定是个儿子【小说中说树精X非树精=女树精】而布蕾恩则笑着补充道，这个“儿子”就叫梅丽莎。【这两个人的故事见《宿命之剑》的“宿命之剑”】<br>   独臂的<a href="http://witcher.huijiwiki.com/wiki/%E9%9B%85%E5%B0%94" target="_blank" rel="noopener">雅尔</a>也来了，这是一位年轻的牧师，编年史家，来自艾尔兰德，是南尼克的一个学徒，他来这里主要是因为他暗恋的希瑞，心疼的南尼克觉得，希瑞对于这个残疾青年的隐晦的调情似乎太过冷淡。<br>   打头的不速之客是布利姆巫德的<a href="http://witcher.huijiwiki.com/wiki/%E8%89%BE%E6%A0%BC%E7%BD%97%E7%93%A6%E5%B0%94" target="_blank" rel="noopener">艾格罗瓦尔</a>王子，他的到来被视作为一个奇迹，因为他和杰洛特曾经毫不留情的公开鄙视对方，更奇怪的是，他是和他的妻子美人鱼<a href="http://witcher.huijiwiki.com/wiki/%E5%B8%8C%E6%81%A9%E5%A8%9C%E5%85%B9" target="_blank" rel="noopener">希恩娜兹</a>一起来的，尽管她为了一双异常漂亮的腿牺牲了自己的鱼尾，但人们都知道她从未离开过海岸，因为她对陆地充满恐惧【这段故事见《宿命之剑》的“一点牺牲”】<br>   没人料到还会有其他的国王会对于此事比较上心——说来说去也没人邀请他们。尽管如此，还是有很多国王派发贺信，礼物，使者——或者以上的一并送出。他们应该是事先商量好了，因为他们的使者是组团来的，彼此都相互认识了。伊夫骑士代表埃塞因国王，领主苏力沃伊代表文斯拉夫国王，玛索尔姆爵士代表西吉斯蒙德国王，德弗卢爵士代表<a href="http://witcher.huijiwiki.com/wiki/%E9%9B%85%E5%A6%B2" target="_blank" rel="noopener">雅坦</a>王后，他们这几个人的旅行一定很愉快，因为伊夫的嘴唇被割破了，苏力沃伊的胳膊绑在板子上，玛索尔姆一瘸一拐的，而德弗卢醉的很厉害，几乎要从马上摔下来了。<br>   没人能邀请金龙<a href="http://witcher.huijiwiki.com/wiki/%E5%8D%9A%E5%B0%94%E5%A5%87" target="_blank" rel="noopener">维纶特瑞坦梅斯</a>,因为没人知道怎么邀请他以及他到底在哪，令众人吃惊的是，他还是来了，自然是隐藏了真实的形态，是以骑士博尔奇“三只寒鸦”的身份来的，当然，有丹德里恩在的地方，就没有什么隐私可言，但是当吟游诗人指着这位卷发骑士声称他其实是一条金龙时，还是没什么人相信。<br>   没人会料到还有一群各式各样的流浪人的到来，当然，也没人邀请他们。他们被登记为“丹德里恩的朋友和熟人”，主要是诗人，歌手和剧场演员，还有杂耍演员，职业骰子手，鳄鱼训练师以及四个浓妆艳抹的女人，其中三个毫无疑问就是妓女，而第四个虽然看上去不像，但毫无疑问也是，有两个算命的，其中一个还是个骗子，还有一个雕塑家，一个金发女郎，和一个醉酒的灵媒师，还有个麻子脸的侏儒，自称是舒滕巴赫<br>   在一艘外形犹如一只天鹅背着一个巨大的枕头的魔法船上，术士团到了，他们比邀请的要少上4倍，但是比预期来的要多上三倍，正如传言所说的那样，叶妮芙的同行并不认同她会嫁给一个外人，还是个猎魔人，他们中的一部分人直接无视邀请，另一部分人则以没时间为由，说是要去参见一年一度的世界修道院集会，因此，在那艘被丹德里恩唤做“枕头鸟”的船上只有沃尔的多瑞加雷，牛堡的<a href="http://witcher.huijiwiki.com/wiki/%E8%8E%B1%E5%BE%B7%E5%85%8B%E9%87%8C%E5%A4%AB" target="_blank" rel="noopener">莱德克里夫</a>,以及一头栗色头发的特莉丝·梅利葛德</p><hr><h1 id="VI"><a href="#VI" class="headerlink" title="VI"></a>VI</h1><p>   “是你邀请的特莉丝·梅利葛德？”<br>   “没有的事，”猎魔人急忙摇了摇头，暗自庆幸自己的血液循环系统不会让自己脸红。“不是我，估计是丹德里恩，尽管他们都说他们是通过水晶占卜知道的。”<br>   “我不希望特莉丝·梅利葛德出现在我的婚礼上！”<br>   “为什么呀，她可是你的朋友。”<br>   “不要把我当傻子，猎魔人！是个人就知道你跟她有一腿。”<br>   “扯淡！”<br>   叶妮芙的紫罗兰色眼睛危险的眯着。<br>   “是真的”<br>   “真不是”<br>   “就是真的”<br>   “够了，”他生气的把头扭向一边，“就是真的了，你想怎么样？”<br>   女术士沉默了，摆弄着脖子上的黑曜石星星。<br>   “也没什么，”女术士最终开了口，“我就是想让你承认罢了，不要冲我撒谎，杰洛特，永远也不要”</p><hr><h1 id="VII"><a href="#VII" class="headerlink" title="VII"></a>VII</h1><p>   城堡的石墙散发出一股潮湿的气息，外加一股子药草的酸味。阳光照在褐色的泥水上，竟然拽出了沼泽地里某种植物的暖绿色和海狸百合闪闪发光的黄色<br>城堡也慢慢苏醒过来，渐渐有了生机。城堡西翼，有人打开百叶窗，放声大笑。有人用一种微弱的声音请求来一些泡菜卤水，丹德里恩的一位同事，一个盲诗人，一边刮着胡子，一边放声唱到：</p><p>干草仓后的栅栏上，<br>有只公鸡高声唱，<br>姑娘我会赶到你身旁，<br>来上一炮也无妨……</p><p>   门吱扭一声开了，丹德里恩来到院子中，他伸了伸懒腰，揉了揉眼睛<br>   “你好啊，新郎官，”他疲惫的说道。“如果你想要溜走，就只有现在了。”<br>   “丹德里恩，你竟然成了早起的鸟儿。”<br>   “我压根就没上床”，诗人嘟囔着，坐在猎魔人旁的石凳上，靠着长满藤蔓的石墙。“神啊，多么每美妙的夜晚，但不管怎么说，可不是每天都有好朋友要结婚，自然是要好好的庆祝一下。”<br>   “婚礼的宴会是在今天，”杰洛特提醒道，“你能撑得过去吗？”<br>   “你瞧不起我吗？”</p><p>   艳阳高照，鸟儿在灌木丛中啾啾的叫着，湖上传来溅水声和咯咯的笑声，那是菲斯奈特的红发树精女儿们莫丽恩、希瑞菈、莫娜、艾思娜和卡什卡正和往常一样光着身子在湖中玩耍，特莉丝·梅利葛德和莫斯萨克的朋友芙蕾雅正看着她们。而城垛上，皇家的使者们，伊夫骑士，苏力沃伊领主，玛索尔姆爵士和德弗卢爵士却为了争抢一个望远镜而大打出手。</p><p>   “玩得还好吗，丹德里恩？”<br>   “别提了。”<br>   “又出什么乱子了？”<br>   “可是有那么几个。”</p><p>   正如诗人所说，第一个争端是关于种族的。宴会开到一半时，特里科·朗格瑞文克·勒托特突然发作，说他已经忍受够了半身人的伪装，勒托特指着在坐的树精，精灵，半身人，美人鱼，人类和一个声称自己是舒滕巴赫的侏儒，说他们每个人都能做他们自己而只有他，特里科必须得伪装成别人的样子，这就是种歧视，然后他突然变回了自己自然模样，看到这一幕，加德尼娅·比伯威特当场晕了过去，艾格罗瓦尔王子差点被龙虾给噎着，而里夫·卡尔迪米恩的女儿阿妮卡则歇斯底里的叫了起来，这混乱场面最终还是靠着金龙维纶特瑞坦梅斯得以拯救，当然，是以骑士博尔奇“三只寒鸦”的形态。他淡淡的向勒托特解释道，说异形是一种天赐的恩惠，然而这种恩惠也要求他保持一种社会能够接受的形态，而且也是出于对东道主的礼仪。<br>   可是勒托特指责维纶特瑞坦梅斯，说他的这番话完全就是种族主义，沙文主义以及站着说话不腰疼。因此受辱的维纶特瑞坦梅斯猛地变成了龙形，毁坏了几件家具，引得众人一阵恐慌，待局势稍微缓和下来时，一场激烈的争端就开始了，人类和非人种族在互相指责对方的不宽容，对方的种族歧视，这场争论意想不到的转折来自脸上长着雀斑的媚儿，就是那个不像妓女的妓女，她说这场争辩就是扯淡，对于“专业人士”来说，是不是人根本就没有关系，还说愿意当场证明（当然，钱要到位。）甚至包括处在自然形态下的维纶特瑞坦梅斯，在那片刻间的寂静中，众人听到那个灵媒师说她也愿意做同样的事，而且不收钱。维纶特瑞坦梅斯赶忙转换话题，开始讨论一些相对安全的话题，比如经济，政治，狩猎，钓鱼以及冒险。<br>   其他的事情可能相对来说不那么暴力。莫斯萨克，莱德克里夫和多瑞加雷比他们谁能用意念控制更多的东西浮空。最终是多瑞加雷赢了，他成功的将两把椅子，一个水果盘，一碗汤，一个地球仪，一只猫，两只狗以及菲斯奈特和布蕾恩的女儿卡什卡悬在空中。<br>   然后是菲斯奈特和布蕾恩的两个女儿，希瑞拉和莫娜扭打在一起，于是她们被要求返回自己的房间，不一会拉格纳和玛索尔姆爵士为菲斯奈特的大女儿莫林又打了起来。生气的菲斯奈特赶忙把自己的红发女儿们都关在了屋子里，然后自己兴冲冲的跑去参加由莫斯萨克的女友芙蕾雅组织的斗酒。很快，丹德里恩的朋友们，那些诗人和歌手，纷纷喝倒在桌子下，很明显芙蕾雅对于酒精有难以想象的抑制能力，近乎于免疫。但是菲斯奈特，克拉茨·安·克莱特，里夫·卡尔迪米恩仍然勇敢的战斗着，然后他们也败下阵来。术士莱德克里夫此时却还坚定的举着酒杯，直到人们发现他带着一个独角兽的角，拿掉之后，他一下子就不行了。有那么一段时间，桌子上都没人，然后就来了一个穿着老式服装的卡夫坦人，他脸色苍白，没人认识他。他和芙蕾雅喝了几个来回，过了一会，站了起来，晕晕乎乎的，礼貌的鞠了一躬，穿过一堵墙，就好像一阵雾，通过对大厅中的挂画的彻底搜查，人们认定他可能是几百年前在黑暗时代被谋杀的罗兹罗格的继承人“魔鬼”威廉姆。<br>   这座古堡藏着各种各样的秘密，早些年，它以它的阴森可怕而闻名，但是人们都比较怀疑，毕竟并没有发生什么超自然的事。午夜时分，一只吸血鬼从开着的窗子飞来进来，一进来，就被矮人亚尔潘·齐格林扔了头大蒜，然后被他追着打。整个晚上，总能听见货真价实的鬼哭狼嚎，但没人在意，人们都觉得是丹德里恩和他的朋友在搞鬼。然而，楼梯上大量的外质表明，这的确就是货真价实的鬼魂，还有几个人滑到在上面。</p><p>   有个影子跨过门槛，他眨着火一般的眼睛，淘气的捏了希恩娜兹的屁股一把，看来要想解决这些误会可能要有些难度了，因为希恩娜兹认定就是丹德里恩干的，这个鬼影立刻借着这个误会，四处捣乱，直到他被南尼克抓住并用驱魔术驱逐出去。<br>   几个人声称自己看见了苍白夫人，传说中，她被活埋在洛史洛格城堡的地下墓穴中。而别的人则觉得这个不是苍白夫人，而是那个女灵媒师在画廊中走动着找酒喝<br>   然后就开始有人失踪了，最开始失踪的是伊夫骑士和鳄鱼杀手，不一会人，人们发现拉格纳和年轻的女祭司尤妮德也没了。然后是加德尼娅·比伯威特，但后来才知道她去睡觉了。接着是独臂的雅尔和第二个年轻女祭司小爱若拉。虽然希瑞对雅尔没什么感情可言，但还是有些担心，但很显然，这个年轻人不小心摔在了阴沟里，在里面睡着了。而小爱若拉则是在楼梯口被发现了，旁边还有精灵凯瑞尔丹。特莉丝·梅利葛德和来自凯尔莫罕的猎魔人艾斯卡尔被发现了消失在花园的凉亭附近。早上，有人声称看见了在凉亭那里看见了变形怪特里科，人们就在议论纷纷，琢磨着这个异形怪到底变成了谁的模样，甚至有人觉得这里有两个异形怪。他们想向金龙维纶特瑞坦梅斯征求下意见，毕竟他也是个变形专家，结果这条龙也不见了，妓女媚儿和他在一起。<br>   第二个妓女也没了，同时消失的还有一个算命的，剩下的一个算命的说他才是真的那个，但是没人能证明。同时，那个自称是舒滕巴赫的侏儒也不见了。</p><p>   “你大概已经后悔了，”吟游诗人打了个大大的哈欠，“你不在真的是太遗憾了，那可是相当的精彩。”<br>   “我的确挺后悔的，”猎魔人感叹道，“但是你懂得……我不能,因为叶妮芙……总之你应该是最了解的。”<br>   “那是肯定的，”丹德里恩赞成到，“所以我才不会傻到去结婚。”</p><hr><h1 id="VIII"><a href="#VIII" class="headerlink" title="VIII"></a>VIII</h1><p>   城堡的厨房中传来了平底锅的叮当声，快乐的笑声以及哼哼的小调声。要为这么多客人提供盛宴是个问题，因为赫维格国王平日几乎就没什么客人。术士的到来并没有解决任何问题，出于对于食品安全的考量，食物都得是自然的东西，不掺杂一点魔法，所以南尼克到处助抓人打下手。一开始并不简单，因为被拉过来的人一点厨房的常识也没有，而那些会做饭的早就跑掉了。然而还是加德尼娅·比伯威特带着一群半身人过来帮忙。令人吃惊的是，丹德里恩招来的那四个妓女都是出乎意料的厨房能手。<br>   供给方面也没有问题菲斯奈特和艾格罗瓦尔组织了一场狩猎，打来了不少鹿肉，布蕾恩和他的女儿们只用了两个小时就打来了足够多的野味，众所周知树精大多箭术惊人，就连小女儿卡什卡弯弓搭箭也很流畅。热衷钓鱼的老国王赫维格一早就到湖上打鱼去了。带回了梭子鱼，狭鳕鱼还有好大只的贝斯鱼。ke的小儿子洛基跟他一同去的，岛民出身的他驾船打鱼样样精通，并且他也是早上为数不多能派上用场的，因为他和赫维格国王一样不沾酒。<br>   在变形怪特里科的驱使下，丹迪·比伯威特和他的亲戚们开始打扫大厅和各个房间，他们又赶着两个算命的，鳄鱼杀手，雕塑家还有喝的烂醉的灵媒师一同打扫清理。<br>   看管地下室的酒水的工作一开始交给了丹德里恩和他的朋友们，后来被证明这是一个灾难性的决定，于是这些诗人们就被赶了出去，钥匙交到莫斯萨克的女朋友芙蕾雅手中。但是丹德里恩和他的朋友们还赖着不走了，试图用抒情诗打动芙蕾雅，可这位岛民却像抵制酒精那样抵制他们的诗歌。<br>   杰洛特猛地抬起头来，他被从石子路上传来的马蹄声惊醒了，卡尔比从墙边的灌木丛中冲出，是希瑞来了，她穿着她的黑色皮革护甲，背上背着把剑，正是名剑格维尔，是她从科洛奇沙漠的地下墓穴中得到的。<br>   有那么一会他们就要彼此对视，也不说话。女孩驾着马向前，卡尔比向着杰洛特咬了过去，却被希瑞猛地拉了回来。<br>   “就是今天了，”猎魔女说道，“是今天，杰洛特。”<br>   “是今天，”猎魔人背靠着墙，确认到。<br>   “我很高兴”，她的声音中有种不确定，“我想……我不太肯定你们两个会不会幸福，但我还是很高兴。”<br>   “希瑞，下马，我们得谈谈。”<br>   女孩甩了下头，把头发甩到了后面。杰洛特看见了一道又宽又丑的伤疤——这是一段不堪回首的往事，希瑞就是为了遮住伤疤才将头发蓄长，但是她总是忘了挡住伤疤。<br>   “我要走了，杰洛特”她告诉猎魔人，“宴会之后，立马上路。”<br>   “下马，希瑞。”<br>   猎魔女跳下马来，坐在他身旁，杰洛特抱住了她，希瑞靠在他的肩上。<br>   “我要离开了，”她又说了一遍。<br>   他什么也没说，话到嘴边，但是他觉得不合适，或者说不必要。他什么也没说。<br>   “我知道你在想什么，”她慢慢的说道，“你觉得我是要逃跑，的确是这样。”<br>   他还是沉默着，他确实明白。<br>   “毕竟，在经历了这么多风风雨雨，你终于和叶结婚了，你理应幸福，理应有一个安定的家，但是这一切却令我感到害怕，杰洛特，所以……我要逃离这一切。”<br>   他还是沉默着，他想起了自己的逃跑。<br>   “宴会结束马上就走，”希瑞又说了一遍。“我想……我想要再次感受策马急行的风，我想眺望地平线上的星星，我想要晚上吹丹德里恩歌谣的调调，我渴求战斗，渴求用剑一决胜负，渴求冒险，渴求胜利带给我的喜悦，并且我渴求孤孤单单的一个人，你能明白我的意思吗？”<br>   “明白，”杰洛特悲伤的笑了笑，“我当然明白，你是我的宿命，你是个猎魔人，你要去做你必须要做的，但我必须要告诉你一件事，你不能一走了之，尽管你在不停的尝试。”<br>   “我知道，”她回应到，紧紧的抱住他，“我也希望有一天，如果我不停的等待，如果我有足够的耐心，我大概也有像你这样的一天……如此好的一天……即使……”<br>   “即使什么，希瑞？”<br>   “我很丑，而且还有那样一道难看的伤疤……”<br>   “希瑞！”他打断她，“你是世上最漂亮的女孩……当然只是在叶之后。”<br>   “杰洛特……”<br>   “你不信的话，去问丹德里恩。”<br>   “杰洛特，我……”<br>   “说起来，他死哪里去了……”<br>   “我要去南方，”她打断了他，不敢直视他。“战后仍然不安定，那里的人们需要保护，我会派上用场的，还要去科洛奇……还有尼弗迦德，我和格威尔在那里还有未了结的事。”<br>   她突然沉默了，脸变得冷漠起来。绿色的眼睛眯了起来，嘴角挂满了仇恨。我记得，杰洛特，我还记得，就像现在一样。上一次他们并肩在吕思勋城堡作战。楼梯上已经血流成河，他们就站在血泊当中。狼和猫，两个冷血的杀人机器，非人的速度和非人的冷漠，围上来的尼弗迦德人慢慢的后退。一只出奇冷静的狼和一只出奇疯狂的猫，闪烁的刀锋，哭喊声，四处迸溅的鲜血，以及遍地凋零的生命……就像那样，就像上一次那样。<br>   希瑞将头发向后甩去，灰白的头发在太阳穴处一阵震荡。<br>   “我还用未竟之事，”她冷冷的说道，“为了<a href="http://witcher.huijiwiki.com/wiki/%E7%B1%B3%E5%B8%8C%E5%B0%94" target="_blank" rel="noopener">米希尔</a>,为了我的米希尔，我已经为她报了仇，但是只杀一个人是不够的。”<br>   <a href="http://witcher.huijiwiki.com/wiki/%E7%B1%B3%E5%B8%8C%E5%B0%94" target="_blank" rel="noopener">雷欧·邦纳特</a>，她杀了他，为她报了仇。希瑞啊希瑞，你现在已经处在深渊边缘，女儿，即使杀了上千人也换不回你的米希尔，要提防仇恨啊，那种堪比癌症的情感。<br>   “你要当心你自己啊。”他低沉的说。<br>   “我宁愿让别人当心，”她讽刺的笑了笑，“这样回报更多，也更加有意义。”<br>   我再也见不到她了，他想，如果她走了，我不会再见到她了。<br>   “还会再见的，”她出乎意料的回答道，脸上挂着一个女术士而非猎魔人的微笑。“还会再见的，杰洛特。”<br>   她如一个男孩般跑开了，敏捷的跳上马鞍。<br>   “架，卡尔比！！”<br>【以上对话涉及的人的确是后面小说中的人物，但是故事的发展稍微不太一样】<br>马蹄铁踏在路上，迸溅出火花。丹德里恩不知从哪里冒出来了，他把鲁特琴挂在肩上，腾出手来，一手拿着一大罐啤酒。</p><p>   “来，喝一杯”他说着，坐在他身边，“这对你有好处。”<br>   “我不太确定，叶妮芙警告我，如果他在我身上闻到酒味”<br>   “嚼些欧芹就行了，喝吧，你这妻管严。”</p><p>   他们静静的坐了好长时间，慢悠悠的喝着啤酒，丹德里恩叹了口气。<br>   “希瑞要走了，是吗？”<br>   “嗯。”<br>   “我觉得也是，杰洛特，听我说两句……”<br>   “丹德里恩，你还是闭嘴吧。”<br>   “哦。好吧。”<br>   他们又沉默了。厨房传来了一股烤鹿肉的香味，刺柏的味道很浓。<br>   “……结束了（Something ends），”杰洛特艰难的说，“都结束了。”<br>   “可不是这样，”诗人严肃的反驳道，“是开始了（Something begins）”</p><hr><h1 id="IX"><a href="#IX" class="headerlink" title="IX"></a>IX</h1><p>   下午是在一片哭声中度过的，一切都是从美之灵药开始的，这种灵药，更准确的说是一种软膏，在古老的习俗中，也被称作“格拉玛耶”，据说可以使女性变得更加漂亮，更加引人注目。在各个主妇的要求下，te准备了大量的药膏。于是在场的女士们开始按照习俗涂抹。但是，在锁死的门后传来了希瑞菈、莫娜、艾思娜和卡什卡的哭声，她们不允许使用格拉玛耶，只有大女儿莫丽恩才能享受这一殊荣。哭的最响的是卡什卡，在她的上一层，莉莉正在哇哇的哭，她是dan的女儿，因为她发现和大多数魔法物品一样，格拉玛耶对半身人不起作用，在花园中瞎逛的灵媒师只是嗅了嗅，可她不知道的是嗅上一口就提神醒脑的后果，酒醒之后她陷入了无尽的忧郁当中。城堡的西翼，里夫·卡尔迪米恩的女儿阿妮卡也哭了起来，她不知道格拉玛耶是要涂在眼睛下面的，却吃了那药膏，现在正在腹泻。希瑞也拿了她那一份，涂在了卡尔比的眼下。<br>   女祭司小爱若拉和尤妮德也哭了，因为叶妮芙拒绝穿她们为她精心制作的白色婚纱，甚至南尼克在一旁劝也没用，叶妮芙骂骂咧咧，还把盘子给摔了，大声喊着她穿上这玩意就像一个他妈的白衣处女，南尼克也生气了，大声骂着她的行为比三个该死处女还糟糕。叶妮芙也没有回骂回去，直接放了一道闪电，打穿了塔楼的屋顶。这一举措还是有好的一面的，突如其来的巨响让卡尔迪米恩的女儿一惊，竟然吓好了她的腹泻。<br>   又有人看见特莉丝和猎魔人艾斯卡尔溜进了花园的小亭子，两人还手牵着手，毫无疑问，这次两人都是本人，因为变形怪特里科正在和丹迪·比伯威特和金龙维纶特瑞坦梅斯喝酒。<br>   人们又仔仔细细的找了一遍，还是没找到那个自称是舒滕巴赫的侏儒。</p><hr><h1 id="X"><a href="#X" class="headerlink" title="X"></a>X</h1><p>   “叶……”<br>   她看上去心情激动，金色的宝冠下，她那黑色的波浪般的卷发，垂在肩头，乌黑亮丽。立起的衣领是白色棉织，而袖口却镶着黑色条纹，两者通过紫罗兰色的紧身上衣连在一起。<br>   “花，别忘了花”，特莉丝在一旁提醒道，她一身深蓝色的装扮，递给新娘一束白玫瑰，“哦，叶。我太开心了……”<br>   “特莉丝，亲爱的……”叶妮芙突然抽泣起来，两个女术士紧紧地拥抱在一起，轻吻着彼此的钻石耳环。<br>   “意思意思就行了”南尼克在一旁不耐烦的提醒道，抚平洁白的祭祀服上的褶皱。“走，我们去教堂，爱若拉，尤妮德，托着她的裙摆，否则她会在楼梯口摔死自己的。”<br>   叶妮芙走向杰洛特伸出，伸出戴着白色蕾丝手套的手，整理了杰洛特嵌着银边的黑色斗篷的衣领，杰洛特伸出胳膊挽住她。<br>   “杰洛特，”他在她耳边轻轻的说道，“我还是不敢相信。”<br>   “叶，”杰洛特低声的回答道，“我爱你。”<br>   “我知道。”叶妮芙喃喃道。</p><hr><h1 id="XI"><a href="#XI" class="headerlink" title="XI"></a>XI</h1><p>   “赫维格死哪里去了？”<br>   “不知道，”丹德里恩一边轻抚着他那身时髦上衣的扣子，一边回答道。<br>   “说起来，希瑞去哪了？”<br>   “不知道。”叶妮芙皱起眉头，吸了吸鼻子。“你那股欧芹味的道不错啊，丹德里恩，你改吃素了吗？”<br>   宾客们开始陆续入场，小小的礼拜堂变得拥挤起来，一身黑礼服的艾格罗瓦尔坐在闪着白光的美人鱼希恩娜兹身边。他们的身边是一群穿着米黄色，棕色衣服的半身人，亚尔潘和金龙维纶特瑞坦梅斯则浑身上下金光闪闪，菲斯奈特和多瑞格雷则是一身紫色装扮，皇家使团的各位使者则和他们各自的纹章保持着一致的色调，精灵和树精是一身绿色。而丹德里恩和他的朋友们则穿的花里胡哨，五颜六色的的衣服。<br>   “有人看见洛基了吗？”莫斯萨克问道。<br>   “洛基？”艾斯卡尔走了过来，顺着装饰着野鸡毛的帽子看向德鲁伊。“洛基和赫维格一起湖上捕鱼去了，我看见他们的船还在湖上，希瑞则是去叫他们回来。”<br>   “这是什么时候的事?”<br>   “有一会了”。<br>   “诅咒你们得瘟疫，这群该死的渔夫，”克拉茨·安·克莱特咒骂道，“他们这是钓鱼钓上头了，把正事给忘了，雷格纳，去吧他们叫回来。”<br>   “等一下，”布蕾恩一把推开想要吃她豆腐的丹德里恩，“我们需要跑的快的人，莫娜，卡什卡， Raenn’ess aen laeke, va!”<br>   “早就说了，”南尼克气得不行，“赫维格根本就不靠谱，不敬畏神灵的白痴还要让他负责？谁还赞成他继续做主婚人？”<br>   “他好歹是个国王，”杰洛特不确定的说道，“可能叫前国王更确切，但好歹是个国王”<br>   “万岁……”一个算命的听到国王两个字后职业本能的开始唱起歌来，幸好，旁边的鳄鱼杀手及时放倒了他。半身人们开始骚动起来，有人骂骂咧咧，还有人被别人锤了鼻子，变形怪特里科踩到了加德尼娅·比伯威特的裙子，她开始尖叫起来，灵媒师则无缘无故的抽泣了起来<br>   “要是在这么等下去，”叶妮芙紧紧地抓住花束，努力保持着微笑，“再等一会我就要吐血了，马上给我开始。”<br>   “不要乱动，叶，”特莉丝悄声说道，“紧身衣要裂开了。”<br>   “那个侏儒舒滕巴赫跑到哪里去了，”一个歌手叫喊道。<br>   “我们也不知道啊。”四个妓女异口同声的喊道。<br>   “狗娘养的，马上派个人去找他，”丹德里恩大喊到，“他是负责带花过来的，现在可怎么办，舒滕巴赫和花都不在这，这婚礼可怎么继续？”<br>   被派去寻找国王的树精姐妹尖叫着冲进婚礼大厅，洛基则紧随其后，身上又脏又湿，前额上破了一个大口子。<br>   “洛基，”克拉奇喊了起来，“什么情况？”<br>   “妈妈！！！！！！”卡什卡哭喊道。<br>   “Que’ss aen!，”布蕾恩抓住她的两个女儿，抚慰她们，用精灵语问道，”Que’ss aen que suecc’ss feal, caer me?”<br>   “我们的船翻了……”洛基上气不接下气的说道，“就在岸边，来了只大怪物！，我用船桨揍他，但是他就直接吞了…….吞了我的船桨！”<br>   “谁？什么东西？”<br>   “杰洛特，”布蕾恩喊道，“杰洛特，莫娜说那是一只cinarea”<br>   “一只巨水蝽!”猎魔人惊叫道，“艾斯卡尔，快把我的剑拿来！”<br>   【怪物出自《精灵之血》，按照时间上来看，这是后来作者才安排的。】<br>   “我的法杖呢，”多瑞格雷也喊了一声，“雷德克里夫，我的法杖在哪？”<br>   “希瑞！”洛基喊了一声，擦了擦额头的鲜血，“希瑞正在和那怪兽战斗！”<br>   “操蛋了，希瑞根本打不过一只巨水蝽！艾斯卡尔，把我的马也牵来”<br>   “等一下，”叶妮芙甩掉头上的宝冠，“我们用传送门，那样更快，多瑞格雷，特莉丝，雷德克里夫，把你们的手给我……”<br>   一阵沉默过后，又响起了尖叫声，赫维格国王出现在门口，浑身又湿又脏，但是全身完好。他身边则站着一个光头的年轻人，身上穿着一套闪闪发光奇怪的盔甲。希瑞则紧随他们之后，手上提着格维尔，浑身泥泞，衣服滴着水，头发蓬乱，一道恐怖的伤疤横在脸上，从太阳穴直到下巴，袖口下的衣服被撕烂了，鲜血直流。<br>   “希瑞！！”<br>   “我杀了它，”猎魔人女孩弱弱的说道，“我劈开了它的头。”<br>   希瑞几乎要倒下了，杰洛特，艾斯卡尔和丹德里恩簇拥上前把住她，但就是这样她也没放开她的剑。<br>   “又受伤了……”吟游诗人悲叹到，“又是伤到了脸，为什么她的命运就这么不堪……”<br>   叶妮芙高声尖叫，一把推开雅尔，这个独臂的年轻人正好站在叶妮芙和希瑞之间，希瑞身上的泥巴和鲜血弄脏了女术士的婚纱，但是她一点也不在意。叶妮芙用手指按住猎魔人女孩的脸，吟诵了了一个魔法咒语，在杰洛特看来，整个城堡都因为这个法术晃了一下，甚至太阳也暗淡了一秒。叶妮芙缓慢的把手指从希瑞脸上移开，众人惊叹起来，巨大，丑陋的伤口变成一条细细的红线，只有几滴血而已，希瑞倒在杰洛特怀中。<br>   “厉害！”多瑞格雷感叹道，“这可是大师的手笔。”<br>   “干得好，叶，”特莉丝静静的说道，而一旁的南尼克则哭了起来。<br>   叶妮芙笑了笑，眼睛向上一翻，晕了过去，杰洛特还是在她如丝带般倒下之前抱住了她。</p><hr><h1 id="XII"><a href="#XII" class="headerlink" title="XII"></a>XII</h1><p>   “杰洛特，冷静，”南尼克说，“别太激动，过一会就好了，她只是用力过猛，别那么紧张了……你知道她有多爱希瑞。”<br>   “我知道。”杰洛特抬起头，看着门口站着的那个穿着一身闪闪发光的奇怪盔甲的年轻人。<br>   “听着，孩子，现在回到礼堂，这里没你事了，只是告诉我，你是谁？”<br>   “我，我是加拉哈德。”年轻的骑士回答道，“我想……我想问下那位美丽勇敢的少女怎么样了？”<br>   “哪一个？”猎魔人笑道，“这里有两个，两个都是漂亮，勇敢的少女，尽管其中一个只是偶然才是的，你说的是哪一个？”<br>   年轻人的脸，明显红了，“年轻的那一位……”他回答道，“就是那个义无反顾跑去帮助渔王的那位。”<br>   “谁？”<br>   “他说的是赫维格，”南尼克插嘴道，“巨水蝽在赫维格和洛基捕鱼时攻击了他们的船，希瑞则冲向了巨水蝽，而这个小伙子正好在近旁，过去帮了希瑞。”<br>   “你帮了希瑞，”猎魔人满怀感激的看着这个年轻的骑士，“你叫什么来着……”<br>   “加拉哈德，请问这里是阿瓦隆，渔王的城堡吗？”<br>   【阿瓦隆：亚瑟王传说中的极乐世界】<br>   门开了，叶妮芙在特莉丝的搀扶下出现在门口，她的脸色苍白。<br>   “叶！”<br>   “我们去礼堂。”女术士平静的要求到。“客人们都等着呢。”<br>   “叶……我们不急，可以再迟些。”<br>   “即使是恶魔要带走我，我也要嫁给你，而且是现在！”<br>   “希瑞怎么样了？”<br>   “哪个希瑞？”，猎魔人女孩从叶妮芙身后冒出，她正在往脸上涂抹着格拉玛耶。<br>   “一切都好，杰洛特，不过是一道擦伤，我都没什么感觉。”<br>   加拉哈德单膝跪地，铠甲发出金属碰撞的咯吱声。<br>   “女神……”<br>   希瑞漂亮的绿眼睛睁圆了。<br>   “希瑞，请允许我……”猎魔人说道，“这个骑士，嗯，加拉哈德，你们应当彼此见过了，他当时帮了你一把。”<br>   希瑞脸红了，格拉玛耶开始生效了，细小的伤疤在红润的脸蛋上几乎看不见了。<br>   “女神，”加拉哈德喃喃的说道，“您是如此亲切，如此美丽，请允许我留下,我想……”<br>   “毫无疑问，他想成为你的骑士，希瑞，”特莉丝说道。<br>   希瑞优雅的欠身行礼，但始终一句话也没说。<br>   “客人还等着呢，”叶妮芙打断他们。“加拉哈德，我在我看来，你不仅是个勇敢的战士，而且还是有礼貌的小伙子，你和我的……我的女儿并肩作战，所以，在婚礼上你可以挽住她，希瑞，快去换一身裙子，杰洛特，整理整理的你的头发，把你的内衬塞回袖子里去，都出来了，十分钟之内我要在礼堂看见你们。”</p><hr><h1 id="XIII"><a href="#XIII" class="headerlink" title="XIII"></a>XIII</h1><p>  婚礼仪式无比的辉煌，夫人和女孩们感动的哭成一片，赫维格——是前国王，但仍然是个国王——主持的婚礼，来自凯尔莫罕的维瑟米尔和南尼克作为这对新婚夫妻的父母方，特莉丝和艾斯卡尔是证婚人，加拉哈德陪着希瑞，后者脸红的像一枝娇艳的牡丹。<br>  佩剑的人们把剑搭在了一起，支起一个架子。丹德里恩和他的朋友们则演奏者鲁特琴，唱着特意为这个时刻谱写的曲子，在菲斯奈特的红发女儿们和美人鱼希恩娜兹的优美的歌声的伴奏下，丹德里恩开始即兴的祝愿这对新婚夫妻幸福，好运，以及一个成功的新婚之夜，听到这话，叶妮芙娇嗔的给了他一脚。【这里和原著有冲突，美人鱼献祭了尾巴换了腿以后，就失去了声音】<br>  人们聚集在王座大厅，各就各位，叶妮芙和杰洛特坐在主席上，手上绑着婚礼纱带，他们微笑着回应各位嘉宾的祝福和祝酒词。<br>  昨晚还乱搞一气的客人们，今晚则彻底变了样，都在以一种文明的方式尽情享乐，在相当长的一段时间里竟然没有人喝醉，当然只有一个人例外，那就是可怜的独臂小伙子雅尔，他无法忍受在加拉哈德甜甜的注视下满脸通红的希瑞，不停的喝闷酒 。今晚也没人意外失踪，除了卡什卡，不久之后，在桌子底下看见了她，她趴在一直狗身上，睡得正香呢。<br>  吸取了前一晚的教训，洛史洛格的鬼魂们也没有再来捣乱，只有一个例外，那就是只剩下骨架和裹尸布的马洪，突然出现在艾格罗瓦尔,莫斯萨克和菲斯奈特身后，然而王子，男爵和德鲁伊正非常专注的讨论政治，甚至都没有注意到他，由于没有一个人鸟他，这个骨架非常的沮丧。他在桌子旁四处走动，冷不丁的用他的牙齿咬了特莉丝一口，而女术士正温柔的依偎在艾斯卡尔的手臂上，她优雅的举起了手，掰断了他的手指头，狗处理了掰断的指骨。<br>  “愿伟大的梅里特利女神保佑你们夫妻俩，”南尼克亲吻了叶妮芙，和杰洛特碰了碰杯。“但是你们可没少走弯路，不过可算是结了婚。我真的很高兴，希望希瑞也能跟你们一样，找到命中注定的那个人后，能痛快的定下终生。”<br>  “我觉得，”杰洛特看向被猎魔人女孩迷住的加拉哈德，“她已经找到一个了。”<br>  “你说的是那个不知从哪里来的怪人？”女祭司惊讶道，“他们之间是没有结果的，你有没有仔细观察过那个人？没有？那你现在看看他在干嘛，他现在正在向希瑞求爱，但是手却不停的摸索着桌子上的酒杯，这可不太正常，我实在想不明白希瑞看他就像看一张照片那样仔细，雅尔，他可不一样，这孩子有理性，懂礼貌……”<br>  “您那有理性，懂礼貌的加尔已经摔到桌子下面去了，”叶妮芙打断了女祭司，“南尼克，别说了，希瑞过来了。”<br>  灰发的猎魔人女孩坐在赫维格让出的椅子上，搂住女术士。<br>  “我要离开了。”她平静地说。<br>  “我知道，孩子。”<br>  “加拉哈德……加拉哈德打算跟着我，也不知道为什么，我大概不能阻止他吧，对吗？”<br>  “当然阻止不了，杰洛特！”叶妮芙的眼睛，在温暖的紫罗兰色调中闪闪发光，看着她的丈夫，“到桌边去，陪客人们说说话，你也可以稍微喝上一小杯，但是只能是一小杯，我想和我的女儿谈谈，这是女人之间的谈话。”<br>  杰洛特叹了口气。<br>  聚会的氛围上来了。丹德里恩的朋友们唱的小黄歌让卡尔迪米恩的女儿安尼卡满脸通红。醉醺醺的龙v紧紧的抱着喝的更醉的变形怪特里科，试图说服他，变成a王子然后和美人鱼上床可不是个太友好的行为。<br>  菲斯奈特的红发女儿们则为了取悦那些皇家的使者们尽情的展现她们美妙的身姿，而皇家的使者们也在尽他们的全力打动树精们，看他们表演，总有种在游乐场的错觉。亚尔潘齐格林，用带有浓重鼻音的嗓子向精灵凯瑞尔丹说他打小就想当个精灵。莫斯萨克大喊着政府药丸，而艾格罗瓦尔则极力反对，当然也没人知道他们说的是哪个政府，赫维格国王则对加德尼娅说他用马鬃绳钓上了条大鲤鱼，半身人只是梦游般的点了点头，并且时不时的拍打下旁边的丈夫叫他不要喝的太多。<br>  画廊里，两个算命的和鳄鱼杀手则在四处走动，想找到那个名字叫舒滕巴赫的侏儒，但是仍旧找不到【未见侏儒——我们仍未找到那天前来赴宴的那个名字叫做舒滕巴赫的侏儒】，芙蕾雅显然讨厌酒量不行的男人，于是就在这和那个女灵媒师喝赫尔特·斯凯尔特，两人都保持着一种高尚和严肃的静默，因为这是一场无声的战斗。<br>  杰洛特绕着桌子走了一圈，挨个和客人们碰了杯，客人们也拍着他的背，祝他幸福。最后他来到了加拉哈德和丹德里恩附近，加拉哈德盯着诗人的酒杯，嘟嘟囔囔的说着什么，而吟游诗人则眯着眼睛仔细听着。杰洛特打算一探究竟。<br>  “……于是我就上了船，”加拉哈德说，“船驶向那片薄雾，我得向您承认，丹德里恩大师，我那时候怕的不行……我承认我有时候会失去希望，就像这次，我觉得我的末日到了，我会死在那片无法穿透的薄雾中，然后太阳就出来了…..在湖面上闪烁，就好像…金子一般。然后在我前方就是…阿瓦隆，这里是阿瓦隆，对吗？”<br>  “不是，”丹德里恩一边给两人满上，一边回答道，“这是Schwemmland，可以翻译成沼泽地……先喝一杯吧，加拉哈德。”<br>  “这个城堡……一定是蒙萨尔瓦特，不是吗？”<br>  “可不是，这个城堡叫洛史洛格，我就从来没听说过什么蒙萨尔瓦特，孩子，如果我都没听说过的话，那就是没有的事了，年轻人，为新婚夫妇干一杯吧。”<br>  “干杯，丹德里恩大师，但是那位国王，他不是渔王吗？”<br>  “赫维格？哦，他是挺喜欢钓鱼的，这倒是真的，他以前喜欢打猎，但是在奥斯战役中伤了腿，然后就再也不能骑马了，但你也不能叫人家渔王，首先，这个名字太蠢了，其次，你这样会冒犯到赫维格的。”<br>  加拉哈德半晌没说话，只是晃动着杯子中剩下一半的酒，然后他深深地叹了口气，环顾四周。<br>  “他们是对的，”他低声说道，“这只是个传说，一个童话，一段幻象，简而言之，这就是个谎言，这就是一片普通的沼泽地而不是阿瓦隆，没有希望了。”【阿瓦隆跟这个地方外表差不多】<br>  “喂，喂，”诗人用手戳了戳他，“不要伤心，孩子，你忧郁个什么劲？你正在参加一场婚礼派对，所以要做到就是高兴点，喝喝酒，唱唱歌。你还年轻，还有大把时光。还有一辈子的路要走。”<br>  “一辈子？”骑士若有所思的重复道，“那又如何，丹德里恩大师，有什么开始了，还是说有什么结束了？”<br>  丹德里恩好奇的看了他一眼。<br>  “不，我可不知道，如果连我都不知道的话，那就没人知道了，所以结论就是吗，没什么要结束，也没什么要开始。”<br>  “我不明白。”<br>  “你明白也没什么用。”</p><p>  加拉哈德想了想，皱起眉。<br>  “那圣杯呢？”他最后问道，“圣杯到哪里去了？”<br>  “圣杯又是什么东西？”<br>  “是我们追寻的东西，”他解释道，悲伤的看着吟游诗人，“那是最重要的，没有它，我们的生命就没什么意义，没有它，我们的生命永远不完整。”<br>  吟游诗人紧闭双唇，以他那著名的神色看向骑士，眼神中充满睿智和诚恳。<br>  “你个傻蛋，”他回答道，“你一整晚都坐在你的‘圣杯’旁边。”<br>  【这段亚瑟王的圆桌骑士异世界穿越是真的秀】</p><hr><h1 id="XIV"><a href="#XIV" class="headerlink" title="XIV"></a>XIV</h1><p>  午夜时分的，当客人已经玩的上头时，杰洛特和叶妮芙从宴会中脱离出来，他们终于可以平和的看看对方。突然，门开了，强盗维辛来了，人们都称他作“抢劫柏”，维辛身长两米开外，留着及腰长的大胡子，鼻子的颜色和形状都像萝卜，一直肩膀上扛着他那根著名的大棍子“牙签”，另一只肩膀上则扛着个大袋子。<br>  杰洛特和叶妮芙都认识这位“抢劫柏”。他俩谁也没想着要邀请他来。毫无疑问，这又是丹德里恩干的好事。<br>  “维辛，欢迎你，”女术士微笑道，“能记住我们真的是太好了，来，请坐”<br>  强盗倚着牙签，恭敬的鞠了一躬<br>  “祝你们快快乐乐，早生贵子”，他大声说道，“祝你们夫妻俩百年好合……我在说什么？两百年，该死的，应该是两百年。啊，我很高兴，杰洛特，还有叶妮芙夫人，我就知道你们会结婚的，尽管你们总是像,像狗一样打来打去。他妈的，我在说什么鸟话……”<br>  “欢迎，欢迎，维辛。”猎魔人说着，向着他能找到的最大的杯子倒酒，“为我们的健康干杯，你是打哪来的？有谣言说你进了监狱。”<br>  “他们把我给放了。”“抢劫柏”喝了一大口，叹了口气，“你们怎么说的，他妈的，保释？然后我就到这里来了，亲爱的，我给你们带了礼物，打开看看。”<br>  “这什么玩意，”女术士高声叫道，看着那个大口袋，里面的东西还在不停的动。<br>  “我是在路上看见的，”，抢劫柏回答道，“我是在花坛那里找见的，那有个光着屁股的石头女人，你知道的，就是有鸽子在上面……”<br>  “这袋子里到底是什么？”<br>  “哦，是一个，嗯，怎么说呢，一个小恶魔。这就当做新婚礼物了。你们这有放养动物的地方吗，没有？好吧，你们可以把他做成标本，然后挂着走廊上，人们看见了会惊叹的。但是我得告诉你，这他妈的是个骗子，他一直说自己叫舒滕巴赫。”</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>java多线程学习6（CAS，原子类，CountDownLatch，CyclicBarrier，Semaphore）</title>
      <link href="/2019/07/02/ithreading-6/"/>
      <url>/2019/07/02/ithreading-6/</url>
      
        <content type="html"><![CDATA[<p><img src="/upload/pasted-361.png" width="70%"></p><a id="more"></a><h1 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>CAS通常是指（Compare And Swap或 Compare And Set）是硬件操作系统级别提供的具有原子性的原语指令，利用它可以在多线程中取得和同步一样的效果。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>基于<a href="https://www.junglezero.top/2019/04/23/%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81-1/#more">乐观锁</a>。以i++为例子举例，一般情况下是三步操作，分别是取值，+操作，存值，但是如果是多线程操作，就会存在线程安全的问题，对于CAS，首先获取旧的预期值，在准备保存时，和当前内存中的值进行对比（compare）,如果两个值相等，说明这个值没有发生改变，此时就存入新值（swap），如果发生改变，说明这个值已经被别的线程修改，此时当前线程不会进行操作，或者循环几个周期</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>因为加锁花销太大了（悲观锁）<br>结合上一个多线程的学习（AQS）,包括下面的原子类型，就可以发现实际上CAS是java并发包主要应用的一个方法</p><h2 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h2><h3 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h3><p>既然是基于乐观锁，那么势必会有ABA问题，所谓ABA问题，就是在当前线程准备存储过程中，如果这个值从A变成了B又变回了A，则对于当前线程，值是没有发生改变的，虽然从结果来看没什么影响，但是这实际上是个潜在的问题，解决的方法在上面的那个链接已经说明，就是添加一个版本号，或者时间戳</p><h3 id="自旋式循环"><a href="#自旋式循环" class="headerlink" title="自旋式循环"></a>自旋式循环</h3><p>当存值失败时，就有可能进入循环状态（自旋），如果多次失败，就会有效率上的问题</p><h1 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h1><p>java并发包下提供了java.util.concurrent.atomic包，包中包含了16个类（java8）</p><p><img src="/upload/pasted-339.png" alt="upload successful"></p><h1 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>摘录自API文档</p><blockquote><p>A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.</p></blockquote><blockquote><p>A CountDownLatch is initialized with a given count. The await methods block until the current count reaches zero due to invocations of the countDown() method, after which all waiting threads are released and any subsequent invocations of await return immediately. This is a one-shot phenomenon – the count cannot be reset. If you need a version that resets the count, consider using a CyclicBarrier.</p><p>A CountDownLatch is a versatile synchronization tool and can be used for a number of purposes. A CountDownLatch initialized with a count of one serves as a simple on/off latch, or gate: all threads invoking await wait at the gate until it is opened by a thread invoking countDown(). A CountDownLatch initialized to N can be used to make one thread wait until N threads have completed some action, or some action has been completed N times.</p><p>A useful property of a CountDownLatch is that it doesn’t require that threads calling countDown wait for the count to reach zero before proceeding, it simply prevents any thread from proceeding past an await until all threads could pass. </p></blockquote><p>从上面的描述中，得知几个事情</p><ul><li>这是一个计数器，用来使一个或者多个线程等待其他线程完成其操作</li><li>使用一个数值初始化，调用await使【当前线程】进入等待状态，当被等待的线程完成其任务时调用countDown()使计数–，直到减到0时【当前线程】不再等待</li><li>可以把countDownLatch理解为一个开关或者，只有【被等待线程】调用countDown()，await的线程才能“从大门进去”</li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>文档中给到了一个Driver-Worker的实例<br>使用两个CountDownLatch，第一个在driver准备就绪之前，阻止worker执行，第二个使driver等待直到worker执行完<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver</span> </span>&#123; <span class="comment">// ...</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     CountDownLatch startSignal = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">     CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="comment">// create and start threads</span></span><br><span class="line">       <span class="keyword">new</span> Thread(<span class="keyword">new</span> Worker(startSignal, doneSignal)).start();</span><br><span class="line"></span><br><span class="line">     doSomethingElse();            <span class="comment">// driver先执行</span></span><br><span class="line">     startSignal.countDown();      <span class="comment">// 调用countDown使startSignal归0</span></span><br><span class="line">     doSomethingElse();</span><br><span class="line">     doneSignal.await();           <span class="comment">// 使driver等着worker的线程执行完（等待doneSignal归0）</span></span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch startSignal;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line">   Worker(CountDownLatch startSignal, CountDownLatch doneSignal) &#123;</span><br><span class="line">     <span class="keyword">this</span>.startSignal = startSignal;</span><br><span class="line">     <span class="keyword">this</span>.doneSignal = doneSignal;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">//等待startSignal归0</span></span><br><span class="line">       startSignal.await();</span><br><span class="line">       doWork();</span><br><span class="line">       <span class="comment">//worker线程每执行完，调用countdown，是doneSignal减1</span></span><br><span class="line">       doneSignal.countDown();</span><br><span class="line">     &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;&#125; <span class="comment">// return;</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>文档中还给到了一个另一个实例：<br>将一个问题分成多个部分，然后每个线程运行一部分<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Driver2</span> </span>&#123; <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    CountDownLatch doneSignal = <span class="keyword">new</span> CountDownLatch(N);</span><br><span class="line">    Executor e = ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) <span class="comment">// create and start threads</span></span><br><span class="line">      e.execute(<span class="keyword">new</span> WorkerRunnable(doneSignal, i));</span><br><span class="line"></span><br><span class="line">    doneSignal.await();           <span class="comment">// wait for all to finish</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkerRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> CountDownLatch doneSignal;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> i;</span><br><span class="line">  WorkerRunnable(CountDownLatch doneSignal, <span class="keyword">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">this</span>.doneSignal = doneSignal;</span><br><span class="line">    <span class="keyword">this</span>.i = i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      doWork(i);</span><br><span class="line">      doneSignal.countDown();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123;&#125; <span class="comment">// return;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>和上面的CountDownLatch类似，但还是有区别的</p><blockquote><p>A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point. CyclicBarriers are useful in programs involving a fixed sized party of threads that must occasionally wait for each other. The barrier is called cyclic because it can be re-used after the waiting threads are released.</p><p>A CyclicBarrier supports an optional Runnable command that is run once per barrier point, after the last thread in the party arrives, but before any threads are released. This barrier action is useful for updating shared-state before any of the parties continue.</p></blockquote><p>这个强调的是“使一套线程等待彼此，直到所有的线程都到达了检查点（barrier point）”，相比于上面的CountDownLatch，它不需要执行线程去调用变化（countdown）</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>有两个构造方法<br><img src="/upload/pasted-340.png" alt="upload successful"><br>第一个方法的参数是这一组需要互相等待的线程的数量<br>当输入的数量大于需要运行的线程的数量时，由于到达检查点的线程（运行await）的数量小于预定的，所以会一直等待<br>当输入的参数小于需要进行互相等待的数量时，先到者优先，没有抢到的只能顺序运行<br>第二个方法还多一个Runnable对象，包括上面也说到了，这个线程的参数是指当所有的线程到达检查点时，并不会立刻运行，会先跑传入的参数的这个线程，这个线程完了，其他到检查点的线程才会解除等待状态</p><p><img src="/upload/pasted-341.png" alt="upload successful"><br>调用await时，有几个情况会使等待线程不再等待：</p><ul><li>最后一个线程到达检查点</li><li>超时</li><li>别的线程打断当前线程</li><li>别的线程打断别的等待线程（到达检查点的线程）</li><li>别的线程超时</li><li>对于当前的检查点，别的线程调用了它的reset方法</li></ul><p>CylicBarrier比countDownLatch优越在reset上，因为可以重复使用</p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>假设有一个使用场景，需要计算四个地方的值，然后进行汇总，计算部分的值单开一个线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建线程数量为4的检查点，四个线程到达检查点后，运行this的run</span></span><br><span class="line">    <span class="keyword">private</span> CyclicBarrier c=<span class="keyword">new</span> CyclicBarrier(<span class="number">4</span>,<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">//假设有4个需要计算的表，启动四个线程</span></span><br><span class="line">    <span class="keyword">private</span> Executor executor= Executors.newFixedThreadPool(<span class="number">4</span>);</span><br><span class="line">    <span class="comment">//保存结果</span></span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;String,Integer&gt; results=<span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">count</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//假设计算结果为1</span></span><br><span class="line">                    results.put(Thread.currentThread().getName(),<span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="comment">//计算完毕后，在检查点等着</span></span><br><span class="line">                        c.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(<span class="string">"结果计算完毕，"</span>+Thread.currentThread().getName()+<span class="string">"溜了"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;String,Integer&gt; sheet:results.entrySet())&#123;</span><br><span class="line">            result+=sheet.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"输出计算结果："</span>+result);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        CyclicBarrierTest c=<span class="keyword">new</span> CyclicBarrierTest();</span><br><span class="line">        c.count();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：</p><p><img src="/upload/pasted-342.png" alt="upload successful"></p><h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><h2 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h2><p>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。</p><blockquote><p>A counting semaphore. Conceptually, a semaphore maintains a set of permits. Each acquire() blocks if necessary until a permit is available, and then takes it. Each release() adds a permit, potentially releasing a blocking acquirer. However, no actual permit objects are used; the Semaphore just keeps a count of the number available and acts accordingly.</p></blockquote><p>关键点：Semaphore维持一个“许可证”（permit）来控制线程访问数量。通过acquire()获取许可，通过release()释放<br>要想理解其方法的实现，一定要知道一个重要的事情，这个工具是基于AQS实现的，通过观察源码可以发现不管是公平不公平的acquire还是release，都是基于内部自己继承<a href="https://www.junglezero.top/2019/06/28/va%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%88Lock%EF%BC%8CAQS-ReentrantLock%EF%BC%89/">AQS</a>的一个内部类Sync实现的</p><h2 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h2><p>构造方法：<br><img src="/upload/pasted-343.png" alt="upload successful"><br>两个参数，一个是许可证的数量，再一个是允不允许公平（AQS那一套），默认不公平的</p><p><img src="/upload/pasted-344.png" alt="upload successful"><br>如果还有许可证就马上返回，许可证数量减1，如果没有许可证则进入阻塞序列直到有其他线程调用release或者被打断</p><h2 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h2><p>文档中给到了一个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pool</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_AVAILABLE = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Semaphore available = <span class="keyword">new</span> Semaphore(MAX_AVAILABLE, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getItem</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    available.acquire();</span><br><span class="line">    <span class="keyword">return</span> getNextAvailableItem();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putItem</span><span class="params">(Object x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (markAsUnused(x))</span><br><span class="line">      available.release();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not a particularly efficient data structure; just for demo</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> Object[] items = ... whatever kinds of items being managed</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span>[] used = <span class="keyword">new</span> <span class="keyword">boolean</span>[MAX_AVAILABLE];</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> Object <span class="title">getNextAvailableItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!used[i]) &#123;</span><br><span class="line">         used[i] = <span class="keyword">true</span>;</span><br><span class="line">         <span class="keyword">return</span> items[i];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// not reached</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">markAsUnused</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;</span><br><span class="line">      <span class="keyword">if</span> (item == items[i]) &#123;</span><br><span class="line">         <span class="keyword">if</span> (used[i]) &#123;</span><br><span class="line">           used[i] = <span class="keyword">false</span>;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125; <span class="keyword">else</span></span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个例子实际上并没有很显示的应用在多线程中，但还是有一点要说的，要是看的仔细，就会发现acquire，release方法并没有外面上锁，这是因为Semaphore，内部维持着一个实现AQS的内部类</p><p>当许可证的数量设置为1时，这时Semaphore就成为了一个互斥锁，但是和一般的锁不同的是这个Semaphore可以被其他线程调用（因为Semaphore没有拥有者的概念），这个特性可以用在解决死锁上（文档中说的）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreLockTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SemaphoreLock lock=<span class="keyword">new</span> SemaphoreLock();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">3</span>;i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                            lock.lock();</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">"抢到了锁"</span>);</span><br><span class="line">                            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">"释放了锁"</span>);</span><br><span class="line">                        lock.unlock();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreLock</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Semaphore semaphore=<span class="keyword">new</span> Semaphore(<span class="number">1</span>);</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;</span><br><span class="line">            semaphore.release();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> semaphore.tryAcquire();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>字符串专题</title>
      <link href="/2019/06/30/StringProblemsCollection/"/>
      <url>/2019/06/30/StringProblemsCollection/</url>
      
        <content type="html"><![CDATA[<h1 id="顺时针打印矩阵"><a href="#顺时针打印矩阵" class="headerlink" title="顺时针打印矩阵"></a>顺时针打印矩阵</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>题目描述：输入一个矩阵，按照从外向里以顺时针打印出每一个数字，例如：输入如下矩阵，则依次打印出的数字为：1、2、3、4、8、12、16、15、14、13、9、5、6、7、11、10.<br><img src="/upload/pasted-336.png" alt="upload successful"></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Problem20</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] array=&#123;</span><br><span class="line">                &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;,&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;,&#123;<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;,&#123;<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>,<span class="number">16</span>&#125;&#125;;</span><br><span class="line">        Problem20 testCircle=<span class="keyword">new</span> Problem20();</span><br><span class="line">        testCircle.printMatixClockwisely(array);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printMatixClockwisely</span><span class="params">(<span class="keyword">int</span>[][] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(array==<span class="keyword">null</span>)<span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(array[<span class="number">0</span>].length&gt;start*<span class="number">2</span>&amp;&amp;array.length&gt;start*<span class="number">2</span>)&#123;</span><br><span class="line">            printOneCircle(array,start);</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printOneCircle</span><span class="params">(<span class="keyword">int</span>[][] array, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=start;i&lt;array[<span class="number">0</span>].length-start;i++)&#123;</span><br><span class="line">            System.out.print(array[start][i]+<span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(array.length-<span class="number">1</span>-start&gt;start)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=start+<span class="number">1</span>;i&lt;array.length-start-<span class="number">1</span>;i++)&#123;</span><br><span class="line">                System.out.print(array[i][array[<span class="number">0</span>].length-<span class="number">1</span>-start]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(array[<span class="number">0</span>].length-start-<span class="number">1</span>&gt;start &amp;&amp;</span><br><span class="line">                array.length-start-<span class="number">1</span>&gt;start)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=array.length-start-<span class="number">1</span>;i&gt;start;i--)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(array[array.length-start-<span class="number">1</span>][i]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(array.length-<span class="number">1</span>-start&gt;start &amp;&amp;</span><br><span class="line">                array[<span class="number">0</span>].length-<span class="number">1</span>-start&gt;start)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=array.length-start-<span class="number">1</span>;i&gt;start;i--)</span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(array[i][start]+<span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h1><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>主要的思路就是定住一个排后面的,对于定住这个问题，用到了递归的思想<br><img src="/upload/pasted-355.png" alt="upload successful"><br>这里存在的问题就是如果后面有重复的字母，就不在进行交换</p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串的排列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">permutation</span><span class="params">(String a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] chars=a.toCharArray();</span><br><span class="line">    permutationHelper(chars,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">permutationHelper</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> current)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (current==chars.length-<span class="number">1</span>)</span><br><span class="line">        System.out.println(chars.toString());</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=current;i&lt;chars.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isExisted(chars,current,i))&#123;</span><br><span class="line">                swap(chars,current,i);</span><br><span class="line">                permutationHelper(chars,current+<span class="number">1</span>);</span><br><span class="line">                swap(chars,i,current);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> current, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> temp=chars[i];</span><br><span class="line">    chars[i]=chars[current];</span><br><span class="line">    chars[current]=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isExisted</span><span class="params">(<span class="keyword">char</span>[] chars, <span class="keyword">int</span> current, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k=current;k&lt;i;k++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (chars[k]==chars[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="字符串的组合"><a href="#字符串的组合" class="headerlink" title="字符串的组合"></a>字符串的组合</h1><h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><p>{a,b,c}要求输出{a,b,c,ab,ac,bc,abc}。</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>可以将题目分成小问题来理解，1个字符的组合+2个字符的组合+3个字符的组合，因此我们只要找到一般的方法，即从n个字符中找m个字符的组合就可以了。<br>我们可以把n个字符分成两部分，第一个字符和其他所有字符。如果组合里包含第一个字符，则下一步在剩余的字符里选取m-1个字符；如果组合里不包含第一个字符，则下一步在剩余的n-1个字符里选取m个字符，从中可以看出又是个递归的过程。</p><h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="keyword">char</span>[] array)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= array.length ; i ++ )</span><br><span class="line">            combination(array,<span class="number">0</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">combination</span><span class="params">(<span class="keyword">char</span>[] strArr, <span class="keyword">int</span> begin, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(stack);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (begin &gt;= strArr.length) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//把第一个字符放入组合中,在剩余的字符中选取num-1个字符</span></span><br><span class="line">            stack.push(strArr[begin]);</span><br><span class="line">            combination(strArr, begin + <span class="number">1</span>, num - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//组合里不包含第一个字符,则下一步在剩余的字符中选取num个字符</span></span><br><span class="line">            stack.pop();</span><br><span class="line">            combination(strArr, begin + <span class="number">1</span>, num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>因为组合问题，比如3个元素的组合就有2^3-1种，所以不妨给他们进行编号，就像上面的问题，从a——abc一次编号为 001——111。1就代表该位置出现字符。例如：001-&gt;c,010-&gt;b,101-&gt;ac……，所以原题就是要求输出”001”-“111”这2^n-1个组合对应的字符串。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">　　String s = <span class="string">"abc"</span>;</span><br><span class="line">　　ArrayList&lt;String&gt; result = combineString(s);</span><br><span class="line">　　<span class="keyword">for</span>(String r : result)&#123;</span><br><span class="line">　　　　System.out.println(r);</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;String&gt; <span class="title">combineString</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">　　<span class="keyword">int</span> len = s.length();</span><br><span class="line">　　ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(); </span><br><span class="line">　　<span class="keyword">int</span> count = (<span class="keyword">int</span>) (Math.pow(<span class="number">2</span>, len));</span><br><span class="line">　　<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; count; ++i)&#123;</span><br><span class="line">　　　　String temp = <span class="string">""</span>;</span><br><span class="line">　　　　String str = Integer.toBinaryString(i);</span><br><span class="line">　　　　<span class="keyword">while</span>(str.length() &lt; len)&#123;</span><br><span class="line">　　　　　　str = <span class="string">"0"</span> + str;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; str.length(); ++j)&#123;</span><br><span class="line">　　　　　　<span class="keyword">if</span>(str.charAt(j) == <span class="string">'1'</span>)&#123;</span><br><span class="line">　　　　　　　　temp += s.charAt(j);</span><br><span class="line">　　　　　　&#125;</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　list.add(temp);</span><br><span class="line">　　&#125;</span><br><span class="line">　　<span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>树（二叉树）专题</title>
      <link href="/2019/06/30/%E9%A2%98/"/>
      <url>/2019/06/30/%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="基本结构（实现）"><a href="#基本结构（实现）" class="headerlink" title="基本结构（实现）"></a>基本结构（实现）</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode left;</span><br><span class="line">    TreeNode right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h1><h2 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h2><p>是一种先访问根结点，再访问左子节点，再访问右子结点的访问方式，用递归方式很容易实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">preorderTraverse</span><span class="params">(TreeNode t)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(t!=<span class="keyword">null</span>)&#123;</span><br><span class="line">         System.out.println(t.val+<span class="string">""</span>);</span><br><span class="line">         preorderTraverse(t.left);</span><br><span class="line">         preorderTraverse(t.right);</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环的方法实现：<br>对于当前结点，首先访问，然后访问其左子结点，若其左子结点为空（即“访问到头了”）就要访问其右子结点，这个时候，就需要栈来记录其没有访问右子结点的父结点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preOrderTraverse2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    TreeNode pNode = root;</span><br><span class="line">    <span class="comment">//栈不为空表示还有没有访问右结点的父结点存在</span></span><br><span class="line">    <span class="keyword">while</span> (pNode != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">//若结点不为空，直接访问，下一步循环其左结点，并将该结点入栈，以便访问其右结点</span></span><br><span class="line">        <span class="keyword">if</span> (pNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.print(pNode.val+<span class="string">"  "</span>);</span><br><span class="line">            stack.push(pNode);</span><br><span class="line">            pNode = pNode.left;</span><br><span class="line">            <span class="comment">//左节点为空，即“到头”了，此时要从栈中找出没有访问右结点的父结点，出栈，访问其右结点</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//pNode == null &amp;&amp; !stack.isEmpty()</span></span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            pNode = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h2><p>先访问左子结点，再访问父结点，再访问右子结点<br>递归方式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderTraverse1</span><span class="params">(TreeNode node)</span> </span>&#123;  </span><br><span class="line">       <span class="keyword">if</span> (node != <span class="keyword">null</span>) &#123;  </span><br><span class="line">           inOrderTraverse1(root.left);  </span><br><span class="line">           System.out.print(root.val+<span class="string">"  "</span>);  </span><br><span class="line">           inOrderTraverse1(root.right);  </span><br><span class="line">       &#125;  </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>非递归方式：和之前差不多，只不过这次是在某个结点出栈的时候进行访问<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inOrderTraverse2</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    LinkedList&lt;TreeNode&gt; stack = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    TreeNode pNode = root;</span><br><span class="line">    <span class="keyword">while</span> (pNode != <span class="keyword">null</span> || !stack.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.push(pNode);</span><br><span class="line">            pNode = pNode.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">//pNode == null &amp;&amp; !stack.isEmpty()</span></span><br><span class="line">            TreeNode node = stack.pop();</span><br><span class="line">            System.out.print(node.val + <span class="string">"  "</span>);</span><br><span class="line">            pNode = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h2><p>先访问左结点，再放问右结点，最后访问根结点<br>递归方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postOrderTraverse1</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">        postOrderTraverse1(root.left);</span><br><span class="line">        postOrderTraverse1(root.right);</span><br><span class="line">        System.out.print(root.val+<span class="string">"  "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>非递归方法：<br>初始根结点入栈，对于栈顶结点，如果其有左子结点或者右子结点且没有被访问，则按照右子结点，左子结点的顺序入栈，如果是叶子节点名，则出栈，直接访问，并用标记<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h1 id="常见题目"><a href="#常见题目" class="headerlink" title="常见题目"></a>常见题目</h1><h2 id="根据前序和中序遍历构造二叉树（假设不包含重复数字）"><a href="#根据前序和中序遍历构造二叉树（假设不包含重复数字）" class="headerlink" title="根据前序和中序遍历构造二叉树（假设不包含重复数字）"></a>根据前序和中序遍历构造二叉树（假设不包含重复数字）</h2><p>重点：</p><p><img src="/upload/pasted-317.png" alt="upload successful"></p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span>[] in)</span> </span>&#123;</span><br><span class="line">TreeNode root = reConstructBinaryTree(pre, <span class="number">0</span>, pre.length - <span class="number">1</span>, in, <span class="number">0</span>, in.length - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前序遍历&#123;1,2,4,7,3,5,6,8&#125;和中序遍历序列&#123;4,7,2,1,5,3,8,6&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">reConstructBinaryTree</span><span class="params">(<span class="keyword">int</span>[] pre, <span class="keyword">int</span> startPre, <span class="keyword">int</span> endPre, <span class="keyword">int</span>[] in, <span class="keyword">int</span> startIn, <span class="keyword">int</span> endIn)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (startPre &gt; endPre || startIn &gt; endIn) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">TreeNode root = <span class="keyword">new</span> TreeNode(pre[startPre]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = startIn; i &lt;= endIn; i++)</span><br><span class="line"><span class="keyword">if</span> (in[i] == pre[startPre]) &#123;</span><br><span class="line">root.left = reConstructBinaryTree(pre, startPre + <span class="number">1</span>, startPre + i - startIn, in, startIn, i - <span class="number">1</span>);</span><br><span class="line">root.right = reConstructBinaryTree(pre, i - startIn + startPre + <span class="number">1</span>, endPre, in, i + <span class="number">1</span>, endIn);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树的子结构"><a href="#树的子结构" class="headerlink" title="树的子结构"></a>树的子结构</h2><h3 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h3><p>输入两棵二叉树A，B，判断B是不是A的子结构。（ps：我们约定空树不是任意一个树的子结构）</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先在树1中找到树2的根结点，然后在比较左子树和右子树</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树的子结构</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasSubTree</span><span class="params">(TreeNode t1,TreeNode t2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result=<span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1!=<span class="keyword">null</span>&amp;&amp;t2!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1==t2)</span><br><span class="line">            result=checkSubTree(t1,t2);</span><br><span class="line">        <span class="keyword">if</span> (!result)</span><br><span class="line">            hasSubTree(t1.left,t2);</span><br><span class="line">        <span class="keyword">if</span> (!result)</span><br><span class="line">            hasSubTree(t1.right,t2);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkSubTree</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t2==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1.val!=t2.val)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> checkSubTree(t1.left,t2.left)&amp;&amp;checkSubTree(t1.right,t2.right);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="镜像二叉树"><a href="#镜像二叉树" class="headerlink" title="镜像二叉树"></a>镜像二叉树</h2><h3 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h3><p>输入一个二叉树，输出它的镜像</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p><img src="/upload/pasted-335.png" alt="upload successful"><br>通过示例图可以看出，输出镜像结点的方法就是从根结点开始，交换左右孩子…不断递归知道到达叶子结点<br>需要注意的是递归</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">mirrorTree</span> <span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    TreeNode temp = root.left;</span><br><span class="line">    root.left=root.right;</span><br><span class="line">    root.right=temp;</span><br><span class="line"></span><br><span class="line">    mirrorTree(root.left);</span><br><span class="line">    mirrorTree(root.right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h2><h3 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h3><p>输入一个树，判断是不是对称的，即这棵树是不是和他的镜像树相同</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>注意找到递归的突破口</p><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对称二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode t1)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isSymmetrical(t1,t1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t1==<span class="keyword">null</span>&amp;&amp;t2==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1==<span class="keyword">null</span>||t2==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (t1.val!=t2.val)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (t1.left.val==t2.right.val)&amp;&amp;(t1.right.val==t2.left.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非递归方法，用栈实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSymmetric</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    stack.push(root.left);</span><br><span class="line">    stack.push(root.right);</span><br><span class="line">    <span class="keyword">while</span> (!stack.empty()) &#123;</span><br><span class="line">        TreeNode n1 = stack.pop(), n2 = stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (n1 == <span class="keyword">null</span> &amp;&amp; n2 == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (n1 == <span class="keyword">null</span> || n2 == <span class="keyword">null</span> || n1.val != n2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        stack.push(n1.left);</span><br><span class="line">        stack.push(n2.right);</span><br><span class="line">        stack.push(n1.right);</span><br><span class="line">        stack.push(n2.left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="从上到下打印二叉树"><a href="#从上到下打印二叉树" class="headerlink" title="从上到下打印二叉树"></a>从上到下打印二叉树</h1><h2 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h2><p>从上到下打印一棵二叉树，同一层的结点按照从左到右的顺序打印</p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>利用一个队列放下一系列需要打印的结点</p><h2 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从上到下打印二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTreeTopToBottom</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; q=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>||root.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        q.add(root.left);</span><br><span class="line">        q.add(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(root.val);</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span> (q.peek().left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            q.add(q.peek().left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q.peek().right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            q.add(q.peek().right);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(q.poll().val);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="分行从上到下打印二叉树"><a href="#分行从上到下打印二叉树" class="headerlink" title="分行从上到下打印二叉树"></a>分行从上到下打印二叉树</h1><h2 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h2><p>上一道题的一种变式</p><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>添加两个变量，分别对当前行和下一行计数</p><h2 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTreeTopToBottomByLine</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; q=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    q.add(root);</span><br><span class="line">    <span class="keyword">int</span> currentLine=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> nextLine=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span> (q.peek().left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            q.add(q.peek().left);</span><br><span class="line">            nextLine++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q.peek().right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            q.add(q.peek().right);</span><br><span class="line">            nextLine++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(q.poll().val);</span><br><span class="line">        currentLine--;</span><br><span class="line">        <span class="keyword">if</span> (currentLine==<span class="number">0</span>)&#123;</span><br><span class="line">            System.out.println();</span><br><span class="line">            currentLine=nextLine;</span><br><span class="line">            nextLine=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="之字形打印二叉树"><a href="#之字形打印二叉树" class="headerlink" title="之字形打印二叉树"></a>之字形打印二叉树</h1><h2 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h2><p>请实现一个函数按照之字形打印二叉树，即第一行按照从左往右的顺序，第二行从右往左，第三行从左往右依次类推</p><h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><p>有了上两道题的铺垫，我们对于这道题，首先可以看出这也需要逐行的分析，也就是偶数行需要从左往右打印，奇数行需要从右向左（从第0行开始），同样也用队列当做容器</p><h2 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h2><p>LeetCode第103题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">    Queue&lt;TreeNode&gt; queue=<span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>) <span class="keyword">return</span> ans;</span><br><span class="line">    queue.offer(root);</span><br><span class="line">    <span class="keyword">int</span> level=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">int</span> num=queue.size();</span><br><span class="line">        List&lt;Integer&gt; list=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;num;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(level%<span class="number">2</span>!=<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (queue.peek().left!=<span class="keyword">null</span>)queue.offer(queue.peek().left);</span><br><span class="line">                <span class="keyword">if</span> (queue.peek().right != <span class="keyword">null</span>) queue.offer(queue.peek().right);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (queue.peek().right != <span class="keyword">null</span>) queue.offer(queue.peek().right);</span><br><span class="line">                <span class="keyword">if</span> (queue.peek().left!=<span class="keyword">null</span>)queue.offer(queue.peek().left);</span><br><span class="line">            &#125;</span><br><span class="line">            list.add(queue.poll().val);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.add(list);</span><br><span class="line">        level++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="二叉搜索树的后续遍历序列"><a href="#二叉搜索树的后续遍历序列" class="headerlink" title="二叉搜索树的后续遍历序列"></a>二叉搜索树的后续遍历序列</h1><h2 id="描述-6"><a href="#描述-6" class="headerlink" title="描述"></a>描述</h2><p>输入一个整数数组，判断该数组是不是某二叉搜素树后续遍历的结果，假设输入的数都各不相同</p><h2 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h2><p>应当抓住<a href="https://www.junglezero.top/2018/02/14/%EF%BC%882%EF%BC%89/">二叉搜索树</a>的特点,即对于根结点，左子树的结点数值都比根结点小，右子树的结点数值都比根结点大，然后递归的方式寻找</p><h2 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树的后续遍历序列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSquenceOfBST</span><span class="params">(<span class="keyword">int</span> [] sequence, <span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sequence==<span class="keyword">null</span>||sequence.length==<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> root=sequence[sequence.length-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i=start;</span><br><span class="line">    <span class="comment">//确定左子树边界</span></span><br><span class="line">    <span class="keyword">for</span> (;i&lt;end;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (sequence[i]&gt;root)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> j=i;</span><br><span class="line">    <span class="comment">//在右子树中，如果存在小于根结点的值，则说明这个序列不是个搜索树的后续遍历</span></span><br><span class="line">    <span class="keyword">for</span> (;j&lt;end;j++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (sequence[j]&lt;root)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归判断左子树</span></span><br><span class="line">    <span class="keyword">boolean</span> left=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        left=isSquenceOfBST(sequence,<span class="number">0</span>,i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//递归判断右子树</span></span><br><span class="line">    <span class="keyword">boolean</span> right=<span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (i&lt;end)&#123;</span><br><span class="line">        right=isSquenceOfBST(sequence,i,end);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left&amp;&amp;right;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树中和为某一值的路径"><a href="#二叉树中和为某一值的路径" class="headerlink" title="二叉树中和为某一值的路径"></a>二叉树中和为某一值的路径</h1><h2 id="描述-7"><a href="#描述-7" class="headerlink" title="描述"></a>描述</h2><p>输入一个二叉树和一个整数，打印二叉树中结点的值的和为输入整数的所有路径，从根结点一直到尾结点为一个路径</p><h2 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h2><p>这个题很明显想到用回溯法，用一个栈来存放结点</p><h2 id="实现-8"><a href="#实现-8" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉树中和为某一值的路径</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findPath</span><span class="params">(TreeNode root,<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root==<span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">       <span class="keyword">int</span> curentNum=<span class="number">0</span>;</span><br><span class="line">       findPath(root,num,stack,curentNum);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findPath</span><span class="params">(TreeNode root, <span class="keyword">int</span> num, Stack&lt;Integer&gt; stack, <span class="keyword">int</span> curentNum)</span> </span>&#123;</span><br><span class="line">       curentNum+=root.val;</span><br><span class="line">       stack.push(root.val);</span><br><span class="line">       <span class="keyword">if</span> (root.left==<span class="keyword">null</span>&amp;&amp;root.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">           <span class="keyword">if</span> (curentNum==num)&#123;</span><br><span class="line">               System.out.println(<span class="string">"找到一条路径："</span>);</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> n:stack)&#123;</span><br><span class="line">                   System.out.print(n+<span class="string">" "</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (root.left!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           findPath(root.left,num,stack,curentNum);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (root.right!=<span class="keyword">null</span>)&#123;</span><br><span class="line">           findPath(root.right,num,stack,curentNum);</span><br><span class="line">       &#125;</span><br><span class="line">       stack.pop();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="二叉搜素树和双向链表"><a href="#二叉搜素树和双向链表" class="headerlink" title="二叉搜素树和双向链表"></a>二叉搜素树和双向链表</h1><h2 id="描述-8"><a href="#描述-8" class="headerlink" title="描述"></a>描述</h2><p>输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求<br>不能创建任何新的结点，只能调整树中结点指针的指向</p><h2 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h2><p>还是要抓住二叉搜素树的特点<br><img src="/upload/pasted-349.png" alt="upload successful"><br>中序遍历恰好可以使一棵二叉搜索树按顺序输出<br><img src="/upload/pasted-350.png" alt="upload successful"><br>按照中序遍历的顺序，当我们遍历到根结点时，它的左子树已经转换成一个排序的好的双向链表了，并且处在链表中最后一个的结点是当前值最大的结点。我们把值为8的结点和根结点链接起来，10就成了最后一个结点，接着我们就去遍历右子树，并把根结点和右子树中最小的结点链接起来。</p><h2 id="实现-9"><a href="#实现-9" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">Convert</span><span class="params">(TreeNode pRootOfTree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pRootOfTree == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(pRootOfTree.left == <span class="keyword">null</span> &amp;&amp; pRootOfTree.right == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> pRootOfTree;</span><br><span class="line">    </span><br><span class="line">    TreeNode leftNode = Convert(pRootOfTree.left);</span><br><span class="line">    TreeNode curNode = leftNode;</span><br><span class="line">    <span class="comment">//找到左子树最右边的叶子节点</span></span><br><span class="line">    <span class="keyword">while</span>(curNode != <span class="keyword">null</span> &amp;&amp; curNode.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        curNode = curNode.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接根节点与左子树的最右叶子节点</span></span><br><span class="line">    <span class="keyword">if</span>(leftNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        pRootOfTree.left = curNode;</span><br><span class="line">        curNode.right = pRootOfTree;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//右子树的最左叶子节点</span></span><br><span class="line">    TreeNode rightNode = Convert(pRootOfTree.right);</span><br><span class="line">    <span class="comment">//连接根节点与右子树的最左叶子节点</span></span><br><span class="line">    <span class="keyword">if</span>(rightNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        pRootOfTree.right = rightNode;</span><br><span class="line">        rightNode.left = pRootOfTree;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//考虑没有左子树的情况</span></span><br><span class="line">    <span class="keyword">return</span> leftNode==<span class="keyword">null</span>?pRootOfTree:leftNode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="序列化二叉树"><a href="#序列化二叉树" class="headerlink" title="序列化二叉树"></a>序列化二叉树</h1><h2 id="描述-9"><a href="#描述-9" class="headerlink" title="描述"></a>描述</h2><p>请实现两个函数，分别用来序列化和反序列化二叉树</p><h2 id="分析-9"><a href="#分析-9" class="headerlink" title="分析"></a>分析</h2><p>二叉树的序列化是指：把一棵二叉树按照某种遍历方式的结果以某种格式保存为字符串，从而使得内存中建立起来的二叉树可以持久保存。序列化可以基于先序、中序、后序、层序的二叉树遍历方式来进行修改，序列化的结果是一个字符串，序列化时通过 某种符号表示空节点（$）</p><p>二叉树的反序列化是指：根据某种遍历顺序得到的序列化字符串结果str，重构二叉树。</p><h2 id="实现-10"><a href="#实现-10" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">Serialize</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">    StringBuilder b=<span class="keyword">new</span> StringBuilder();</span><br><span class="line">    circleSerialize(root,b);</span><br><span class="line">    <span class="keyword">return</span> b.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">circleSerialize</span><span class="params">(TreeNode root, StringBuilder b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="keyword">null</span>)</span><br><span class="line">        b.append(<span class="string">"$,"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前序遍历</span></span><br><span class="line">    b.append(root.val+<span class="string">","</span>);</span><br><span class="line">    circleSerialize(root.left,b);</span><br><span class="line">    circleSerialize(root.right,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反序列化（根据前序遍历结果）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> TreeNode <span class="title">DeSeriablize</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">   String[] s= str.split(<span class="string">","</span>);</span><br><span class="line">   <span class="keyword">int</span> index=-<span class="number">1</span>;</span><br><span class="line">   <span class="keyword">return</span> DeSeriablizeCore(str,index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> TreeNode <span class="title">DeSeriablizeCore</span><span class="params">(String str, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    String[]s=str.split(<span class="string">","</span>);</span><br><span class="line">    TreeNode node=<span class="keyword">null</span>;</span><br><span class="line">    index++;</span><br><span class="line">    <span class="keyword">if</span> (!s[index].equals(<span class="string">"$"</span>)) &#123;</span><br><span class="line">        node = <span class="keyword">new</span> TreeNode(Integer.parseInt(s[index]));</span><br><span class="line">        node.left=DeSeriablizeCore(str,index);</span><br><span class="line">        node.right=DeSeriablizeCore(str,index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> [object Object] </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程学习5（Lock，AQS，ReentrantLock，ReentrantReadWriteLock，Condition）</title>
      <link href="/2019/06/28/va%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%88Lock%EF%BC%8CAQS-ReentrantLock%EF%BC%89/"/>
      <url>/2019/06/28/va%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%88Lock%EF%BC%8CAQS-ReentrantLock%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><img src="/upload/pasted-362.png" width="70%"></p><a id="more"></a><h1 id="Lock-接口"><a href="#Lock-接口" class="headerlink" title="Lock 接口"></a>Lock 接口</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Java程序是靠synchronized关键字实现锁功能的，而Java SE 5之后，并发包中新增<br>了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized关键字类似的同步功<br>能，只是在使用时需要显式地获取和释放锁。虽然它缺少了（通过synchronized块或者方法所提<br>供的）隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以<br>及超时获取锁等多种synchronized关键字所不具备的同步特性</p><p>相比于Synchronized，Lock具有以下几个特性</p><p><img src="/upload/pasted-331.png" alt="upload successful"></p><h2 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h2><h3 id="void-lock-void-unlock"><a href="#void-lock-void-unlock" class="headerlink" title="void lock(),void unlock()"></a>void lock(),void unlock()</h3><p>这两个方法一个是上锁，一个是解锁<br>基本相当于synchronized关键字，具体使用方法如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">lock.lock();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="void-lockInterruptibly-throws-InterruptedException"><a href="#void-lockInterruptibly-throws-InterruptedException" class="headerlink" title="void lockInterruptibly() throws InterruptedException;"></a>void lockInterruptibly() throws InterruptedException;</h3><p>这个方法可以中断的获取锁，这就是和synchronized（lock()）很大的一个不同，即在抢锁的过程中可以中断该线程</p><p>演示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">validLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"Thread-"</span>+Thread.currentThread().getName()+<span class="string">"takes the synlock"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">        e.printStackTrace();;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>   <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String arg[])</span></span>&#123;</span><br><span class="line">    Thread t1=<span class="keyword">new</span> Thread()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            validLock();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Thread t2 =<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            validLock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t2.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个例子中，线程2是不会响应中断的</p><p>然而<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">validLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">"Thread-"</span>+Thread.currentThread().getName()+<span class="string">"takes the synlock"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">        e.printStackTrace();;</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>   <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String arg[])</span></span>&#123;</span><br><span class="line">    Thread t1=<span class="keyword">new</span> Thread()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                validLock();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    Thread t2 =<span class="keyword">new</span> Thread()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                validLock();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t2.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个实例中。t2会响应中断</p><h3 id="tryLock"><a href="#tryLock" class="headerlink" title="tryLock()"></a>tryLock()</h3><p>通过这个方式可以非阻塞的获取锁，即，即使抢不到锁，该线程也不会进入block状态，tryLock()的返回值是boolean,获取锁成功返回true，没获取锁返回false</p><p>具体用法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">TestTryLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lock.tryLock())&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"抢不到锁，溜了溜了（反正绝对不堵着）"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="boolean-tryLock-long-time-TimeUnit-unit-throws-InterruptedException"><a href="#boolean-tryLock-long-time-TimeUnit-unit-throws-InterruptedException" class="headerlink" title="boolean tryLock(long time, TimeUnit unit) throws InterruptedException;"></a>boolean tryLock(long time, TimeUnit unit) throws InterruptedException;</h3><p>这个就是超时获取锁的体现，如果在指定时间内没有获取锁，就退出，在这个指定的时间内，也可以中断</p><h3 id="Condition-newCondition"><a href="#Condition-newCondition" class="headerlink" title="Condition newCondition();"></a>Condition newCondition();</h3><p>用来创建一个基于当前同步器的Condition对象，下文会介绍Condition</p><h1 id="AQS-AbstractQueuedSynchronizer"><a href="#AQS-AbstractQueuedSynchronizer" class="headerlink" title="AQS(AbstractQueuedSynchronizer)"></a>AQS(AbstractQueuedSynchronizer)</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>队列同步器AbstractQueuedSynchronizer（以下简称同步器），是用来构建锁或者其他同步组<br>件的基础框架，它使用了一个int成员变量（一个atomic int value）表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作，所以说AQS是JUC锁的灵魂所在</p><h2 id="各种概念"><a href="#各种概念" class="headerlink" title="各种概念"></a>各种概念</h2><h3 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h3><p>同步器依赖内部的同步队列（一个FIFO双向队列）来完成同步状态的管理，当前线程获取<br>同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node）并将其<br>加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再<br>次尝试获取同步状态。</p><p>同步器包含了两个节点类型的引用，一个指向头节点，而另一个指向尾节点。<br>试想一下，当一个线程成功地获取了同步状态（或者锁），其他线程将无法获取到同步状态，转<br>而被构造成为节点并加入到同步队列中，而这个加入队列的过程必须要保证线程安全，因此同步器提供了一个基于CAS的设置尾节点的方法：compareAndSetTail(Node expect,Node<br>update)，它需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式<br>与之前的尾节点建立关联</p><p><img src="/upload/pasted-332.png" alt="upload successful"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="独占锁的的实现"><a href="#独占锁的的实现" class="headerlink" title="独占锁的的实现"></a>独占锁的的实现</h3><h4 id="我们要做的"><a href="#我们要做的" class="headerlink" title="我们要做的"></a>我们要做的</h4><p>在API文档中，提到这么一句</p><blockquote><p>Subclasses should be defined as non-public internal helper classes that are used to implement the synchronization properties of their enclosing class. </p></blockquote><p>也就是说在使用上，要把AQS的继承类写在阻塞队列的内部，作为一个内部类出现<br>官方文档中还提到：<br>要想实现一个自定义同步器，就要实现以下几种方法，并且对于线程的状态，运用 getState(), setState(int) and/or compareAndSetState(int, int): </p><ul><li>tryAcquire(int)</li><li>tryRelease(int)</li><li>tryAcquireShared(int)</li><li>tryReleaseShared(int)</li><li>isHeldExclusively(</li></ul><p>API文档中也给了一个非重入式互斥独占锁的实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要自定义的锁</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 上文提到的内部类</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">     <span class="comment">// Reports whether in locked state</span></span><br><span class="line">     <span class="comment">//返回是否独占当前锁（0表示为占用锁，1表示锁已经被占用）</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Acquires the lock if state is zero</span></span><br><span class="line">     <span class="comment">//状态为0时尝试获取锁</span></span><br><span class="line">     <span class="comment">//重点要实现的方法</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//意思是传入的accauires的值必须要是1，要是不是1就退出了</span></span><br><span class="line">       <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">       <span class="comment">//这是一个原子操作</span></span><br><span class="line">       <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">         <span class="comment">//如果成功将状态从0变成了1，说明抢到锁，并且排他的（Exclusive）占用这把锁（独占）</span></span><br><span class="line">         <span class="comment">//并不用考虑这两个动作会不会发生同步问题，因为该方法是accquire调用的，其内部已经实现了某种竞争机制</span></span><br><span class="line">         setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Releases the lock by setting state to zero</span></span><br><span class="line">     <span class="comment">//将状态设为0来释放锁</span></span><br><span class="line">     <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// Otherwise unused</span></span><br><span class="line">       <span class="keyword">if</span> (getState() == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">       <span class="comment">//将独占锁的线程设置为空</span></span><br><span class="line">       setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">       <span class="comment">//将状态设置为0</span></span><br><span class="line">       setState(<span class="number">0</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Provides a Condition</span></span><br><span class="line">     <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> ConditionObject(); &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// Deserializes properly</span></span><br><span class="line">     <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">       s.defaultReadObject();</span><br><span class="line">       setState(<span class="number">0</span>); <span class="comment">// reset to unlocked state</span></span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//上面就是几个重要方法的实现，具体使用如下</span></span><br><span class="line">   <span class="comment">// The sync object does all the hard work. We just forward to it.</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//调用Accquire</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>                </span>&#123; sync.acquire(<span class="number">1</span>); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>          </span>&#123; <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>              </span>&#123; sync.release(<span class="number">1</span>); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> Condition <span class="title">newCondition</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> sync.newCondition(); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span>         </span>&#123; <span class="keyword">return</span> sync.isHeldExclusively(); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasQueuedThreads</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> sync.hasQueuedThreads(); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     sync.acquireInterruptibly(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">       <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> sync.tryAcquireNanos(<span class="number">1</span>, unit.toNanos(timeout));</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h4 id="细节理解"><a href="#细节理解" class="headerlink" title="细节理解"></a>细节理解</h4><h5 id="acquire"><a href="#acquire" class="headerlink" title="acquire()"></a>acquire()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryAcquire(int arg):线程安全的获取同步状态<br>acquireQueued(addWaiter(Node.EXCLUSIVE), arg)：构造同步节点（独占式<br>Node.EXCLUSIVE，同一时刻只能有一个线程成功获取同步状态）并通过addWaiter(Node node)<br>方法将该节点加入到同步队列的尾部，最后调用acquireQueued(Node node,int arg)方法，使得该<br>节点以“死循环”的方式获取同步状态<br>…<br>。。。<br>…<br>。。。</p><p><img src="/upload/pasted-333.png" alt="upload successful"></p><h3 id="共享锁的实现"><a href="#共享锁的实现" class="headerlink" title="共享锁的实现"></a>共享锁的实现</h3><p>一个例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwinsLock</span> <span class="keyword">implements</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">//依然是内部类的方式实现</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">    <span class="comment">//状态用“0,1,2”进行标记</span></span><br><span class="line">        Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count must large than zero."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(count);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//实现tryAcquireShared</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> reduceCount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();<span class="keyword">int</span> newCount = current - reduceCount;</span><br><span class="line">                <span class="keyword">if</span> (newCount &lt; <span class="number">0</span> || compareAndSetState(current,</span><br><span class="line">                        newCount)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> newCount;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//实现tryReleaseShared</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> returnCount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="keyword">int</span> newCount = current + returnCount;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, newCount)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他接口方法略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是一个允许最多两个线程同时访问的共享锁，因而实现的方法是shared那些。同步器会先计算出获取后的同步状态，然后通过CAS确保状态的正确设置，当tryAcquireShared(int reduceCount)方法返回值大于等于0时，当前线程才获取同步状态，对于上层的TwinsLock而言，则表示当前线程获得了锁</p><h1 id="ReentrantLock（重入锁）"><a href="#ReentrantLock（重入锁）" class="headerlink" title="ReentrantLock（重入锁）"></a>ReentrantLock（重入锁）</h1><h2 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h2><p>根据其名字，可以知道，这个锁是可“重复使用”的（synchronized也是支持重入的），一般情况下（如上文实现的互斥独占锁），如果让一个已经上锁的线程尝试再次上锁，那么它就会被自己所阻塞，最终进入阻塞状态它实际上，是Lock的一种实现，另外，还涉及到一个公平的问题</p><h2 id="细节分析"><a href="#细节分析" class="headerlink" title="细节分析"></a>细节分析</h2><h3 id="重进入的实现"><a href="#重进入的实现" class="headerlink" title="重进入的实现"></a>重进入的实现</h3><p>锁的获取：<br>识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理重进入的过程</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>锁的释放：<br>重复获取锁n次，就需要重复释放锁n次（有一个计数器）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//每次释放，都要做减法，只有状态值为0才能释放出去，允许其他线程抢</span></span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="公平和不公平"><a href="#公平和不公平" class="headerlink" title="公平和不公平"></a>公平和不公平</h3><p>所谓公平和不公平，是指能不按照运行的绝对时间获取锁，即FIFO<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasQueuedPredecessors</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// The correctness of this depends on head being initialized</span></span><br><span class="line">    <span class="comment">// before tail and on head.next being accurate if the current</span></span><br><span class="line">    <span class="comment">// thread is first in queue.</span></span><br><span class="line">    Node t = tail; <span class="comment">// Read fields in reverse initialization order</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    <span class="keyword">return</span> h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == <span class="keyword">null</span> || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过观察我们可以返现相比于上文的nofair方法，这个方法多了一个hasQueuedPredecessors()，上面也附上了这个方法的实现，可以了解到“公平”就是通过同步器队列实现的，查看当前线程是否有前置结点，如果没有前置结点，则获得锁。<br>有一点要记住：默认的ReentrantLock中的require是非公平的方法，因为其效率更高</p><h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p>读写锁在之前已经自己实现过一次了<br><a href="https://www.junglezero.top/2019/04/16/%E7%BA%BF%E7%A8%8B%E8%AF%BB%E5%86%99%E9%94%81%E5%88%86%E7%A6%BB/">自己实现的读写锁</a><br>根据以前的总结，读写锁需要注意的是：读进程和读进程可以同时进行，但是读进程和写进程是互斥的</p><p>API文档介绍了这个类的几个特性：</p><ul><li>支持公平不公平的抢锁（默认是不公平的）</li><li>可重入</li><li>可以从写锁降级至读锁，但不能从读锁升级为写锁</li><li>获取过程可以被打断</li><li>支持Condition</li></ul><h3 id="细节分析-1"><a href="#细节分析-1" class="headerlink" title="细节分析"></a>细节分析</h3><h4 id="读写状态的确定"><a href="#读写状态的确定" class="headerlink" title="读写状态的确定"></a>读写状态的确定</h4><p>实现时，采用了一个整型变量进行维护读写两种状态</p><p><img src="/upload/pasted-334.png" alt="upload successful"><br>当前同步状态值为S，写状态等于S&amp;0x0000FFFF（将高16位全部抹去），读状态等于S&gt;&gt;&gt;16（无符号补0右移<br>16位）。当写状态增加1时，等于S+1，当读状态增加1时，等于S+(1&lt;&lt;16)，也就是<br>S+0x00010000。<br>S不等于0时，当写状态（S&amp;0x0000FFFF）等于0时，则读状态（S&gt;&gt;&gt;16）大于0，即读锁已被获取。</p><h4 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 存在读锁或者当前获取线程不是已经获取写锁的线程</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(c + acquires);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (writerShouldBlock() || !compareAndSetState(c, c + acquires)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setExclusiveOwnerThread(current);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读写锁要确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞</p><h4 id="读锁"><a href="#读锁" class="headerlink" title="读锁"></a>读锁</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">int</span> nextc = c + (<span class="number">1</span> &lt;&lt; <span class="number">16</span>);</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; c)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp; owner != Thread.currentThread())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS保证）增加读状态，成功获取读锁。</p><h4 id="写锁降级"><a href="#写锁降级" class="headerlink" title="写锁降级"></a>写锁降级</h4><p>API文档中给到了一个降级锁的实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CachedData</span> </span>&#123;</span><br><span class="line">  Object data;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="keyword">boolean</span> cacheValid;</span><br><span class="line">  <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">processCachedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    rwl.readLock().lock();</span><br><span class="line">    <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">      <span class="comment">// Must release read lock before acquiring write lock</span></span><br><span class="line">      rwl.readLock().unlock();</span><br><span class="line">      rwl.writeLock().lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Recheck state because another thread might have</span></span><br><span class="line">        <span class="comment">// acquired write lock and changed state before we did.</span></span><br><span class="line">        <span class="keyword">if</span> (!cacheValid) &#123;</span><br><span class="line">          data = ...</span><br><span class="line">          cacheValid = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Downgrade by acquiring read lock before releasing write lock</span></span><br><span class="line">        rwl.readLock().lock();</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        rwl.writeLock().unlock(); <span class="comment">// Unlock write, still hold read</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      use(data);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      rwl.readLock().unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><p>API文档已经说明了适合使用在数据量较大的容器，读操作比写操作更多的情况下，也给到了一个实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RWDictionary</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Data&gt; m = <span class="keyword">new</span> TreeMap&lt;String, Data&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReentrantReadWriteLock rwl = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Lock r = rwl.readLock();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Lock w = rwl.writeLock();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Data <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    r.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.get(key); &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; r.unlock(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> String[] allKeys() &#123;</span><br><span class="line">    r.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.keySet().toArray(); &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; r.unlock(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Data <span class="title">put</span><span class="params">(String key, Data value)</span> </span>&#123;</span><br><span class="line">    w.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="keyword">return</span> m.put(key, value); &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; w.unlock(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    w.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123; m.clear(); &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; w.unlock(); &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意，读锁和写锁都有最大值的限制：65535</p><h2 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><p>用官方文档的话来说，Condition的作用就是用来替代object监视器的wait，notify，notifyAll方法，并且，A Condition instance is intrinsically bound to a lock.要想生成一种condition，调用lock方法的new condition创建。<br>下面用一个官方API文档中写的例子讲解用法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoundedBuffer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">  <span class="keyword">final</span> Condition notFull  = lock.newCondition(); </span><br><span class="line">  <span class="keyword">final</span> Condition notEmpty = lock.newCondition(); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> Object[] items = <span class="keyword">new</span> Object[<span class="number">100</span>];</span><br><span class="line">  <span class="keyword">int</span> putptr, takeptr, count;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Object x)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (count == items.length)</span><br><span class="line">        notFull.await();</span><br><span class="line">      items[putptr] = x;</span><br><span class="line">      <span class="keyword">if</span> (++putptr == items.length) putptr = <span class="number">0</span>;</span><br><span class="line">      ++count;</span><br><span class="line">      notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">        notEmpty.await();</span><br><span class="line">      Object x = items[takeptr];</span><br><span class="line">      <span class="keyword">if</span> (++takeptr == items.length) takeptr = <span class="number">0</span>;</span><br><span class="line">      --count;</span><br><span class="line">      notFull.signal();</span><br><span class="line">      <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个例子实现的是一个有界缓存，类似于<a href="https://www.junglezero.top/2019/03/29/a%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%883%EF%BC%89/">生产者/消费者</a>，当缓存不为空时，消费者就可以拿取数据，当缓存不满时，生产者就可以放入数据，唯一不同的是这里的锁不是synchronized，而监视器用的也不是object</p><h3 id="细节分析-2"><a href="#细节分析-2" class="headerlink" title="细节分析"></a>细节分析</h3><p>一个Condition包含一个FIFO等待队列，队列中的结点都包含一个线程的引用，如果一个线程调用了Condition.await()方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态，对于一个Lock（同步器），其包含一个阻塞队列和多个等待队列（一个Condition对应一个）</p><h4 id="等待await"><a href="#等待await" class="headerlink" title="等待await"></a>等待await</h4><p><img src="/upload/pasted-337.png" alt="upload successful"><br>该方法的线程成功获取了锁的线程，也就是同步队列中的首节点，该方法会将当前线程构造成节点并加入等待队列中，然后释放同步状态，唤醒同步队列中的后继节点，然后当前线程会进入等待状态。<br>等待队列中的节点被唤醒，则唤醒节点的线程开始尝试获取同步状态。如果不是通过其他线程调用Condition.signal()方法唤醒，而是对等待线程进行中断，则会抛出InterruptedException。</p><h4 id="通知signal"><a href="#通知signal" class="headerlink" title="通知signal"></a>通知signal</h4><p><img src="/upload/pasted-338.png" alt="upload successful"></p>]]></content>
      
      
      
        <tags>
            
            <tag> java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表专题</title>
      <link href="/2019/06/24/%E4%B8%93%E9%A2%98/"/>
      <url>/2019/06/24/%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="在O-1-删除链表中的结点"><a href="#在O-1-删除链表中的结点" class="headerlink" title="在O(1)删除链表中的结点"></a>在O(1)删除链表中的结点</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>给定单链表的头指针和一个节点指针，定义一个函数在O(1)时间删除该节点</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>一般的链表删除结点都是从头结点遍历，找到要删除的结点然后进行删除，但是这个题目由于给了要删除结点的位置，就可以采取一些别的措施<br><img src="/upload/pasted-325.png" alt="upload successful"><br>这里的一个思路就是看重了结点的值：把要删除结点的下一个结点的值赋给要删除的结点，此时在删除要删除结点的下一个结点（如c）<br>但是还要注意特殊情况：</p><ul><li>要删除的结点是尾结点：此时只能从头结点顺序遍历，然后找到尾结点的前一个结点，然后再删除</li><li>要删除的链表只有一个结点，直接将头结点设为空</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除链表中的结点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">DeleteNode</span><span class="params">(ListNode first,ListNode deleteNode)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        first=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (deleteNode.next==<span class="keyword">null</span>)&#123;</span><br><span class="line">        ListNode l=first;</span><br><span class="line">        <span class="keyword">while</span> (l.next!=deleteNode)&#123;</span><br><span class="line">            l=l.next;</span><br><span class="line">        &#125;</span><br><span class="line">        l.next=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    deleteNode.val=deleteNode.next.val;</span><br><span class="line">    deleteNode.next=deleteNode.next.next;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链表中倒数第K个结点"><a href="#链表中倒数第K个结点" class="headerlink" title="链表中倒数第K个结点"></a>链表中倒数第K个结点</h1><h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><p>输入一个链表，输出该链表中倒数第k个结点。</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>一般思路：向后找n-k+1个结点，需要两次遍历，第一次遍历找到n<br>更好的想法：两个指针，第一个指针首先移动k-1然后第二指针开始从头移动，此时两个指针同时移动，当第一个指针到达尾结点时，第二个指针所指就是要找到点<br>但是仍然要注意一些特殊的情况：</p><ul><li>输入的头结点为空：结果返回null</li><li>链表数小于k:无意义，结果返回null</li><li>k为0:无意义，结果返回null</li></ul><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">findKthNodeInLinkedList</span><span class="params">(ListNode head,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (head==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    ListNode Ahead=head;</span><br><span class="line">    ListNode Behind=head;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k-<span class="number">1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (Ahead.next!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            Ahead=Ahead.next;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (Ahead!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        Ahead=Ahead.next;</span><br><span class="line">        Behind=Behind.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Behind;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="链表中环的入口结点"><a href="#链表中环的入口结点" class="headerlink" title="链表中环的入口结点"></a>链表中环的入口结点</h1><h2 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h2><p>输入一个链表如果有环，返回其入口结点</p><h2 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h2><p>第一步：确定链表有环：用两个指针，一个一次移动一步，另一个一次移动两步，若两个指针在移动中相等，则证明有环<br>第二步，找到环的长度：从两个指针相遇的地方开始，再次回到这个点的计数就是环的长度<br>第三步，找到入口，在知道了环的长度以后，就和上面的题一样了</p><h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//链表中环的入口结点</span></span><br><span class="line">    <span class="function">ListNode <span class="title">findEntryInCircle</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode slow=head;</span><br><span class="line">        ListNode fast=head;</span><br><span class="line">        ListNode meetingNode=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用快慢指针判断是否有环</span></span><br><span class="line">        <span class="keyword">while</span> (slow!=<span class="keyword">null</span>&amp;&amp;fast!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            fast=fast.next.next;</span><br><span class="line">            <span class="comment">//记录相遇结点</span></span><br><span class="line">            <span class="keyword">if</span> (slow==fast)</span><br><span class="line">                meetingNode=slow;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//fast到了null时，一定无环</span></span><br><span class="line">        <span class="keyword">if</span> (fast==<span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> circleLen=<span class="number">1</span>;</span><br><span class="line">        slow=slow.next;</span><br><span class="line">        <span class="comment">//从相遇结点出发，再次回到相遇结点，计数，找出环的长度</span></span><br><span class="line">        <span class="keyword">while</span> (slow!=meetingNode)&#123;</span><br><span class="line">            slow=slow.next;</span><br><span class="line">            circleLen++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//两个指针，一个先走n（环的长度），当两个指针相遇时，就是环的入口</span></span><br><span class="line">        ListNode Ahead=head;</span><br><span class="line">        ListNode Behind=head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;circleLen;i++)&#123;</span><br><span class="line">            Ahead=Ahead.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (Ahead!=Behind)&#123;</span><br><span class="line">            Ahead=Ahead.next;</span><br><span class="line">            Behind=Behind.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Ahead;</span><br><span class="line">.</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h1><h2 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h2><p>输入一个链表，反转链表后，输出新链表的表头。</p><h2 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h2><p>设置三个指针，head为当前节点，pre为当前节点的前一个节点，next为当前节点的下一个节点，需要pre和next的目的是让当前节点从pre-&gt;head-&gt;next1-&gt;next2变成pre<-head next1->next2的过程中，用pre让节点反转所指方向，next节点保存next1节点防止链表断开<br>仍然要注意特殊输入</-head></p><h2 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反转链表</span></span><br><span class="line"> <span class="function">ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span></span>&#123;</span><br><span class="line">     ListNode ReverseHead=<span class="keyword">null</span>;</span><br><span class="line">     ListNode node=head;</span><br><span class="line">     ListNode pre=<span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">while</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">         <span class="comment">//先获取当前结点的下一个结点</span></span><br><span class="line">         ListNode Next=node.next;</span><br><span class="line">         <span class="comment">//若下一个结点为空，则证明到头了</span></span><br><span class="line">         <span class="keyword">if</span> (Next==<span class="keyword">null</span>)</span><br><span class="line">             ReverseHead=node;</span><br><span class="line">         <span class="comment">//修改当前结点的下一个结点</span></span><br><span class="line">         node.next=pre;</span><br><span class="line">         <span class="comment">//当前结点成为新的pre</span></span><br><span class="line">         pre=node;</span><br><span class="line">         <span class="comment">//下一个结点成为新的当前结点</span></span><br><span class="line">         node=Next;</span><br><span class="line">         </span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ReverseHead;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h1 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h1><h2 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h2><p>输入两个单调递增的链表，输出两个链表合成后的链表，当然我们需要合成后的链表满足单调不减规则。</p><h2 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h2><p>注意处理两个链表为空的情况</p><h2 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//合并两个排序链表</span></span><br><span class="line"><span class="function">ListNode <span class="title">Merge</span><span class="params">(ListNode l1,ListNode l2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2==<span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    ListNode node1=l1;</span><br><span class="line">    ListNode node2=l2;</span><br><span class="line">    ListNode MergeList =<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (l1.val&gt;l2.val)&#123;</span><br><span class="line">        MergeList=l1;</span><br><span class="line">        MergeList.next=Merge(l1.next,l2);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        MergeList=l2;</span><br><span class="line">        MergeList.next=Merge(l1,l2.next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> MergeList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="复杂链表的复制"><a href="#复杂链表的复制" class="headerlink" title="复杂链表的复制"></a>复杂链表的复制</h1><h2 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h2><p>实现函数复制一个复杂链表。在复杂链表中，每个结点除了有一个 next，指针指向下一个结点外，还有一个指向链表中任意结点或 null。</p><h2 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h2><p>照猫画虎法，<br>先在每个结点后生成其复制结点，下一步是最关键的复杂指针的复制，就是照猫画虎，不管指针有多么的复杂，都会有A1.random=A.random.next，B1.random=B.random.next，C1.random=C.random.next，这样就解决了这个题的难点，最后把链表拆分。</p><h2 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复杂链表的复制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ComplicatedLinkedListNode <span class="title">copyComplicatiedLinkedList</span><span class="params">(ComplicatedLinkedListNode firstNode)</span></span>&#123;</span><br><span class="line">    <span class="comment">//第一步，在每个结点后面复制其自身的结点</span></span><br><span class="line">    ComplicatedLinkedListNode node=firstNode;</span><br><span class="line">    <span class="keyword">while</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        ComplicatedLinkedListNode newNode=<span class="keyword">new</span> ComplicatedLinkedListNode(node.val);</span><br><span class="line">        newNode.next=node.next;</span><br><span class="line">        node.next=newNode;</span><br><span class="line">        node=newNode.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第二步，复制复杂指针，依照A1.random=A.random.next</span></span><br><span class="line">    ComplicatedLinkedListNode node2=firstNode;</span><br><span class="line">    node=firstNode.next;</span><br><span class="line">    <span class="keyword">while</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        node.random=node2.random.next;</span><br><span class="line">        node=node.next.next;</span><br><span class="line">        node2=node2.next.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第三步。拆分出目标链表</span></span><br><span class="line">    node=firstNode.next;</span><br><span class="line">    node2=node.next;</span><br><span class="line">    <span class="keyword">while</span> (node!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        node.next=node2.next;</span><br><span class="line">        node2=node.next.next;</span><br><span class="line">        node=node.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ComplicatedLinkedListNode ans=firstNode.next;</span><br><span class="line">    firstNode.next=<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值/数组算法题整理</title>
      <link href="/2019/06/24/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
      <url>/2019/06/24/%E7%AE%97%E6%B3%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="数值的整数次方"><a href="#数值的整数次方" class="headerlink" title="数值的整数次方"></a>数值的整数次方</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个double类型的浮点数base和int类型的整数exponent。求base的exponent次方。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>分清各种情况：</p><ul><li>指数为负：需要将底数求倒数然后再将指数取正</li><li>指数为最小的负数（Integer.MIN_VALUE），此时不能直接取正，直接二分递归再取正</li><li>底数为0，指数为负：会出现对0求倒数情况，要特殊处理</li><li>指数为0：无论底数，结果为1</li><li>可以用二分的思想减少运算</li></ul><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"底数为0无意义"</span>);</span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">0</span>)&#123;</span><br><span class="line">        x=<span class="number">1</span>/x;</span><br><span class="line">        n=-n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == Integer.MIN_VALUE)</span><br><span class="line">        <span class="keyword">return</span> myPow(x*x, -(n/<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> n%<span class="number">2</span>==<span class="number">0</span>?myPow(x*x,n/<span class="number">2</span>):x*myPow(x*x,n/<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="打印从1到最大的n位数"><a href="#打印从1到最大的n位数" class="headerlink" title="打印从1到最大的n位数"></a>打印从1到最大的n位数</h1><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><p>输入数字n,按顺序打印出从1到最大的n位十进制数，比如输入3,则打印出1,2,3一直到最大的3位数即999</p><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>这个题看似白给，实际容易被白给，因为当n特别特别大时，要是想直接输出数，是不可能的，因此要想到大数模拟，而大数从1到999…999递增的输出，用String模拟就又是一个问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//打印从1到最大的N位数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PrintOneToMaxNthDigits</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">char</span>[]num=<span class="keyword">new</span> <span class="keyword">char</span>[n+<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//从第一位开始初始化</span></span><br><span class="line">    num[<span class="number">0</span>]=<span class="string">'0'</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        num[<span class="number">0</span>]=(<span class="keyword">char</span>) (i+<span class="string">'0'</span>);</span><br><span class="line">        <span class="comment">//进入递归方法</span></span><br><span class="line">        print1ToMaxOfNDigitsRecursely(num,n,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print1ToMaxOfNDigitsRecursely</span><span class="params">(<span class="keyword">char</span>[] num, <span class="keyword">int</span> n, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//递归终止条件 ：已经填充到了最后一位</span></span><br><span class="line">    <span class="keyword">if</span> (index==n)&#123;</span><br><span class="line">        printNum(num);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//当前位从0-9依次填充</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        num[index+<span class="number">1</span>]=(<span class="keyword">char</span>)(i+<span class="string">'0'</span>);</span><br><span class="line">        <span class="comment">//递归到下一位</span></span><br><span class="line">        print1ToMaxOfNDigitsRecursely(num,n,index+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印从num中第一个非0位到第0位</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNum</span><span class="params">(<span class="keyword">char</span>[] num)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=num.length-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">        <span class="keyword">if</span> (num[i]!=<span class="string">'0'</span>)&#123;</span><br><span class="line">            start=i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=start;j++)</span><br><span class="line">        System.out.print(num[j]);</span><br><span class="line"></span><br><span class="line">    System.out.print(<span class="string">"    "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="数组中出现次数超过一半的数"><a href="#数组中出现次数超过一半的数" class="headerlink" title="数组中出现次数超过一半的数"></a>数组中出现次数超过一半的数</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>题目：输入 n 个整数，找出其中最小的 k 个数。例如输入 4,5,1， 6,2,7,3,8 这<br>8 个数字，则最少的 4 个数字是 1,2,3,4.</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>如果某个数在数组中出现的次数超过数组长度的一半，则如果这是个有序数组，这个数肯定是中位数<br>可以利用快排中差分的思想<br>另外，也可以按照数组的特点，遍历数组，然后计数，遇见相同的就+1，遇见不同的就-1，若为0就替换，遍历完数组肯定是</p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组中超过一半的数</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">moreThanHalfNum</span><span class="params">(<span class="keyword">int</span> []data)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (checkInvalidArray(data))</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> middle=data.length/<span class="number">2</span>;</span><br><span class="line">      <span class="keyword">int</span> start=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> end=data.length-<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">int</span> index=Partition(data,data.length,start,end);</span><br><span class="line">      <span class="keyword">while</span> (index!=middle)&#123;</span><br><span class="line">          <span class="keyword">if</span> (index&gt;middle)&#123;</span><br><span class="line">              end=index-<span class="number">1</span>;</span><br><span class="line">              index=Partition(data,data.length,start,end);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              start=index+<span class="number">1</span>;</span><br><span class="line">              index=Partition(data,data.length,start,end);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">int</span> result=data[middle];</span><br><span class="line">      <span class="keyword">if</span> (checkMoreThanHalf(result,data))</span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkMoreThanHalf</span><span class="params">(<span class="keyword">int</span> result, <span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">      <span class="keyword">while</span> (i&lt;data.length)&#123;</span><br><span class="line">          <span class="keyword">if</span> (data[i]==result)</span><br><span class="line">              count++;</span><br><span class="line">          i++;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (count&gt;data.length/<span class="number">2</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkInvalidArray</span><span class="params">(<span class="keyword">int</span>[] data)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (data.length==<span class="number">0</span>||data==<span class="keyword">null</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">Partition</span><span class="params">(<span class="keyword">int</span> [ ]data,<span class="keyword">int</span> length,<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (data==<span class="keyword">null</span>||length&lt;=<span class="number">0</span>||start&lt;<span class="number">0</span>||end&gt;=length)&#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      Random r=<span class="keyword">new</span> Random();</span><br><span class="line">      <span class="keyword">int</span> index= r.nextInt(end-start+<span class="number">1</span>)+start;</span><br><span class="line">      swap(data,index,end);</span><br><span class="line">      <span class="keyword">int</span> small=start-<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span> (index=start;index&lt;end;end++)&#123;</span><br><span class="line">          <span class="keyword">if</span> (data[index]&lt;data[end])&#123;</span><br><span class="line">              small++;</span><br><span class="line">              <span class="keyword">if</span> (small!=index)</span><br><span class="line">                  swap(data,index,small);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      small++;</span><br><span class="line">      swap(data,small,end);</span><br><span class="line">      <span class="keyword">return</span> small;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> [] data,<span class="keyword">int</span> index,<span class="keyword">int</span> index2)</span></span>&#123;</span><br><span class="line">      <span class="keyword">int</span> temp=data[index];</span><br><span class="line">       data[index]=data[index2];</span><br><span class="line">       data[index2]=temp;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组中出现次数超过一半的数字</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span>  <span class="title">MoreThanHalfNum</span><span class="params">(<span class="keyword">int</span> [] data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (checkInvalidArray(data))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> result=data[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> times=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;data.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (data[i]==result)</span><br><span class="line">            times++;</span><br><span class="line">        <span class="keyword">else</span> times--;</span><br><span class="line">        <span class="keyword">if</span> (times==<span class="number">0</span>) &#123;</span><br><span class="line">            result = data[i];</span><br><span class="line">            times = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!checkMoreThanHalf(result,data))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="数组中前K个小的数"><a href="#数组中前K个小的数" class="headerlink" title="数组中前K个小的数"></a>数组中前K个小的数</h1><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>除了排序以外，可以使用最大堆来存放K个数，遇见比堆顶小的数时，删去堆顶元素，新元素进堆</p><h2 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最小的k个数</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ArrayList&lt;Integer&gt; <span class="title">getLeastKNumber</span><span class="params">(<span class="keyword">int</span> [] data,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">      ArrayList&lt;Integer&gt; ans=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      <span class="keyword">int</span> len=data.length;</span><br><span class="line">      <span class="keyword">if</span> (k&gt;len||k&lt;<span class="number">0</span>)</span><br><span class="line">          <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//使用优先队列创建最大堆（优先队列就是靠堆实现的）</span></span><br><span class="line">      PriorityQueue&lt;Integer&gt; maxHeap=<span class="keyword">new</span> PriorityQueue(k, <span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">          <span class="meta">@Override</span></span><br><span class="line">          <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">              <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">          <span class="keyword">if</span> (maxHeap.size()!=k)&#123;</span><br><span class="line">              maxHeap.add(data[i]);</span><br><span class="line">          &#125;<span class="keyword">else</span> <span class="keyword">if</span> (maxHeap.peek()&gt;data[i])&#123;</span><br><span class="line">              maxHeap.poll();</span><br><span class="line">              maxHeap.offer(data[i]);</span><br><span class="line">              </span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (Integer i:maxHeap)&#123;</span><br><span class="line">          ans.add(i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h1 id="数据流的中位数"><a href="#数据流的中位数" class="headerlink" title="数据流的中位数"></a>数据流的中位数</h1><h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><p>得到一个数据流的中位数，若这个数据流的个数为奇数个，则是中间那个数，若是偶数个数，则是中间两个数的平均数</p><h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h2><p>如果把数组分为两个部分，前半部分的最大值和后半部分的最小值要是知道了，就可以确定中位数了，而不用排序的方式，就想到了最大堆和最小堆</p><h2 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据流的中位数</span></span><br><span class="line"> <span class="comment">//使用最大堆和最小堆实现</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMiduemNum</span><span class="params">(<span class="keyword">int</span> [] nums)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">     <span class="comment">//最大堆</span></span><br><span class="line">     PriorityQueue&lt;Integer&gt; maxHeap=<span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="comment">//最小堆</span></span><br><span class="line">     PriorityQueue&lt;Integer&gt; minHeap=<span class="keyword">new</span> PriorityQueue&lt;&gt;(<span class="keyword">new</span> Comparator&lt;Integer&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">     <span class="comment">//当i为偶数时，把数字加入到最大堆（从0开始）</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> n:nums)&#123;</span><br><span class="line">         <span class="keyword">if</span> (i%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">             maxHeap.add(n);</span><br><span class="line">         &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//加入最小堆时，若当前数比最大堆的最大数要小（要是这个时候把这个数加入最小堆就不满足要求了），则把这个数加入最大堆，然后把最大堆的最大数加入最小堆</span></span><br><span class="line">             <span class="keyword">if</span> (n&lt;maxHeap.peek()) &#123;</span><br><span class="line">                 maxHeap.add(n);</span><br><span class="line">                 minHeap.add(maxHeap.poll());</span><br><span class="line">             &#125;<span class="keyword">else</span> minHeap.add(n);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">if</span> (nums.length%<span class="number">2</span>==<span class="number">0</span>)&#123;</span><br><span class="line">         <span class="keyword">return</span> (maxHeap.peek()+minHeap.peek())/<span class="number">2</span>;</span><br><span class="line">     &#125;<span class="keyword">else</span> <span class="keyword">return</span> maxHeap.peek();</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程常识（各种杂七杂八的东西）</title>
      <link href="/2019/06/20/%E5%B8%B8%E8%AF%86%EF%BC%88%E5%90%84%E7%A7%8D%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E4%B8%9C%E8%A5%BF%EF%BC%89/"/>
      <url>/2019/06/20/%E5%B8%B8%E8%AF%86%EF%BC%88%E5%90%84%E7%A7%8D%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB%E7%9A%84%E4%B8%9C%E8%A5%BF%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="各种编码"><a href="#各种编码" class="headerlink" title="各种编码"></a>各种编码</h1><p> 很多人都把Unicode编码挂在嘴边，其实咱们现实生活中遇到的编码基本都是Unicode的</p><p>因为Unicode兼容了大多数老版本的编码规范例如 ASCII</p><p>Unicode编码定义了这个世界上几乎所有字符（就是你眼睛看到的长那个样子的符号）的数字表示</p><p>也就是说Unicode为每个字符发了一张身份证，这张身份证上有一串唯一的数字ID确定了这个字符</p><p>在这个纷乱世界上存在的唯一性。Unicode给这串数字ID起了个名字叫［码点］（Code Point）</p><p>而很多人说的编码其实是想表达［Unicode转换格式］（即UTF，Unicode Transformation Formats）</p><p>有没有觉得眼前一亮豁然开朗？没错 这就是我们看到的UTF-8/UTF-16/UTF-32的前缀来源</p><p>这个［Unicode转换格式］的存在是为了解决［码点］在计算机中的二进制表现形式而设计的</p><p>毕竟我们的机内表示涉及存储位宽，兼容古老编码格式，码点是数值过大的罕见字符等问题</p><p>［码点］经过映射后得到的二进制串的转换格式单位称之为［码元］（Code Unit）。也就是说如果有一种UTF的码点二进制表示有n字节，其码元为8位（1个byte），那么其拥有码元n个。每种UTF的码元都不同，其宽度被作为区分写在了UTF的后缀——这就是UTF-8/UTF-16/UTF-32的由来。UTF-8的码元是8位的，UTF-16的码元是16位的。大部分的编程语言采用16位的码元作为机内表示。这就是我们在各种语言中调用获取一个字符串中character的数量时会出现这么多混乱的原因。事实上我们调用这些方法时取得的不是字符个数，而是码元个数！一旦我们的字符串中包含了位于基本平面之外的码点，那么就会需要更多的码元来表示，这个时候就会出现测试时常见的困惑——为何return的字符数比实际字符数要多？所以实际写代码时要特别注意这个问题。</p><p>采取不同的映射方式可以得到不同格式的二进制串，但是他们背后所表示的［码点］永远是一致的就好像你换身份证但是身份证号不变一样。由于平时人们误把［转换格式］也称为［编码］，所以造成今天Unicode／UTF傻傻分不清楚且遣词造句运用混乱的悲桑局面。</p><p>Unicode 编码 发展到今天 扩展到了 21 位（从 U+0000 到 U+10FFFF ）。这一点很重要： Unicode 不是 16 位的编码， 它是 21 位的。这 21 位提供了 1,114,112 个码点，其中，只有大概 10% 正在使用，所以还有相当大的扩充空间。</p><p>编码空间被分成 17 个平面（plane），每个平面有 65,536 个字符（正好填充2个字节，16位）。0 号平面叫做「基本多文种平面」（ BMP, Basic Multilingual Plane ），涵盖了几乎所有你能遇到的字符，除了 emoji（emoji位于1号平面 - -）。其它平面叫做补充平面，大多是空的。</p><p>总结一下各种编码格式的特质：</p><p>UTF-32</p><p>最清楚明了的一个 UTF 就是 UTF-32 ：它在每个码点上使用整 32 位。32 大于 21，因此每一个 UTF-32 值都可以直接表示对应的码点。尽管简单，UTF-32却几乎从来不在实际中使用，因为每个字符占用 4 字节太浪费空间了。</p><p>UTF-16 以及「代理对」（ Surrogate Pairs ）的概念</p><p>UTF-16要常见得多，它是根据有 16 位固定长度的码元（ code units ）定义的。UTF-16 本身是一种长度可变的编码。基本多文种平面（BMP）中的每一个码点都直接与一个码元相映射。鉴于 BMP 几乎囊括了所有常见字符，UTF-16 一般只需要 UTF-32 一半的空间。其它平面里很少使用的码点都是用两个 16 位的码元来编码的，这两个合起来表示一个码点的码元就叫做代理对（ surrogate pair ）。</p><p>UTF-8</p><p>UTF-8 使用一到四个字节来编码一个码点。从 0 到 127 的这些码点直接映射成 1 个字节（对于只包含这个范围字符的文本来说，这一点使得 UTF-8 和 ASCII 完全相同）。接下来的 1,920 个码点映射成 2 个字节，在 BMP 里所有剩下的码点需要 3 个字节。Unicode 的其他平面里的码点则需要 4 个字节。UTF-8 是基于 8 位的码元的，因此它并不需要关心字节顺序（不过仍有一些程序会在 UTF-8 文件里加上多余的 BOM）。</p><p>有效率的空间使用（仅就西方语言来讲），以及不需要操心字节顺序问题使得 UTF-8 成为存储和交流 Unicode 文本方面的最佳编码。它也已经是文件格式、网络协议以及 Web API 领域里事实上的标准了。</p><p>我们的JVM中保存码点是UTF16的转换格式，从char的位宽为16位也可以看得出来。由于绝大部分编码的码点位于基本平面，所以使用16位可以几乎表示所有常用字符。这就是许多语言编译器或运行时都使用UTF16的原因。英文在使用UTF16时也是2字节表示的。当我们想要使用其他平面的字符时，码元超过2个字节，就需要使用代理对在语言中的特定表示方式，譬如‘\U112233’之类的。</p><p>使用UTF8时，常用的Alphabet和Numeric都在前127字节，被有效率地用一个字节表示。而我们的中文由于排在1920个码点之后，所以使用3个字节表示，这方面就比UTF16转换格式耗费更多空间。</p><p>最后，不论使用哪种UTF转换格式，都是程序员自己可以选择的一种表达方式而已。我们可以通过Java方便的API进行自如转换。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>栈和队列专题</title>
      <link href="/2019/06/18/%E9%98%9F%E5%88%97%E4%B8%93%E9%A2%98/"/>
      <url>/2019/06/18/%E9%98%9F%E5%88%97%E4%B8%93%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="用两个栈实现队列"><a href="#用两个栈实现队列" class="headerlink" title="用两个栈实现队列"></a>用两个栈实现队列</h1><p>栈和队列一个先进后出，一个先进先出，因此应当想办法“逆转”一下，这就是第二个栈的作用<br><img src="/upload/pasted-318.png" alt="upload successful"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">TwoStackToQueue</span></span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; s1=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; s2=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Qoffer</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">        s1.push(num);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">pull</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!s2.isEmpty())</span><br><span class="line">            <span class="keyword">return</span> s2.pop();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s1.isEmpty())&#123;</span><br><span class="line">                s2.push(s1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!s2.isEmpty())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"queue is empty"</span>);</span><br><span class="line">            <span class="keyword">return</span> s2.pop();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="用两个队列模拟栈"><a href="#用两个队列模拟栈" class="headerlink" title="用两个队列模拟栈"></a>用两个队列模拟栈</h1><p>对于入栈操作，直接加入队列即可。而对于出栈操作，应当知道对于模拟的情况，是删除队尾元素，而队列又是先入先出的，因此，应当先将队列前的元素移到另外一个栈，然后再“弹栈”</p><p><img src="/upload/pasted-319.png" alt="upload successful"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> Integer <span class="title">pop</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!q1.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (q1.size() != <span class="number">1</span>) &#123;</span><br><span class="line">                q2.offer(q1.poll());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (Integer) q1.poll();</span><br><span class="line">        &#125;<span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">if</span> (!q2.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">while</span> (q2.size()!=<span class="number">1</span>)&#123;</span><br><span class="line">                    q1.offer(q2.poll());</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> (Integer) q2.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"栈为空"</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="包含min函数的栈"><a href="#包含min函数的栈" class="headerlink" title="包含min函数的栈"></a>包含min函数的栈</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>定义一个栈，其中有一个获取最小值的方法，在这个栈中，调用push,pop,min的时间复杂度都是O(1)</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>这个题的难点就在于如何对于任何入栈出栈，如何实时的维持最小值，应当知道最小值相关的操作都是和入栈出栈操作是同步的，这个时候想到应当维持一个和主栈同步的辅助栈用来维持每个位置的最小值</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span>  Stack&lt;Integer&gt; mainStack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; helperStack;</span><br><span class="line">    MinStack()&#123;</span><br><span class="line">        mainStack=<span class="keyword">new</span> Stack();</span><br><span class="line">        helperStack=<span class="keyword">new</span> Stack();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">        helperStack.pop();</span><br><span class="line">        <span class="keyword">return</span> mainStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Integer i)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (i&lt;helperStack.peek())&#123;</span><br><span class="line">            helperStack.push(i);</span><br><span class="line">        &#125;<span class="keyword">else</span> </span><br><span class="line">            helperStack.push(helperStack.peek());</span><br><span class="line">        mainStack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getMin</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helperStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="栈的压入、弹出序列"><a href="#栈的压入、弹出序列" class="headerlink" title="栈的压入、弹出序列"></a>栈的压入、弹出序列</h1><h2 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h2><p>给定两个序列，一个是入栈的序列，一个是出栈的序列，判断出栈序列是否满足前面的入栈序列</p><h2 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h2><p>按照实际的手动操作进行分析：对于入栈序列，如果和出栈序列的第一数相同，说明这个数一进栈就出栈了，所以可以省略进栈这个过程；如果这个数和出栈数不相同，因此这个数入栈，进行下一个数的对比……当入栈序列已经判断完毕，这个时候就要判断栈中的数，这就比较简单了</p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//栈的压入弹出序列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPopOrder</span><span class="params">(<span class="keyword">int</span>[]pushOrder,<span class="keyword">int</span>[] popOrder)</span></span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack=<span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (j&lt;pushOrder.length)&#123;</span><br><span class="line">        <span class="keyword">if</span> (pushOrder[j]!=popOrder[i]||stack.peek()!=popOrder[i])&#123;</span><br><span class="line">            stack.push(pushOrder[j]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span></span><br><span class="line">        <span class="keyword">if</span> (pushOrder[j]==popOrder[i])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (stack.peek()==popOrder[i])&#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (stack.isEmpty())&#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.peek()!=popOrder[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 栈和队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《算法分析》课程整理</title>
      <link href="/2019/06/06/%E6%B3%95%E5%88%86%E6%9E%90%E3%80%8B%E8%AF%BE%E7%A8%8B%E6%95%B4%E7%90%86-1/"/>
      <url>/2019/06/06/%E6%B3%95%E5%88%86%E6%9E%90%E3%80%8B%E8%AF%BE%E7%A8%8B%E6%95%B4%E7%90%86-1/</url>
      
        <content type="html"><![CDATA[<h1 id="递归和分治"><a href="#递归和分治" class="headerlink" title="递归和分治"></a>递归和分治</h1><h2 id="整数划分问题"><a href="#整数划分问题" class="headerlink" title="整数划分问题"></a>整数划分问题</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>任何一个大于1的自然数，总可以拆分为若干个小于n的自然数之和，试求n的所有拆分，将最大拆分数不超过m的划分个数记做去q(n,m)</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>根据n和m的情况，可以分为以下几种情况：<br>根据n和m的关系，考虑以下几种情况： </p><ol><li>当n=1时，不论m的值为多少（m&gt;0)，只有一种划分即{1}; </li><li>当m=1时，不论n的值为多少，只有一种划分即n个1，{1,1,1,…,1}; </li><li>当n=m时，根据划分中是否包含n，可以分为两种情况：<br> (1) 划分中包含n的情况，只有一个即{n}；<br> (2) 划分中不包含n的情况，这时划分中最大的数字也一定比n小，即n的所有(n-1)划分。因此 f(n,n) =1 + f(n,n-1); </li><li>当n&lt;m时，由于划分中不可能出现负数，因此就相当于f(n,n); </li><li>但n&gt;m时，根据划分中是否包含最大值m，可以分为两种情况：<br> (1) 划分中包含m的情况，即{m, {x1,x2,…xi}}, 其中{x1,x2,… xi} 的和为n-m，可能再次出现m，因此是（n-m）的m划分，因此这种划分个数为f(n-m, m);<br> (2) 划分中不包含m的情况，则划分中所有值都比m小，即n的(m-1)划分，个数为f(n,m-1);因此 f(n, m) = f(n-m, m)+f(n,m-1);</li></ol><p>通过以上规律，得到递推公式：</p><ul><li>f(n, m)= 1; (n=1 or m=1)</li><li>f(n, m)=f(n, n); (n&lt;m)</li><li>1+ f(n, m-1); (n=m)</li><li>f(n-m,m)+f(n,m-1); (n&gt;m)</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/函数：q(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span><br><span class="line"><span class="comment">//作用：用来得到正整数n，最大加数不大于m的划分个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">q</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="comment">//若正整数或最大加数小于1，则返回0</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;<span class="number">1</span>||m&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//若正整数或最大加数等于1，则划分个数为1（n个1相加）</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>||m==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//若最大加数实际上不能大于正整数n，若大于则划分个数等于最大加数为n的划分个数</span></span><br><span class="line">    <span class="keyword">if</span>(n&lt;m) <span class="keyword">return</span> q(n,n);</span><br><span class="line">    <span class="comment">//若正整数等于最大加数，则划分个数等于</span></span><br><span class="line">    <span class="keyword">if</span> (n==m) <span class="keyword">return</span> <span class="number">1</span>+q(n,n-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> q(n,m-<span class="number">1</span>)+q(n-m,m);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Strassen矩阵乘法"><a href="#Strassen矩阵乘法" class="headerlink" title="Strassen矩阵乘法"></a>Strassen矩阵乘法</h2><h3 id="一般的矩阵乘法思路"><a href="#一般的矩阵乘法思路" class="headerlink" title="一般的矩阵乘法思路"></a>一般的矩阵乘法思路</h3><p><img src="/upload/pasted-297.png" alt="upload successful"><br>复杂度为O(n3)</p><h3 id="一种改进方法"><a href="#一种改进方法" class="headerlink" title="一种改进方法"></a>一种改进方法</h3><p><img src="/upload/pasted-298.png" alt="upload successful"></p><h3 id="Strassen方法"><a href="#Strassen方法" class="headerlink" title="Strassen方法"></a>Strassen方法</h3><p><img src="/upload/pasted-299.png" alt="upload successful"></p><p><img src="/upload/pasted-300.png" alt="upload successful"><br>这个方法的特点就是减少了一次乘法，虽然多了14次加法，但是加法计算基本没有成本<br>时间复杂度：</p><p><img src="/upload/pasted-301.png" alt="upload successful"></p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h2><ul><li>动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题。</li><li>但是经分解得到的子问题往往不是互相独立的。不同子问题的数目常常只有多项式量级。在用分治法求解时，有些子问题被重复计算了许多次。</li><li>如果能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，就可以避免大量重复计算，从而得到多项式时间算法。</li></ul><h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><ul><li>找出最优解的性质，并刻划其结构特征。</li><li>递归地定义最优值。</li><li>以自底向上的方式计算出最优值。</li><li>根据计算最优值时得到的信息，构造最优解</li></ul><h2 id="矩阵连乘问题"><a href="#矩阵连乘问题" class="headerlink" title="矩阵连乘问题"></a>矩阵连乘问题</h2><h3 id="基本内容-1"><a href="#基本内容-1" class="headerlink" title="基本内容"></a>基本内容</h3><p>对于一般的矩阵乘法来说，如矩阵A(m,n)与矩阵B(n,p)相乘需要进行的加法次数为m<em>n</em>p次乘法。</p><p>由于矩阵乘法满足结合律，因此矩阵相乘的结合性，会影响整个计算表达式的乘法执行次数。</p><p>如下面的例子，其中A(10,5)、B(5,20)、C(20,3)：</p><p>　　　　(1) ((AB)C) 执行乘法次数为1300次</p><p>　　　　(2) (A(BC)) 执行乘法次数为450次</p><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><p>预处理：<br>将矩阵连乘积AiAi+1…Aj简记为A[i:j]，这里i≤j。<br>考察计算A[i:j]的最优计算次序。设这个计算次序在矩阵Ak和Ak+1之间将矩阵链断开，i≤k&lt;j，则其相应完全加括号方式为（AiAi+1… Ak）（Ak+1 Ak+2… Aj ）。<br>计算量：A[i:k]的计算量加上A[k+1:j]的计算量，再加上A[i:k]和A[k+1:j]相乘的计算量。<br>分析最优解的结构<br>特征：计算A[i:j]的最优次序所包含的计算矩阵子链 A[i:k]和A[k+1:j]的次序也是最优的。<br>矩阵连乘计算次序问题的最优解包含着其子问题的最优解。这种性质称为最优子结构性质。问题的最优子结构性质是该问题可用动态规划算法求解的显著特征。<br>设计算A[i:j]，1≤i≤j≤n，所需要的最少数乘次数m[i,j]，则原问题的最优值为m[1,n]。<br>当i=j时，A[i:j]=Ai，因此，m[i,i]=0，i=1,2,…,n。<br>当i&lt;j时，m[i,j]=m[i,k]+m[k+1,j]+pi-1pkpj，这里Ai的维数为pi-1×pi。<br>可以递归地定义m[i,j]为：<br> <img src="/upload/pasted-306.png" alt="upload successful"><br>k的位置只有j-i种可能。</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MatrixChain</span><span class="params">(<span class="keyword">int</span> [] p，<span class="keyword">int</span> n，<span class="keyword">int</span> [] []m，<span class="keyword">int</span> [][]s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//当m[i][j]中i==j时，m[i][j]==0</span></span><br><span class="line">　<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) m[i][i] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//从m[1][2],m[2][3],m[3][4]开始计算</span></span><br><span class="line">　<span class="keyword">for</span> (<span class="keyword">int</span> r = <span class="number">2</span>; r &lt;= n; r++)</span><br><span class="line">　　<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n - r+<span class="number">1</span>; i++) &#123;</span><br><span class="line">　　　<span class="keyword">int</span> j=i+r-<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//先将m[i][j]初始化，即当k=i的时候</span></span><br><span class="line">　　　m[i][j] = m[i+<span class="number">1</span>][j]+ p[i-<span class="number">1</span>]*p[i]*p[j];</span><br><span class="line">            <span class="comment">//初始化s[i][j]</span></span><br><span class="line">　　　s[i][j] = i;</span><br><span class="line">            <span class="comment">//依次遍历k的每一个取值，按照递推公式，取最小值作为m[i][j],此时的k作为s[i][j]的值</span></span><br><span class="line">　　　<span class="keyword">for</span> (<span class="keyword">int</span> k = i+<span class="number">1</span>; k &lt; j; k++) &#123;</span><br><span class="line">　　　　<span class="keyword">int</span> t = m[i][k] + m[k+<span class="number">1</span>][j] + p[i-<span class="number">1</span>]*p[k]*p[j];</span><br><span class="line">    <span class="comment">//遍历过程中，若发现 当前k的选择拥有最小的m，则记录m和k的值，此时的k即为拆分的位置</span></span><br><span class="line">　　　　<span class="keyword">if</span> (t &lt; m[i][j]) &#123; m[i][j] = t; s[i][j] = k;&#125;</span><br><span class="line">　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h2><h3 id="基本内容-2"><a href="#基本内容-2" class="headerlink" title="基本内容"></a>基本内容</h3><p>给定两个字符串，求解这两个字符串的最长公共子序列（Longest Common Sequence）。比如字符串1：BDCABA；字符串2：ABCBDAB</p><p>则这两个字符串的最长公共子序列长度为4，最长公共子序列是：BCBA</p><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><p>①最优子结构</p><p>设 X=(x1,x2,…..xn) 和 Y={y1,y2,…..ym} 是两个序列，将 X 和 Y 的最长公共子序列记为LCS(X,Y)</p><p>找出LCS(X,Y)就是一个最优化问题。因为，我们需要找到X 和 Y中最长的那个公共子序列。而要找X 和 Y的LCS，首先考虑X的最后一个元素和Y的最后一个元素。</p><p>1）如果 xn=ym，即X的最后一个元素与Y的最后一个元素相同，这说明该元素一定位于公共子序列中。因此，现在只需要找：LCS(Xn-1，Ym-1)<br>LCS(Xn-1，Ym-1)就是原问题的一个子问题。</p><p>2）如果xn != ym，产生了两个子问题：LCS(Xn-1，Ym) 和 LCS(Xn，Ym-1)</p><p>因为序列X 和 序列Y 的最后一个元素不相等嘛，那说明最后一个元素不可能是最长公共子序列中的元素嘛。</p><p>LCS(Xn-1，Ym)表示：最长公共序列可以在(x1,x2,….x(n-1)) 和 (y1,y2,…yn)中找。<br>LCS(Xn，Ym-1)表示：最长公共序列可以在(x1,x2,….xn) 和 (y1,y2,…y(n-1))中找。<br>求解上面两个子问题，得到的公共子序列谁最长，那谁就是 LCS（X,Y）。用数学表示就是：<br>LCS=max{LCS(Xn-1，Ym)，LCS(Xn，Ym-1)}</p><p>由于条件 1)  和  2)  考虑到了所有可能的情况。因此，我们成功地把原问题 转化 成了 三个规模更小的子问题。</p><p>②重叠子问题<br>重叠子问题是啥？就是说原问题 转化 成子问题后，  子问题中有相同的问题。咦？我怎么没有发现上面的三个子问题中有相同的啊？？？？</p><p>OK，来看看，原问题是：LCS(X,Y)。子问题有 ❶LCS(Xn-1，Ym-1)    ❷LCS(Xn-1，Ym)    ❸LCS(Xn，Ym-1)</p><p>初一看，这三个子问题是不重叠的。可本质上它们是重叠的，因为它们只重叠了一大部分。举例：</p><p>第二个子问题：LCS(Xn-1，Ym) 就包含了：问题❶LCS(Xn-1，Ym-1)，为什么？</p><p>因为，当Xn-1 和 Ym 的最后一个元素不相同时，我们又需要将LCS(Xn-1，Ym)进行分解：分解成：LCS(Xn-1，Ym-1) 和 LCS(Xn-2，Ym)</p><p>也就是说：在子问题的继续分解中，有些问题是重叠的。<br>递推公式：</p><p><img src="/upload/pasted-296.png" alt="upload successful"></p><p>c[i,j]表示：(x1,x2….xi) 和 (y1,y2…yj) 的最长公共子序列的长度</p><p>③得到最长公共子序列的具体内容</p><p><img src="/upload/pasted-303.png" alt="upload successful"><br>由问题的分析可知，我们找最长公共子序列，是比较两个字符串的最后一位，若最后一位相等，则这个字符肯定是最长公共子序列的内容，因此此时，按照递推公式的描述，“斜向上”移动，当两个字符不相等时，此时根据前面的分析，可以是第一个字符串前移，也可以是第二个字符串前移，两种方式都可以，规定一种就好</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findLCS</span><span class="params">(String A, <span class="keyword">int</span> n, String B, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            dp[i][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (A.charAt(i - <span class="number">1</span>) == B.charAt(j - <span class="number">1</span>)) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j] &gt; dp[i][j - <span class="number">1</span>] ? dp[i - <span class="number">1</span>][j] : dp[i][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n][m];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h2><h3 id="基本内容-3"><a href="#基本内容-3" class="headerlink" title="基本内容"></a>基本内容</h3><p>求一个序列的最大子段和即最大连续子序列之和。例如序列[4, -3, 5, -2, -1, 2, 6, -2]的最大子段和为11=[4+(-3)+5+(-2)+(-1)+(2)+(6)]。</p><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>设前边界为1，后边界为i，且C(i)是子序列A[1,..i]必须包含元素A[i]的向前连续延伸的最大子段和：</p><p>遍历所有以i (1≤i≤n)为后边界的最大子段和Ci得出最优解：<br>f(i)=array<a href="i=0,f(i-1">i</a>&lt;0)<br>f(i)=f(i-1)+array[i]</p><h3 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSumDyn</span><span class="params">( <span class="keyword">int</span> array[],<span class="keyword">int</span> len )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ( b &gt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            b += array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            b = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( b &gt; sum )</span><br><span class="line">        &#123;</span><br><span class="line">            sum = b;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多边形游戏"><a href="#多边形游戏" class="headerlink" title="多边形游戏"></a>多边形游戏</h2><h3 id="基本内容-4"><a href="#基本内容-4" class="headerlink" title="基本内容"></a>基本内容</h3><h2 id="图像压缩"><a href="#图像压缩" class="headerlink" title="图像压缩"></a>图像压缩</h2><p>在计算机中，常用像素点的灰度值序列{p1,p1,……pn}表示图像。其中整数pi,1&lt;=i&lt;=n，表示像素点i的灰度值。通常灰度值的范围是0~255。因此最多需要8位表示一个像素。</p><p>压缩的原理就是把序列{p1,p1,……pn}进行设断点，将其分割成一段一段的。分段的过程就是要找出断点，让一段里面的像素的最大灰度值比较小，那么这一段像素(本来需要8位)就可以用较少的位(比如7位)来表示，从而减少存储空间。</p><p>b代表bits,l代表length,分段是，b[i]表示每段一个像素点需要的最少存储空间(少于8位才有意义)，l[i]表示每段里面有多少个像素点，s[i]表示从0到i压缩为一共占多少存储空间。</p><p> 如果限制l[i]&lt;=255,则需要8位来表示l[i]。而b[i]&lt;=8，需要3位表示b[i]。所以每段所需的存储空间为l[i]*b[i]+11位。假设将原图像分成m段，那么需要</p><p><img src="/upload/pasted-304.png" alt="upload successful"><br>图像压缩问题的本质就是要确定像素序列{p1,p1,……pn}的最优分段，使得依此分段所需的存储空间最小</p><h3 id="分析-4"><a href="#分析-4" class="headerlink" title="分析"></a>分析</h3><p>最优子结构<br>设l[i],b[i],1&lt;=i&lt;=m是{p1,p1,……pn}的一个最优分段，则l[1],b[1]是{p1,……,pl[1]}的一个最优分段，且l[i],b[i],2&lt;=i&lt;=m是{pl[1]+1,……,pn}的一个最优分段。即图像压缩问题满足最优子结构性质。<br>动态规划方程<br> 设s[i],1&lt;=i&lt;=n是像素序列{p1,p1,……pi}的最优分段所需的存储位数，则s[i]为前i-k个的存储位数加上后k个的存储空间。由最优子结构性质可得：</p><p><img src="/upload/pasted-307.png" alt="upload successful"></p><p><img src="/upload/pasted-308.png" alt="upload successful"></p><h3 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Compress</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span> p[],<span class="keyword">int</span> s[],<span class="keyword">int</span> l[],<span class="keyword">int</span> b[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> Lmax = <span class="number">256</span>,header = <span class="number">11</span>;  </span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=n; i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        b[i] = length(p[i]);<span class="comment">//计算像素点p需要的存储位数  </span></span><br><span class="line">        <span class="keyword">int</span> bmax = b[i];  </span><br><span class="line">        s[i] = s[i<span class="number">-1</span>] + bmax;  </span><br><span class="line">        l[i] = <span class="number">1</span>;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>; j&lt;=i &amp;&amp; j&lt;=Lmax;j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span>(bmax&lt;b[i-j+<span class="number">1</span>])  </span><br><span class="line">            &#123;  </span><br><span class="line">                bmax = b[i-j+<span class="number">1</span>];  </span><br><span class="line">            &#125;  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">if</span>(s[i]&gt;s[i-j]+j*bmax)  </span><br><span class="line">            &#123;  </span><br><span class="line">                s[i] = s[i-j] + j*bmax;  </span><br><span class="line">                l[i] = j;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        s[i] += header;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">(<span class="keyword">int</span> i)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> k=<span class="number">1</span>;  </span><br><span class="line">    i = i/<span class="number">2</span>;  </span><br><span class="line">    <span class="keyword">while</span>(i&gt;<span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        k++;  </span><br><span class="line">        i=i/<span class="number">2</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> k;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Traceback</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">int</span>&amp; i,<span class="keyword">int</span> s[],<span class="keyword">int</span> l[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    Traceback(n-l[n],i,s,l);  </span><br><span class="line">    s[i++]=n-l[n];<span class="comment">//重新为s[]数组赋值，用来存储分段位置  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="电路布线问题"><a href="#电路布线问题" class="headerlink" title="电路布线问题"></a>电路布线问题</h2><h3 id="基本内容-5"><a href="#基本内容-5" class="headerlink" title="基本内容"></a>基本内容</h3><p>在一块电路板的上、下两端分别有n个接线柱。根据电路设计，要求用导线(i,π(i)) 将上端接线柱i与下端接线柱π(i)相连，如下图。其中，π(i),1≤ i ≤n,是｛1,2,…,n｝的一个排列。导线(I, π(i))称为该电路板上的第i条连线。对于任何1 ≤ i ≤ j ≤n,第i条连线和第j条连线相交的充要条件是π(i)&gt; π(j).</p><p><img src="/upload/pasted-309.png" alt="upload successful"><br>在制作电路板时，要求将这n条连线分布到若干绝缘层上。在同一层上的连线不相交。电路布线问题要确定将哪些连线安排在第一层上，使得该层上有尽可能多的连线。换句话说，该问题要求确定导线集Nets = ｛i，π(i)，1 ≤ i ≤ n｝的最大不相交子集。 </p><h3 id="分析-5"><a href="#分析-5" class="headerlink" title="分析"></a>分析</h3><p>记N(i,j) = {t|(t, π(t)) ∈ Nets,t ≤ i, π(t) ≤ j }. N(i,j)的最大不相交子集为MNS（i,j）Size(i,j)=|MNS(i,j)|。<br>(1)当i = 1时</p><p><img src="/upload/pasted-310.png" alt="upload successful"><br>(2)当i &gt;1时</p><p>① j &lt;π(i)。此时，(i,π(i)) 不属于N(i,j)。故在这种情况下，N(i,j) = N(i-1,j)，从而Size(i,j)=Size(i-1,j)。</p><p>② j ≥π(i)。此时，若(i, π(i))∈MNS(i,j)，则对任意(t, π(t))∈MNS(i,j)有t &lt; i且π(t)&lt; π(i)；否则，(t, π(t))与(i, π(i))相交。在这种情况下MNS(i,j)-{(i, π(i))}是N(i-1, π(i)-1)的最大不相交子集。否则，子集MNS(i-1, π(i)-1)∪{(i, π(i))}包含于N(i,j)是比MNS(i,j)更大的N(i,j)的不相交子集。这与MNS(i,j)的定义相矛盾。</p><p>若(i, π(i))不属于MNS(i,j)，则对任意(t, π(t))∈MNS(i,j)，有t&lt;i。从而MNS(i,j)包含于N(i-1,j)，因此，Size(i,j)≤Size(i-1,j)。<br>另一方面，MNS(i-1,j)包含于N(i,j),故又有Size(i,j) ≥Size(i-1,j)，从而Size（i,j）= Size(i-1,j)。</p><p><img src="/upload/pasted-311.png" alt="upload successful"><br>电路布线问题的最优值为Size(n,n)。由该问题的最优子结构性质可知，子问题最优值的递归关系如下：</p><p><img src="/upload/pasted-312.png" alt="upload successful"></p><p>根据递归方程得到如下二维表</p><p><img src="/upload/pasted-313.png" alt="upload successful"></p><h2 id="0-1背包问题（动态规划）"><a href="#0-1背包问题（动态规划）" class="headerlink" title="0-1背包问题（动态规划）"></a>0-1背包问题（动态规划）</h2><h3 id="基本内容-6"><a href="#基本内容-6" class="headerlink" title="基本内容"></a>基本内容</h3><p>给定种物品和一个容量为的背包，物品的重量是，其价值为，背包问题是如何使选择装入背包内的物品，使得装入背包中的物品的总价值最大。其中，每种物品只有全部装入背包或不装入背包两种选择。</p><h3 id="分析-6"><a href="#分析-6" class="headerlink" title="分析"></a>分析</h3><p>在解决问题之前，为描述方便，首先定义一些变量：Vi表示第 i 个物品的价值，Wi表示第 i 个物品的体积，定义V(i,j)：当前背包容量 j，前 i 个物品最佳组合对应的价值，同时背包问题抽象化（X1，X2，…，Xn，其中 Xi 取0或1，表示第 i 个物品选或不选）。<br>1、建立模型，即求max(V1X1+V2X2+…+VnXn)；<br>2、寻找约束条件，W1X1+W2X2+…+WnXn&lt;capacity；<br>3、寻找递推关系式，面对当前商品有两种可能性：</p><ul><li>包的容量比该商品体积小，装不下，此时的价值与前i-1个的价值是一样的，即V(i,j)=V(i-1,j)；</li><li>还有足够的容量可以装该商品，但装了也不一定达到当前最优价值，所以在装与不装之间选择最优的一个，即V(i,j)=max｛V(i-1,j)，V(i-1,j-w(i))+v(i)｝。<br>其中V(i-1,j)表示不装，V(i-1,j-w(i))+v(i) 表示装了第i个商品，背包容量减少w(i)，但价值增加了v(i)；<br>由此可以得出递推关系式：</li><li>j&lt;w(i)      V(i,j)=V(i-1,j)</li><li>j&gt;=w(i)     V(i,j)=max｛V(i-1,j)，V(i-1,j-w(i))+v(i)｝</li></ul><p>然后就是填表，根据递推公式，填完如下<br>w(2,3,4,5) v(3,4,5,6) cap=8</p><p>根据动态规划函数，v[4,8]就是最大价值<br><img src="/upload/pasted-314.png" alt="upload successful"><br><img src="/upload/pasted-315.png" alt="upload successful"><br><img src="/upload/pasted-316.png" alt="upload successful"></p><h3 id="实现-5"><a href="#实现-5" class="headerlink" title="实现"></a>实现</h3><h2 id="剪绳子（动态规划）"><a href="#剪绳子（动态规划）" class="headerlink" title="剪绳子（动态规划）"></a>剪绳子（动态规划）</h2><h3 id="基本内容-7"><a href="#基本内容-7" class="headerlink" title="基本内容"></a>基本内容</h3><p>给你一根长度为n绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m≥1）。每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0]<em>k[1]</em>…*k[m]可能的最大乘积是多少？例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18。</p><h3 id="分析-7"><a href="#分析-7" class="headerlink" title="分析"></a>分析</h3><p>如果不能发现最优子结构，可以自小向大推：绳子长度为1时，最大乘积只能是0，绳子长度为2时，切成1和1，结果也是1，绳子长度为3时，切成1和2，结果是2，绳子长度为4时，可以分为1<em>1</em>1<em>1，1</em>2<em>1，1</em>3，2<em>2，最大乘积为4，因此可以发现最优子结构f(n)=max(f(i)</em>f(n-i))</p><h3 id="实现-6"><a href="#实现-6" class="headerlink" title="实现"></a>实现</h3><p>在实现时，可以从下到上实现，利用数组存储中间结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">cutRoats</span><span class="params">(<span class="keyword">int</span>  length)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length&lt;<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"长度不合法"</span>);</span><br><span class="line">    <span class="keyword">if</span> (length&lt;=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (length==<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (length==<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>  []  product=<span class="keyword">new</span> <span class="keyword">int</span>[length+<span class="number">1</span>];</span><br><span class="line">    product[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    product[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    product[<span class="number">2</span>]=<span class="number">2</span>;</span><br><span class="line">    product[<span class="number">3</span>]=<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">4</span>;i&lt;=length;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=i/<span class="number">2</span>;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (max &lt; product[j] * product[i - j])</span><br><span class="line">                max = product[j] * product[i - j];</span><br><span class="line">        &#125;</span><br><span class="line">        product[i]=max;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> product[length];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="剪绳子（贪心算法）"><a href="#剪绳子（贪心算法）" class="headerlink" title="剪绳子（贪心算法）"></a>剪绳子（贪心算法）</h2><h3 id="基本内容-8"><a href="#基本内容-8" class="headerlink" title="基本内容"></a>基本内容</h3><p>给你一根长度为n绳子，请把绳子剪成m段（m、n都是整数，n&gt;1并且m≥1）。每段的绳子的长度记为k[0]、k[1]、……、k[m]。k[0]<em>k[1]</em>…*k[m]可能的最大乘积是多少？例如当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到最大的乘积18</p><h3 id="分析-8"><a href="#分析-8" class="headerlink" title="分析"></a>分析</h3><p>多数情况下，贪心算法是得不到最优解的，但是本题依赖于一个数学证明：当绳子长度大于5时，尽可能的剪出长度为3的绳子是最优解</p><h3 id="实现-7"><a href="#实现-7" class="headerlink" title="实现"></a>实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProductAfterCutting_solution2</span><span class="params">(<span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (length &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> timesOf3 = length / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> timesOf2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (length - timesOf3 * <span class="number">3</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        timesOf3--;</span><br><span class="line">        <span class="comment">// timesOf2=2;  //错误！</span></span><br><span class="line">    &#125;</span><br><span class="line">    timesOf2 = (length - timesOf3 * <span class="number">3</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>) (Math.pow(<span class="number">3</span>, timesOf3) * Math.pow(<span class="number">2</span>, timesOf2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h1>]]></content>
      
      
      <categories>
          
          <category> 刷算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课程整理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无向图</title>
      <link href="/2019/04/25/%E5%9B%BE/"/>
      <url>/2019/04/25/%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<p>…省略掉图在离散数学中的许多定义</p><h1 id="无向图的数据结构"><a href="#无向图的数据结构" class="headerlink" title="无向图的数据结构"></a>无向图的数据结构</h1><p>这里使用邻接表数组表示</p><p><img src="/upload/pasted-295.png" alt="upload successful"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> V; <span class="comment">//定点数目</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> E;       <span class="comment">//边的数目</span></span><br><span class="line">    <span class="keyword">private</span> Bag&lt;Integer&gt;[] adj; <span class="comment">//邻接表</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 以V(定点的个数为依据进行初始化)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  V number of vertices</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if &#123;<span class="doctag">@code</span> V &lt; 0&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> V)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (V &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Number of vertices must be nonnegative"</span>);</span><br><span class="line">        <span class="keyword">this</span>.V = V;</span><br><span class="line">        <span class="keyword">this</span>.E = <span class="number">0</span>;</span><br><span class="line">        adj = (Bag&lt;Integer&gt;[]) <span class="keyword">new</span> Bag[V];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">            adj[v] = <span class="keyword">new</span> Bag&lt;Integer&gt;();<span class="comment">//初始化所有链表为空</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes a new graph that is a deep copy of &#123;<span class="doctag">@code</span> G&#125;.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  G the graph to copy</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(Graph G)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(G.V());</span><br><span class="line">        <span class="keyword">this</span>.E = G.E();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++) &#123;</span><br><span class="line">            <span class="comment">// reverse so that adjacency list is in same order as original</span></span><br><span class="line">            Stack&lt;Integer&gt; reverse = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : G.adj[v]) &#123;</span><br><span class="line">                reverse.push(w);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : reverse) &#123;</span><br><span class="line">                adj[v].add(w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回图中结点个数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of vertices in this graph</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of edges in this graph.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of edges in this graph</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">E</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> E;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// throw an IllegalArgumentException unless &#123;@code 0 &lt;= v &lt; V&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateVertex</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= V)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"vertex "</span> + v + <span class="string">" is not between 0 and "</span> + (V-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向图中加入v-w边</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  v one vertex in the edge</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  w the other vertex in the edge</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless both &#123;<span class="doctag">@code</span> 0 &lt;= v &lt; V&#125; and &#123;<span class="doctag">@code</span> 0 &lt;= w &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">        validateVertex(v);</span><br><span class="line">        validateVertex(w);</span><br><span class="line">        E++;</span><br><span class="line">        adj[v].add(w);</span><br><span class="line">        adj[w].add(v);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回某结点的邻接表集.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  v the vertex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the vertices adjacent to vertex &#123;<span class="doctag">@code</span> v&#125;, as an iterable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= v &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">adj</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        validateVertex(v);</span><br><span class="line">        <span class="keyword">return</span> adj[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回结点的个数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  v the vertex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the degree of vertex &#123;<span class="doctag">@code</span> v&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= v &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">degree</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        validateVertex(v);</span><br><span class="line">        <span class="keyword">return</span> adj[v].size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a string representation of this graph.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of vertices &lt;em&gt;V&lt;/em&gt;, followed by the number of edges &lt;em&gt;E&lt;/em&gt;,</span></span><br><span class="line"><span class="comment">     *         followed by the &lt;em&gt;V&lt;/em&gt; adjacency lists</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        StringBuilder s = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        s.append(V + <span class="string">" vertices, "</span> + E + <span class="string">" edges "</span> + NEWLINE);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; V; v++) &#123;</span><br><span class="line">            s.append(v + <span class="string">": "</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : adj[v]) &#123;</span><br><span class="line">                s.append(w + <span class="string">" "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            s.append(NEWLINE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="深度优先搜索-Depth-First-Search"><a href="#深度优先搜索-Depth-First-Search" class="headerlink" title="深度优先搜索(Depth-First Search)"></a>深度优先搜索(Depth-First Search)</h1><p>深度优先搜索可以理解为拿着一根绳子走迷宫，开始选择一条没有走过的路，每到一个路口，就对当前位置进行标记，当再次到达标记位置时，利用绳子回退到上一个路口，如此往复，循环渐进<br>而实现的程序上描述起来就更为简单：在访问一个顶点时，把当前的结点进行标记，然后递归的访问没有标记的顶点</p><p><img src="/upload/DFS.gif" alt="upload successful"><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DepthFirstPaths</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;    <span class="comment">// 标记顶点是否被标记</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] edgeTo;        <span class="comment">// edgeTo[v] = s到v的路径上最后一条边的起点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> s;         <span class="comment">// 搜索的起点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始进行广度优先麦搜索</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> G the graph</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s the source vertex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= s &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DepthFirstPaths</span><span class="params">(Graph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        edgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        <span class="comment">//验证s是否合法</span></span><br><span class="line">        validateVertex(s);</span><br><span class="line">        dfs(G, s);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关键递归步骤</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Graph G, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//将当前访问的顶点标记为已访问</span></span><br><span class="line">        marked[v] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//依次递归访问当前结点的所有相邻结点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w : G.adj(v)) &#123;</span><br><span class="line">            <span class="comment">//如果未访问，则访问该顶点</span></span><br><span class="line">            <span class="keyword">if</span> (!marked[w]) &#123;</span><br><span class="line">                edgeTo[w] = v;</span><br><span class="line">                dfs(G, w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判定源结点s和当前结点是有通路</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v the vertex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if there is a path, &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= v &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        validateVertex(v);</span><br><span class="line">        <span class="keyword">return</span> marked[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回源结点s和当前结点v的一条通路路径，如果不存在该路径，则返回null</span></span><br><span class="line"><span class="comment">     * </span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  v the vertex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the sequence of vertices on a path between the source vertex</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> s&#125; and vertex &#123;<span class="doctag">@code</span> v&#125;, as an Iterable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= v &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        validateVertex(v);</span><br><span class="line">        <span class="keyword">if</span> (!hasPathTo(v)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Stack&lt;Integer&gt; path = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = v; x != s; x = edgeTo[x])</span><br><span class="line">            path.push(x);</span><br><span class="line">        path.push(s);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// throw an IllegalArgumentException unless &#123;@code 0 &lt;= v &lt; V&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateVertex</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> V = marked.length;</span><br><span class="line">        <span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= V)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"vertex "</span> + v + <span class="string">" is not between 0 and "</span> + (V-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h1><h2 id="基本内容"><a href="#基本内容" class="headerlink" title="基本内容"></a>基本内容</h2><p><img src="/upload/BFS2.gif" alt="upload successful"><br><strong>引入</strong>：单点路径问题，在一个图中，给定两个结点，找出这两点之间是否存在路径，如果存在，找出最短路径<br><strong>分析</strong>：dfs并不能解决这个问题，因为其遍历整个图的顺序和找出最短路径没有关系,而相比之下，广度优先搜索正是为了这个目标而出现的，要找到s到v的最短路径。从s开始，找到距离s为1条边的点，如果找不到，就在距离为2的边中查找直到找到为止，如果把深度优先搜索比作为一个人拿着绳子走迷宫，那么，那么广度优先搜索就好像一群人向着各个方向走<br><strong>实现</strong>：使用一个队列保存已经被标记但是其邻接表还未进行检查的顶点，先将起点放入队列，然后重复以下步骤知道队列为空</p><ul><li>取队列中下一个顶点v并进行访问标记</li><li>将与v相邻的所有未被标记过的顶点</li></ul><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  The &#123;<span class="doctag">@code</span> BreadthFirstPaths&#125; class represents a data type for finding</span></span><br><span class="line"><span class="comment"> *  shortest paths (number of edges) from a source vertex &lt;em&gt;s&lt;/em&gt;</span></span><br><span class="line"><span class="comment"> *  (or a set of source vertices)</span></span><br><span class="line"><span class="comment"> *  to every other vertex in an undirected graph.</span></span><br><span class="line"><span class="comment"> *  &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *  This implementation uses breadth-first search.</span></span><br><span class="line"><span class="comment"> *  The constructor takes time proportional to &lt;em&gt;V&lt;/em&gt; + &lt;em&gt;E&lt;/em&gt;,</span></span><br><span class="line"><span class="comment"> *  where &lt;em&gt;V&lt;/em&gt; is the number of vertices and &lt;em&gt;E&lt;/em&gt; is the number of edges.</span></span><br><span class="line"><span class="comment"> *  Each call to &#123;<span class="doctag">@link</span> #distTo(int)&#125; and &#123;<span class="doctag">@link</span> #hasPathTo(int)&#125; takes constant time;</span></span><br><span class="line"><span class="comment"> *  each call to &#123;<span class="doctag">@link</span> #pathTo(int)&#125; takes time proportional to the length</span></span><br><span class="line"><span class="comment"> *  of the path.</span></span><br><span class="line"><span class="comment"> *  It uses extra space (not including the graph) proportional to &lt;em&gt;V&lt;/em&gt;.</span></span><br><span class="line"><span class="comment"> *  &lt;p&gt;</span></span><br><span class="line"><span class="comment"> *  For additional documentation,</span></span><br><span class="line"><span class="comment"> *  see &lt;a href="https://algs4.cs.princeton.edu/41graph"&gt;Section 4.1&lt;/a&gt;   </span></span><br><span class="line"><span class="comment"> *  of &lt;i&gt;Algorithms, 4th Edition&lt;/i&gt; by Robert Sedgewick and Kevin Wayne.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span> Robert Sedgewick</span></span><br><span class="line"><span class="comment"> *  <span class="doctag">@author</span> Kevin Wayne</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BreadthFirstPaths</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INFINITY = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span>[] marked;  <span class="comment">// marked[v] = 标记s和v之间有通路</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] edgeTo;      <span class="comment">// edgeTo[v] = previous edge on shortest s-v path</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] distTo;      <span class="comment">// distTo[v] = number of edges shortest s-v path</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">     * Computes the shortest path between the source vertex &#123;<span class="doctag">@code</span> s&#125;</span></span><br><span class="line"><span class="comment">     * and every other vertex in the graph &#123;<span class="doctag">@code</span> G&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> G the graph</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s the source vertex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= s &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BreadthFirstPaths</span><span class="params">(Graph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        distTo = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        edgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        validateVertex(s);</span><br><span class="line">        bfs(G, s);</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">check</span><span class="params">(G, s)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes the shortest path between any one of the source vertices in &#123;<span class="doctag">@code</span> sources&#125;</span></span><br><span class="line"><span class="comment">     * and every other vertex in graph &#123;<span class="doctag">@code</span> G&#125;.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> G the graph</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sources the source vertices</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= s &lt; V&#125; for each vertex</span></span><br><span class="line"><span class="comment">     *         &#123;<span class="doctag">@code</span> s&#125; in &#123;<span class="doctag">@code</span> sources&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BreadthFirstPaths</span><span class="params">(Graph G, Iterable&lt;Integer&gt; sources)</span> </span>&#123;</span><br><span class="line">        marked = <span class="keyword">new</span> <span class="keyword">boolean</span>[G.V()];</span><br><span class="line">        distTo = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        edgeTo = <span class="keyword">new</span> <span class="keyword">int</span>[G.V()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++)</span><br><span class="line">            distTo[v] = INFINITY;</span><br><span class="line">        validateVertices(sources);</span><br><span class="line">        bfs(G, sources);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// breadth-first search from a single source</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Graph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> Queue&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++)</span><br><span class="line">            distTo[v] = INFINITY;</span><br><span class="line">        distTo[s] = <span class="number">0</span>;</span><br><span class="line">        marked[s] = <span class="keyword">true</span>;</span><br><span class="line">        q.enqueue(s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = q.dequeue();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : G.adj(v)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!marked[w]) &#123;</span><br><span class="line">                    edgeTo[w] = v;</span><br><span class="line">                    distTo[w] = distTo[v] + <span class="number">1</span>;</span><br><span class="line">                    marked[w] = <span class="keyword">true</span>;</span><br><span class="line">                    q.enqueue(w);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// breadth-first search from multiple sources</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(Graph G, Iterable&lt;Integer&gt; sources)</span> </span>&#123;</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> Queue&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> s : sources) &#123;</span><br><span class="line">            marked[s] = <span class="keyword">true</span>;</span><br><span class="line">            distTo[s] = <span class="number">0</span>;</span><br><span class="line">            q.enqueue(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!q.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = q.dequeue();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : G.adj(v)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!marked[w]) &#123;</span><br><span class="line">                    edgeTo[w] = v;</span><br><span class="line">                    distTo[w] = distTo[v] + <span class="number">1</span>;</span><br><span class="line">                    marked[w] = <span class="keyword">true</span>;</span><br><span class="line">                    q.enqueue(w);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Is there a path between the source vertex &#123;<span class="doctag">@code</span> s&#125; (or sources) and vertex &#123;<span class="doctag">@code</span> v&#125;?</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v the vertex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> true&#125; if there is a path, and &#123;<span class="doctag">@code</span> false&#125; otherwise</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= v &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        validateVertex(v);</span><br><span class="line">        <span class="keyword">return</span> marked[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the number of edges in a shortest path between the source vertex &#123;<span class="doctag">@code</span> s&#125;</span></span><br><span class="line"><span class="comment">     * (or sources) and vertex &#123;<span class="doctag">@code</span> v&#125;?</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> v the vertex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the number of edges in a shortest path</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= v &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">distTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        validateVertex(v);</span><br><span class="line">        <span class="keyword">return</span> distTo[v];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns a shortest path between the source vertex &#123;<span class="doctag">@code</span> s&#125; (or sources)</span></span><br><span class="line"><span class="comment">     * and &#123;<span class="doctag">@code</span> v&#125;, or &#123;<span class="doctag">@code</span> null&#125; if no such path.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  v the vertex</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the sequence of vertices on a shortest path, as an Iterable</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException unless &#123;<span class="doctag">@code</span> 0 &lt;= v &lt; V&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterable&lt;Integer&gt; <span class="title">pathTo</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        validateVertex(v);</span><br><span class="line">        <span class="keyword">if</span> (!hasPathTo(v)) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        Stack&lt;Integer&gt; path = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">int</span> x;</span><br><span class="line">        <span class="keyword">for</span> (x = v; distTo[x] != <span class="number">0</span>; x = edgeTo[x])</span><br><span class="line">            path.push(x);</span><br><span class="line">        path.push(x);</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// check optimality conditions for single source</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(Graph G, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check that the distance of s = 0</span></span><br><span class="line">        <span class="keyword">if</span> (distTo[s] != <span class="number">0</span>) &#123;</span><br><span class="line">            StdOut.println(<span class="string">"distance of source "</span> + s + <span class="string">" to itself = "</span> + distTo[s]);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check that for each edge v-w dist[w] &lt;= dist[v] + 1</span></span><br><span class="line">        <span class="comment">// provided v is reachable from s</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> w : G.adj(v)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hasPathTo(v) != hasPathTo(w)) &#123;</span><br><span class="line">                    StdOut.println(<span class="string">"edge "</span> + v + <span class="string">"-"</span> + w);</span><br><span class="line">                    StdOut.println(<span class="string">"hasPathTo("</span> + v + <span class="string">") = "</span> + hasPathTo(v));</span><br><span class="line">                    StdOut.println(<span class="string">"hasPathTo("</span> + w + <span class="string">") = "</span> + hasPathTo(w));</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (hasPathTo(v) &amp;&amp; (distTo[w] &gt; distTo[v] + <span class="number">1</span>)) &#123;</span><br><span class="line">                    StdOut.println(<span class="string">"edge "</span> + v + <span class="string">"-"</span> + w);</span><br><span class="line">                    StdOut.println(<span class="string">"distTo["</span> + v + <span class="string">"] = "</span> + distTo[v]);</span><br><span class="line">                    StdOut.println(<span class="string">"distTo["</span> + w + <span class="string">"] = "</span> + distTo[w]);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// check that v = edgeTo[w] satisfies distTo[w] = distTo[v] + 1</span></span><br><span class="line">        <span class="comment">// provided v is reachable from s</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">0</span>; w &lt; G.V(); w++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasPathTo(w) || w == s) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> v = edgeTo[w];</span><br><span class="line">            <span class="keyword">if</span> (distTo[w] != distTo[v] + <span class="number">1</span>) &#123;</span><br><span class="line">                StdOut.println(<span class="string">"shortest path edge "</span> + v + <span class="string">"-"</span> + w);</span><br><span class="line">                StdOut.println(<span class="string">"distTo["</span> + v + <span class="string">"] = "</span> + distTo[v]);</span><br><span class="line">                StdOut.println(<span class="string">"distTo["</span> + w + <span class="string">"] = "</span> + distTo[w]);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// throw an IllegalArgumentException unless &#123;@code 0 &lt;= v &lt; V&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateVertex</span><span class="params">(<span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> V = marked.length;</span><br><span class="line">        <span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= V)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"vertex "</span> + v + <span class="string">" is not between 0 and "</span> + (V-<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// throw an IllegalArgumentException unless &#123;@code 0 &lt;= v &lt; V&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">validateVertices</span><span class="params">(Iterable&lt;Integer&gt; vertices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (vertices == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"argument is null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> V = marked.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v : vertices) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v &lt; <span class="number">0</span> || v &gt;= V) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"vertex "</span> + v + <span class="string">" is not between 0 and "</span> + (V-<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Unit tests the &#123;<span class="doctag">@code</span> BreadthFirstPaths&#125; data type.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args the command-line arguments</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        In in = <span class="keyword">new</span> In(args[<span class="number">0</span>]);</span><br><span class="line">        Graph G = <span class="keyword">new</span> Graph(in);</span><br><span class="line">        <span class="comment">// StdOut.println(G);</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> s = Integer.parseInt(args[<span class="number">1</span>]);</span><br><span class="line">        BreadthFirstPaths bfs = <span class="keyword">new</span> BreadthFirstPaths(G, s);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; G.V(); v++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (bfs.hasPathTo(v)) &#123;</span><br><span class="line">                StdOut.printf(<span class="string">"%d to %d (%d):  "</span>, s, v, bfs.distTo(v));</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> x : bfs.pathTo(v)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (x == s) StdOut.print(x);</span><br><span class="line">                    <span class="keyword">else</span>        StdOut.print(<span class="string">"-"</span> + x);</span><br><span class="line">                &#125;</span><br><span class="line">                StdOut.println();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                StdOut.printf(<span class="string">"%d to %d (-):  not connected\n"</span>, s, v);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>乐观锁和悲观锁</title>
      <link href="/2019/04/23/%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81-1/"/>
      <url>/2019/04/23/%E9%94%81%E5%92%8C%E6%82%B2%E8%A7%82%E9%94%81-1/</url>
      
        <content type="html"><![CDATA[<h1 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>当我们要对一个数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。</p><p>这种借助数据库锁机制在修改数据之前先锁定，再修改的方式被称之为悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）。</p><p>之所以叫做悲观锁，是因为这是一种对数据的修改抱有悲观态度的并发控制方式。我们一般认为数据被并发修改的概率比较大，所以需要在修改之前先加锁。</p><p>悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。</p><p>但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，还会降低并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。</p><p><img src="/upload/pasted-285.png" alt="upload successful"></p><p>Java里面的同步原语synchronized关键字的实现也是悲观锁。</p><h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>以MySQL为例<br>要使用悲观锁，必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set autocommit=0;<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//0.开始事务</span><br><span class="line"></span><br><span class="line"><span class="keyword">begin</span>;</span><br><span class="line"></span><br><span class="line">//1.查询出商品库存信息</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> quantity <span class="keyword">from</span> items <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">for</span> <span class="keyword">update</span>;</span><br><span class="line"></span><br><span class="line">//2.修改商品库存为2</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> items <span class="keyword">set</span> quantity=<span class="number">2</span> <span class="keyword">where</span> <span class="keyword">id</span>= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">//3.提交事务</span><br><span class="line"></span><br><span class="line"><span class="keyword">commit</span>;</span><br></pre></td></tr></table></figure></p><p>以上，在对id = 1的记录修改前，先通过for update的方式进行加锁，然后再进行修改。这就是比较典型的悲观锁策略。</p><p>如果以上修改库存的代码发生并发，同一时间只有一个线程可以开启事务并获得id=1的锁，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。</p><p>上面我们提到，使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意</p><h1 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h1><h2 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h2><p>乐观锁（ Optimistic Locking ） 是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。</p><p>相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。</p><p><img src="/upload/pasted-292.png" alt="upload successful"><br>乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。</p><h2 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h2><p>使用乐观锁就不需要借助数据库的锁机制了。</p><p>乐观锁的概念中其实已经阐述了他的具体实现细节：主要就是两个步骤：冲突检测和数据更新。其实现方式有一种比较典型的就是Compare and Swap(CAS)。</p><p>CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p><p>比如前面的扣减库存问题，通过乐观锁可以实现如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">//查询出商品库存信息，quantity = 3</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> quantity <span class="keyword">from</span> items <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">//修改商品库存为<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> items <span class="keyword">set</span> quantity=<span class="number">2</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">and</span> quantity = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></p><p>以上，我们在更新之前，先查询一下库存表中当前库存数（quantity），然后在做update的时候，以库存数作为一个修改条件。当我们提交更新的时候，判断数据库表对应记录的当前库存数与第一次取出来的库存数进行比对，如果数据库表当前库存数与第一次取出来的库存数相等，则予以更新，否则认为是过期数据。</p><p>以上更新语句存在一个比较重要的问题，即传说中的ABA问题。</p><p>比如说一个线程one从数据库中取出库存数3，这时候另一个线程two也从数据库中库存数3，并且two进行了一些操作变成了2，然后two又将库存数变成3，这时候线程one进行CAS操作发现数据库中仍然是3，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。</p><p><img src="/upload/pasted-293.png" alt="upload successful"><br>有一个比较好的办法可以解决ABA问题，那就是通过一个单独的可以顺序递增的version字段。改为以下方式即可：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//查询出商品信息，version = 1</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">version</span> <span class="keyword">from</span> items <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span></span><br><span class="line"></span><br><span class="line">//修改商品库存为<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> items <span class="keyword">set</span> quantity=<span class="number">2</span>,<span class="keyword">version</span>= <span class="number">3</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="number">1</span> <span class="keyword">and</span> <span class="keyword">version</span>= <span class="number">2</span>;</span><br></pre></td></tr></table></figure></p><p>乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现ABA问题，因为版本号只会增加不会减少。</p><p><img src="/upload/pasted-294.png" alt="upload successful"></p><p>以上SQL其实还是有一定的问题的，就是一旦发上高并发的时候，就只有一个线程可以修改成功，那么就会存在大量的失败。</p><p>对于像淘宝这样的电商网站，高并发是常有的事，总让用户感知到失败显然是不合理的。所以，还是要想办法减少乐观锁的粒度的。</p><p>有一条比较好的建议，可以减小乐观锁力度，最大程度的提升吞吐率，提高并发能力！如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//修改商品库存</span><br><span class="line"></span><br><span class="line"><span class="keyword">update</span> item</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span> quantity=quantity - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span> <span class="keyword">and</span> quantity - <span class="number">1</span>&gt; <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>以上SQL语句中，如果用户下单数为1，则通过quantity - 1 &gt; 0的方式进行乐观锁控制。</p><p>以上update语句，在执行过程中，会在一次原子操作中自己查询一遍quantity的值，并将其扣减掉1。</p><h1 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h1><p>在乐观锁与悲观锁的选择上面，主要看下两者的区别以及适用场景就可以了。</p><p>1、乐观锁并未真正加锁，效率高。一旦锁的粒度掌握不好，更新失败的概率就会比较高，容易发生业务失败。</p><p>2、悲观锁依赖数据库锁，效率低。更新失败的概率比较低。</p><p>随着互联网三高架构（高并发、高性能、高可用）的提出，悲观锁已经越来越少的被使用到生产环境中了，尤其是并发量比较大的业务场景。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库相关 </category>
          
          <category> java多线程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java多线程 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程上下文设计模式</title>
      <link href="/2019/04/22/%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/04/22/%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>上下文是贯穿整个系统或阶段生命周期的对象，其包含了系统全局的一些信息，比如登录之后的用户信息，账号信息以及程序每一个阶段运行时的数据。<br>在有些时候，单个线程执行的任务步骤会非常多，后一个步骤的输入有可能是前一个步骤的输出，比如在单个线程多步骤执行时，为了使得功能单一，有时候我们会采用GOF职责链设计模式。</p><p><img src="/upload/pasted-284.png" alt="upload successful"></p><h1 id="利用ThreadLocal实现"><a href="#利用ThreadLocal实现" class="headerlink" title="利用ThreadLocal实现"></a>利用ThreadLocal实现</h1><p>某个任务，需要分别从数据库和http查询内容<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutionTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> QueryFromDBAction queryAction = <span class="keyword">new</span> QueryFromDBAction();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> QueryFromHttpAction httpAction = <span class="keyword">new</span> QueryFromHttpAction();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接执行不用传参</span></span><br><span class="line">        queryAction.execute();</span><br><span class="line">        System.out.println(<span class="string">"The name query successful"</span>);</span><br><span class="line">        httpAction.execute();</span><br><span class="line">        System.out.println(<span class="string">"The card id query successful"</span>);</span><br><span class="line"></span><br><span class="line">        Context context = ActionContext.getActionContext().getContext();</span><br><span class="line">        System.out.println(<span class="string">"The Name is "</span> + context.getName() + <span class="string">" and CardId "</span> + context.getCardId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上下文类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String cardId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCardId</span><span class="params">(String cardId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cardId = cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCardId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cardId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>全局管理上下文<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActionContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Context&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;Context&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Context <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Context();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//嵌套内部类单例模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ContextHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ActionContext actionContext = <span class="keyword">new</span> ActionContext();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ActionContext <span class="title">getActionContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ContextHolder.actionContext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Context <span class="title">getContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ActionContext</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>任务中具体内容执行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryFromDBAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">            String name = <span class="string">"Alex "</span> + Thread.currentThread().getName();</span><br><span class="line">            <span class="comment">//调用全局context，并直接修改context</span></span><br><span class="line">            ActionContext.getActionContext().getContext().setName(name);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueryFromHttpAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个任务就分为两步，首先获取name，从context中，然后再根据name获取cardID，存入context</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Context context = ActionContext.getActionContext().getContext();</span><br><span class="line">        String name = context.getName();</span><br><span class="line">        String cardId = getCardId(name);</span><br><span class="line">        context.setCardId(cardId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getCardId</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"435467523543"</span> + Thread.currentThread().getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ThreadLocal的理解与使用</title>
      <link href="/2019/04/18/readLocal%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/04/18/readLocal%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="基本理解"><a href="#基本理解" class="headerlink" title="基本理解"></a>基本理解</h1><p>ThreadLocal是一个本地线程副本变量工具类。主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。</p><p><img src="/upload/pasted-282.png" alt="upload successful"></p><p>从上面的ThreadLocal结构图中，可以发现</p><ul><li>每个Thread线程内部都有一个Map。</li><li>Map里面存储线程本地对象（key）和线程的变量副本（value）</li><li>但是，Thread内部的Map是由ThreadLocal维护的，由ThreadLocal负责向map获取和设置线程的变量值。、</li><li>所以对于不同的线程，每次获取副本值时，别的线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰。</li></ul><h1 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h1><p>在Thread中的ThreadLocalMap由ThreadLocal类维护</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment">     * by the ThreadLocal class. */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadLocal提供的三个核心方法</p><blockquote><p><strong>public T get()</strong></p></blockquote><p>Returns the value in the current thread’s copy of this thread-local variable. If the variable has no value for the current thread, it is first initialized to the value returned by an invocation of the initialValue() method.</p><blockquote></blockquote><p><strong>Returns:</strong><br>    the current thread’s value of this thread-local </p><p>简单来说，该方法就是获得当前线程副本的变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the value in the current thread's copy of this</span></span><br><span class="line"><span class="comment"> * thread-local variable.  If the variable has no value for the</span></span><br><span class="line"><span class="comment"> * current thread, it is first initialized to the value returned</span></span><br><span class="line"><span class="comment"> * by an invocation of the &#123;<span class="doctag">@link</span> #initialValue&#125; method.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the current thread's value of this thread-local</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> (T)e.value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本过程：<br>1.获取当前线程的ThreadLocalMap对象threadLocals<br>2.从map中获取线程存储的K-V Entry节点。<br>3.从Entry节点获取存储的Value副本值返回。<br>4.map为空的话返回初始值null，即线程变量副本为null，在使用时需要注意判断NullPointerException。</p><blockquote><p><strong>public void set(T value)</strong></p></blockquote><p>Sets the current thread’s copy of this thread-local variable to the specified value. Most subclasses will have no need to override this method, relying solely on the initialValue() method to set the values of thread-locals.</p><blockquote></blockquote><p><strong>Parameters:</strong><br>    value - the value to be stored in the current thread’s copy of this thread-local.</p><p>set()方法用于保存当前线程的副本变量值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sets the current thread's copy of this thread-local variable</span></span><br><span class="line"><span class="comment"> * to the specified value.  Most subclasses will have no need to</span></span><br><span class="line"><span class="comment"> * override this method, relying solely on the &#123;<span class="doctag">@link</span> #initialValue&#125;</span></span><br><span class="line"><span class="comment"> * method to set the values of thread-locals.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to be stored in the current thread's copy of</span></span><br><span class="line"><span class="comment"> *        this thread-local.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p><strong>remove</strong></p></blockquote><blockquote><p>public void remove()</p></blockquote><p>  Removes the current thread’s value for this thread-local variable. If this thread-local variable is subsequently read by the current thread, its value will be reinitialized by invoking its initialValue() method, unless its value is set by the current thread in the interim. This may result in multiple invocations of the initialValue method in the current thread.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Removes the current thread's value for this thread-local</span></span><br><span class="line"><span class="comment"> * variable.  If this thread-local variable is subsequently</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@linkplain</span> #get read&#125; by the current thread, its value will be</span></span><br><span class="line"><span class="comment"> * reinitialized by invoking its &#123;<span class="doctag">@link</span> #initialValue&#125; method,</span></span><br><span class="line"><span class="comment"> * unless its value is &#123;<span class="doctag">@linkplain</span> #set set&#125; by the current thread</span></span><br><span class="line"><span class="comment"> * in the interim.  This may result in multiple invocations of the</span></span><br><span class="line"><span class="comment"> * &lt;tt&gt;initialValue&lt;/tt&gt; method in the current thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line"> <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">     m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ThreadLocalMap的问题"><a href="#ThreadLocalMap的问题" class="headerlink" title="ThreadLocalMap的问题"></a>ThreadLocalMap的问题</h2><p>ThreadLocalMap是ThreadLocal的内部类，没有实现Map接口，用独立的方式实现了Map的功能，其内部的Entry也独立实现。</p><p><img src="/upload/pasted-283.png" alt="upload successful"><br>由于ThreadLocalMap的key是弱引用，而Value是强引用。这就导致了一个问题，ThreadLocal在没有外部对象强引用时，发生GC时弱引用Key会被回收，而Value不会回收，如果创建ThreadLocal的线程一直持续运行，那么这个Entry对象中的value就有可能一直得不到回收，发生内存泄露</p><p>避免：<br>既然Key是弱引用，那么我们要做的事，就是在调用ThreadLocal的get()、set()方法时完成后再调用remove方法，将Entry节点和Map的引用关系移除，这样整个Entry对象在GC Roots分析后就变成不可达了，下次GC的时候就可以被回收。<br>如果使用ThreadLocal的set方法之后，没有显示的调用remove方法，就有可能发生内存泄露，所以养成良好的编程习惯十分重要，使用完ThreadLocal之后，记得调用remove方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;Session&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;Session&gt;();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    threadLocal.set(<span class="keyword">new</span> Session(<span class="number">1</span>, <span class="string">"Misout的博客"</span>));</span><br><span class="line">    <span class="comment">// 其它业务逻辑</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    threadLocal.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>数据库连接：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder = <span class="keyword">new</span> ThreadLocal&lt;Connection&gt;() &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">initialValue</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(DB_URL);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> connectionHolder.get();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Session:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal threadSession = <span class="keyword">new</span> ThreadLocal();  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getSession</span><span class="params">()</span> <span class="keyword">throws</span> InfrastructureException </span>&#123;  </span><br><span class="line">    Session s = (Session) threadSession.get();  </span><br><span class="line">    <span class="keyword">try</span> &#123;  </span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            s = getSessionFactory().openSession();  </span><br><span class="line">            threadSession.set(s);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (HibernateException ex) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InfrastructureException(ex);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> s;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>确保挂起设计模式（Guarded Suspension）</title>
      <link href="/2019/04/18/%E6%8C%82%E8%B5%B7%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88Guarded-Suspension-%EF%BC%89/"/>
      <url>/2019/04/18/%E6%8C%82%E8%B5%B7%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%88Guarded-Suspension-%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="基本含义"><a href="#基本含义" class="headerlink" title="基本含义"></a>基本含义</h1><p>Guarded Suspension意为保护暂停，其核心思想是仅当服务进程准备好时，才提供服务。设想一种场景，服务器可能会在很短时间内承受大量的客户端请求，客户端请求的数量可能超过服务器本身的即时处理能力，而服务端程序又不能丢弃任何一个客户请求。此时，最佳的处理方案莫过于让客户端要求进行排队，由服务端程序一个接一个处理。这样，既保证了所有的客户端请求均不丢失，同时也避免了服务器由于同时处理太多的请求而崩溃</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><p>request类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代表可能会有很多的请求类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> String value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Request</span><span class="params">(String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>请求队列：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求等待队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> LinkedList&lt;Request&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获得等待队列的一个request，当没有request时，线程进行等待</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Request <span class="title">getRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">            <span class="keyword">while</span> (queue.size() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    queue.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Request request = queue.removeFirst();</span><br><span class="line">            <span class="keyword">return</span> request;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在队列中加入新的请求</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putRequest</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (queue) &#123;</span><br><span class="line">            queue.addLast(request);</span><br><span class="line">            <span class="comment">//唤醒等待线程</span></span><br><span class="line">            queue.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>客户端线程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//请求队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RequestQueue queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Random random;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String sendValue;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClientThread</span><span class="params">(RequestQueue queue, String sendValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">        <span class="keyword">this</span>.sendValue = sendValue;</span><br><span class="line">        random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//假设是10条请求</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Client -&gt; request "</span> + sendValue);</span><br><span class="line">            queue.putRequest(<span class="keyword">new</span> Request(sendValue));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//模拟花费时间</span></span><br><span class="line">                Thread.sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>服务端线程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务端线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RequestQueue queue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Random random;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ServerThread</span><span class="params">(RequestQueue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">        random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!closed) &#123;</span><br><span class="line">            Request request = queue.getRequest();</span><br><span class="line">            <span class="comment">//当请求为空时，跳出本次循环</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == request) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Received the empty request."</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Server -&gt;"</span> + request.getValue());</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">//中断时，跳出run方法</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.closed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">this</span>.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试线程：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuspensionClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> RequestQueue queue = <span class="keyword">new</span> RequestQueue();</span><br><span class="line">        <span class="keyword">new</span> ClientThread(queue, <span class="string">"Alex"</span>).start();</span><br><span class="line">        ServerThread serverThread = <span class="keyword">new</span> ServerThread(queue);</span><br><span class="line">        serverThread.start();</span><br><span class="line">        <span class="comment">//serverThread.join();</span></span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        serverThread.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Client -&gt; request Alex</span><br><span class="line">Server -&gt;Alex</span><br><span class="line">Client -&gt; request Alex</span><br><span class="line">Server -&gt;Alex</span><br><span class="line">Client -&gt; request Alex</span><br><span class="line">Server -&gt;Alex</span><br><span class="line">Client -&gt; request Alex</span><br><span class="line">Server -&gt;Alex</span><br><span class="line">Client -&gt; request Alex</span><br><span class="line">Server -&gt;Alex</span><br><span class="line">Client -&gt; request Alex</span><br><span class="line">Server -&gt;Alex</span><br><span class="line">Client -&gt; request Alex</span><br><span class="line">Server -&gt;Alex</span><br><span class="line">Client -&gt; request Alex</span><br><span class="line">Server -&gt;Alex</span><br><span class="line">Client -&gt; request Alex</span><br><span class="line">Server -&gt;Alex</span><br><span class="line">Client -&gt; request Alex</span><br><span class="line">Server -&gt;Alex</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> java多线程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程future设计模式</title>
      <link href="/2019/04/17/%E7%A8%8Bfuture%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/04/17/%E7%A8%8Bfuture%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>future设计模式实际上相当一个异步完成任务充分利用本应当的等待时间，有点类似于商品订单。比如在网购时，当看中某一件商品时就可以提交订单，当订单处理完成后，在家里等待商品送货上门即可。或者说更形象的我们发送Ajax请求时，页面是异步进行后台处理，用户无需一直等待请求结果，可以继续浏览或操作其他内容<br>类似于下面的一个商品订单的时序图</p><p><img src="/upload/pasted-280.png" alt="upload successful"><br>客户端发送一个长时间的请求，服务端不需等待该数据处理完成便立即返回一个伪造的代理数据（相当于商品订单，不是商品本身），用户也无需等待，先去执行其他的若干操作后，再去调用服务器已经完成组装的真实数据。该模型充分利用了等待的时间片段。</p><h1 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h1><p><img src="/upload/pasted-281.png" alt="upload successful"><br>Main：启动系统，调用Client发出请求；</p><p>Client：返回Data对象，理解返回FutureData，并开启ClientThread线程装配RealData；</p><p>Data：返回数据的接口；</p><p>FutureData：Future数据，构造很快，但是是一个虚拟的数据，需要装配RealData；</p><p>RealData：真实数据，构造比较慢。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>具体实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">Client client = <span class="keyword">new</span> Client();</span><br><span class="line"><span class="comment">//理解返回一个FutureData</span></span><br><span class="line">Data data = client.request(<span class="string">"name"</span>);</span><br><span class="line">System.out.println(<span class="string">"请求完毕！"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理其他业务</span></span><br><span class="line"><span class="comment">//这个过程中，真是数据RealData组装完成，重复利用等待时间</span></span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真实数据</span></span><br><span class="line">System.out.println(<span class="string">"数据 = "</span>+ data.getResult());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>client:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Data <span class="title">request</span><span class="params">(<span class="keyword">final</span> String queryStr)</span></span>&#123;</span><br><span class="line"><span class="keyword">final</span> FutureData future = <span class="keyword">new</span> FutureData();</span><br><span class="line"><span class="comment">//开启一个新的线程来构造真实数据</span></span><br><span class="line"><span class="keyword">new</span> Thread()&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">RealData realData = <span class="keyword">new</span> RealData(queryStr);</span><br><span class="line">future.setRealData(realData);&#125;</span><br><span class="line">&#125;.start();</span><br><span class="line"><span class="keyword">return</span> future;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Data:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span>  String <span class="title">getResult</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>FutureData<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 是对RealData的一个包装</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> limin</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureData</span> <span class="keyword">implements</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">protected</span> RealData realData =<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">boolean</span> isReady = <span class="keyword">false</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setRealData</span><span class="params">(RealData realData)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(isReady)&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>.realData=realData;</span><br><span class="line">isReady=<span class="keyword">true</span>;</span><br><span class="line">notifyAll();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">synchronized</span>  String <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(!isReady)&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">wait();</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> realData.result;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>RealData:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealData</span> <span class="keyword">implements</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line"><span class="keyword">protected</span>  String  result;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RealData</span><span class="params">(String para)</span></span>&#123;</span><br><span class="line"> <span class="comment">//构造比较慢</span></span><br><span class="line">StringBuffer sb= <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">sb.append(para);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">result= sb.toString();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> java多线程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>绘卷水浒传 20周年企划 第六章 翻译</title>
      <link href="/2019/04/16/%E7%BB%98%E5%8D%B7%E6%B0%B4%E6%B5%92%E4%BC%A0-20%E5%91%A8%E5%B9%B4%E4%BC%81%E5%88%92-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E7%BF%BB%E8%AF%91/"/>
      <url>/2019/04/16/%E7%BB%98%E5%8D%B7%E6%B0%B4%E6%B5%92%E4%BC%A0-20%E5%91%A8%E5%B9%B4%E4%BC%81%E5%88%92-%E7%AC%AC%E5%85%AD%E7%AB%A0-%E7%BF%BB%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<p><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-166.jpg" width="70%"></p><a id="more"></a><hr><p><font color="#FF0000">原文作者 森下翠和插画作者 正子公也 版权所有<br><br>个人翻译<br><br>仅供个人娱乐及同好者欣赏<br></font><br><br><br><a href="http://suikoden.com/" target="_blank" rel="noopener">原文地址</a></p><hr><h1 id="第六章-月下天堂"><a href="#第六章-月下天堂" class="headerlink" title="第六章 月下天堂"></a>第六章 月下天堂</h1><p>史进眺望着对面激扬而起的水花<br>手持长枪，稳稳的站着，这长枪，来自于死在逃亡路上的武器贩子“乌鸦嘴”，这些买卖人到生命的尽头都带着自己兜售的商品<br>史进感觉到了阵阵凉风<br>身旁站着的是金山大师和鲁智深<br>史进回头看了看背后的石窟，然后继续观察着对岸的走向<br>突然跃动起来，背上的龙，呼之欲出<br>（时候未到）<br>史进舔了舔干燥的嘴唇<br>现在，即使是这种等待，也是战斗</p><p>这个时候，石秀却潜伏在对岸<br>黎明之前，他在伊水上游渡河，绕过南岸的岩山<br>这是由石秀，李忠，陈达，杨春以及众亲近弟兄组成的敢死队，总计一百多人，他们留下了在正面战场的史进和鲁智深，只带了善于奇袭的梁山弟兄<br>杨春从岩石后面探出身子，窥视着北面<br>“一半的敌军正在渡河，另一半都在岸边待命”<br>石秀点了点头<br>“剩下的，正是守护林灵素的道士军，共计一万五千人”<br>官军打算躺过伊水，一口气消灭僧众，他们依仗人数上的优势，现在正全神贯注的集中在北岸<br>就趁着这个机会，奇袭敌后<br>因而留在北岸的史进众人也没发起攻击，正在等着恰到好处的机会<br>石秀他们的目标正是官军的统帅——“通真达灵元妙先生”林灵素<br>林灵素才是掀起这场法难的元凶，只要杀掉他，剩下的道士就会做鸟兽散<br>（皇帝也会清醒过来吧，即使没有，杀掉他也是大快人心）<br>昨晚王定六等人已经侦察到了敌人的本阵的帅旗是巨大的“太极旗”，石秀等人确认的在朝霞中飘展的太极旗后，就缓缓的下了岩山<br>他们沿着路一点点的向下，已经看不见敌人的大军了，在岩山脚下，依然徘徊者清晨的气息，石秀等人止住气息，慎重的前行着，依据太阳掌握着大致的方向<br>周围都是岩石和树林，地形错综复杂，穿过这里，不久就会到达本阵，实际上，已经可以感觉到从雾霭的另一端大军的气息<br>但是，不管怎么走，都看不见那太极旗，也无法接近敌军阵地<br>李忠注意到<br>“这地上的脚印可不是官军的，是哪里来的啊”<br>众人自己的脚比划了比划<br>“这不是我们自己的吗？”<br>“还真是”<br>陈达叫了一声<br>“迷路了，不，不对”<br>陈达和杨春认同的点了点头<br>“这是幻术”</p><p><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-133.jpg" alt="陈达和杨春"><br>石秀并不认同<br>“林灵素就是个徒有虚名的玩意”<br>“话是这么说，事不是这个事啊”<br>陈达郁闷的摸了摸被露水沾湿的络腮胡子，看着周围的杂树林<br>陈达和杨春是“神机军师”朱武的兄弟，朱武擅长布阵，不管是八卦阵还是摩诃兵法，都很精通，当年兄弟几人也和史进在芒砀山和“混世魔王”樊瑞战斗过<br>“这周遭就是当时那股子气息”<br>石秀沉默了，石秀也曾在梁山泊的芦苇荡迷瞪过，当年三打祝家庄时，也勿入了迷宫<br>“他妈的，怎么就这么倒霉”<br>石秀看着地上的纷乱的脚印<br>“史进众兄弟还在等着我们的奇袭”<br>抬头望望天，却被郁郁葱葱的树林遮住了，连太阳也看不见了</p><hr><p>金山大师正在北岸，面对着渡河而来的洛阳军<br>身上法衣已经血迹斑斑，也被刀刃划拨，在风中丝丝缕缕的飘荡着<br>鲁智深脱了光膀。杵着禅杖<br>两位大师站在反射着朝阳的河岸边上<br>鲁智深健壮的脊梁上，正闪耀着一朵盛开的红牡丹，金山大师察觉到了，一手握着般若雷，一手向着那朵牡丹行礼<br>“‘一切众生皆有佛性’——佛在人心”</p><p>鲁智深的禅杖激起一朵巨大的水花<br>战斗已经开始了<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-134.jpg" alt="2"><br>禅杖挥向了冲在前面的官军，毫不费力的将他们打翻在水中，丐帮的众人也怪叫着冲向前去，他们的武器各式各样，有棍子，有斧头，有农具，有扁担，还有不知在哪里捡到了的破败的兵器，虽然他们很瘦弱，但是手脚的力量也不可小觑，这凶猛的气势好像发狂的野狗一般<br>南北少林的武僧们正用精湛的拳法毫不留情的打倒眼前的官军，失去了“白光尊师”的护国禅僧们还有八人幸存，每当他们手持禅杖跃动时，便会有数十敌人应声而倒<br>两军曾在少林寺交过手，最终结果是率领洛阳军的宇文将军战死，半数的士兵失去战斗力，因而正都指挥使出征，然而此时他正在林灵素的本阵待命，实际的指挥则是手下的部将们<br>莫志正专心的射箭，可以说百发百中，毫无例外的穿过敌人的喉咙<br>（人和鸟没什么区别）<br>莫志一支一支的搭着箭，只是轻轻一瞄就出手了，轻快的弓弦音震动着耳膜，莫志不知不觉嘴角露出笑意<br>伊水已经一片血红，横尸遍野<br>岸边的佛像仁慈的微笑着，俯视着一片鲜红的战场<br>鲁智深背对着佛的微笑，在人群中厮杀着<br>人生在世，本是奇迹般的偶然重叠而生<br>“尽管如此，可死起来却这么的容易”<br>鲁智深砍翻眼前的敌人，大喊一声<br>“南无、阿弥陀佛！”</p><p>史进等人坚守在岸边，迎击着渡河而来的官军，背后的岩洞中是负伤者和诵经的僧尼<br>史进面前，有源源不断的官军涌来，枪出，弯折，猛跃，敌倒。史进的耳畔，只有自己的心跳和呼吸的声音<br>敌人众多，把史进团团围住，史进的枪已经断了<br>史进拾起已经倒下的少林武僧的棒子，继续战斗着，折断之后，就又用脚尖挑起一根，从来没有停下来<br>“石秀那边什么情况”<br>敌人还在一个劲的增加着<br>“奇袭还没开始吗？”<br>本想看看对岸的情况，却被袭击而来的敌人打断了<br>敌人包围史进，从四面八方出枪，史进闪身躲了过去，敌人又从身后砍过来，王定六的匕首，又在背后暗杀了袭击的敌人<br>“看来是赶不上了”<br>匕首闪闪发光，杀死了一个又一个敌人，无论倒下多少，都没有到头<br>洛阳军已经上岸了，禁军也正在赶过来，已经看不见河水了，放眼望去，全是敌军<br>王定六观察着这场战斗的去向，身上肩负着回报梁山泊的任务，但是，他也早已把生死抛在了脑后</p><p>官军正在陆陆续续的上岸<br>兵法云“半渡而击之”，可是，因为一直在等着石秀等人发起的奇袭，已经错过了出击的最好机会。已经让不少人上了岸。史进等人正在被逼后退，身后就是石窟，后面是陡峭的岩山，他们已经没有退路了，藏在石窟中的伤员和尼姑拼了命的投掷他们能拿到手的东西，不管是贡品台，还是破败的佛像的头，一道道弧线在空中划过，念经声响彻天地<br>白马寺的高僧们围着圣典《四十二章经》，一心求着佛的救赎，官军不知何时放出火矢，燃起了熊熊烈火，不小心也点燃了佛教传入这个国度最初的经典，顷刻间化为灰烬<br>僧侣们悲叹起来<br>“这就是末世吗？”<br>在这最后时刻，众僧尼已经做好了死的觉悟，但是，金山大师并没有放弃生的希望，舞动的般若雷，正是他的意志。旁边的鲁智深挥舞着禅杖，虽然被团团围住，但是他没在后退，脚就如定在地上一般<br>鲁智深等人站在最前面，承受着大军压境的巨大压力<br>龙门石窟旁卷起惊涛骇浪<br>“禁军已经上岸了！”<br>继先锋五千的洛阳军，一万名禁军登录伊水北岸<br>在对岸，还有一万五千道士军待命<br>莫志为了寻找退路而仰望着山顶，如果有机会爬上山的话大概还有机会逃命，就在这个时候，他好像看到了什么<br>悬崖上出现了“宋”的旗帜<br>“这里还有敌军出现吗？”<br>甚至伊水下游袭来的船队，也打着“宋”的旗帜<br>“敌人的援军！”<br>这回莫志彻底的绝望了，如果是官军的援军到了，那毫无疑问是节度使“药师”徐京和“老风流”王焕的军队——那些节度使终于响应了出征的命令<br>莫志慌了神，赶忙找到作为最后希望支柱的金山大师<br>金山大师沉吟不语，般若雷掷地有声<br>身后的巨大的卢遮那佛，仍然保持着慈悲的微笑<br>（大概就要终结了吧）<br>莫志仰望着卢遮那佛<br>打破不杀生戒的自己，是会得到宽恕还是最终会堕入地狱的轮回，那样的话，金山大师和天穹和尚都一样的<br>最终一起堕入地狱<br>莫志只求一死，手中握着最后一支箭，把箭头抵在脖子上，莫志看了看史进，又看向了鲁智深<br>（都要下地狱了，那个和尚怎么还在笑）<br>鲁智深兴高采烈的战斗着，血的殷红，背上牡丹的鲜红，健壮的肌肉闪耀着耀眼的光芒。他发出响彻四方的呐喊<br>“定能取胜！都爬起来，爬起来打倒他们！！”<br>本打算一死了事的莫志停了下来，一幅震惊的画面映入本要放弃的眼睛中<br>（那是流星吗——）<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-135.jpg" alt="feijian"><br>苍穹之中，看到了五道闪耀的光芒，他马上意识到那是箭，这五支从天而来的箭，在空中画出五道美丽的银线，五名官兵中箭而倒<br>莫志发现那是从下游杀入的船队射过来的，一个壮年武者精神抖擞的站在船头。秀丽的身姿，华丽的甲胄，还有那手中朱红色的弓<br>（那是！）<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-136.jpg" alt="huarong"><br>梁山泊席位第九，绰号“小李广”，正是花荣，爱弓朱雁的弦正在清吟着，花荣再次放箭，又有五个官军倒下。下游的船队一个个的靠岸了，上来的“宋军”，袭击了到达北岸的禁军，冲在最前面的是挥舞着双板斧的黑大汉<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-137.jpg" alt="likui"><br>“黑旋风”李逵，梁山泊席位第二十二，是专为杀人而生的天杀之星<br>山上下来的“宋军”也向北岸的洛阳军发起攻击<br>“冲上去！”<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-138jpg" alt="wusong"><br>从山上打着“宋”的旗号新加入战场的军队，领头的是“行者”武松，他正是江湖上赫赫有名的在景阳冈打虎的壮士，接下来是清风山的头领，“锦毛虎”燕顺，以及“打虎将”李忠的结拜兄弟，桃花山上的好汉“小霸王”周通，他们向着正在袭击手无寸铁的僧尼的洛阳军发起了冲锋<br>驾船而来的，正是“立地太岁”阮小二，“玉幡竿”孟康，光着膀子的汉子们陆续从船上下来，船头，作为“向导”的“鼓上蚤”时迁挥着胳膊，给同伴发出信号<br>“赶上了！！”<br>原来这些打着“宋”的旗号的军队，正是在山东秘密集结的梁山泊军<br>岩山上也出现了旗帜<br>石窟东面的岩山上，出现了一支骑兵队，一个禁军军官举着剑<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-139.jpg" alt="yangzhi1"><br>官军的援军——可是鲁智深却制止了打算迎击的武僧们<br>“等一下”<br>鲁智深很熟悉那张脸，覆盖半张脸的青斑是不可能弄错的——“青面兽”杨志<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-140.jpg" alt="yangzhi2"><br>梁山泊席次第十七，正是传说的英雄“杨无敌”杨令公的子孙，手持家传宝剑吹毛剑的无双剑客<br>杨志展现着当年那个“杨制使”的身姿，身边率领的军队脱下官军的伪装<br>而右边站着的，是“金枪手”徐宁<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-141.jpg" alt="xuning"><br>梁山泊席次第十八，本是禁军中金枪班的教头，是钩镰枪的传承者，身着祖传宝铠“賽唐猊”的英豪<br>左边的是梁山泊席位第十五的“风流双枪将”董平，背后挂着书写着“英雄双枪将”，“无双万户侯”的旗子，手持着标志性的双枪<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-142.jpg" alt="dongping"><br>他是一个自负文武双全的英俊<br>二人华丽的甲胄，正在战场上闪耀着<br>他们分散着离开梁山泊，向西行进，途中从官军那里夺走伪装，根据“智多星”吴用料事如神的智谋，又有两山泊完整的情报网，“梁山泊军”就在这个恰当的时候出现了<br>狼藉的战场上空，一只乌鸦正在空中盘旋，“锦豹子”杨林把分散出动的梁山泊同伴们引导到此<br>“看来重要角色已经到齐了，那么好戏就此开场了”</p><p>梁山泊的骑兵从山上冲刺而下<br>这个时候，史进也觉察到了战场上形势的变化<br>“那边，卢员外也到了吗？”<br>殿军的将领，正是坐第二把交椅的“玉麒麟”卢俊义，曾经是大名府的富豪，也被人称作“河北三绝”，本身也是武艺高强，养子“浪子”燕青，正拉着马嘴<br>卢俊义抬头看着由侯健缝制的“宋”的蓝旗<br>本来，宋军的旗帜为红色，相传宋国的本命颜色便是红<br>这里的“宋”指代的是梁山泊头领“及时雨”宋江的“宋”<br>那是比蓝天还有蓝的旗帜<br>“很不巧宋江大哥很忙，准备上吧，燕青！”<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-143.jpg" alt="lujunyi"><br>“交给我吧”<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-144.jpg" alt="yanqing"><br>燕青扛着旗子从山上跑下来</p><hr><p>这个时候，石秀感到视野一片模糊，眼前一片重重叠叠的景象<br>“能看见路了！”<br>如同阳光照在阴暗处一般，道路出现在密集的丛林当中<br>“可以继续前进了”<br>石秀跑了起来，他早已经听见了战场的喧嚣声，心急如焚<br>“等一下”<br>李忠想要阻止他<br>“这是幻想吧”<br>“那也顾不上了！”<br>陈达追着石秀，石秀就在一片晃动的视野中狂奔着<br>突然，眼前出现了几个黑衣道士，众人都手持铜剑<br>“敌人！”<br>石秀挥手就要砍，道士也开始迎击，顿时火花迸溅，视野突然一片晃动，听见了一个老者的声音<br>“你看错了，我们不是敌人”<br>石秀停了下来，道士们也四下散开<br>“看破！”<br>道士们跳向树梢，用剑尖刺穿了贴在树干上的咒符。这是用血写的咒符。一个白胡子老者出现在一脸茫然的石秀众人面前<br>“结界削弱了……这都是幻术，你们不要惊慌了”<br>石秀盯着老者<br>“你是哪里来的？”<br>“贫道来自华山”<br>华山是河南道教的最高峰，他们是山里的无醉长老以及被唤作“华山十子”的众弟子，他们因憎恨林灵素的恶行，特地赶到这里支援<br>无醉长老高举着拂尘，挥去了头上的虚空<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-145.jpg" alt="wuzuizhanglao"><br>只见无数燃烧的符咒纷纷落地，突然间，视野犹如被清洗过一般明亮起来，森林终于有了尽头，道路展开了，远处，可以看见林灵素的太极旗在飘扬<br>石秀情不自禁的笑了<br>“你们也是道士吧？”<br>“‘德不孤，必有邻’——这是儒教的一句话，‘正义’无门”<br>“这样的话就不和你客气了”<br>就这样，石秀等人穿过丛林，向着道士军的背后发起奇袭，林灵素的本阵，被一万五千道士军团守护着，这些人基本都是武者和军人出身的野心家，为了投机，投身于道教<br>他们也发现了北岸事态的变化，但是并没有动摇，只要保护好林灵素，即使洛阳军，禁军全灭，取胜也没什么问题<br>“敌袭，保护‘通真达灵元妙先生’！”<br>金甲道士们迎击石秀众人而上，走在前面的是一个军人出身的壮汉，他出身于军中，手持大刀，看了看石秀众人<br>“就这么些人吗？一口气消灭掉吧”<br>石秀咂了咂舌，本来他们的目标是以少量兵力引起敌方本阵的混乱，然后趁机偷袭林灵素，现在可倒好，周围都很明朗，石秀等人光天化日之下，实力被看的一清二楚<br>为首的壮汉嚎叫着挥着大刀发出进攻，然而，他正在叫唤的头猛的飞在空中<br>石秀一惊，紧接着冷笑起来<br>将此人斩首的是一个面呈菜色的独臂男子<br>梁山泊席位第三十二——石秀的义兄，薊州的“砍头杨雄”，正是“病关索”杨雄<br>“让你久等了，石秀”<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-146.jpg" alt="yangxiong"><br>“我可是一直在等着啊”<br>杨雄和石秀并肩杀入道士中<br>道士们突然乱了起来，这些自称“六甲神兵”的一万五千道士，基本都是“临时道士”，一看对面攻势凶猛，根本就没想过作战，他们不过是借此机会接近林灵素<br>道士们一哄而散，众人也不知道是什么情况，只是感觉一片混乱，觉得被大军奇袭了后方，石秀杨雄等人奋勇作战，再加上华山道士们的支持<br>“这是大军的奇袭！”<br>“我们中出了叛徒！”<br>官军动摇的情况，也传到了北岸作战的金山大师和史进那里<br>金山大师向着陷入迷茫的众僧人大喝一声<br>“勿失战机！”<br>大师鼓舞着众人，进行反击，般若雷轰鸣着，向敌人迈出一步<br>可那一步却未能迈出，有人从背后刺了一剑，“张神剑”大叫起来<br>“是那个混蛋”<br>叛徒满天星混入了信徒当中<br>“赶快把《精武大宝经典》给我交出来”<br>金山大师踢向背后，可是满天星却犹如妖狐一般闪身到了金山大师身前<br>“《精武大宝经典》到手了！！”<br>满天星抓着法衣的领子，正准备砍向金山大师，可他的刀，却被一根棒子止住<br>“我‘九纹龙’当你的对手”<br>“你打不过我的”<br>史进飞快的旋转棒子，向满天星发起攻击，这边满天星也不示弱，挥刀向着史进正面砍去，史进避开了满天星的大刀，向后纵身，虽然紧紧握着棒子，但是由于满天星的大刀挡着，无法发起攻击<br>“你赢不了的！”<br>满天星又使出一层力，突然间，一阵风起，满天星停了下来<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-147.jpg" alt="shijin2"><br>“夕照流星”——史进的棒子贯穿了满天星的胸口<br>就这样，满天星倒在了金山大师脚旁<br>大师从倒下的满天星手中拿走一卷古老的经典<br>“你了解这个吗？”<br>“这是武林宝典……上面写了制霸天下的秘籍？”<br>“正是”<br>大师把秘经按在额头上<br>“这是在敦煌沙漠中发觉的天竺经典，是磨砺灵魂 ，锻炼身体，提升悟性的宝典——那个时候武人还是一无是处”<br>满天星在地上微微呻吟，大师语速平缓，继续说道<br>“无明无尽——没有武力高下，岂有强弱之分？你这么想看，就给你看看吧”<br>“那些最终断绝消息的武者？”<br>“他们最终都选择了落发为僧”<br>满天星用空洞的目光望着史进<br>“梁山泊的‘九纹龙’……受教了，亦无遗憾”<br>金山大师合上了已经断气的年轻人的眼，沉吟道<br>“这世上还没有能领悟《精武大宝藏经》的人啊”<br>般若雷从大师手中脱落，脚下已经鲜血如柱。</p><p>战斗还在继续着<br>史进抓起一匹马，跳上马背，向着伊水河奔去<br>“林灵素现在何处？”<br>踏着水花跃上南岸，就可以看见林灵素的本营，已经受到了石秀等人的袭击，太极旗已经倾斜，可以看见众官军将领正在守着两个道士，一个身着潇洒的道服，另一个头上裹着布<br>史进朝着道士看去<br>“那是林灵素！”<br>就在这时，怪道士从衣服下面投出弯刀，史进躲开弯刀，向着林灵素砍去<br>听到了石秀的声音<br>“史进，注意后面！”<br>可是为时已晚，本来飞出去的弯刀，又折返回来，已经可以感受到刀锋的迫近，却又无法防御，就在史进马上就要被割断喉咙的时候，不知从哪里飞来一只棒子，敲到了弯刀<br>史进看见了那根飞来的棒子<br>（师父！）<br>可是，四下里敌我混杂，找不到那个身影</p><p>太极旗轰然折断<br>林灵素慌乱的叫了起来<br>“这些是什么人，现在什么情况？”<br>只见一个黑大汉双手持板斧，犹如暴风雨一般迫近，林灵素胸中燃起了无名的怒火<br>（这些贱种，又怎么能杀了我！）<br>林灵素手抓着背后安坐在莲花座的怪道士<br>“想些办法吧！！”<br>林灵素双手抓住怪道士的头<br>“把他们杀掉！”<br>在说出这句话的同时，不知哪里来的强大邪恶力量，从林灵素的口中流入体内，一股漆黑的力量萦绕着林灵素的身体，禁锢着灵魂，阻断了自由<br>林灵素呆住了，感受到了某种“存在”，怪道士正充斥着他的身体<br>（你——）<br>林灵素自称道士，但是他深知所谓法术不过是障眼法，但是此时此刻他清楚的感觉到了自己已经成了那个法力的奴隶<br>林灵素头顶生出一道青烟，天空中出现了一个巨大神灵的身影，只见他身着蓝衣，双眸闪烁着群青色的光芒。那是冷酷的杀戮之光。手上握着触天长冰杖，风雪呼啸。道士们胆战心惊地叫出了那个名字。<br>“青华帝君！”<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-148.jpg" alt="qinghuadijun"><br>是拥有无穷神力的万能之神，只要遵循，就无所畏惧<br>只见他默默抬起双眼，那个神的面孔，正是“通真达灵元妙先生”林灵素，身边的六甲神兵突然放出光芒，本来在战场节节败退的他们，突然发起了猛攻<br>而这背后真正的支配者，正站在“青华帝君”的头上，怪道士——“金华魔人”包道乙——终于显现出真正的力量<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-149.jpg" alt="baodaoyi"><br>“你不是想成为神吗，那就把身体献给‘力量’吧”</p><hr><p>僧侣们纷纷抛下武器，伏在地上<br>战斗中的僧侣知道自己距离地狱的轮回已经不远了<br>终于来“迎接”他们了<br>不是乘着七彩云彩而来的菩萨，而是踏着火焰的恶鬼<br>“佛法将尽，世界将末”<br>随着“青华帝君”的出现，六甲神兵的大军也渡过伊水<br>他们目睹着卢遮那佛在烈火中燃烧，身体已经崩坏，僧侣们四下奔逃，诵经声已经变成了悲鸣，僧侣们已经走到临头<br>“大师啊，救救我们吧”<br>金山大师是众人最后的希望，用法力和武术来阻止这个恶魔神吧<br>年轻的见习僧人莫志也默念着经文，手中握着弓箭，母亲的希冀，龙门大禅师的教诲都在心中，可是，眼前的生命却无法挽回<br>救济众生的弥勒佛降世，那已经是五十六亿七千万年后的事了<br>【《菩萨处胎经》：“弥勒当知，汝复受记，五十六亿七千万岁于此树王下成无上等正觉。”】<br>莫志咬紧牙关，瞄准“青华帝君”的眼，放了一箭，不过，他只是张了张嘴，箭就像树叶一样被吞没了<br>护卫伤者的“张神剑”，已经被人砍断了腿倒下了<br>“青华帝君”拄着拐杖，向卢遮那佛前进。<br>就在这时，金山大师站了出来，挡在前面<br>“退下，天魔”<br>没有兵器，没有扈从，只是张开手掌，伸出双手<br>“青华帝君”的手杖刺进了他的胸膛<br>史进感觉周围突然变的一片昏暗，鲁智深看着天空，噼里啪啦的迸发出火花<br>一瞬间，所有人的呼吸都止住了<br>所有人所发出的情感——恐惧，已经到了极点<br>突然一个大爆炸，雷声轰鸣<br>什么也听不见了<br>那是覆天盖地，前所未有的轰鸣</p><hr><p>雷鸣撼动了天空<br>林灵素的意识，被包道乙支配着，只知道自己化身“青华帝君”，正向着金山大师发起攻击，不知是谁喊了一句<br>“林灵素杀死了金山大师！”<br>林灵素感到支配自己的包道乙微微一笑，同时，他也感到了无数人的愤怒<br>这些愤怒横穿天空，撕裂了风，化作落雷冲入金山大师的胸膛，金色光芒四散，闪耀在整个龙门<br>光芒在旋涡中回旋，金山大师所释放的光芒，不断流转，竟化身为龙，龙猛的跃起，缠绕在石窟中毘沙门天像上<br>“啊……!”<br>人们屏住呼吸<br>毘沙门天突然睁开了眼睛<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-150.jpg" alt="pishamentian"><br>只见神王双目燃着怒火，龙化作神火，缠绕在剑上，燃起的火直冲天空，毘沙门天正在行进着。【真神仙打架】<br>左手端着宝塔，右手拿着剑，就这么从悬崖上跳了下来，注视着“青华帝君”，“青华帝君”已经准备好逃走，却被从乌云中涌出的黄金魔人挡住了去路<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-151.jpg" alt="sharu"><br>毘沙门天挥舞着剑，向着失去退路的“青华帝君”的头顶砍了一刀，直至鸠尾。<br>“青华帝君”的蓝色身体开始剥落，里面是一片虚无，在这片虚无中，一朵莲花开始绽放<br>莲花向着四周发出金色光芒，茎正在慢慢的延伸，直达天际，伴随清脆的响声花开了，盛开的莲花顶端，出现了一个白眉白须，满面慈爱笑容的老神仙，道士们看着手中的拂尘，七寸的耳朵，额头三道皱纹，不禁叫出声来<br>“道德天尊——太上老君！”<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-152.jpg" alt="taishanglaojun"><br>正是道教的先祖——老子，化身神仙的身影<br>毘沙门天又开始行进，举着宝塔，卢遮那佛崩塌了，从碎石中，浮现出正在安详微笑的圣者释迦的身姿，坐在黄金莲花上，只见他飞向空中，在七彩云彩的伴随下，和老子并排而坐<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-153.jpg" alt="shijia"><br>两人都是圣母诞下，历经凡人的坎坷，最终化身为神的人<br>抬头仰望着被光环包围的二尊的人们，恍惚间听见了仙女和天人演奏的乐曲<br>敌我无言</p><hr><p>“入云龙”公孙胜伫立在云雾缭绕的岩山之巅，虽然双目紧闭，但是脑海中“怪道士”包道乙的身姿却异常清晰<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-154.jpg" alt="gongsunsheng"><br>（外法道士——已经死了吗？）<br>包道乙被公孙胜猛烈的法力所击倒，吐血而卧<br>公孙胜收起龙杖，转过身去<br>法力在空气中消散，包道乙终于可以活动了<br>他刚才在屏住气息装死<br>（这是二仙山的森罗万象之气）<br>但是，却还有一个气息<br>（暗中做法操控黄金魔人的……）<br>所谓二仙山的法戒，应当是容不下相异的外法的<br>包道乙只觉得自己里力量全部消散了，有人，不，周围的一切夺走了他的气<br>这种力量的真实面目是在金华山修行的老道，因为有着优秀的潜质，为了追求终极的法力，故涉猎了外法，他的力量，并不是天然的气，而是根据人心增幅的力量<br>身旁，觉得“怪道士”的法术更好的林灵素慌了神<br>“跟这种法力相比，你实在算不得什么啊”<br>包道乙匍匐着，混在重叠的尸体中逃走了<br>二仙山的术，才是真正的法术，并不是映照人内心的恐惧，而是实际存在的自然之气，通常可以感觉的到，只不过人们熟视无睹<br>那是只有达到“无我”境地，与世界融为一体才可以驾驭的力量<br>（必须赶紧逃走了，罗真人看不了那么远，向南……然后）<br>怪道士眼中发出怪异的光芒<br>（需要更强大的依附）<br>更加强大的人——</p><hr><p>林灵素清醒过来，站起身来环顾四周<br>（是一场梦吗？）<br>不知不觉，神佛已经消散不见，地上的人们呆立着不知所措<br>大家都莫名其妙的忘了自己要做到事<br>梁山泊的好汉，也莫名其妙的消失了<br>这个时候，石窟的上方，岩山的顶端，出现了色彩鲜艳的旌旗，是皇室的龙旗，举着旗子的仪仗走了过来，郎朗的声音在空中回响<br>“奉天承运，皇帝诏曰——众人下跪受旨”<br>这是一个让人难以相信的声音，压过了战场的喧嚣，响彻四方<br>在场的数万人，无论远近，听得一清二楚<br>岩山上，皇帝的亲卫军排起了长队，那是青年将校曹晟率领的五十轻骑，全是华丽的金吾卫装束，不过，却显得一片灰尘，他们是从东京疾驰而来，赶赴龙门<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-155.jpg" alt="qinweijun"><br>曹晟身边并排的是金奴公主——银树。史进等人也没能马上认出来，并不是因为扎着头发，穿着公主的装束，而是因为被禁卫军环绕的银树，脸色苍白，一脸刚毅<br>身边白马的侍从，正是发出响彻千里的声音的人<br>“荣德公主殿下！”<br>在众人的注视下，银树在曹将军的帮助下从马上下来，就这样强支撑这身体，向着悬崖边走去<br>她深吸一口气<br>“战争，已经结束了！”</p><p>接着侍从的声音响彻天地<br>“废佛令停止了，赶快放下武器！”<br>银树双手拿着诏书，这是盖有皇帝玉玺的亲笔诏书<br>她的眼睛在战场上徘徊，在数万人中，寻找着那个熟悉的身影，她发现了正在叫唤的太白<br>“薛永，还活着！”<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-156.jpg" alt="xueyong"><br>银树大声的呼唤着那个名字<br>“薛永！”<br>薛永虽然受了伤，但是听见银树的声音，猛地站起身来<br>那时，他为了守护银树，孤身一人与追兵战斗，就在战斗到极限时，薛永发现自己并不是一个人——铁锹，铁算盘，铁笛，铁棒，保护着薛永<br>“——黄门四怪！”<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-157.jpg" alt="huangmensiguai"><br>“九尾龟”陶宗旺、“神算子”蒋敬、“铁笛仙”马麟、以及“摩云金翅”欧鹏，默默无言的战斗着<br>记忆逐渐模糊<br>回过神来，薛永正在陶宗旺的马上，马麟正在给他疗伤，告诉他他们正要前往龙门<br>银树正在招手，一切都不是幻觉！<br>公主身边的侍从，是“铁叫子”乐和，银树的侍从，正是梁山泊——不，应当说是整个大宋嗓子最好的“铁叫子”乐和<br>他受吴用之命接近王都尉，为了解救智真长老而四处奔走<br>一行人中，也有作为传令在东京和梁山泊之间奔走的“神行太保”戴宗<br>（梁山泊的众兄弟救了银树）<br>薛永凝视着彼方的银树，目光如炬<br>公主庄严华丽的打扮，佩戴的珍贵宝石，真的好耀眼，还有那温暖人心的笑容<br>（太好了！）<br>虽然这样想着，却好像看见了幻象，薛永也无法回首</p><p>林灵素只感觉世界一下子崩塌了<br>只觉得一片空虚，脚下隐约有黑暗的深渊张着嘴——明明自己没有施展过法术，却看到了那种幻影<br>郭道士赶到林灵素身边，得知事情有变，他火速赶了过来<br>“‘通真达灵元妙先生’，接下来如何？”<br>“——杀！”<br>林灵素听到了自己心底的声音<br>“公主也好，金吾卫也罢，统统杀掉吧”<br>然后再把责任归结于“叛军”，自己再率军平定他们<br>直到现在，林灵素都还没有认清形势，更没有看透自己。也许耳边慕容贵妃的声音正在回响<br>金吾将军曹晟对林灵素不放心，于是让手下侍卫护卫金奴公主<br>“林元帅，赶快下达撤军的命令”<br>林灵素冷冷的看着曹晟，只有五十护卫，听命林灵素的道士军团“六甲神兵”还残留着数千人<br>这个时候，两个密探赶了过来，一个是催促节度使出兵的使者，另一个是监视慕容贵妃的密探<br>一个使者告诉他<br>“王焕已经离开了宅邸！”<br>“现在才赶过来吗？”<br>“身边的随从都在念着‘南无阿弥陀佛’”<br>“什么？”<br>监视慕容贵妃的密探向困惑的林灵素又低语道<br>“慕容贵妃已经越过国境，到达辽国，辽国大军已经在沙漠中布阵了”<br>面对意想不到的报告，林灵素终于反应过来<br>密探之所以这么迟，是因为慕容贵妃去了辽国<br>（那女人成了辽国的走狗吗？）<br>这下就全都能说通了，猫儿一直催促节度使发兵的理由也能理解了，守卫边境的节度使一旦出动，辽国就有机可乘<br>（大宋若亡，成了国师又有什么意义）<br>林灵素终于做出了正确的选择<br>“——贫道林灵素受旨”<br>他仰望着金奴公主，跪了下来</p><p>战斗已经结束，道士们扔下武器<br>银树把后续事情交给曹将军处理，急忙赶到临终的金山大师身边<br>银树在东京时，她跟随王都尉到了艮岳，银树提到了关于慕容贵妃的事情，王都尉马上意识到还有比“法难”更加严峻的事，他同时收到了辽军在山西边境活动的报告，如果节度使受命镇压“叛乱”，那辽军就要攻过来了——向皇帝进言速做决断<br>皇帝选择相信自己的女儿<br>听闻了金山大师并没有反叛之心，他放心了<br>此时大师正躺在地上，周围有僧侣守护着，银树紧紧地握住金山大师的手，已经冰凉，她靠近大师的耳朵，把一切告诉他<br>“废佛已经停息，马上将在全国范围内下令，智真长老也平安无事”<br>听完银树的话，金山大师也终于走到了生命的尽头<br>没有什么奇迹<br>不见百只翔鹤，也不见七彩祥云<br>只是人们感觉到了河畔吹来的清爽的风，注意到阳光下焕发的生机<br>一只白鸽悠然的飞过天空<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-158.jpg" alt="baige"></p><hr><p>与此同时，山西代州郊外，国境附近<br>天空中一直海东青正在盘旋，那是来自北方的猛禽<br>面对视线南方围堵的长城，辽国大贵族，大将军兀颜光目光锐利<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-159.jpg" alt="wuyanguang"><br>风沙中行进的那人，是一个金发碧眼的壮汉，身着厚重的盔甲，正在马上等着“回报”<br>正在焦急的等待着狼烟升起<br>他的身后，是契丹的三万精锐骑兵<br>他们计划一看到信号，就攻入雁门关，越过长城，侵入山西，南下方向有五台山，这一带由于智真长老受难，反宋气焰日益高涨，举着“护法”的旗帜，进攻起来应该很容易吧<br>防守的关键，是两个节度使，太原的“药师”徐京和洛阳的“老风流”王焕。辽军是不怕宋军的，虽然数量和装备都占优，但是士兵怯懦，即使百人，也不敌契丹一骑<br>（但是，“节度使”可是不一样的）<br>徐京，王焕两个猛人养出的兵士，一直坚定的阻挡着辽国的进攻<br>现在这两人应该已经发兵龙门了<br>兀颜光所等待的，就是“节度使已经出兵”的回报<br>若是他们不在驻扎地，就立刻发起攻击，打下太原府，然后向西与后续部队会和攻下洛阳，就可以将宋国的西面纳入怀中，周边是西夏，大理，吐蕃等佛教国家，应当会支持“救佛”这个大义名分<br>（宋国的幼稚皇帝是真的愚蠢）<br>当然，辽国也是佛教国家，从皇帝到平民都是虔诚的佛教徒，兀颜光受辽国皇帝之命出征，发起一场救济僧侣和扩张领土一举两得的战争<br>一个探子疾驰而来<br>“报！”<br>探子在兀颜光面向跪下<br>“徐京，王焕两节度使并没有发兵的迹象”<br>探子汇报了侦察的结果，虽然东京方面多次下令出战，但两个节度使却迟迟没有出兵<br>兀颜光一脸沮丧<br>（可惜了，看来那个女人也立不了功了）<br>不久，又有探子回报龙门的战斗已经结束，法难也已经结束的消息<br>兀颜光注视着军队后方，一群青衣侍女护卫的马车，也许是已经察觉到情况有变，正要撤离<br>不知何时，这个女人出现在辽国，凭借其美貌和才能进入宫廷，现在已经上位到出入朝廷的地步，但是她的来历依旧成谜<br>兀颜光回转马头<br>“虽说是场面话，但两国尚有盟约，被宋军盯上了就麻烦了”<br>兀颜光拔出宝剑<br>“全军，撤回燕京”<br>兀颜光率领辽军如风般的撤走了，西北荒野又陷入一片寂静</p><hr><p>老风流”王焕正在骑马奔驰<br>“看我一人斩杀他千名无道道士！”<br>当龙门映入眼帘时，王焕一声吼叫，止住了马<br>“怎么，已经结束了吗？”<br>王焕在马上捋着长长的胡须，手中横着爱用的长枪<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-160.jpg" alt="王焕"><br>“真是窝囊，再坚持一下就好了”<br>他的身后是一批同样长须飘飘的老者，他们身着已经褪了色的铠甲，但仍不失英勇的气概，这些人是已经卸甲还乡的老将，有的是和王焕并肩作战的战友，有的是当年他的手下，他们曾在战场并肩杀敌，虽然已经退休，但是仍然保留着当年的情报网，一得知王焕出走的消息，他们纷纷拿出已经多年不穿的战甲，重新披挂上阵，前来支援<br>石窟周边，伊水河畔，无数的尸体，僧侣和尼姑不分敌我的看护着正在呻吟的人们<br>在微笑的卢遮那佛旁边，色彩鲜艳的“宋”的旗帜合着上供的鲜花，毫无疑问，护法军胜利了<br>王焕放声大笑<br>“这是佛罚，是佛罚啊”<br>王焕亡故的爱妻，贺玲玲，是当年洛阳闻名的美女【名妓，嗯】，年轻时，某个清明，两人在白马寺相遇，从此便私定终生，但是却被某个高官阻拦，王焕沦落不得不投身山贼，但他依旧虔诚，总到寺院参拜，坚信两人一定终成眷属，最终实现了愿望<br>【出自元杂剧《逞风流王焕百花亭》】<br>他想起了薄命佳人临终遗言<br>“即使战乱，也不要毁坏佛寺”<br>他拿出爱妻遗留的梳子<br>“我王焕，即使对君不忠，也不会违背和女人的约定”<br>王焕的白须在空中飘扬，哈哈大笑<br>国家无道，便落草为寇，这种念头，从青春之日就不断在王焕心中生长<br>“那么。就回去吧，女人们该担心了”<br>“只要将军一句话，即使奉上白发首级，我等也在所不辞”<br>即使节度使未出兵支援，即使王焕“秘密叛逃”，这次也没有任何人前来问罪<br>之后，王焕命令这些曾经的部下前往那些堆满了金银的道观征收“保护费”，重建被烧毁的诸寺<br>法难结束，害怕寺院报复的道士们，都纷纷表示“合作”</p><p>伊水岸边，孟康的船停泊着，等待着归来的客人<br>“铁叫子”乐和已经上了船<br>在这不算太热的初夏时节，乘船出游大概是一件美事，乐和本想放声歌唱一曲，但是想了想却又作罢<br>龙门的战场，还有无数的生命正在飘忽不定的闪烁，各种各样的想法交错，他不知道应该唱一首什么样的歌<br>取而代之的是，他向着河岸的石秀打了声招呼<br>“石秀大哥还不打算回去吗”<br>“哥，你怎么说”<br>石秀问坐在身边的杨雄<br>“洛阳不是大哥的故乡吗，要不顺道去看看吧”<br>“不，不用了，这一道下来太累了，我已经受够了”<br>“那咱们就回去吧”<br>石秀背着杨雄，猛地跳上了船，水花飞溅，孟康嘟嘟囔囔的发了句牢骚<br>“船夫哥，赶快开船吧”<br>石秀一身疲惫的躺在甲板上<br>船离开龙门<br>风景渐行渐远，但蓝天依旧湛蓝</p><p>史进手持小木龙，仰望着石窟<br>“——那我们就回去了”<br>“张神剑”拄着一把枪，牵着一匹失去主人的军马，手下也有几人幸存，也还带着从达摩堂领来的赏钱<br>“虽然这次很亏本，但想来可以和子孙后代炫耀，也还算不错”<br>“张神剑”举着长剑，那正是他绰号的由来<br>“再见了，‘史进’”</p><p>史进在僧侣和石窟之间寻找着，但是不见木龙行者和王进的身影<br>在一个无人的小石窟中，刚好可以容纳一个木龙，石窟的佛像正在雕刻中，脸还没有刻好<br>“这就是师父”<br>史进相信王进就在龙门<br>“好像又离开了”<br>李忠一脸疲惫的走向史进<br>受伤的脚上缠着布，李忠安慰道<br>“你已经掌握了师父的一切本领，如果没什么可教的了，师父自然会默默离开”<br>“再也见不到他了吗？”<br>“所谓‘恩师’，大抵如此”<br>陈达杨春也过来了，带着从道士和官军那里的战利品，陈达怀里鼓鼓囊囊<br>“给朱大哥带上一份土特产，回去就没那么多说教了”<br>“土特产的话，还有更好的哦”<br>大家朝着伊水岸边望去<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-161.jpg" alt="123"><br>蓝天下，两人（一狗）的身影，如画一般</p><hr><p>“父亲已经准许我不用再当尼姑了”<br>银树抓着薛永的手，公主的打扮，楚楚动人<br>“薛永，你也不用当什么艺人了，我已经拜托父亲，让他封你为将军”<br>薛永笑了笑<br>“这个”<br>他解开挂在脖子上的玉护符，挂在了银树脖子上<br>“给我吗？”<br>银树笑靥如花，薛永却转移了视线<br>“看，大家都在等着你呢”<br>银树松开了薛永的手<br>“是啊”<br>她作为“特使”很忙，除了战后的善后工作，还要为彭尼等伤员请来太医，并命令侍从准备金山大师的灵柩，也派遣曹晟将军寻找慕容贵妃<br>但是，不可思议的是，银树已经不那么在乎她了<br>那个坏人，是不可能善终的<br>“薛永，你在这等我，随我回东京”<br>“嗯”<br>“一定”<br>“嗯，一定”<br>银树被众多护卫守卫着离去，回过头了，笑着挥手<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-162.jpg" alt="yinshu"><br>“好汉不会说谎的”</p><p>史进呼唤着在岸边发呆的薛永<br>“嘿，美男子”<br>“史进大哥”<br>“你喜欢吧”<br>“不要再拿我开玩笑了，人家可是……”<br>薛永自顾自的说着<br>“可是堂堂的公主”<br>史进抓住薛永的手腕<br>“这样那咱们就绑她上山”<br>“什么？”<br>“赚她上山，然后你娶了她”<br>薛永沉默不语，两人哈哈大笑<br>船正在岸边等着，史进向着船走去，薛永也跟了过来<br>“史进大哥找到师父了吗？”<br>“啊，见到了”<br>史进握着木龙，抬头仰望着龙门的蓝天<br>他看见彭尼被人，手中握着一朵鲜艳的红曼珠沙华<br>史进深吸了一口凉爽的河风<br>“回去了!”<br>阮小二架着船离开了岸边<br>岸边的石佛们微笑着送一行人离去，薛永一直望着龙门，望着已经快要消失的银树的身影<br>声音已经传不到了<br>可是那笑容，却照亮了七里的距离<br>“再见，祝你幸福”</p><hr><p>在混乱的人群中，莫志寻找着史进<br>莫志手中拿着天穹和尚赐予的弓——“破烦恼宝弓”——不管天穹和尚是怎么想的，这个弓至少解开了年轻的莫志的疑惑<br>可是却怎么也找不见史进，死伤者中也不见，叫了名字也没人答应<br>取而代之的是，莫志遇到了以前白马寺的僧侣们，他们是护卫着《四十二章经》一同前来龙门的和尚，虽然白马寺的至宝《四十二章经》已经没了，但是他们都幸存了下来<br>那些和尚盯着莫志手中的弓<br>“莫志啊，你破了杀戒，竟然没用堕入地狱？”<br>“没有”<br>莫志毫不羞涩的回答道，也不打算反驳<br>只是，他清楚的说道<br>“我已经不是‘莫志’了，我有我的志向”<br>莫志昂首挺胸，举着手中的弓<br>“我要和一切不正当战斗，用我的弓消灭一切不公”<br>并且，他也要超越“梁山泊的花荣”，成为大宋第一，不，应该是世界第一的优秀神弓手<br>年轻的射手燃着热血，抛弃了僧衣，手中握着弓，拿着沾着鲜血的《精武大宝藏经》<br>“我要还俗，恢复本名，我的本名是——庞万春”</p><hr><p>岩山之巅，立着两个怪人<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-163.jpg" alt="1"><br>是一个黑衣道士和一个三眼的异形者<br>这是“幻魔君”乔道清和他的弟子“神驹子”马灵——他们是在山西揭竿而起，自封为晋王的田虎麾下重臣，他们建立晋国，企图推翻宋的统治<br>他们混在道士中招募有用的人才，并且依仗林灵素判断打败宋的可能性<br>他们对此相当失望<br>“林灵素什么的真是不够看啊”<br>乔道清咒骂道<br>“不过是一个夸夸其谈的混账玩意，搞了这么一出无聊的闹剧”<br>“师父，方才那个怪人，是什么来历？”<br>“大概是金华山一带的邪教徒吧”<br>“咱们这次帮着宋这一边真的好吗？”<br>阻挡“青华帝君”撤退的金色魔人，正是“幻魔君”乔道清施法召唤的<br>“好不容易跑来一趟，稍微玩一下也没什么问题，话说回来，契丹若是打过来，对我们建国也没好处啊”<br>正是因为辽国窥视着山西的领土，徐京王焕的防守重点在国境，田虎也才能发展起来<br>“妄图以宋国内乱制造机会的想法还是不要再提了，果然，国运只能依靠力量，稳健派的卞祥等人大概会厌恶吧”<br>乔道清觉得，需要更强大的人入伙<br>这样想着，一个名叫包道乙的怪道士，正拖着受伤的身体匆匆离去<br>“回去吧，马灵”<br>马灵看了看天空，已经不见云彩<br>“那个毘沙门天……”<br>马灵的额头抽搐着，第三只眼可以感觉到空气中残留的“气”<br>乔道清也感受到了如此强烈的波动<br>“只怕是二仙山的五雷天心正法，不，不对，应该是公孙一清——‘入云龙’”<br>“一清道人已经入伙梁山了”<br>“即使他们打着‘宋’的旗子，也瞒不过我，那伙人就是梁山的”<br>梁山泊为何会站在僧侣这一边，乔道清也想不明白<br>（那伙人不知在搞什么阴谋）<br>乔道清只感觉后背一阵战栗，可不能惹恼了这伙人啊<br>“‘梁山泊’——还是通报‘龙公’孙安一声吧”<br>不安的风，正围着乔道清的漆黑法衣打转</p><hr><p>东京开封——中心的皇城<br>那棵树至今仍在宫中一角，已经长起来了，只是不受欢迎，被遗忘在庭院中<br>柔软的树干、艳丽的绿叶、星光般的白色花朵。银木犀的甜蜜香味在微风中散发出来。<br>银树——赵金奴，穿着公主的装束，再次站在树下<br>十年前在绝望中离开，十年后又重回起点，也看见了已经长大成人的亲哥哥，可是金奴，永德公主这些称呼，在她看来却相当陌生<br>“公主殿下，圣上有请”<br>“我问你们，有个叫薛永的，来没来”<br>金奴这一天中已经不知道问了多少次<br>“他带着只大狗……约定好回来的”<br>“公主殿下，并没有这样的人”<br>金奴告别了怀念的庭院<br>纵使闭上双眼，也再也见不到儿时的梦幻世界<br>金奴离开了没有了母亲的身影的后宫，在侍女的陪伴下，前往自己的父亲身边，身为太子的哥哥和智真长老也在那里<br>虽然智真长老因为断食而消瘦，但身体还算硬朗<br>在皇帝多次的劝说下，智真长老终于做了上座<br>皇帝为自己被人蒙蔽而道歉，慰问长老，并且安排禁卫护送长老返回五台山<br>金奴走到智真长老面前<br>她还有想要确认的事，关于无法从金山大师那里得知的自己的命运<br>“我真的是个‘不吉之子’吗？”<br>长老拿着念珠，注视着公主的眼睛<br>“‘天有三日，望月辉耀’——公主啊，你的命运，就犹如被三轮太阳一同照射般一样残酷，但是，即使被太阳摧残的大地，也会有清凉的夜晚降临，云端之上，满月也会闪耀，不管以后发生什么，请公主柔韧，坚强的活下去”<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-164.jpg" alt="1"><br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-165.jpg" alt="2"><br>荣德公主赵金奴在宋国被金国灭亡后，就被掳到了金国，父亲，哥哥几乎所有的皇族，都成了俘虏，境遇相当残酷，在艰难的北上之旅中，不少公主，后妃丧命<br>金奴在二十五岁那年，在这场动乱中活了下来，失去了丈夫左卫将军曹晟，成了金国皇族完颜昌的侧室，但最终却在金国的政变中所杀<br>最终，以皇后的礼遇下葬，终结了波澜的一生</p><hr><p>出征河南的好汉们都回来了，梁山泊又恢复了往日的平静<br>中秋之夜，又是前头领晁盖的忌日，大家聚首聚义厅，举行着大规模的宴会<br>在山中待命的好汉们，都想听听史进这次的遭遇，就都围在史进身边，史进和大家聊着自己的各种遭遇，大家都痛快的开怀畅饮，座位上，还有一个为不在这里的人准备的酒杯<br>史进喝的酩酊大醉，为了醒酒来到外面，月亮正圆<br>湖面上，满月的影子清晰可见，薛永和太白正在那边<br>“好生快活啊”<br>听见一声感叹，薛永回头一笑<br>“的确是啊”<br>宴会仍在继续<br>史进也上前来，望着湖面上浮现的月光<br>想来师父王进，也在某处享受着一时的静谧吧<br>也一定正在享受着一杯酒，和某人一同赏月吧<br><img src="http://suikoden.com/graphies/images/aniv20-6/108%20Outlaws-166.jpg" alt="1"><br>宣和年间——那是大宋和梁山泊最后一个安宁的时期</p>]]></content>
      
      
      <categories>
          
          <category> 绘卷水浒传 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 绘卷水浒传 二十周年番外 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java的String三剑客（String，StringBuilder，StringBuffer）</title>
      <link href="/2019/04/16/va%E7%9A%84String%E4%B8%89%E5%89%91%E5%AE%A2%EF%BC%88String%EF%BC%8CStringBuilder%EF%BC%8CStringBuffer-%EF%BC%89/"/>
      <url>/2019/04/16/va%E7%9A%84String%E4%B8%89%E5%89%91%E5%AE%A2%EF%BC%88String%EF%BC%8CStringBuilder%EF%BC%8CStringBuffer-%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>在有了不可变对象和不可变类的概念以后，就可以分析一下java中String，StringBuilder，StringBuffer三个概念<br>网上有一篇很简单明了的<a href="https://www.cnblogs.com/su-feng/p/6659064.html" target="_blank" rel="noopener">教程</a></p><h1 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h1><p>运行速度，或者说是执行速度，在这方面运行速度快慢为：<strong>StringBuilder &gt; StringBuffer &gt; String</strong><br>而原因就是在于String是不可变的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str=<span class="string">"abc"</span>;</span><br><span class="line">System.out.println(str);</span><br><span class="line">str=str.replace(<span class="string">"c"</span>,<span class="string">"mn"</span>);</span><br><span class="line">System.out.println(str);</span><br></pre></td></tr></table></figure><p>有人会说，这样str不是变了吗？<br>要想解释这个问题，首先我们要知道String类属于不可变类，而它的对象属于不可变对象<br>然后看一部分replace方法的源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Replaces each substring of this string that matches the literal target</span></span><br><span class="line"><span class="comment">     * sequence with the specified literal replacement sequence. The</span></span><br><span class="line"><span class="comment">     * replacement proceeds from the beginning of the string to the end, for</span></span><br><span class="line"><span class="comment">     * example, replacing "aa" with "b" in the string "aaa" will result in</span></span><br><span class="line"><span class="comment">     * "ba" rather than "ab".</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  target The sequence of char values to be replaced</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  replacement The replacement sequence of char values</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>  The resulting string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@since</span> 1.5</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span> </span>&#123;</span><br><span class="line">        String tgtStr = target.toString();</span><br><span class="line">        String replStr = replacement.toString();</span><br><span class="line">        <span class="keyword">int</span> j = indexOf(tgtStr);</span><br><span class="line">        <span class="keyword">if</span> (j &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> tgtLen = tgtStr.length();</span><br><span class="line">        <span class="keyword">int</span> tgtLen1 = Math.max(tgtLen, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> thisLen = length();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> newLenHint = thisLen - tgtLen + replStr.length();</span><br><span class="line">        <span class="keyword">if</span> (newLenHint &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder(newLenHint);</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            sb.append(<span class="keyword">this</span>, i, j).append(replStr);</span><br><span class="line">            i = j + tgtLen;</span><br><span class="line">        &#125; <span class="keyword">while</span> (j &lt; thisLen &amp;&amp; (j = indexOf(tgtStr, j + tgtLen1)) &gt; <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> sb.append(<span class="keyword">this</span>, i, thisLen).toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>可以发现，底层应用的实际是StringBuilder，而且问题的关键是，由于是不可变对象，所以一切所谓的“改变”，都会创建新的对象<br>而对于StringBuilder和StringBuffer，他们都是可变对象<br>而StringBuillder StringBuffer,是内容可以改变的字符串。StringBuillder StringBuffer底层使用的可变的字符数组（没有使用final来修饰）</p><p><img src="/upload/pasted-346.png" alt="upload successful"></p><p>因而发生改变时不需要额外创建新的对象，所以速度更快</p><h1 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h1><p>String自不必说，因为不可变对象一定是线程安全的<br>对于StringBuffer，如果观看源码的话，会发现涉及改变的操作都上了锁（synchronized 关键字）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, Object obj)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.insert(offset, String.valueOf(obj));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> StringIndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">insert</span><span class="params">(<span class="keyword">int</span> offset, String str)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.insert(offset, str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而StringBuilder却没有<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(StringBuffer sb)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.append(sb);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(CharSequence s)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.append(s);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>根据其特点，可以总结出具体应用场景:</p><p>String：适用于少量的字符串操作的情况</p><p>StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况<br>　　<br>StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况</p>]]></content>
      
      
      <categories>
          
          <category> java基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java基础 </tag>
            
            <tag> java常用类 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程不可变对象设计模式</title>
      <link href="/2019/04/16/%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/04/16/%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>不可变对象(Immutable Objects)</strong>即对象一旦被创建它的状态（对象的数据，也即对象属性值）就不能改变，任何对它的改变都应该产生一个新的对象。<br><strong>可变对象(Mutable Objects)</strong>：相对于不可变类，可变类创建实例后可以改变其成员变量值，开发中创建的大部分类都属于可变类。</p><ul><li>不可变对象一定是线程安全的</li><li>可变对象不一定是线程不安全的</li></ul><h1 id="官方文档对于不可变类和对象的说明"><a href="#官方文档对于不可变类和对象的说明" class="headerlink" title="官方文档对于不可变类和对象的说明"></a>官方文档对于不可变类和对象的说明</h1><ol><li>Don’t provide “setter” methods — methods that modify fields or objects referred to by fields.</li><li>Make all fields final and private.</li><li>Don’t allow subclasses to override methods. The simplest way to do this is to declare the class as final. A more sophisticated approach is to make the constructor private and construct instances in factory methods.</li><li>If the instance fields include references to mutable objects, don’t allow those objects to be changed: <ul><li>Don’t provide methods that modify the mutable objects.</li><li>Don’t share references to the mutable objects. Never store references to external, mutable objects passed to the constructor; if necessary, create copies, and store references to the copies. Similarly, create copies of your internal mutable objects when necessary to avoid returning the originals in your methods</li></ul></li></ol><h1 id="不可变对象的一个例子"><a href="#不可变对象的一个例子" class="headerlink" title="不可变对象的一个例子"></a>不可变对象的一个例子</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类是final的</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableRGB</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//所有的属性都是final private的</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">int</span> red;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">int</span> green;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> <span class="keyword">int</span> blue;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Values must be between 0 and 255.</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> red,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> green,</span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="keyword">int</span> blue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (red &lt; <span class="number">0</span> || red &gt; <span class="number">255</span></span><br><span class="line">            || green &lt; <span class="number">0</span> || green &gt; <span class="number">255</span></span><br><span class="line">            || blue &lt; <span class="number">0</span> || blue &gt; <span class="number">255</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//没有setter方法</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImmutableRGB</span><span class="params">(<span class="keyword">int</span> red,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> green,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> blue,</span></span></span><br><span class="line"><span class="function"><span class="params">                        String name)</span> </span>&#123;</span><br><span class="line">        check(red, green, blue);</span><br><span class="line">        <span class="keyword">this</span>.red = red;</span><br><span class="line">        <span class="keyword">this</span>.green = green;</span><br><span class="line">        <span class="keyword">this</span>.blue = blue;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRGB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((red &lt;&lt; <span class="number">16</span>) | (green &lt;&lt; <span class="number">8</span>) | blue);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这种转换的方式实际上产生了一个新的实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ImmutableRGB <span class="title">invert</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ImmutableRGB(<span class="number">255</span> - red,</span><br><span class="line">                       <span class="number">255</span> - green,</span><br><span class="line">                       <span class="number">255</span> - blue,</span><br><span class="line">                       <span class="string">"Inverse of "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="一些讨论"><a href="#一些讨论" class="headerlink" title="一些讨论"></a>一些讨论</h1><ol><li><p>当不可变类中包含List类型时<br>如果只是单单纯的返回List，是有机会对其进行更改的<br>应当采用以下方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableList(list);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>线程安全<br>不可变对象是线程安全的，适合在多线程的环境下进行同步而不用考虑线程安全的问题</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> java多线程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程读写锁分离</title>
      <link href="/2019/04/16/%E7%BA%BF%E7%A8%8B%E8%AF%BB%E5%86%99%E9%94%81%E5%88%86%E7%A6%BB/"/>
      <url>/2019/04/16/%E7%BA%BF%E7%A8%8B%E8%AF%BB%E5%86%99%E9%94%81%E5%88%86%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>顾名思义，就是对于多线程下的读写操作（有进行读操作的线程也有进行写操作的线程），此时设计锁时应注意分离：两个读线程可以并发执行，两个写线程不可，一个读线程和一个写线程也不可，基于这个原则，进行读写锁的设计</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>读写锁类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读写锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//记录当前有多少个线程在进行读操作</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> readingReaders = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//记录正在等待的读线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> waitingReaders = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//正在进行写操作的线程（只有一个）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> writingWriters = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//等待进行读操作的线程</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> waitingWriters = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//设置一变量，用来控制写进程的抢锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> preferWriter = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> preferWriter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.preferWriter = preferWriter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读操作的上锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">readLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//首先等待读线程数+1</span></span><br><span class="line">        <span class="keyword">this</span>.waitingReaders++;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//当有线程进行写操作时，当前读操作线程等待，若是偏向于写操作，则也进行等待</span></span><br><span class="line">            <span class="keyword">while</span> (writingWriters &gt; <span class="number">0</span> || (preferWriter &amp;&amp; waitingWriters &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//读进程+1</span></span><br><span class="line">            <span class="keyword">this</span>.readingReaders++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//最终完成操作后-1</span></span><br><span class="line">            <span class="keyword">this</span>.waitingReaders--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读操作的解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">readUnlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.readingReaders--;</span><br><span class="line">        <span class="comment">//唤醒等待线程</span></span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读操作上锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writeLock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.waitingWriters++;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//当有进行读操作的线程或者写操作的线程正在运行时，当前线程都要进入等待状态</span></span><br><span class="line">            <span class="keyword">while</span> (readingReaders &gt; <span class="number">0</span> || writingWriters &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.writingWriters++;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.waitingWriters--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读操作解锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">writeUnlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.writingWriters--;</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>共享数据类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">SharedData</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//假设为一个数组，读操作在其中读数据，写操作在其中写数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span>[] buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义读写锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span>  ReadWriteLock lock = <span class="keyword">new</span> ReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SharedData</span><span class="params">(<span class="keyword">int</span>  size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.buffer = <span class="keyword">new</span> <span class="keyword">char</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">this</span>.buffer[i] = <span class="string">'*'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//多线程读操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span>[] read() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//先上读线程锁</span></span><br><span class="line">            lock.readLock();</span><br><span class="line">            <span class="comment">//具体读操作</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.doRead();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//最终释放掉锁</span></span><br><span class="line">            lock.readUnlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//多线程写操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span> c)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//写操作锁</span></span><br><span class="line">            lock.writeLock();</span><br><span class="line">            <span class="comment">//实际的写操作</span></span><br><span class="line">            <span class="keyword">this</span>.doWrite(c);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//放锁</span></span><br><span class="line">            lock.writeUnlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWrite</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.length; i++) &#123;</span><br><span class="line">            buffer[i] = c;</span><br><span class="line">            slowly(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//模拟具体读操作：创建一个当前数组的副本</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] doRead() &#123;</span><br><span class="line">        <span class="keyword">char</span>[] newBuf = <span class="keyword">new</span> <span class="keyword">char</span>[buffer.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buffer.length; i++)</span><br><span class="line">            newBuf[i] = buffer[i];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模拟花费时间</span></span><br><span class="line">        slowly(<span class="number">50</span>);</span><br><span class="line">        <span class="keyword">return</span> newBuf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">slowly</span><span class="params">(<span class="keyword">int</span> ms)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(ms);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>读线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">ReaderWorker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//共享资源</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SharedData data;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReaderWorker</span><span class="params">(SharedData data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//读取内容</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">char</span>[] readBuf = data.read();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" reads "</span> + String.valueOf(readBuf));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>写线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriterWorker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Random random = <span class="keyword">new</span> Random(System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//共享数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SharedData data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要写的内容</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String filler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对于写的内容的索引</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WriterWorker</span><span class="params">(SharedData data, String filler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.filler = filler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">//不断的进行写入操作</span></span><br><span class="line">                <span class="keyword">char</span> c = nextChar();</span><br><span class="line">                data.write(c);</span><br><span class="line">                 System.out.println(Thread.currentThread().getName()+<span class="string">" writes "</span>+ c);</span><br><span class="line">                <span class="comment">//随机休眠时间</span></span><br><span class="line">                Thread.sleep(random.nextInt(<span class="number">1000</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">char</span> <span class="title">nextChar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span> c = filler.charAt(index);</span><br><span class="line">        index++;</span><br><span class="line">        <span class="comment">//将index重置</span></span><br><span class="line">        <span class="keyword">if</span> (index &gt;= filler.length())</span><br><span class="line">            index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadWritLockClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> SharedData sharedData = <span class="keyword">new</span> SharedData(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">new</span> ReaderWorker(sharedData).start();</span><br><span class="line">        <span class="keyword">new</span> ReaderWorker(sharedData).start();</span><br><span class="line">        <span class="keyword">new</span> ReaderWorker(sharedData).start();</span><br><span class="line">        <span class="keyword">new</span> ReaderWorker(sharedData).start();</span><br><span class="line">        <span class="keyword">new</span> ReaderWorker(sharedData).start();</span><br><span class="line">        <span class="keyword">new</span> WriterWorker(sharedData, <span class="string">"qwertyuiopasdfg"</span>).start();</span><br><span class="line">        <span class="keyword">new</span> WriterWorker(sharedData, <span class="string">"QWERTYUIOPASDFG"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread-4 reads **********</span><br><span class="line">Thread-2 reads **********</span><br><span class="line">Thread-1 reads **********</span><br><span class="line">Thread-0 reads **********</span><br><span class="line">Thread-3 reads **********</span><br><span class="line">Thread-5 writes q</span><br><span class="line">Thread-6 writes Q</span><br><span class="line">Thread-4 reads QQQQQQQQQQ</span><br><span class="line">Thread-1 reads QQQQQQQQQQ</span><br><span class="line">Thread-3 reads QQQQQQQQQQ</span><br><span class="line">Thread-2 reads QQQQQQQQQQ</span><br><span class="line">Thread-0 reads QQQQQQQQQQ</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> java多线程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GOT第八季第一集观感（就是剧透,就是剧透，大量图片剧透）</title>
      <link href="/2019/04/15/OT%E7%AC%AC%E5%85%AB%E5%AD%A3%E7%AC%AC%E4%B8%80%E9%9B%86%E8%A7%82%E6%84%9F%EF%BC%88%E5%B0%B1%E6%98%AF%E5%89%A7%E9%80%8F%EF%BC%89/"/>
      <url>/2019/04/15/OT%E7%AC%AC%E5%85%AB%E5%AD%A3%E7%AC%AC%E4%B8%80%E9%9B%86%E8%A7%82%E6%84%9F%EF%BC%88%E5%B0%B1%E6%98%AF%E5%89%A7%E9%80%8F%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>第一集，作为最终季的1/6，我觉得反映的第一个主题就是重逢,顺便回应第一季的第一集</p><p>开头兄弟二人</p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/ptiGwe803RxWS2H1*r6W*GRpUbAnuNkxo1WjhrQytlw!/b/dMEAAAAAAAAA&amp;bo=gAc4BAAAAAADd.k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/rz*nwe0m6GKh2Vtx5NPEHg0szboq2Y0zT.syXTXAg6k!/b/dLYAAAAAAAAA&amp;bo=gAc4BAAAAAADd.k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>第一季第一集开头的回忆杀（为背景板的狼大默哀一分钟）<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/APCXgdffANyQFEb*VljTnRWmCF.j2otHOnbwk0ZT1z4!/b/dLYAAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>北境权利最高层的兄妹二人重逢<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/ET3m1JtaTn.OSp46PTlkW6boB6OeE.l7C1FJvPHqcBA!/b/dLYAAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>当年被夫妻的二人重逢，两人经历了自打乔大帝的婚礼分离后，各自遇上了各种风浪，都已经成长起来<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/zGBfl7FoGE9VExlYnsO0nUsG0SK9R2Pa.qnhrS95Dxo!/b/dL8AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>兄妹二人重逢,兄妹二人的剑代表了他们的成长<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/VGKFxoQGapXZt6Ce.G607r*K.nfKKu7S62DQPR*WXvc!/b/dL8AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/XXe*ky97I3GuGHM0G3KdvDX8MSMZYbXhC0K5jMmFkY0!/b/dD4BAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/hcEk3S580XFudW6HQvOYFrhBXdvfP4HLo5YUnNfO16o!/b/dL4AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>铁民家族兄妹二人，大姐表示你特么救驾来迟了<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/kqlHXDrVq5.AzKLPfojEPgYP7jK8OxRp4WOsrou5ovM!/b/dLYAAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/glAJCz7lqTlraE4fx2iJBdB*d4V1PgHv2bSOpAcWYsk!/b/dL8AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>不太冷的杀手和暗藏杀机的小姑娘重逢，两人心情都很复杂，看见彼此还活着大概也有些高兴<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/dFhUuGHhrxaflO7o6R1ogq46jzu8d4I1VylozH9bDU8!/b/dFQBAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/EeX8eo07oj5A11Gi3u5GGAAD7GqvEc7GlPAyguUlsOQ!/b/dLYAAAAAAAAA&amp;bo=gAc4BAAAAAADd.k!&amp;rf=viewer_4&amp;t=5" alt="猎犬"></p><p>当年的逃亡路上的小伙伴重逢<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/8HySdarX0LpjeoFUbSjasEPHjIwGZfPm8zlFcILs29E!/b/dFQBAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>当年的守夜人好基友重逢<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/Tx2xPhG0iNDuzsB9TE59ncVo9IL.*UgndSNNN9doQAk!/b/dDQBAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>以及在本集末尾弑君者和布兰（还是改叫三眼乌鸦）的重逢，不得不说弑君者是真的帅，两人的心情估计也十分微妙<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/h70VN*XQuWnsOlscEL1i7c*T0BlTwmjkkOpArzma6Yw!/b/dMAAAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/ARjoFO*RUfnb67xyU747GJAbzQaXJeLttpfyqxq.gXg!/b/dDQBAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"><br>想想当年<br>（第一季第一集的结尾）<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/uKbEY2*mcdnHUzTrWVa5PycwWfSbWKWjDCeXTtQa8JM!/b/dL8AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/8uCU.xccrjdexEfYiXc49dZB7CmR.2opr049czppBxM!/b/dL8AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>最终季开篇，肯定要交代背景</p><ul><li>联盟的形成，以及众人不同的看法，此处以傲娇小女王为代表</li></ul><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/Jr8*rHDm3xMNC5SDNisrEJFsFObQVwVGPVUiNNlHHF0!/b/dLYAAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><ul><li>据说很牛逼还有大象的黄金团来袭</li></ul><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/IGyi1wYLKaaqvdyKPZvR6VgOgFZa9ULoDNGYpD9gD2s!/b/dEkBAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/tPTrgCyZAO7Bw4XWHoIVxfZSaoxptbCJ8t9HB7iNNHc!/b/dFMBAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/R5y0wqbsAeo4lmcciqc*inNTlM7t3jY6vjjqPQlRa18!/b/dL8AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><ul><li>一无所知的雪诺终于知道自己到底是个什么神仙</li></ul><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/hmgQhC05JRiiBQJQiROweKfa*uZ36v5Ot3ZYweVJJDQ!/b/dLkAAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><ul><li>夜王又一次用人体行为艺术下了战书</li></ul><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/qKRTpOQzJ83OEmgXV9BDuKn04YP1e5Dip874UurgkxU!/b/dL8AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><ul><li>弑君者代表铁王座率军赶赴抗妖前线的北地</li></ul><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/b9B0JzaHWcsK*DYUyLVssnMGInn6XxjYC0uYuw8sn1k!/b/dDABAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>然后，作为最终季开篇，表明主要登场人物及其立场自然是必不可少的（纯属个人根据情况推测的）<br>一无所知琼恩雪诺：王位什么的不重要，大敌当前，我们要团结———&gt;我特么本是一无所知的二逼小青年，现在全知道了，感觉好复杂<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/7yRourdnruYwAOewG.yLXOTA0i.t16NP4jghvxzkfrE!/b/dLgAAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/XsffEnGX2gUjILAHEts46qJTGGottTJgNkvJcbtyS8I!/b/dEkBAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/NhUt6YMPcq*po3ADxsgDZTIAvFmDBfqQBSTADC1HApc!/b/dL8AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>……(省略一堆头衔)的龙妈：君之所向便是光，并表示好歹我也是有这么多头衔的女王，要是小姑子不给面子……<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/iau195BHlQmZUmo5jVbEuYNzvJxqYwFvQmVMAJ7M1bU!/b/dLkAAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/qT2CVgaTPDZ5rbsep7xt1.XU*aGFvP0dO6ukSUR9V64!/b/dL8AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>临冬女爵三傻：不行不行先把谁当老大这个事搞明白（你个外来的小妮子敢在这里撒泼）<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/Ghl.OR.NZqo.*f.7*YjUju.rG*TR4kP8BetdKxsYXbw!/b/dL4AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>传奇刺客艾莉雅：咱（我们？）这一家子整整齐齐的就好<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/kJT.wblPug3YZZatP8YoEfRzcEmSbDCntJ*KRVlVhFw!/b/dL8AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>同盟的三个顶级谋士<br>小恶魔：先别说别的了，先把那群妖怪干趴再说吧，现在关键是团结人心，毕竟欧尼桑不是个省油的灯……<br>洋葱骑士：最后搞个联合政府也还是不错的，那两位很般配<br>八爪蜘蛛：Nothing lasts（原话）</p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/WG6vhSZyH6qHiaUtFf62BLII.1.U2d4PZ06pXzqfu3M!/b/dDEBAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>“臭佬”（并不）席恩：我还是和我史塔克家的难兄难弟们在一起吧<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/Ap6Gm.2QLfFcHVjdsohhXFQj3Zd4ZicSGmnC80ZM91Y!/b/dL4AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>作者本体：兄弟我挺你，你比那贱货正统的多，况且那贱货还杀了我的爸爸和哥哥<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/5aWkJpntUDKwZsI*eJubgI2u*wqp7GnUJ4eAXccNoiw!/b/dLYAAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>给钱办事的波隆爵士：贵圈真尼玛乱,他妈的兄弟对不住了……(给弩这个细节也表示都知道弑君者是近战高手，尽管你手黑，尽管他废了个胳膊，但估计近战刚也是打不过)<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/jGgfEoEeiW8vC84voj7FRM2mA4jtSuWj*vUu1emwcu4!/b/dFMBAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="波隆"></p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/ExkAWSDL5r46vfJ4wb1yW.WSHTCyvJZtFwOP5OycOI0!/b/dDQBAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>想当年这位仁兄拼了老命在龙焰之下拉了兄弟一把，现在却受命要做掉他<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/OK.Q8thY1WOL6Z3ycxxWbJ37*tdSE7UjNsNFjKeQZjc!/b/dL8AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>舰队司令：我就是个用屌思考的人，我一切的动机就是日您，女王陛下（我觉得这个人是真心有点意思，他在这集里面所有的对话基本离不开日女王）<br><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/C53FZAZg*MdDSmhv8y0hpfxufjusNB87NhIlGGM0aOM!/b/dLYAAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>坐在铁王座上的色后：都是好事，都是好事啊</p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/qqqeDnHt.DIGPCvzk.u38C3XSiSxP6To.edupw7xTlY!/b/dL4AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"></p><p>三眼乌鸦：……就这么要凉了吗？！</p><p><img src="http://m.qpic.cn/psb?/V12fsRZe2vN5XQ/AFt1o2WZTzvlvTwq3xJIG8K0KTcZrEqJgbO6yKh1HNc!/b/dL8AAAAAAAAA&amp;bo=gAc4BAAAAAADB5k!&amp;rf=viewer_4&amp;t=5" alt="upload successful"><br>要是仔细看的话，就会发现，整集他多处出现，坐在轮椅上四处观望着这群人，看来这位才是手里有剧本的人</p><p>其实也不用多说什么，看着这些人如何反转吧，毕竟面对选择，谁尼玛都纠结，一纠结就要有人死，毕竟是最终季的开始，好戏马上就要上演了</p>]]></content>
      
      
      
        <tags>
            
            <tag> 个人杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单线程执行设计模式（Single Thread Execution）</title>
      <link href="/2019/04/15/%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/04/15/%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>在多线程的状况下，对于某些共享资源，我们需要在使用的时候确保安全性，因此这种模式下，同一时刻只能有一个线程去访问共享资源，就像独木桥一次通过一个人一样</p><h1 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SharedResource 指代多线程下的共享资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Gate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> counter = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">"Nobody"</span>;</span><br><span class="line">    <span class="keyword">private</span> String address = <span class="string">"Nowhere"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 临界值</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> address</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">pass</span><span class="params">(String name, String address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.counter++;</span><br><span class="line">        <span class="comment">/*race*/</span></span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        verify();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置验证规则：当name和address的首字母不相同时，输出打断</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">verify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.name.charAt(<span class="number">0</span>) != <span class="keyword">this</span>.address.charAt(<span class="number">0</span>)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"*******BROKEN********"</span> + toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"No."</span> + counter + <span class="string">":"</span> + name + <span class="string">","</span> + address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指代操作临界资源的线程</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String myName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String myAddress;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Gate gate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String myName, String myAddress, Gate gate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myName = myName;</span><br><span class="line">        <span class="keyword">this</span>.myAddress = myAddress;</span><br><span class="line">        <span class="keyword">this</span>.gate = gate;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(myName + <span class="string">" BEGIN"</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.gate.pass(myName, myAddress);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Gate gate = <span class="keyword">new</span> Gate();</span><br><span class="line">        User bj = <span class="keyword">new</span> User(<span class="string">"Baobao"</span>, <span class="string">"Beijing"</span>, gate);</span><br><span class="line">        User sh = <span class="keyword">new</span> User(<span class="string">"ShangLao"</span>, <span class="string">"ShangHai"</span>, gate);</span><br><span class="line">        User gz = <span class="keyword">new</span> User(<span class="string">"GuangLao"</span>, <span class="string">"GuangZhou"</span>, gate);</span><br><span class="line"></span><br><span class="line">        bj.start();</span><br><span class="line">        sh.start();</span><br><span class="line">        gz.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">*******BROKEN********No.111356925:GuangLao,GuangZhou</span><br><span class="line">*******BROKEN********No.111357328:Baobao,Beijing</span><br><span class="line">*******BROKEN********No.111357709:GuangLao,GuangZhou</span><br><span class="line">*******BROKEN********No.111362695:Baobao,Beijing</span><br></pre></td></tr></table></figure></p><p>可以看到，其中有的输出结果name和address不同，尽管初始化线程传入的参数时是相同的。有的是满足验证规则但还是输出打断<br>解释：比如A线程传入参数Beyco和Beijing，当向pass方法传入Beyco时，A线程被B线程打断，B线程传入Shenzhen，此时verify自然就broke；另一种情况是，继前面一种情况之后，此时参数已经是Beyco和Shenzhen，在准备toString时，B线程又将address传入实参Beijing，所以就出现了首字母相同还是broke的情况。<br>解决：对于共享资源，在多线程状态下使用，最好的办法自然是上锁，将pass方法和toString方法加上同步锁即可<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>   <span class="keyword">void</span> <span class="title">pass</span><span class="params">(String name, String address)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.counter++;</span><br><span class="line">    <span class="comment">/*race*/</span></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.address = address;</span><br><span class="line">    verify();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>   String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"No."</span> + counter + <span class="string">":"</span> + name + <span class="string">","</span> + address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> java多线程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>观察者模式和线程监控</title>
      <link href="/2019/04/15/%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9B%91%E6%8E%A7/"/>
      <url>/2019/04/15/%E8%80%85%E6%A8%A1%E5%BC%8F%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9B%91%E6%8E%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="基本理解"><a href="#基本理解" class="headerlink" title="基本理解"></a>基本理解</h1><p><img src="/upload/pasted-278.png" alt="upload successful"><br>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有的观察者对象，使它们能够自动更新自己。</p><p>四个角色</p><ul><li>抽象被观察者角色：也就是一个抽象主题，它把所有对观察者对象的引用保存在一个集合中，每个主题都可以有任意数量的观察者。抽象主题提供一个接口，可以增加和删除观察者角色。一般用一个抽象类和接口来实现。</li><li>抽象观察者角色：为所有的具体观察者定义一个接口，在得到主题通知时更新自己。</li><li>具体被观察者角色：也就是一个具体的主题，在集体主题的内部状态改变时，所有登记过的观察者发出通知。</li><li>具体观察者角色：实现抽象观察者角色所需要的更新接口，一边使本身的状态与制图的状态相协调。</li></ul><h1 id="java实现例子"><a href="#java实现例子" class="headerlink" title="java实现例子"></a>java实现例子</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 抽象被观察者接口</span></span><br><span class="line"><span class="comment"> * 声明了添加、删除、通知观察者方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observerable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 抽象观察者</span></span><br><span class="line"><span class="comment"> * 定义了一个update()方法，当被观察者调用notifyObservers()方法时，观察者的update()方法会被回调。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jstao</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被观察者，也就是微信公众号服务</span></span><br><span class="line"><span class="comment"> * 实现了Observerable接口，对Observerable接口的三个方法进行了具体实现</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WechatServer</span> <span class="keyword">implements</span> <span class="title">Observerable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//注意到这个List集合的泛型参数为Observer接口，设计原则：面向接口编程而不是面向实现编程</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; list;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WechatServer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        list.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!list.isEmpty())</span><br><span class="line">            list.remove(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">            Observer oserver = list.get(i);</span><br><span class="line">            oserver.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInfomation</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = s;</span><br><span class="line">        System.out.println(<span class="string">"微信服务更新消息： "</span> + s);</span><br><span class="line">        <span class="comment">//消息更新，通知所有观察者</span></span><br><span class="line">        notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察者</span></span><br><span class="line"><span class="comment"> * 实现了update方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> jstao</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">        read();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">" 收到推送消息： "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：<br>首先注册了三个用户，ZhangSan、LiSi、WangWu。公众号发布了一条消息”PHP是世界上最好用的语言！”，三个用户都收到了消息。</p><p>用户ZhangSan看到消息后颇为震惊，果断取消订阅，这时公众号又推送了一条消息，此时用户ZhangSan已经收不到消息，其他用户</p><p>还是正常能收到推送消息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        WechatServer server = <span class="keyword">new</span> WechatServer();</span><br><span class="line">        </span><br><span class="line">        Observer userZhang = <span class="keyword">new</span> User(<span class="string">"ZhangSan"</span>);</span><br><span class="line">        Observer userLi = <span class="keyword">new</span> User(<span class="string">"LiSi"</span>);</span><br><span class="line">        Observer userWang = <span class="keyword">new</span> User(<span class="string">"WangWu"</span>);</span><br><span class="line">        </span><br><span class="line">        server.registerObserver(userZhang);</span><br><span class="line">        server.registerObserver(userLi);</span><br><span class="line">        server.registerObserver(userWang);</span><br><span class="line">        server.setInfomation(<span class="string">"PHP是世界上最好用的语言！"</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"----------------------------------------------"</span>);</span><br><span class="line">        server.removeObserver(userZhang);</span><br><span class="line">        server.setInfomation(<span class="string">"JAVA是世界上最好用的语言！"</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="利用观察者模式监控线程状态"><a href="#利用观察者模式监控线程状态" class="headerlink" title="利用观察者模式监控线程状态"></a>利用观察者模式监控线程状态</h1><p>观察者抽象类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LifeCycleObserver</span> </span>&#123;</span><br><span class="line">    <span class="comment">//当被观察者（这个例子中是“可被观察线程”）发生改变时，调用该方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(ObservableRunnable.RunnableEvent event)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>被观察者类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ObservableRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//单一的被观察者</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">protected</span> LifeCycleObserver observer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObservableRunnable</span><span class="params">(<span class="keyword">final</span> LifeCycleObserver listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.observer = listener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发生线程事件时，调用该方法提醒观察者</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">notifyChange</span><span class="params">(<span class="keyword">final</span> RunnableEvent event)</span> </span>&#123;</span><br><span class="line">        observer.onEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程状态枚举</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> RunnableState &#123;</span><br><span class="line">        RUNNING, ERROR, DONE</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义状态改变的类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RunnableEvent</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> RunnableState state;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Thread thread;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Throwable cause;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">RunnableEvent</span><span class="params">(RunnableState state, Thread thread, Throwable cause)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.state = state;</span><br><span class="line">            <span class="keyword">this</span>.thread = thread;</span><br><span class="line">            <span class="keyword">this</span>.cause = cause;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> RunnableState <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> state;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">getThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> thread;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Throwable <span class="title">getCause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cause;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体观察者的实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLifeCycleObserver</span> <span class="keyword">implements</span> <span class="title">LifeCycleObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//多线程加锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object LOCK = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//该观察者有一个根据id查询线程的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">concurrentQuery</span><span class="params">(List&lt;String&gt; ids)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ids == <span class="keyword">null</span> || ids.isEmpty())</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        ids.stream().forEach(id -&gt; <span class="keyword">new</span> Thread(<span class="keyword">new</span> ObservableRunnable(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//被观察线程是运行态，传Running参数</span></span><br><span class="line">                    notifyChange(<span class="keyword">new</span> RunnableEvent(RunnableState.RUNNING, Thread.currentThread(), <span class="keyword">null</span>));</span><br><span class="line">                    System.out.println(<span class="string">"query for the id "</span> + id);</span><br><span class="line">                    Thread.sleep(<span class="number">1000L</span>);</span><br><span class="line">                    <span class="comment">//传递Done参数</span></span><br><span class="line">                    notifyChange(<span class="keyword">new</span> RunnableEvent(RunnableState.DONE, Thread.currentThread(), <span class="keyword">null</span>));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    <span class="comment">//发生异常，传递error</span></span><br><span class="line">                    notifyChange(<span class="keyword">new</span> RunnableEvent(RunnableState.ERROR, Thread.currentThread(), e));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, id).start());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="comment">// 观察者的"反应方法"</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onEvent</span><span class="params">(ObservableRunnable.RunnableEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//多线程加锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            System.out.println(<span class="string">"The runnable ["</span> + event.getThread().getName() + <span class="string">"] data changed and state is ["</span> + event.getState() + <span class="string">"]"</span>);</span><br><span class="line">            <span class="keyword">if</span> (event.getCause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"The runnable ["</span> + event.getThread().getName() + <span class="string">"] process failed."</span>);</span><br><span class="line">                event.getCause().printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLifeCycleClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ThreadLifeCycleObserver().concurrentQuery(Arrays.asList(<span class="string">"1"</span>, <span class="string">"2"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The runnable [1] data changed and state is [RUNNING]</span><br><span class="line">The runnable [2] data changed and state is [RUNNING]</span><br><span class="line">query for the id 2</span><br><span class="line">query for the id 1</span><br><span class="line">The runnable [1] data changed and state is [DONE]</span><br><span class="line">The runnable [2] data changed and state is [DONE]</span><br></pre></td></tr></table></figure></p><p>当运行中有异常时<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">The runnable [1] data changed and state is [RUNNING]</span><br><span class="line">The runnable [2] data changed and state is [RUNNING]</span><br><span class="line">query for the id 2</span><br><span class="line">query for the id 1</span><br><span class="line">The runnable [2] data changed and state is [DONE]</span><br><span class="line">The runnable [1] data changed and state is [DONE]</span><br><span class="line">The runnable [1] data changed and state is [ERROR]</span><br><span class="line">The runnable [1] process failed.</span><br><span class="line">java.lang.ArithmeticException: / by zero</span><br><span class="line">at aConcurenty.concurrent2.chapter4.ThreadLifeCycleObserver$1.run(ThreadLifeCycleObserver.java:35)</span><br><span class="line">at java.base/java.lang.Thread.run(Thread.java:844)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> java多线程学习 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java多线程 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap和ConcurrentHashMap</title>
      <link href="/2019/04/11/oncurrentHashMap/"/>
      <url>/2019/04/11/oncurrentHashMap/</url>
      
        <content type="html"><![CDATA[<p><a href="http://www.importnew.com/28263.html" target="_blank" rel="noopener">http://www.importnew.com/28263.html</a></p><h1 id="Hashmap"><a href="#Hashmap" class="headerlink" title="Hashmap"></a>Hashmap</h1><h2 id="1-7"><a href="#1-7" class="headerlink" title="1.7"></a>1.7</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>HashMap 是一个散列表，它存储的内容是键值对(key-value)映射。<br>HashMap 继承于AbstractMap，实现了Map、Cloneable、java.io.Serializable接口。<br>HashMap 的实现不是同步的，这意味着它<strong>不是线程安全</strong>的。它的key、value都可以为null。此外，HashMap中的映射不是有序的。</p><p>HashMap 的实例有两个参数影响其性能：“初始容量” 和 “加载因子”。容量 是哈希表中桶的数量，初始容量 只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。<br>通常，默认加载因子是 0.75, 这是在时间和空间成本上寻求一种折衷。加载因子过高虽然减少了空间开销，但同时也增加了查询成本（在大多数 HashMap 类的操作中，包括 get 和 put 操作，都反映了这一点）。在设置初始容量时应该考虑到映射中所需的条目数及其加载因子，以便最大限度地减少 rehash 操作次数。如果初始容量大于最大条目数除以加载因子，则不会发生 rehash 操作。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>在详细介绍HashMap的代码之前，我们需要了解：HashMap就是一个散列表，它是通过“拉链法”解决哈希冲突的。<br>见<a href="散列表">https://www.junglezero.top/2018/02/17/%EF%BC%88%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%89/</a><br>还需要再补充说明的一点是影响HashMap性能的有两个参数：初始容量(initialCapacity) 和加载因子(loadFactor)。容量 是哈希表中桶的数量，初始容量只是哈希表在创建时的容量。加载因子 是哈希表在其容量自动增加之前可以达到多满的一种尺度。当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表进行 rehash 操作（即重建内部数据结构），从而哈希表将具有大约两倍的桶数。</p><p><img src="/upload/pasted-271.png" alt="upload successful"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认的初始容量是16，必须是2的幂。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最大容量（必须是2的幂且小于2的30次方，传入容量过大将被这个值替换）</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认加载因子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 存储数据的Entry数组，长度是2的幂。</span></span><br><span class="line">    <span class="comment">// HashMap是采用拉链法实现的，每一个Entry本质上是一个单向链表</span></span><br><span class="line">    <span class="keyword">transient</span> Entry[] table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HashMap的大小，它是HashMap保存的键值对的数量</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HashMap的阈值，用于判断是否需要调整HashMap的容量（threshold = 容量*加载因子）</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载因子实际大小</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HashMap被改变的次数</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定“容量大小”和“加载因子”的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="comment">// HashMap的最大容量只能是MAXIMUM_CAPACITY</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找出“大于initialCapacity”的最小的2的幂</span></span><br><span class="line">        <span class="keyword">int</span> capacity = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (capacity &lt; initialCapacity)</span><br><span class="line">            capacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置“加载因子”</span></span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="comment">// 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。</span></span><br><span class="line">        threshold = (<span class="keyword">int</span>)(capacity * loadFactor);</span><br><span class="line">        <span class="comment">// 创建Entry数组，用来保存数据</span></span><br><span class="line">        table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认构造函数。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置“加载因子”</span></span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">        <span class="comment">// 设置“HashMap阈值”，当HashMap中存储数据的数量达到threshold时，就需要将HashMap的容量加倍。</span></span><br><span class="line">        threshold = (<span class="keyword">int</span>)(DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR);</span><br><span class="line">        <span class="comment">// 创建Entry数组，用来保存数据</span></span><br><span class="line">        table = <span class="keyword">new</span> Entry[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 包含“子Map”的构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Math.max((<span class="keyword">int</span>) (m.size() / DEFAULT_LOAD_FACTOR) + <span class="number">1</span>,</span><br><span class="line">                      DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR);</span><br><span class="line">        <span class="comment">// 将m中的全部元素逐个添加到HashMap中</span></span><br><span class="line">        putAllForCreate(m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">        h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">        <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回索引值</span></span><br><span class="line">    <span class="comment">// h &amp; (length-1)保证返回值的小于length</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取key对应的value</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> getForNullKey();</span><br><span class="line">        <span class="comment">// 获取key的hash值</span></span><br><span class="line">        <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">        <span class="comment">// 在“该hash值对应的链表”上查找“键值等于key”的元素</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">             e != <span class="keyword">null</span>;</span><br><span class="line">             e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k)))</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取“key为null”的元素的值</span></span><br><span class="line">    <span class="comment">// HashMap将“key为null”的元素存储在table[0]位置！</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> V <span class="title">getForNullKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.key == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> e.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HashMap是否包含key</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getEntry(key) != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回“键为key”的键值对</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">getEntry</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取哈希值</span></span><br><span class="line">        <span class="comment">// HashMap将“key为null”的元素存储在table[0]位置，“key不为null”的则调用hash()计算哈希值</span></span><br><span class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key.hashCode());</span><br><span class="line">        <span class="comment">// 在“该hash值对应的链表”上查找“键值等于key”的元素</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];</span><br><span class="line">             e != <span class="keyword">null</span>;</span><br><span class="line">             e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将“key-value”添加到HashMap中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 若“key为null”，则将该键值对添加到table[0]中。</span></span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">        <span class="comment">// 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。</span></span><br><span class="line">        <span class="keyword">int</span> hash = hash(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="comment">// 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！</span></span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若“该key”对应的键值对不存在，则将“key-value”添加到table中</span></span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(hash, key, value, i);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// putForNullKey()的作用是将“key为null”键值对添加到table[0]位置</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> V <span class="title">putForNullKey</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.key == <span class="keyword">null</span>) &#123;</span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                e.value = value;</span><br><span class="line">                e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里的完全不会被执行到!</span></span><br><span class="line">        modCount++;</span><br><span class="line">        addEntry(<span class="number">0</span>, <span class="keyword">null</span>, value, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建HashMap对应的“添加方法”，</span></span><br><span class="line">    <span class="comment">// 它和put()不同。putForCreate()是内部方法，它被构造函数等调用，用来创建HashMap</span></span><br><span class="line">    <span class="comment">// 而put()是对外提供的往HashMap中添加元素的方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putForCreate</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若该HashMap表中存在“键值等于key”的元素，则替换该元素的value值</span></span><br><span class="line">        <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                e.value = value;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 若该HashMap表中不存在“键值等于key”的元素，则将该key-value添加到HashMap中</span></span><br><span class="line">        createEntry(hash, key, value, i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将“m”中的全部元素都添加到HashMap中。</span></span><br><span class="line">    <span class="comment">// 该方法被内部的构造HashMap的方法所调用。</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putAllForCreate</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 利用迭代器将元素逐个添加到HashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; i = m.entrySet().iterator(); i.hasNext(); ) &#123;</span><br><span class="line">            Map.Entry&lt;? extends K, ? extends V&gt; e = i.next();</span><br><span class="line">            putForCreate(e.getKey(), e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重新调整HashMap的大小，newCapacity是调整后的单位</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">        Entry[] oldTable = table;</span><br><span class="line">        <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">        <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建一个HashMap，将“旧HashMap”的全部元素添加到“新HashMap”中，</span></span><br><span class="line">        <span class="comment">// 然后，将“新HashMap”赋值给“旧HashMap”。</span></span><br><span class="line">        Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">        transfer(newTable);</span><br><span class="line">        table = newTable;</span><br><span class="line">        threshold = (<span class="keyword">int</span>)(newCapacity * loadFactor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将HashMap中的全部元素都添加到newTable中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">        Entry[] src = table;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                src[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                    <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);</span><br><span class="line">                    e.next = newTable[i];</span><br><span class="line">                    newTable[i] = e;</span><br><span class="line">                    e = next;</span><br><span class="line">                &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将"m"的全部元素都添加到HashMap中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 有效性判断</span></span><br><span class="line">        <span class="keyword">int</span> numKeysToBeAdded = m.size();</span><br><span class="line">        <span class="keyword">if</span> (numKeysToBeAdded == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算容量是否足够，</span></span><br><span class="line">        <span class="comment">// 若“当前实际容量 &lt; 需要的容量”，则将容量x2。</span></span><br><span class="line">        <span class="keyword">if</span> (numKeysToBeAdded &gt; threshold) &#123;</span><br><span class="line">            <span class="keyword">int</span> targetCapacity = (<span class="keyword">int</span>)(numKeysToBeAdded / loadFactor + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (targetCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">                targetCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">            <span class="keyword">int</span> newCapacity = table.length;</span><br><span class="line">            <span class="keyword">while</span> (newCapacity &lt; targetCapacity)</span><br><span class="line">                newCapacity &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (newCapacity &gt; table.length)</span><br><span class="line">                resize(newCapacity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过迭代器，将“m”中的元素逐个添加到HashMap中。</span></span><br><span class="line">        <span class="keyword">for</span> (Iterator&lt;? extends Map.Entry&lt;? extends K, ? extends V&gt;&gt; i = m.entrySet().iterator(); i.hasNext(); ) &#123;</span><br><span class="line">            Map.Entry&lt;? extends K, ? extends V&gt; e = i.next();</span><br><span class="line">            put(e.getKey(), e.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除“键为key”元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = removeEntryForKey(key);</span><br><span class="line">        <span class="keyword">return</span> (e == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除“键为key”的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeEntryForKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取哈希值。若key为null，则哈希值为0；否则调用hash()进行计算</span></span><br><span class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">        Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">        Entry&lt;K,V&gt; e = prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除链表中“键为key”的元素</span></span><br><span class="line">        <span class="comment">// 本质是“删除单向链表中的节点”</span></span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            Object k;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                modCount++;</span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">if</span> (prev == e)</span><br><span class="line">                    table[i] = next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    prev.next = next;</span><br><span class="line">                e.recordRemoval(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除“键值对”</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">removeMapping</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        Map.Entry&lt;K,V&gt; entry = (Map.Entry&lt;K,V&gt;) o;</span><br><span class="line">        Object key = entry.getKey();</span><br><span class="line">        <span class="keyword">int</span> hash = (key == <span class="keyword">null</span>) ? <span class="number">0</span> : hash(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">        Entry&lt;K,V&gt; prev = table[i];</span><br><span class="line">        Entry&lt;K,V&gt; e = prev;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除链表中的“键值对e”</span></span><br><span class="line">        <span class="comment">// 本质是“删除单向链表中的节点”</span></span><br><span class="line">        <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; e.equals(entry)) &#123;</span><br><span class="line">                modCount++;</span><br><span class="line">                size--;</span><br><span class="line">                <span class="keyword">if</span> (prev == e)</span><br><span class="line">                    table[i] = next;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    prev.next = next;</span><br><span class="line">                e.recordRemoval(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">            prev = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 清空HashMap，将所有的元素设为null</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        Entry[] tab = table;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; i++)</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否包含“值为value”的元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsValue</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 若“value为null”，则调用containsNullValue()查找</span></span><br><span class="line">    <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> containsNullValue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 若“value不为null”，则查找HashMap中是否有值为value的节点。</span></span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length ; i++)</span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i] ; e != <span class="keyword">null</span> ; e = e.next)</span><br><span class="line">                <span class="keyword">if</span> (value.equals(e.value))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 是否包含null值</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">containsNullValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length ; i++)</span><br><span class="line">            <span class="keyword">for</span> (Entry e = tab[i] ; e != <span class="keyword">null</span> ; e = e.next)</span><br><span class="line">                <span class="keyword">if</span> (e.value == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 克隆一个HashMap，并返回Object对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        HashMap&lt;K,V&gt; result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            result = (HashMap&lt;K,V&gt;)<span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">            <span class="comment">// assert false;</span></span><br><span class="line">        &#125;</span><br><span class="line">        result.table = <span class="keyword">new</span> Entry[table.length];</span><br><span class="line">        result.entrySet = <span class="keyword">null</span>;</span><br><span class="line">        result.modCount = <span class="number">0</span>;</span><br><span class="line">        result.size = <span class="number">0</span>;</span><br><span class="line">        result.init();</span><br><span class="line">        <span class="comment">// 调用putAllForCreate()将全部元素添加到HashMap中</span></span><br><span class="line">        result.putAllForCreate(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Entry是单向链表。</span></span><br><span class="line">    <span class="comment">// 它是 “HashMap链式存储法”对应的链表。</span></span><br><span class="line">    <span class="comment">// 它实现了Map.Entry 接口，即实现getKey(), getValue(), setValue(V value), equals(Object o), hashCode()这些函数</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        <span class="comment">// 指向下一个节点</span></span><br><span class="line">        Entry&lt;K,V&gt; next;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造函数。</span></span><br><span class="line">        <span class="comment">// 输入参数包括"哈希值(h)", "键(k)", "值(v)", "下一节点(n)"</span></span><br><span class="line">        Entry(<span class="keyword">int</span> h, K k, V v, Entry&lt;K,V&gt; n) &#123;</span><br><span class="line">            value = v;</span><br><span class="line">            next = n;</span><br><span class="line">            key = k;</span><br><span class="line">            hash = h;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断两个Entry是否相等</span></span><br><span class="line">        <span class="comment">// 若两个Entry的“key”和“value”都相等，则返回true。</span></span><br><span class="line">        <span class="comment">// 否则，返回false</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            Map.Entry e = (Map.Entry)o;</span><br><span class="line">            Object k1 = getKey();</span><br><span class="line">            Object k2 = e.getKey();</span><br><span class="line">            <span class="keyword">if</span> (k1 == k2 || (k1 != <span class="keyword">null</span> &amp;&amp; k1.equals(k2))) &#123;</span><br><span class="line">                Object v1 = getValue();</span><br><span class="line">                Object v2 = e.getValue();</span><br><span class="line">                <span class="keyword">if</span> (v1 == v2 || (v1 != <span class="keyword">null</span> &amp;&amp; v1.equals(v2)))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 实现hashCode()</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (key==<span class="keyword">null</span>   ? <span class="number">0</span> : key.hashCode()) ^</span><br><span class="line">                   (value==<span class="keyword">null</span> ? <span class="number">0</span> : value.hashCode());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getKey() + <span class="string">"="</span> + getValue();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当向HashMap中添加元素时，绘调用recordAccess()。</span></span><br><span class="line">        <span class="comment">// 这里不做任何处理</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">recordAccess</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当从HashMap中删除元素时，绘调用recordRemoval()。</span></span><br><span class="line">        <span class="comment">// 这里不做任何处理</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">recordRemoval</span><span class="params">(HashMap&lt;K,V&gt; m)</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保存“bucketIndex”位置的值到“e”中</span></span><br><span class="line">        Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">        <span class="comment">// 设置“bucketIndex”位置的元素为“新Entry”，</span></span><br><span class="line">        <span class="comment">// 设置“e”为“新Entry的下一个节点”</span></span><br><span class="line">        table[bucketIndex] = <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">        <span class="comment">// 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小</span></span><br><span class="line">        <span class="keyword">if</span> (size++ &gt;= threshold)</span><br><span class="line">            resize(<span class="number">2</span> * table.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建Entry。将“key-value”插入指定位置，bucketIndex是位置索引。</span></span><br><span class="line">    <span class="comment">// 它和addEntry的区别是：</span></span><br><span class="line">    <span class="comment">// (01) addEntry()一般用在 新增Entry可能导致“HashMap的实际容量”超过“阈值”的情况下。</span></span><br><span class="line">    <span class="comment">//   例如，我们新建一个HashMap，然后不断通过put()向HashMap中添加元素；</span></span><br><span class="line">    <span class="comment">// put()是通过addEntry()新增Entry的。</span></span><br><span class="line">    <span class="comment">//   在这种情况下，我们不知道何时“HashMap的实际容量”会超过“阈值”；</span></span><br><span class="line">    <span class="comment">//   因此，需要调用addEntry()</span></span><br><span class="line">    <span class="comment">// (02) createEntry() 一般用在 新增Entry不会导致“HashMap的实际容量”超过“阈值”的情况下。</span></span><br><span class="line">    <span class="comment">//   例如，我们调用HashMap“带有Map”的构造函数，它绘将Map的全部元素添加到HashMap中；</span></span><br><span class="line">    <span class="comment">// 但在添加之前，我们已经计算好“HashMap的容量和阈值”。也就是，可以确定“即使将Map中</span></span><br><span class="line">    <span class="comment">// 的全部元素添加到HashMap中，都不会超过HashMap的阈值”。</span></span><br><span class="line">    <span class="comment">//   此时，调用createEntry()即可。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 保存“bucketIndex”位置的值到“e”中</span></span><br><span class="line">        Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">        <span class="comment">// 设置“bucketIndex”位置的元素为“新Entry”，</span></span><br><span class="line">        <span class="comment">// 设置“e”为“新Entry的下一个节点”</span></span><br><span class="line">        table[bucketIndex] = <span class="keyword">new</span> Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HashIterator是HashMap迭代器的抽象出来的父类，实现了公共了函数。</span></span><br><span class="line">    <span class="comment">// 它包含“key迭代器(KeyIterator)”、“Value迭代器(ValueIterator)”和“Entry迭代器(EntryIterator)”3个子类。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 下一个元素</span></span><br><span class="line">        Entry&lt;K,V&gt; next;</span><br><span class="line">        <span class="comment">// expectedModCount用于实现fast-fail机制。</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount;</span><br><span class="line">        <span class="comment">// 当前索引</span></span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        <span class="comment">// 当前元素</span></span><br><span class="line">        Entry&lt;K,V&gt; current;</span><br><span class="line"></span><br><span class="line">        HashIterator() &#123;</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">            <span class="keyword">if</span> (size &gt; <span class="number">0</span>) &#123; <span class="comment">// advance to first entry</span></span><br><span class="line">                Entry[] t = table;</span><br><span class="line">                <span class="comment">// 将next指向table中第一个不为null的元素。</span></span><br><span class="line">                <span class="comment">// 这里利用了index的初始值为0，从0开始依次向后遍历，直到找到不为null的元素就退出循环。</span></span><br><span class="line">                <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>)</span><br><span class="line">                    ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> next != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取下一个元素</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> Entry&lt;K,V&gt; <span class="title">nextEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            Entry&lt;K,V&gt; e = next;</span><br><span class="line">            <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 注意！！！</span></span><br><span class="line">            <span class="comment">// 一个Entry就是一个单向链表</span></span><br><span class="line">            <span class="comment">// 若该Entry的下一个节点不为空，就将next指向下一个节点;</span></span><br><span class="line">            <span class="comment">// 否则，将next指向下一个链表(也是下一个Entry)的不为null的节点。</span></span><br><span class="line">            <span class="keyword">if</span> ((next = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Entry[] t = table;</span><br><span class="line">                <span class="keyword">while</span> (index &lt; t.length &amp;&amp; (next = t[index++]) == <span class="keyword">null</span>)</span><br><span class="line">                    ;</span><br><span class="line">            &#125;</span><br><span class="line">            current = e;</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 删除当前元素</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (current == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            Object k = current.key;</span><br><span class="line">            current = <span class="keyword">null</span>;</span><br><span class="line">            HashMap.<span class="keyword">this</span>.removeEntryForKey(k);</span><br><span class="line">            expectedModCount = modCount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// value的迭代器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> V <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nextEntry().value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// key的迭代器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> K <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nextEntry().getKey();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Entry的迭代器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Map.<span class="function">Entry&lt;K,V&gt; <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nextEntry();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回一个“key迭代器”</span></span><br><span class="line">    <span class="function">Iterator&lt;K&gt; <span class="title">newKeyIterator</span><span class="params">()</span>   </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> KeyIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回一个“value迭代器”</span></span><br><span class="line">    <span class="function">Iterator&lt;V&gt; <span class="title">newValueIterator</span><span class="params">()</span>   </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ValueIterator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回一个“entry迭代器”</span></span><br><span class="line">    Iterator&lt;Map.Entry&lt;K,V&gt;&gt; newEntryIterator()   &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EntryIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// HashMap的Entry对应的集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回“key的集合”，实际上返回一个“KeySet对象”</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Set&lt;K&gt; ks = keySet;</span><br><span class="line">        <span class="keyword">return</span> (ks != <span class="keyword">null</span> ? ks : (keySet = <span class="keyword">new</span> KeySet()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Key对应的集合</span></span><br><span class="line">    <span class="comment">// KeySet继承于AbstractSet，说明该集合中没有重复的Key。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Iterator&lt;K&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> newKeyIterator();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> containsKey(o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> HashMap.<span class="keyword">this</span>.removeEntryForKey(o) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            HashMap.<span class="keyword">this</span>.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回“value集合”，实际上返回的是一个Values对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Collection&lt;V&gt; <span class="title">values</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Collection&lt;V&gt; vs = values;</span><br><span class="line">        <span class="keyword">return</span> (vs != <span class="keyword">null</span> ? vs : (values = <span class="keyword">new</span> Values()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// “value集合”</span></span><br><span class="line">    <span class="comment">// Values继承于AbstractCollection，不同于“KeySet继承于AbstractSet”，</span></span><br><span class="line">    <span class="comment">// Values中的元素能够重复。因为不同的key可以指向相同的value。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Values</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Iterator&lt;V&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> newValueIterator();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> containsValue(o);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            HashMap.<span class="keyword">this</span>.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回“HashMap的Entry集合”</span></span><br><span class="line">    <span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() &#123;</span><br><span class="line">        <span class="keyword">return</span> entrySet0();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回“HashMap的Entry集合”，它实际是返回一个EntrySet对象</span></span><br><span class="line">    <span class="keyword">private</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet0() &#123;</span><br><span class="line">        Set&lt;Map.Entry&lt;K,V&gt;&gt; es = entrySet;</span><br><span class="line">        <span class="keyword">return</span> es != <span class="keyword">null</span> ? es : (entrySet = <span class="keyword">new</span> EntrySet());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// EntrySet对应的集合</span></span><br><span class="line">    <span class="comment">// EntrySet继承于AbstractSet，说明该集合中没有重复的EntrySet。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() &#123;</span><br><span class="line">            <span class="keyword">return</span> newEntryIterator();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Map.Entry))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            Map.Entry&lt;K,V&gt; e = (Map.Entry&lt;K,V&gt;) o;</span><br><span class="line">            Entry&lt;K,V&gt; candidate = getEntry(e.getKey());</span><br><span class="line">            <span class="keyword">return</span> candidate != <span class="keyword">null</span> &amp;&amp; candidate.equals(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> removeMapping(o) != <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            HashMap.<span class="keyword">this</span>.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// java.io.Serializable的写入函数</span></span><br><span class="line">    <span class="comment">// 将HashMap的“总的容量，实际容量，所有的Entry”都写入到输出流中</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(java.io.ObjectOutputStream s)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i =</span><br><span class="line">            (size &gt; <span class="number">0</span>) ? entrySet0().iterator() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out the threshold, loadfactor, and any hidden stuff</span></span><br><span class="line">        s.defaultWriteObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out number of buckets</span></span><br><span class="line">        s.writeInt(table.length);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out size (number of Mappings)</span></span><br><span class="line">        s.writeInt(size);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write out keys and values (alternating)</span></span><br><span class="line">        <span class="keyword">if</span> (i != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i.hasNext()) &#123;</span><br><span class="line">            Map.Entry&lt;K,V&gt; e = i.next();</span><br><span class="line">            s.writeObject(e.getKey());</span><br><span class="line">            s.writeObject(e.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// java.io.Serializable的读取函数：根据写入方式读出</span></span><br><span class="line">    <span class="comment">// 将HashMap的“总的容量，实际容量，所有的Entry”依次读出</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readObject</span><span class="params">(java.io.ObjectInputStream s)</span></span></span><br><span class="line"><span class="function">         <span class="keyword">throws</span> IOException, ClassNotFoundException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Read in the threshold, loadfactor, and any hidden stuff</span></span><br><span class="line">        s.defaultReadObject();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in number of buckets and allocate the bucket array;</span></span><br><span class="line">        <span class="keyword">int</span> numBuckets = s.readInt();</span><br><span class="line">        table = <span class="keyword">new</span> Entry[numBuckets];</span><br><span class="line"></span><br><span class="line">        init();  <span class="comment">// Give subclass a chance to do its thing.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read in size (number of Mappings)</span></span><br><span class="line">        <span class="keyword">int</span> size = s.readInt();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Read the keys and values, and put the mappings in the HashMap</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;size; i++) &#123;</span><br><span class="line">            K key = (K) s.readObject();</span><br><span class="line">            V value = (V) s.readObject();</span><br><span class="line">            putForCreate(key, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回“HashMap总的容量”</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span>   <span class="title">capacity</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> table.length; &#125;</span><br><span class="line">    <span class="comment">// 返回“HashMap的加载因子”</span></span><br><span class="line">    <span class="function"><span class="keyword">float</span> <span class="title">loadFactor</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> loadFactor;   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="重点方法"><a href="#重点方法" class="headerlink" title="重点方法"></a>重点方法</h3><h4 id="put"><a href="#put" class="headerlink" title="put"></a>put</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当插入第一个元素的时候，需要先初始化数组大小</span></span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 key 为 null，感兴趣的可以往里看，最终会将这个 entry 放到 table[0] 中</span></span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="comment">// 1. 求 key 的 hash 值</span></span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="comment">// 2. 找到对应的数组下标</span></span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length);</span><br><span class="line">    <span class="comment">// 3. 遍历一下对应下标处的链表，看是否有重复的 key 已经存在，</span></span><br><span class="line">    <span class="comment">//    如果有，直接覆盖，put 方法返回旧值就结束了</span></span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">        Object k;</span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            e.value = value;</span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// 4. 不存在重复的 key，将此 entry 添加到链表中，细节后面说</span></span><br><span class="line">    addEntry(hash, key, value, i);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><ul><li>数组初始化<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保证数组大小一定是 2 的 n 次方。</span></span><br><span class="line">    <span class="comment">// 比如这样初始化：new HashMap(20)，那么处理成初始数组大小是 32</span></span><br><span class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line">    <span class="comment">// 计算扩容阈值：capacity * loadFactor</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 算是初始化数组吧</span></span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">    initHashSeedAsNeeded(capacity); <span class="comment">//ignore</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在第一个元素插入 HashMap 的时候做一次数组的初始化，就是先确定初始的数组大小，并计算数组扩容的阈值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inflateTable</span><span class="params">(<span class="keyword">int</span> toSize)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 保证数组大小一定是 2 的 n 次方。</span></span><br><span class="line">    <span class="comment">// 比如这样初始化：new HashMap(20)，那么处理成初始数组大小是 32</span></span><br><span class="line">    <span class="keyword">int</span> capacity = roundUpToPowerOf2(toSize);</span><br><span class="line">    <span class="comment">// 计算扩容阈值：capacity * loadFactor</span></span><br><span class="line">    threshold = (<span class="keyword">int</span>) Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 算是初始化数组吧</span></span><br><span class="line">    table = <span class="keyword">new</span> Entry[capacity];</span><br><span class="line">    initHashSeedAsNeeded(capacity); <span class="comment">//ignore</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里有一个将数组大小保持为 2 的 n 次方的做法，Java7 和 Java8 的 HashMap 和 ConcurrentHashMap 都有相应的要求，只不过实现的代码稍微有些不同，后面再看到的时候就知道了。</p><ul><li>计算具体数组位置</li></ul><p>这个简单，我们自己也能 YY 一个：使用 key 的 hash 值对数组长度进行取模就可以了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> hash, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";</span></span><br><span class="line">    <span class="keyword">return</span> hash &amp; (length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法很简单，简单说就是取 hash 值的低 n 位。如在数组长度为 32 的时候，其实取的就是 key 的 hash 值的低 5 位，作为它在数组中的下标位置。</p><ul><li>添加节点到链表中</li></ul><p>找到数组下标后，会先进行 key 判重，如果没有重复，就准备将新值放入到链表的表头。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前 HashMap 大小已经达到了阈值，并且新值要插入的数组位置已经有元素了，那么要扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((size &gt;= threshold) &amp;&amp; (<span class="keyword">null</span> != table[bucketIndex])) &#123;</span><br><span class="line">        <span class="comment">// 扩容，后面会介绍一下</span></span><br><span class="line">        resize(<span class="number">2</span> * table.length);</span><br><span class="line">        <span class="comment">// 扩容以后，重新计算 hash 值</span></span><br><span class="line">        hash = (<span class="keyword">null</span> != key) ? hash(key) : <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 重新计算扩容后的新的下标</span></span><br><span class="line">        bucketIndex = indexFor(hash, table.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 往下看</span></span><br><span class="line">    createEntry(hash, key, value, bucketIndex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这个很简单，其实就是将新值放到链表的表头，然后 size++</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createEntry</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">int</span> bucketIndex)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; e = table[bucketIndex];</span><br><span class="line">    table[bucketIndex] = <span class="keyword">new</span> Entry&lt;&gt;(hash, key, value, e);</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个方法的主要逻辑就是先判断是否需要扩容，需要的话先扩容，然后再将这个新的数据插入到扩容后的数组的相应位置处的链表的表头。</p><ul><li>数组扩容</li></ul><p>前面我们看到，在插入新值的时候，如果当前的 size 已经达到了阈值，并且要插入的数组位置上已经有元素，那么就会触发扩容，扩容后，数组大小为原来的 2 倍。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">(<span class="keyword">int</span> newCapacity)</span> </span>&#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    <span class="keyword">int</span> oldCapacity = oldTable.length;</span><br><span class="line">    <span class="keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 新的数组</span></span><br><span class="line">    Entry[] newTable = <span class="keyword">new</span> Entry[newCapacity];</span><br><span class="line">    <span class="comment">// 将原来数组中的值迁移到新的更大的数组中</span></span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (<span class="keyword">int</span>)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>扩容就是用一个新的大数组替换原来的小数组，并将原来数组中的值迁移到新的数组中。</p><p>由于是双倍扩容，迁移过程中，会将原来 table[i] 中的链表的所有节点，分拆到新的数组的 newTable[i] 和 newTable[i + oldLength] 位置上。如原来数组长度是 16，那么扩容后，原来 table[0] 处的链表中的所有元素会被分配到新数组中 newTable[0] 和 newTable[16] 这两个位置。代码比较简单，这里就不展开了。</p><p>1.对Key求Hash值，然后再计算下标<br>2.如果没有碰撞，直接放入桶中（碰撞的意思是计算得到的Hash值相同，需要放到同一个bucket中）<br>3.如果碰撞了，以链表的方式链接到后面<br>4.如果链表长度超过阀值( TREEIFY THRESHOLD==8)，就把链表转成红黑树，链表长度低于6，就把红黑树转回链表<br>5.如果节点已经存在就替换旧值<br>6.如果桶满了(容量16*加载因子0.75)，就需要 resize（扩容2倍后重排）</p><h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>当我们调用 get() 方法，HashMap 会使用键对象的 hashcode 找到 bucket 位置，找到 bucket 位置之后，会调用 keys.equals() 方法去找到链表中正确的节点，最终找到要找的值对象。</p><p><img src="/upload/pasted-273.png" alt="upload successful"></p><h2 id="1-8"><a href="#1-8" class="headerlink" title="1.8"></a>1.8</h2><p>Java8 对 HashMap 进行了一些修改，最大的不同就是利用了红黑树，所以其由 数组+链表+红黑树 组成。</p><p>根据 Java7 HashMap 的介绍，我们知道，查找的时候，根据 hash 值我们能够快速定位到数组的具体下标，但是之后的话，需要顺着链表一个个比较下去才能找到我们需要的，时间复杂度取决于链表的长度，为 O(n)。</p><p>为了降低这部分的开销，在 Java8 中，当链表中的元素超过了 8 个以后，会将链表转换为红黑树，在这些位置进行查找的时候可以降低时间复杂度为 O(logN)。</p><p><img src="/upload/pasted-276.png" alt="upload successful"><br>Java7 中使用 Entry 来代表每个 HashMap 中的数据节点，Java8 中使用 Node，基本没有区别，都是 key，value，hash 和 next 这四个属性，不过，Node 只能用于链表的情况，红黑树的情况需要使用 TreeNode。</p><p>我们根据数组元素中，第一个节点数据类型是 Node 还是 TreeNode 来判断该位置下是链表还是红黑树的。</p><h3 id="put-1"><a href="#put-1" class="headerlink" title="put"></a>put</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ublic V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 第三个参数 onlyIfAbsent 如果是 true，那么只有在不存在该 key 时才会进行 put 操作</span></span><br><span class="line"><span class="comment">// 第四个参数 evict 我们这里不关心</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// 第一次 put 值的时候，会触发下面的 resize()，类似 java7 的第一次 put 也要初始化数组长度</span></span><br><span class="line">    <span class="comment">// 第一次 resize 和后续的扩容有些不一样，因为这次是数组从 null 初始化到默认的 16 或自定义的初始容量</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// 找到具体的数组下标，如果此位置没有值，那么直接初始化一下 Node 并放置在这个位置就可以了</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 数组该位置有数据</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 首先，判断该位置的第一个数据和我们要插入的数据，key 是不是"相等"，如果是，取出这个节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">// 如果该节点是代表红黑树的节点，调用红黑树的插值方法，本文不展开说红黑树</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 到这里，说明数组该位置上是一个链表</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 插入到链表的最后面(Java7 是插入到链表的最前面)</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// TREEIFY_THRESHOLD 为 8，所以，如果新插入的值是链表中的第 9 个</span></span><br><span class="line">                    <span class="comment">// 会触发下面的 treeifyBin，也就是将链表转换为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 如果在该链表中找到了"相等"的 key(== 或 equals)</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 此时 break，那么 e 为链表中[与要插入的新值的 key "相等"]的 node</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// e!=null 说明存在旧值的key与要插入的key"相等"</span></span><br><span class="line">        <span class="comment">// 对于我们分析的put操作，下面这个 if 其实就是进行 "值覆盖"，然后返回旧值</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 如果 HashMap 由于新插入这个值导致 size 已经超过了阈值，需要进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>和 Java7 稍微有点不一样的地方就是，Java7 是先扩容后插入新值的，Java8 先插值再扩容，不过这个不重要。</p><ul><li>数组扩容</li></ul><p>resize() 方法用于初始化数组或数组扩容，每次扩容后，容量为原来的 2 倍，并进行数据迁移。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123; <span class="comment">// 对应数组扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将数组大小扩大一倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            <span class="comment">// 将阈值扩大一倍</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// 对应使用 new HashMap(int initialCapacity) 初始化后，第一次 put 的时候</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123;<span class="comment">// 对应使用 new HashMap() 初始化后，第一次 put 的时候</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 用新的数组大小初始化新的数组</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab; <span class="comment">// 如果是初始化数组，到这里就结束了，返回 newTab 即可</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 开始遍历原数组，进行数据迁移。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 如果该数组位置上只有单个元素，那就简单了，简单迁移这个元素就可以了</span></span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="comment">// 如果是红黑树，具体我们就不展开了</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; </span><br><span class="line">                    <span class="comment">// 这块是处理链表的情况，</span></span><br><span class="line">                    <span class="comment">// 需要将此链表拆成两个链表，放到新的数组中，并且保留原来的先后顺序</span></span><br><span class="line">                    <span class="comment">// loHead、loTail 对应一条链表，hiHead、hiTail 对应另一条链表，代码还是比较简单的</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 第一条链表</span></span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="comment">// 第二条链表的新的位置是 j + oldCap，这个很好理解</span></span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>其底层数据与HashMap的数据结构相同，数组+链表+红黑树，桶中的结构可能是链表，也可能是红黑树，红黑树是为了提高查找效率。</p><p><img src="/upload/pasted-274.png" alt="upload successful"></p><h2 id="1-7-1"><a href="#1-7-1" class="headerlink" title="1.7"></a>1.7</h2><p>HashMap的容量由负载因子决定，插入的元素超过了容量的范围就会触发扩容操作，就是rehash。<br>在多线程环境下，若同时存在其他元素进行put操作，如果hash值相同，可能出现在同一数组下用链表表示，出现闭环，导致在get的操作会出现死循环，所以hashmap是线程不安全的。<br>Hashtable是线程安全的，它在所有都涉及到多线程操作时都加了synchronized关键字来锁住整个table，意味着所有线程都在争用一把锁，在多线程的环境下，它是安全的，但效率低下。<br>ConcurrentHashMap采用锁分离技术，将锁的粒度降低，利用多个锁来控制多个小的table。<br>ConcurrentHashMap的数据结构是由一个Segment数组和多个HashEntry组成，如下图所示：</p><p><img src="/upload/pasted-275.png" alt="upload successful"><br>ConcurrentHashMap的初始化是会通过位与运算来初始化Segment的大小，用ssize来表示，如下所示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sshift = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ssize = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (ssize &lt; concurrencyLevel) &#123;</span><br><span class="line">    ++sshift;</span><br><span class="line">    ssize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上所示，因为ssize用位于运算来计算（ssize &lt;&lt;=1），所以Segment的大小取值都是以2的N次方，无关concurrencyLevel的取值，当然concurrencyLevel最大只能用16位的二进制来表示，即65536，换句话说，Segment的大小最多65536个，没有指定concurrencyLevel元素初始化，Segment的大小ssize默认为16。<br>每一个Segment元素下的HashEntry的初始化也是按照位于运算来计算，用cap来表示，如下所示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cap = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (cap &lt; c)</span><br><span class="line">    cap &lt;&lt;= <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><p>如上所示，HashEntry大小的计算也是2的N次方（cap &lt;&lt;=1）， cap的初始值为1，所以HashEntry最小的容量为2。</p><h3 id="put操作"><a href="#put操作" class="headerlink" title="put操作"></a>put操作</h3><p>对于ConcurrentHashMap的数据插入，这里要进行两次Hash去定位数据的存储位置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Segment</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">ReentrantLock</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br></pre></td></tr></table></figure></p><p>从上Segment的继承体系可以看出，Segment实现了ReentrantLock,也就带有锁的功能，当执行put操作时，会进行第一次key的hash来定位Segment的位置，如果该Segment还没有初始化，即通过CAS操作进行赋值，然后进行第二次hash操作，找到相应的HashEntry的位置，这里会利用继承过来的锁的特性，在将数据插入指定的HashEntry位置时（链表的尾端），会通过继承ReentrantLock的tryLock（）方法尝试去获取锁，如果获取成功就直接插入相应的位置，如果已经有线程获取该Segment的锁，那当前线程会以自旋的方式去继续的调用tryLock（）方法去获取锁，超过指定次数就挂起，等待唤醒。</p><h3 id="get操作"><a href="#get操作" class="headerlink" title="get操作"></a>get操作</h3><p>ConcurrentHashMap的get操作跟HashMap类似，只是首先要判断volatile类型变量count是否不等于0，若不等于0则ConcurrentHashMap第一次需要经过一次hash定位到Segment的位置，然后再hash定位到指定的HashEntry，遍历该HashEntry下的链表进行对比，成功就返回，不成功就返回null。是弱一致性的。</p><p>   因为count是volatile，所以对count的写要happens-before于读操作。写线程 M 对链表做的结构性修改，在读线程 N 读取了同一个 volatile 变量后，对线程 N 也是可见的了。虽然线程 N 是在未加锁的情况下访问链表。Java 的内存模型可以保证：只要之前对链表做结构性修改操作的写线程 M 在退出写方法前写 volatile 型变量 count，读线程 N 在读取这个 volatile 型变量 count 后，就一定能“看到”这些修改。使得在 ConcurrentHashMap 中，读线程在读取散列表时，基本不需要加锁就能成功获得需要的值,不仅减少了请求同一个锁的频率（读操作一般不需要加锁就能够成功获得值），也减少了持有同一个锁的时间（只有读到 value 域的值为 null 时 , 读线程才需要加锁后重读）。</p><h3 id="size操作"><a href="#size操作" class="headerlink" title="size操作"></a>size操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (retries++ == RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) ensureSegment(j).lock(); <span class="comment">// force creation</span></span><br><span class="line">        &#125;</span><br><span class="line">        sum = <span class="number">0L</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        overflow = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j) &#123;</span><br><span class="line">            Segment&lt;K,V&gt; seg = segmentAt(segments, j);</span><br><span class="line">            <span class="keyword">if</span> (seg != <span class="keyword">null</span>) &#123; sum += seg.modCount; <span class="keyword">int</span> c = seg.count; <span class="keyword">if</span> (c &lt; <span class="number">0</span> || (size += c) &lt; <span class="number">0</span>)</span><br><span class="line">               overflow = <span class="keyword">true</span>;</span><br><span class="line">            &#125; &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum == last) <span class="keyword">break</span>;</span><br><span class="line">        last = sum; &#125; &#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (retries &gt; RETRIES_BEFORE_LOCK) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; segments.length; ++j)</span><br><span class="line">            segmentAt(segments, j).unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一种方案他会使用不加锁的模式去尝试多次计算ConcurrentHashMap的size，最多三次，比较前后两次计算的结果，结果一致就认为当前没有元素加入，计算的结果是准确的；<br>第二种方案是如果第一种方案不符合，他就会给每个Segment加上锁，然后计算ConcurrentHashMap的size返回。</p><h2 id="1-8-1"><a href="#1-8-1" class="headerlink" title="1.8"></a>1.8</h2><p> JDK1.8的实现已经摒弃了Segment的概念，而是直接用Node数组+链表+红黑树的数据结构来实现，并发控制使用Synchronized和CAS来操作，整个看起来就像是优化过且线程安全的HashMap，虽然在JDK1.8中还能看到Segment的数据结构，但是已经简化了属性，只是为了兼容旧版本，序列化与反序列化的时候会发挥作用。</p><h3 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h3><p>Node是ConcurrentHashMap存储结构的基本单元，继承于HashMap中的Entry，用于存储数据，源代码如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//链表的数据结构</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="comment">//val和next都会在扩容时发生变化，所以加上volatile来保持可见性和禁止重排序</span></span><br><span class="line">    <span class="keyword">volatile</span> V val;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;K,V&gt; next;</span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>       </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>     </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span>   </span>&#123; <span class="keyword">return</span> key.hashCode() ^ val.hashCode(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + val; &#125;</span><br><span class="line">    <span class="comment">//不允许更新value  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        Object k, v, u; Map.Entry&lt;?,?&gt; e;</span><br><span class="line">        <span class="keyword">return</span> ((o <span class="keyword">instanceof</span> Map.Entry) &amp;&amp;</span><br><span class="line">                (k = (e = (Map.Entry&lt;?,?&gt;)o).getKey()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (v = e.getValue()) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (k == key || k.equals(key)) &amp;&amp;</span><br><span class="line">                (v == (u = val) || v.equals(u)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//用于map中的get（）方法，子类重写</span></span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; e = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                K ek;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Node数据结构很简单，它与HashMap中的定义很相似，但是但是有一些差别它对value和next属性设置了volatile同步锁，它不允许调用setValue方法直接改变Node的value域，它增加了find方法辅助map.get()方法。</p><h3 id="TreeNode"><a href="#TreeNode" class="headerlink" title="TreeNode"></a>TreeNode</h3><p>TreeNode继承与Node，但是数据结构换成了二叉树结构，它是红黑树的数据的存储结构，用于红黑树中存储数据，当链表的节点数大于8时会转换成红黑树的结构，树节点类，另外一个核心的数据结构。当链表长度过长的时候，会转换为TreeNode。但是与HashMap不相同的是，它并不是直接转换为红黑树，而是把这些结点包装成TreeNode放在TreeBin对象中，由TreeBin完成对红黑树的包装。而且TreeNode在ConcurrentHashMap集成自Node类，而并非HashMap中的集成自LinkedHashMap.Entry&lt;K,V&gt;类，也就是说TreeNode带有next指针，这样做的目的是方便基于TreeBin的访问。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//树形结构的属性定义</span></span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;</span><br><span class="line">    TreeNode&lt;K,V&gt; right;</span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red; <span class="comment">//标志红黑树的红节点</span></span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next,</span><br><span class="line">             TreeNode&lt;K,V&gt; parent) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> findTreeNode(h, k, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据key查找 从根节点开始找出相应的TreeNode，</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">findTreeNode</span><span class="params">(<span class="keyword">int</span> h, Object k, Class&lt;?&gt; kc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k != <span class="keyword">null</span>) &#123;</span><br><span class="line">            TreeNode&lt;K,V&gt; p = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">do</span>  &#123;</span><br><span class="line">                <span class="keyword">int</span> ph, dir; K pk; TreeNode&lt;K,V&gt; q;</span><br><span class="line">                TreeNode&lt;K,V&gt; pl = p.left, pr = p.right;</span><br><span class="line">                <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((pk = p.key) == k || (pk != <span class="keyword">null</span> &amp;&amp; k.equals(pk)))</span><br><span class="line">                    <span class="keyword">return</span> p;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pl == <span class="keyword">null</span>)</span><br><span class="line">                    p = pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (pr == <span class="keyword">null</span>)</span><br><span class="line">                    p = pl;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((kc != <span class="keyword">null</span> ||</span><br><span class="line">                          (kc = comparableClassFor(k)) != <span class="keyword">null</span>) &amp;&amp;</span><br><span class="line">                         (dir = compareComparables(kc, k, pk)) != <span class="number">0</span>)</span><br><span class="line">                    p = (dir &lt; <span class="number">0</span>) ? pl : pr;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((q = pr.findTreeNode(h, k, kc)) != <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> q;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p = pl;</span><br><span class="line">            &#125; <span class="keyword">while</span> (p != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="TreeBin"><a href="#TreeBin" class="headerlink" title="TreeBin"></a>TreeBin</h3><p>TreeBin从字面含义中可以理解为存储树形结构的容器，而树形结构就是指TreeNode，所以TreeBin就是封装TreeNode的容器，它提供转换黑红树的一些条件和锁的控制。这个类并不负责包装用户的key、value信息，而是包装的很多TreeNode节点。它代替了TreeNode的根节点，也就是说在实际的ConcurrentHashMap“数组”中，存放的是TreeBin对象，而不是TreeNode对象，这是与HashMap的区别。另外这个类还带有了读写锁。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeBin</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//指向TreeNode列表和根节点</span></span><br><span class="line">    TreeNode&lt;K,V&gt; root;</span><br><span class="line">    <span class="keyword">volatile</span> TreeNode&lt;K,V&gt; first;</span><br><span class="line">    <span class="keyword">volatile</span> Thread waiter;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> lockState;</span><br><span class="line">    <span class="comment">// 读写锁状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WRITER = <span class="number">1</span>; <span class="comment">// 获取写锁的状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WAITER = <span class="number">2</span>; <span class="comment">// 等待写锁的状态</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READER = <span class="number">4</span>; <span class="comment">// 增加数据时读锁的状态</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化红黑树</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TreeBin(TreeNode&lt;K,V&gt; b) &#123;</span><br><span class="line">        <span class="keyword">super</span>(TREEBIN, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.first = b;</span><br><span class="line">        TreeNode&lt;K,V&gt; r = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode&lt;K,V&gt; x = b, next; x != <span class="keyword">null</span>; x = next) &#123;</span><br><span class="line">            next = (TreeNode&lt;K,V&gt;)x.next;</span><br><span class="line">            x.left = x.right = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">                x.parent = <span class="keyword">null</span>;</span><br><span class="line">                x.red = <span class="keyword">false</span>;</span><br><span class="line">                r = x;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                K k = x.key;</span><br><span class="line">                <span class="keyword">int</span> h = x.hash;</span><br><span class="line">                Class&lt;?&gt; kc = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">for</span> (TreeNode&lt;K,V&gt; p = r;;) &#123;</span><br><span class="line">                    <span class="keyword">int</span> dir, ph;</span><br><span class="line">                    K pk = p.key;</span><br><span class="line">                    <span class="keyword">if</span> ((ph = p.hash) &gt; h)</span><br><span class="line">                        dir = -<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (ph &lt; h)</span><br><span class="line">                        dir = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> ((kc == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                              (kc = comparableClassFor(k)) == <span class="keyword">null</span>) ||</span><br><span class="line">                             (dir = compareComparables(kc, k, pk)) == <span class="number">0</span>)</span><br><span class="line">                        dir = tieBreakOrder(k, pk);</span><br><span class="line">                        TreeNode&lt;K,V&gt; xp = p;</span><br><span class="line">                    <span class="keyword">if</span> ((p = (dir &lt;= <span class="number">0</span>) ? p.left : p.right) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        x.parent = xp;</span><br><span class="line">                        <span class="keyword">if</span> (dir &lt;= <span class="number">0</span>)</span><br><span class="line">                            xp.left = x;</span><br><span class="line">                        <span class="keyword">else</span></span><br><span class="line">                            xp.right = x;</span><br><span class="line">                        r = balanceInsertion(r, x);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.root = r;</span><br><span class="line">        <span class="function"><span class="keyword">assert</span> <span class="title">checkInvariants</span><span class="params">(root)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="ForwardingNode"><a href="#ForwardingNode" class="headerlink" title="ForwardingNode"></a>ForwardingNode</h3><p>一个用于连接两个table的节点类。它包含一个nextTable指针，用于指向下一张表。而且这个节点的key value next指针全部为null，它的hash值为-1. 这里面定义的find的方法是从nextTable里进行查询节点，而不是以自身为头节点进行查找<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">     * A node inserted at head of bins during transfer operations. </span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;  </span><br><span class="line">        <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;  </span><br><span class="line">        ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;  </span><br><span class="line">            <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);  </span><br><span class="line">            <span class="keyword">this</span>.nextTable = tab;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="function">Node&lt;K,V&gt; <span class="title">find</span><span class="params">(<span class="keyword">int</span> h, Object k)</span> </span>&#123;  </span><br><span class="line">            <span class="comment">// loop to avoid arbitrarily deep recursion on forwarding nodes  </span></span><br><span class="line">            outer: <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = nextTable;;) &#123;  </span><br><span class="line">                Node&lt;K,V&gt; e; <span class="keyword">int</span> n;  </span><br><span class="line">                <span class="keyword">if</span> (k == <span class="keyword">null</span> || tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||  </span><br><span class="line">                    (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) == <span class="keyword">null</span>)  </span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;  </span><br><span class="line">                    <span class="keyword">int</span> eh; K ek;  </span><br><span class="line">                    <span class="keyword">if</span> ((eh = e.hash) == h &amp;&amp;  </span><br><span class="line">                        ((ek = e.key) == k || (ek != <span class="keyword">null</span> &amp;&amp; k.equals(ek))))  </span><br><span class="line">                        <span class="keyword">return</span> e;  </span><br><span class="line">                    <span class="keyword">if</span> (eh &lt; <span class="number">0</span>) &#123;  </span><br><span class="line">                        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> ForwardingNode) &#123;  </span><br><span class="line">                            tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;  </span><br><span class="line">                            <span class="keyword">continue</span> outer;  </span><br><span class="line">                        &#125;  </span><br><span class="line">                        <span class="keyword">else</span>  </span><br><span class="line">                            <span class="keyword">return</span> e.find(h, k);  </span><br><span class="line">                    &#125;  </span><br><span class="line">                    <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)  </span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile关键字</title>
      <link href="/2019/04/09/atile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2019/04/09/atile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="准备概念"><a href="#准备概念" class="headerlink" title="准备概念"></a>准备概念</h1><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><p>当一个变量被两个线程同时处理时，由于两个线程处在不同的CPU中（多核CPU），因此对于该变量存在缓存一致性的问题<br>在硬件层面上，有两种解决方式：总线加锁，通过缓存一致性协议</p><p><img src="/upload/pasted-270.png" alt="upload successful"></p><h2 id="并发编程的三个概念"><a href="#并发编程的三个概念" class="headerlink" title="并发编程的三个概念"></a>并发编程的三个概念</h2><ul><li>原子性：<br>即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。<br>Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</li><li>可见性：<br>可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。<br>对于可见性，Java提供了volatile关键字来保证可见性。<br>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。<br>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</li><li>有序性：<br>即程序执行的顺序按照代码的先后顺序执行<br>一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。（重排序）<br>在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</li></ul><h2 id="happens-before原则"><a href="#happens-before原则" class="headerlink" title="happens-before原则"></a>happens-before原则</h2><p>在java中，有一套“happens-before”原则，满足这个原则，则会顺序执行，不满足则会发生重排序</p><ul><li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li><li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作</li><li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li><li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li><li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</li><li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li><li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li><li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li></ul><h1 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>1.保证了修饰变量的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> INIT_VALUE = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_LIMIT = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> localValue = INIT_VALUE;</span><br><span class="line">            <span class="keyword">while</span> (localValue &lt; MAX_LIMIT) &#123;</span><br><span class="line">                <span class="keyword">if</span> (localValue != INIT_VALUE) &#123;</span><br><span class="line">                    System.out.printf(<span class="string">"The value updated to [%d]\n"</span>, INIT_VALUE);</span><br><span class="line">                    localValue = INIT_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"READER"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> localValue = INIT_VALUE;</span><br><span class="line">            <span class="keyword">while</span> (INIT_VALUE &lt; MAX_LIMIT) &#123;</span><br><span class="line">                System.out.printf(<span class="string">"Update the value to [%d]\n"</span>, ++localValue);</span><br><span class="line">                INIT_VALUE = localValue;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">"UPDATER"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Update the value to [1]</span><br><span class="line">The value updated to [1]</span><br><span class="line">Update the value to [2]</span><br><span class="line">The value updated to [2]</span><br><span class="line">Update the value to [3]</span><br><span class="line">The value updated to [3]</span><br><span class="line">Update the value to [4]</span><br><span class="line">The value updated to [4]</span><br><span class="line">Update the value to [5]</span><br><span class="line">The value updated to [5]</span><br></pre></td></tr></table></figure></p><p>当INIT_VALUE没有被volatile修饰时<br>输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Update the value to [1]</span><br><span class="line">Update the value to [2]</span><br><span class="line">Update the value to [3]</span><br><span class="line">Update the value to [4]</span><br><span class="line">Update the value to [5]</span><br></pre></td></tr></table></figure></p><p>分析：在没有volatile修饰时，对于第一个读线程，此时判定是两个值是相等的，因此执行完毕后就退出了，而有了volatile修饰后，这个值就是可见的了，而且是立即可见，因此会不断的运行</p><p>2.volatile可以保证有序性<br>volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。<br>volatile关键字禁止指令重排序有两层意思：<br>1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；<br>2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。<br>举例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x、y为非volatile变量</span></span><br><span class="line"><span class="comment">//flag为volatile变量</span></span><br><span class="line"> </span><br><span class="line">x = <span class="number">2</span>;        <span class="comment">//语句1</span></span><br><span class="line">y = <span class="number">0</span>;        <span class="comment">//语句2</span></span><br><span class="line">flag = <span class="keyword">true</span>;  <span class="comment">//语句3</span></span><br><span class="line">x = <span class="number">4</span>;         <span class="comment">//语句4</span></span><br><span class="line">y = -<span class="number">1</span>;       <span class="comment">//语句5</span></span><br></pre></td></tr></table></figure></p><p>　由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。<br>并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</p><p>对于<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">context = loadContext();   <span class="comment">//语句1</span></span><br><span class="line">inited = <span class="keyword">true</span>;             <span class="comment">//语句2</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure></p><p>有可能语句2会在语句1之前执行，那么可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。<br>这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>　synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。<br> 通常来说，使用volatile必须具备以下2个条件：</p><p>　　1）对变量的写操作不依赖于当前值</p><p>　　2）该变量没有包含在具有其他变量的不变式中</p><p>1.状态标记量<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> inited = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//线程1:</span></span><br><span class="line">context = loadContext();  </span><br><span class="line">inited = <span class="keyword">true</span>;            </span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;</span><br><span class="line">sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure><p>2.单例模式中的doublecheck<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance==<span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span>(instance==<span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>一个总结：<br>与锁相比，Volatile 变量是一种非常简单但同时又非常脆弱的同步机制，它在某些情况下将提供优于锁的性能和伸缩性。如果严格遵循 volatile 的使用条件 —— 即变量真正独立于其他变量和自己以前的值 —— 在某些情况下可以使用 volatile 代替 synchronized 来简化代码。然而，使用 volatile 的代码往往比使用锁的代码更加容易出错。<br>只能在有限的一些情形下使用 volatile 变量替代锁。要使 volatile 变量提供理想的线程安全，必须同时满足下面两个条件：</p><ul><li>（1）对变量的写操作不依赖于当前值。</li><li>（2）该变量没有包含在具有其他变量的不变式中。<br>实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。<br>第一个条件的限制使 volatile 变量不能用作线程安全计数器。虽然增量操作（x++）看上去类似一个单独操作，实际上它是一个由读取－修改－写入操作序列组成的组合操作，必须以原子方式执行，而 volatile 不能提供必须的原子特性。实现正确的操作需要使 x 的值在操作期间保持不变，而 volatile 变量无法实现这点。 </li></ul><p>参考自 <a href="https://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3920373.html</a></p>]]></content>
      
      
      <categories>
          
          <category> java多线程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java多线程 </tag>
            
            <tag> 关键字系列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程下的单例设计模式</title>
      <link href="/2019/04/09/%E7%A8%8B%E4%B8%8B%E7%9A%84%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/04/09/%E7%A8%8B%E4%B8%8B%E7%9A%84%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h1><p>单例模式确保某个类只有一个实例，而且自行实例化并向整个系统提供这个实例。在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。</p><h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><p>1、单例类只能有一个实例。<br>2、单例类必须自己创建自己的唯一实例。<br>3、单例类必须给所有其他对象提供这一实例。<br>单例模式保证了全局对象的唯一性，比如系统启动读取配置文件就需要单例保证配置的一致性。</p><h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>饿汉式单例模式：类加载初始化时就创建好一个静态的对象供外部使用，除非系统重启，这个对象不会改变，所以本身就是线程安全的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObject1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 无法进行懒加载：一旦类加载了，就会占用内存空间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonObject1 instance = <span class="keyword">new</span> SingletonObject1();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造函数私有</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonObject1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//empty</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonObject1 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>懒汉式单例（延迟加载方式）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObject2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonObject2 instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonObject2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//empty</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//虽然实现了调用才构造（即懒加载），但是存在线程安全问题</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonObject2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance)</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonObject2();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> SingletonObject2.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>部分加锁的懒汉式单例，实际上最初的想法是在整个方法上加锁，但实际上虽然解决了多个实例对象问题，但是该方式运行效率却很低下，下一个线程想要获取对象，就必须等待上一个线程释放锁之后，才可以继续运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObject4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonObject4 instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonObject4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//---</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//double check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonObject4 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">            <span class="comment">//在创建处加锁，防止多个线程的多次创建</span></span><br><span class="line">            <span class="keyword">synchronized</span> (SingletonObject4.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == instance)</span><br><span class="line">                    instance = <span class="keyword">new</span> SingletonObject4();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> SingletonObject4.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态内部类的方法,这种方法巧用类的加载机制，而且也能保证线程安全，在未使用时，不会加载内部类，只有在使用实例时，才会加载内部类，从而初始化实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObject6</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonObject6</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="class"><span class="keyword">class</span> <span class="title">InstanceHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> SingletonObject6 instance = <span class="keyword">new</span> SingletonObject6();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonObject6 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> InstanceHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过内部枚举实现：枚举的构造函数只会调用一次<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonObject7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingletonObject7</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">        INSTANCE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> SingletonObject7 instance;</span><br><span class="line"></span><br><span class="line">        Singleton() &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SingletonObject7();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> SingletonObject7 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingletonObject7 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.INSTANCE.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> java多线程学习 </category>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java多线程 </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从爬楼梯问题所想到的</title>
      <link href="/2019/04/03/%E6%A5%BC%E6%A2%AF%E9%97%AE%E9%A2%98%E6%89%80%E6%83%B3%E5%88%B0%E7%9A%84/"/>
      <url>/2019/04/03/%E6%A5%BC%E6%A2%AF%E9%97%AE%E9%A2%98%E6%89%80%E6%83%B3%E5%88%B0%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p>一道简单的爬楼梯问题</p><p>You are climbing a stair case. It takes n steps to reach to the top.</p><p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?<br><strong>Note:</strong> Given n will be a positive integer.</p><p><strong>Example 1:</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: 2</span><br><span class="line">Output: 2</span><br><span class="line">Explanation: There are two ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step</span><br><span class="line">2. 2 steps</span><br></pre></td></tr></table></figure></p><p><strong>Example2</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Input: 3</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: There are three ways to climb to the top.</span><br><span class="line">1. 1 step + 1 step + 1 step</span><br><span class="line">2. 1 step + 2 steps</span><br><span class="line">3. 2 steps + 1 step</span><br></pre></td></tr></table></figure></p><p>这是一道DP入门级别的题目，按照自顶向下（TOP to BOTTOM）的思考方式,要向到第n级台阶的话，只需要第n-1阶走一级或者n-2阶走两级，这时问题就又变成了到n-1阶和n-2阶有多少种方法，因此可以得到dp式子：dp(n)=dp(n-1)+dp(n-2)</p><p>因此，自然而然就写出了以下实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d[n] &gt; <span class="number">0</span>) <span class="keyword">return</span> d[n];</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> climbStairs(n - <span class="number">1</span>) + climbStairs(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然而，提交以后就报TLE,细细一想，这种递归方式，虽然写起来简单，而且看上去也很好理解，但是这里有个严重的缺陷：有些计算会重复很多次，比如计算dp(6)，需要算dp(5)和dp(4)，算dp(5)需要算dp(4),dp(3),这个时候，dp(4)就算了两次，求的数越大，重复计算的次数也就愈多</p><p>于是我就想班里的搞竞赛的大佬讨教，大佬首先给出了“记录搜索”<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> d[]=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">110</span>];</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d[n] &gt; <span class="number">0</span>) <span class="keyword">return</span> d[n];</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> d[n] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> d[n] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> d[n] = climbStairs(n - <span class="number">1</span>) + climbStairs(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所谓“记录搜索”，就是查表，所谓的表，就是把计算的结果存起来，刚才的问题不就是需要重复计算吗，这样一来就没有重复计算的问题</p><p>后来看讨论区，又有种方法就是自底向上，顺序递推的方式，时间复杂度为O(n)<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (d[n] &gt; <span class="number">0</span>) <span class="keyword">return</span> d[n];</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> N_1=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> N_2=<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">        ans=N_1+N_2;</span><br><span class="line">        N_1=N_2;</span><br><span class="line">        N_2=ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然而，现在又有一个新的问题，假设需要算1e8的情况，那么即使是O(n),也会超时，这时候就需要一种更快的方式<br>这里就有一种新的处理方式：<strong>矩阵快速幂</strong>（感谢大佬特地跑过来给我讲，要不然都没地方去知道）</p>]]></content>
      
      
      <categories>
          
          <category> 刷算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程学习4（线程组，自实现线程池）</title>
      <link href="/2019/04/02/%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/"/>
      <url>/2019/04/02/%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><img src="/upload/pasted-363.png" width="70%"></p><a id="more"></a><h1 id="线程组（Thread-Group）"><a href="#线程组（Thread-Group）" class="headerlink" title="线程组（Thread Group）"></a>线程组（Thread Group）</h1><blockquote><p><strong>public class ThreadGroup</strong><br>extends Object<br>implements Thread.UncaughtExceptionHandler</p></blockquote><p>A thread group represents a set of threads. In addition, a thread group can also include other thread groups. The thread groups form a tree in which every thread group except the initial thread group has a parent.</p><blockquote></blockquote><p>A thread is allowed to access information about its own thread group, but not to access information about its thread group’s parent thread group or any other thread groups.</p><p>从上面的文档可以得知：<br>线程组也是一个树形<br>ThreadGroup中，也有一系列的生成和销毁方法</p><h1 id="线程池-（ThreadPool）"><a href="#线程池-（ThreadPool）" class="headerlink" title="线程池 （ThreadPool）"></a>线程池 （ThreadPool）</h1><h2 id="为什么要有线程池"><a href="#为什么要有线程池" class="headerlink" title="为什么要有线程池"></a>为什么要有线程池</h2><p><img src="/upload/pasted-348.png" alt="upload successful"><br>这里的关键就是把线程的数量控制起来，因为频繁的创建和销毁线程是很占用资源的</p><h2 id="自己实现"><a href="#自己实现" class="headerlink" title="自己实现"></a>自己实现</h2><h3 id="几个需要注意的属性"><a href="#几个需要注意的属性" class="headerlink" title="几个需要注意的属性"></a>几个需要注意的属性</h3><ul><li>任务队列：把等待执行的任务储存起来</li><li>线程队列：用来放线程</li><li>拒绝策略：任务队列应该是有大小的，当有过多的任务申请提交时，应当有拒绝策略，方法有：抛出异常，直接丢弃，进入阻塞状态，放入临时队列</li><li>初始化值：初始时线程池大小（最小）</li><li>运行时：活跃任务多的时候的大小</li><li>最大值：线程池数量最大的情况</li></ul><h3 id="实现代码-注释"><a href="#实现代码-注释" class="headerlink" title="实现代码+注释"></a>实现代码+注释</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleThreadPool</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;<span class="comment">//设置线程池的大小</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> queueSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_TASK_QUEUE_SIZE = <span class="number">2000</span>;<span class="comment">//默认大小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> seq = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义的线程的名称前缀</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String THREAD_PREFIX = <span class="string">"SIMPLE_THREAD_POOL-"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置线程组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> ThreadGroup GROUP = <span class="keyword">new</span> ThreadGroup(<span class="string">"Pool_Group"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//任务队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> LinkedList&lt;Runnable&gt; TASK_QUEUE = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程池中的线程队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> List&lt;WorkerTask&gt; THREAD_QUEUE = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DiscardPolicy discardPolicy;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拒绝策略默认抛出异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> DiscardPolicy DEFAULT_DISCARD_POLICY = () -&gt; &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> DiscardException(<span class="string">"Discard This Task."</span>);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线程池的状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> destroy = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> min;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> max;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> active;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">4</span>, <span class="number">8</span>, <span class="number">12</span>, DEFAULT_TASK_QUEUE_SIZE, DEFAULT_DISCARD_POLICY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleThreadPool</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> active, <span class="keyword">int</span> max, <span class="keyword">int</span> queueSize, DiscardPolicy discardPolicy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.min = min;</span><br><span class="line">        <span class="keyword">this</span>.active = active;</span><br><span class="line">        <span class="keyword">this</span>.max = max;</span><br><span class="line">        <span class="keyword">this</span>.queueSize = queueSize;</span><br><span class="line">        <span class="keyword">this</span>.discardPolicy = discardPolicy;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化：创建 最小数量 的线程</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.min; i++) &#123;</span><br><span class="line">            createWorkTask();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.size = min;</span><br><span class="line">        <span class="keyword">this</span>.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提交 Runable任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">submit</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (destroy)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"The thread pool already destroy and not allow submit task."</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (TASK_QUEUE) &#123;</span><br><span class="line">            <span class="comment">//使用拒绝策略：当任务数量已经大于线程池中的线程数量</span></span><br><span class="line">            <span class="keyword">if</span> (TASK_QUEUE.size() &gt; queueSize)</span><br><span class="line">                discardPolicy.discard();</span><br><span class="line">            <span class="comment">//FIFO队列</span></span><br><span class="line">            TASK_QUEUE.addLast(runnable);</span><br><span class="line">            TASK_QUEUE.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//动态设置线程数量，使线程数量根据min max active之间进行变化</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!destroy) &#123;</span><br><span class="line">            System.out.printf(<span class="string">"Pool#Min:%d,Active:%d,Max:%d,Current:%d,QueueSize:%d\n"</span>,</span><br><span class="line">                    <span class="keyword">this</span>.min, <span class="keyword">this</span>.active, <span class="keyword">this</span>.max, <span class="keyword">this</span>.size, TASK_QUEUE.size());</span><br><span class="line">            <span class="keyword">if</span> (TASK_QUEUE.size() &gt; active &amp;&amp; size &lt; active) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = size; i &lt; active; i++) &#123;</span><br><span class="line">                    createWorkTask();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"The pool incremented to active."</span>);</span><br><span class="line">                size = active;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TASK_QUEUE.size() &gt; max &amp;&amp; size &lt; max) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = size; i &lt; max; i++) &#123;</span><br><span class="line">                    createWorkTask();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"The pool incremented to max."</span>);</span><br><span class="line">                size = max;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (THREAD_QUEUE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (TASK_QUEUE.isEmpty() &amp;&amp; size &gt; active) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"=========Reduce========"</span>);</span><br><span class="line">                    <span class="keyword">int</span> releaseSize = size - active;</span><br><span class="line">                    <span class="keyword">for</span> (Iterator&lt;WorkerTask&gt; it = THREAD_QUEUE.iterator(); it.hasNext(); ) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (releaseSize &lt;= <span class="number">0</span>)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">                        WorkerTask task = it.next();</span><br><span class="line">                        task.close();</span><br><span class="line">                        task.interrupt();</span><br><span class="line">                        it.remove();</span><br><span class="line">                        releaseSize--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    size = active;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createWorkTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建工作线程</span></span><br><span class="line">        WorkerTask task = <span class="keyword">new</span> WorkerTask(GROUP, THREAD_PREFIX + (seq++));</span><br><span class="line">        task.start();</span><br><span class="line">        <span class="comment">//把线程放入队列</span></span><br><span class="line">        THREAD_QUEUE.add(task);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭线程池</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//要向关闭，任务队列必须为空</span></span><br><span class="line">        <span class="keyword">while</span> (!TASK_QUEUE.isEmpty()) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (THREAD_QUEUE) &#123;</span><br><span class="line">            <span class="keyword">int</span> initVal = THREAD_QUEUE.size();</span><br><span class="line">            <span class="keyword">while</span> (initVal &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//遍历每个线程</span></span><br><span class="line">                <span class="keyword">for</span> (WorkerTask task : THREAD_QUEUE) &#123;</span><br><span class="line">                    <span class="comment">//看后面代码可以知道，若是处在blocked状态，则线程是处在while循环当中</span></span><br><span class="line">                    <span class="keyword">if</span> (task.getTaskState() == TaskState.BLOCKED) &#123;</span><br><span class="line">                        <span class="comment">//通过中断抛出异常，跳出while循环</span></span><br><span class="line">                        task.interrupt();</span><br><span class="line">                        <span class="comment">//若不是在循环中，则直接设置为dead</span></span><br><span class="line">                        task.close();</span><br><span class="line">                        initVal--;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(GROUP.activeCount());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.destroy = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getQueueSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queueSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.destroy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> active;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义任务状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">enum</span> TaskState &#123;</span><br><span class="line">        FREE, RUNNING, BLOCKED, DEAD</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拒绝策略的一种结果：抛出异常</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscardException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DiscardException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拒绝策略的接口（公有）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DiscardPolicy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">discard</span><span class="params">()</span> <span class="keyword">throws</span> DiscardException</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//继承Thread，自定义线程进行封装</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerTask</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化状态</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> TaskState taskState = TaskState.FREE;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WorkerTask</span><span class="params">(ThreadGroup group, String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(group, name);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> TaskState <span class="title">getTaskState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.taskState;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重写run方法：要注意完成任务后，当前线程不会直接关闭</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            OUTER:</span><br><span class="line">            <span class="comment">//利用while循环保持</span></span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">this</span>.taskState != TaskState.DEAD) &#123;</span><br><span class="line">                Runnable runnable;</span><br><span class="line">                <span class="comment">//以任务队列为监视器</span></span><br><span class="line">                <span class="keyword">synchronized</span> (TASK_QUEUE) &#123;</span><br><span class="line">                    <span class="comment">//当任务队列为空时，当前线程就会wait住</span></span><br><span class="line">                    <span class="keyword">while</span> (TASK_QUEUE.isEmpty()) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">//此时线程的状态为blocked</span></span><br><span class="line">                            taskState = TaskState.BLOCKED;</span><br><span class="line">                            TASK_QUEUE.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"Closed."</span>);</span><br><span class="line">                            <span class="keyword">break</span> OUTER;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//若有任务，则移除任务队列队首的Runable</span></span><br><span class="line">                    runnable = TASK_QUEUE.removeFirst();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//若取出的任务Runable不为空，则当前线程执行任务</span></span><br><span class="line">                <span class="keyword">if</span> (runnable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//设置当前线程状态为running</span></span><br><span class="line">                    taskState = TaskState.RUNNING;</span><br><span class="line">                    <span class="comment">//运行当前任务</span></span><br><span class="line">                    runnable.run();</span><br><span class="line">                    <span class="comment">//运行完毕后设置为free</span></span><br><span class="line">                    taskState = TaskState.FREE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭线程：将状态设置为dead</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.taskState = TaskState.DEAD;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SimpleThreadPool threadPool = <span class="keyword">new</span> SimpleThreadPool();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">            threadPool.submit(() -&gt; &#123;</span><br><span class="line">                System.out.println(<span class="string">"The runnable  be serviced by "</span> + Thread.currentThread() + <span class="string">" start."</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"The runnable be serviced by "</span> + Thread.currentThread() + <span class="string">" finished."</span>);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line"></span><br><span class="line">       <span class="comment">/* Thread.sleep(10000);</span></span><br><span class="line"><span class="comment">        threadPool.shutdown();</span></span><br><span class="line"><span class="comment">        threadPool.submit(() -&gt; System.out.println("======="));*/</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> java多线程学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最长回文串的几个解法</title>
      <link href="/2019/04/01/%E5%9B%9E%E6%96%87%E4%B8%B2%E7%9A%84%E5%87%A0%E4%B8%AA%E8%A7%A3%E6%B3%95-1/"/>
      <url>/2019/04/01/%E5%9B%9E%E6%96%87%E4%B8%B2%E7%9A%84%E5%87%A0%E4%B8%AA%E8%A7%A3%E6%B3%95-1/</url>
      
        <content type="html"><![CDATA[<h1 id="解法一-动态规划"><a href="#解法一-动态规划" class="headerlink" title="解法一 动态规划"></a>解法一 动态规划</h1><p>应当发现，如果一个字符串是回文串，那么在其两端加上相同的字母也是回文串<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = s.length();</span><br><span class="line">  String res = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][n];</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">      dp[i][j] = s.charAt(i) == s.charAt(j) &amp;&amp; (j - i &lt; <span class="number">3</span> || dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">            </span><br><span class="line">      <span class="keyword">if</span> (dp[i][j] &amp;&amp; (res == <span class="keyword">null</span> || j - i + <span class="number">1</span> &gt; res.length())) &#123;</span><br><span class="line">        res = s.substring(i, j + <span class="number">1</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 刷算法题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程学习3（保护线程，终止线程，synchronized）</title>
      <link href="/2019/03/29/ava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89/"/>
      <url>/2019/03/29/ava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><img src="/upload/pasted-366.png" width="70%"></p><a id="more"></a><h1 id="java-Thread-中涉及的函数"><a href="#java-Thread-中涉及的函数" class="headerlink" title="java Thread 中涉及的函数"></a>java Thread 中涉及的函数</h1><h2 id="Daemon相关（受保护线程）"><a href="#Daemon相关（受保护线程）" class="headerlink" title="Daemon相关（受保护线程）"></a>Daemon相关（受保护线程）</h2><p>官方文档说明：</p><blockquote><p>public final void setDaemon(boolean on)</p><p>Marks this thread as either a daemon thread or a user thread. The Java Virtual Machine exits when the only threads running are all daemon threads.</p><p>This method must be invoked before the thread is started.</p></blockquote><p>文档中有两个需要注意的地方</p><ul><li>当jvm中只有保护线程在运行时，jvm退出</li><li>不能在一个线程已经启动后再把其标记为受保护线程</li></ul><h3 id="两种线程的说明"><a href="#两种线程的说明" class="headerlink" title="两种线程的说明"></a>两种线程的说明</h3><ul><li><p>用户线程: 用户线程可以简单的理解为用户定义的线程,当然包括main线程</p></li><li><p>daemon线程: daemon线程是为我们创建的用户线程提供服务的线程,比如说jvm的GC等等,这样的线程有一个非常明显的特征: 当用户线程运行结束的时候,daemon线程将会自动退出，由于daemon线程的终止条件是当前是否存在用户线程,所以我们不能指派daemon线程来进行一些业务操作,而只能服务用户线程，daemon线程创建的子线程任然是daemon线程.</p></li></ul><h3 id="实例演示"><a href="#实例演示" class="headerlink" title="实例演示"></a>实例演示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaemonThread2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            Thread innerThread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"Do some thing for health check."</span>);</span><br><span class="line">                        Thread.sleep(<span class="number">100_000</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            innerThread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">            innerThread.start();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1_000</span>);</span><br><span class="line">                System.out.println(<span class="string">"T thread finish done."</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明： 首先创建线程对象t，其次在线程内部创建线程对象innerThread，并且在启动之前将其设置为受保护线程，可以发现，innerThread中是一个死循环，而t只是一个休眠一秒的线程</p><p>运行结果：</p><p><img src="/upload/pasted-263.png" alt="upload successful"><br>这也就说明了当用户线程(t)执行完毕后，它的子受保护线程也会停止</p><h2 id="线程ID"><a href="#线程ID" class="headerlink" title="线程ID"></a>线程ID</h2><p>官方文档说明：</p><blockquote><p><strong>public long getId()</strong></p><p>Returns the identifier of this Thread. The thread ID is a positive long number generated when this thread was created. The thread ID is unique and remains unchanged during its lifetime. When a thread is terminated, this thread ID may be reused.</p><p><strong>Returns</strong>:<br>    this thread’s ID.</p></blockquote><p>几点注意：</p><ul><li>ID是一个正的long型</li><li>ID独一无二且保持不变</li></ul><p>源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">long</span> <span class="title">nextThreadID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> ++threadSeqNumber;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>可见ID在实现过程也是逐步累加</p><h2 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h2><p>记住一点，优先级高不一定优先，优先级低不一定落后执行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                Optional.of(Thread.currentThread().getName() + <span class="string">"-Index"</span> + i).ifPresent(System.out::println);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        t1.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line"></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                Optional.of(Thread.currentThread().getName() + <span class="string">"-Index"</span> + i).ifPresent(System.out::println);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t2.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line"></span><br><span class="line">        Thread t3 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                Optional.of(Thread.currentThread().getName() + <span class="string">"-Index"</span> + i).ifPresent(System.out::println);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t3.setPriority(Thread.MIN_PRIORITY);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t3.start();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>运行结果：</p><p><img src="/upload/pasted-265.png" alt="upload successful"></p><h2 id="joint-方法"><a href="#joint-方法" class="headerlink" title="joint 方法"></a>joint 方法</h2><p>官方文档说明：</p><blockquote><p><strong>void     join()</strong><br>Waits for this thread to die.<br><strong>void     join(long millis)</strong><br>Waits at most millis milliseconds for this thread to die.<br><strong>void     join(long millis, int nanos)</strong><br>Waits at most millis milliseconds plus nanos nanoseconds for this thread to die.</p></blockquote><p>理解：应当是让当前线程（父线程）等待此线程（子线程，调用join的线程）结束，当前线程才执行</p><p>实例代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoin</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            IntStream.range(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">                    .forEach(i -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">"-&gt;"</span> + i));</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            IntStream.range(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">                    .forEach(i -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">"-&gt;"</span> + i));</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        t1.start();</span><br><span class="line">        t2.start();</span><br><span class="line">        t1.join();</span><br><span class="line">        t2.join();</span><br><span class="line"></span><br><span class="line">        Optional.of(<span class="string">"All of tasks finish done."</span>).ifPresent(System.out::println);</span><br><span class="line">        IntStream.range(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line">                .forEach(i -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">"-&gt;"</span> + i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果：</p><p><img src="/upload/pasted-267.png" alt="upload successful"></p><p>分析：<br>t1t2两个子线程，在start之后调用join，就使得当前线程（主线程）需要等待两个线程的结束后才能执行</p><p>问题：若当前线程调用join<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().join();</span><br></pre></td></tr></table></figure></p><p>会陷入无限等待状态</p><p>用途：利用join的特性：父线程需要等待子线程结束才可执行，就可以应用到一些有明确先后顺序的线程交互中去</p><h2 id="interrupt方法"><a href="#interrupt方法" class="headerlink" title="interrupt方法"></a>interrupt方法</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><blockquote><p><strong>void     interrupt()</strong><br>Interrupts this thread.<br><strong>static boolean     interrupted()</strong><br>Tests whether the current thread has been interrupted.</p></blockquote><blockquote><p><strong>public void interrupt()</strong></p><p>Interrupts this thread.</p></blockquote><p>Unless the current thread is interrupting itself, which is always permitted, the checkAccess method of this thread is invoked, which may cause a SecurityException to be thrown.</p><blockquote></blockquote><p>If this thread is blocked in an invocation of the wait(), wait(long), or wait(long, int) methods of the Object class, or of the join(), join(long), join(long, int), sleep(long), or sleep(long, int), methods of this class, then its interrupt status will be cleared and it will receive an InterruptedException.</p><blockquote></blockquote><p>If this thread is blocked in an I/O operation upon an InterruptibleChannel then the channel will be closed, the thread’s interrupt status will be set, and the thread will receive a ClosedByInterruptException.</p><blockquote></blockquote><p>If this thread is blocked in a Selector then the thread’s interrupt status will be set and it will return immediately from the selection operation, possibly with a non-zero value, just as if the selector’s wakeup method were invoked.</p><blockquote></blockquote><p>If none of the previous conditions hold then this thread’s interrupt status will be set.</p><blockquote></blockquote><p>Interrupting a thread that is not alive need not have any effect.</p><blockquote></blockquote><p><strong>Throws:</strong><br>    SecurityException - if the current thread cannot modify this thread</p><p>通过文档的介绍知道几点</p><ul><li>运行的权限问题</li><li>对于运行了sleep，wait，join(让父线程进入堵塞状态)等陷入堵塞状态的方法，若调用interrupt，会把当前的“中断标记”清除，然后抛出InterruptedException.</li><li>对于io堵塞的线程，调用interrupt方法会将“中断标记”设为true，并且抛出ClosedByInterruptException</li><li>如果不是处于堵塞状态，调用interrupt会将“中断标记”设为true</li></ul><p>具体体现：</p><p><img src="/upload/pasted-327.png" alt="upload successful"><br><img src="/upload/pasted-326.png" alt="upload successful"><br>输出：</p><p><img src="/upload/pasted-328.png" alt="upload successful"><br>原因：“当前进程”current thread–main</p><p><img src="/upload/pasted-329.png" alt="upload successful"><br>输出<br><img src="/upload/pasted-330.png" alt="upload successful"><br>原因：第二个输出是因为状态被重置</p><h3 id="正确的终止某个线程"><a href="#正确的终止某个线程" class="headerlink" title="正确的终止某个线程"></a>正确的终止某个线程</h3><h4 id="设置一个标志位"><a href="#设置一个标志位" class="headerlink" title="设置一个标志位"></a>设置一个标志位</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">ThreadClose</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置的标志位</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> start = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//在run中循环</span></span><br><span class="line">            <span class="keyword">while</span> (start) &#123;</span><br><span class="line">                <span class="comment">//业务逻辑</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line">        worker.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        worker.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用interrupt"><a href="#使用interrupt" class="headerlink" title="使用interrupt"></a>使用interrupt</h4><ul><li>用isInterrupt()进行判断</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadCloseGraceful2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (!isInterrupted())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//业务逻辑</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//模拟线程因为wait，sleep，join而陷入休眠</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            System.out.println(<span class="string">"输出结果"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Worker worker = <span class="keyword">new</span> Worker();</span><br><span class="line">        worker.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        worker.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里存在一个问题，当把sleep移出while循环后，在进行interrupt，首先会抛异常，但是while循环不会终止，因为根据官方文档说明的，遇见这种堵塞状态，“终止标记”会被消除（重置为false），因此循环不会退出</p><h4 id="利用deamon线程的特性"><a href="#利用deamon线程的特性" class="headerlink" title="利用deamon线程的特性"></a>利用deamon线程的特性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Thread executeThread;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> finished = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        executeThread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//在执行线程中设置一个守护线程</span></span><br><span class="line">                Thread runner = <span class="keyword">new</span> Thread(task);</span><br><span class="line">                runner.setDaemon(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                runner.start();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    runner.join();</span><br><span class="line">                    <span class="comment">//当子线程（runner，守护线程执行完毕后）。将结束标记设置为true</span></span><br><span class="line">                    finished = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    <span class="comment">//e.printStackTrace();</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        executeThread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">long</span> mills)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span> (!finished) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((System.currentTimeMillis() - currentTime) &gt;= mills) &#123;</span><br><span class="line">                System.out.println(<span class="string">"任务超时，需要结束他!"</span>);</span><br><span class="line">                <span class="comment">//关闭执行线程，则守护线程的子线程就一定关闭了</span></span><br><span class="line">                executeThread.interrupt();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                executeThread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"执行线程被打断!"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        finished = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><h3 id="非线程安全"><a href="#非线程安全" class="headerlink" title="非线程安全"></a>非线程安全</h3><p>多个线程对同一个对象的同一个实例变量进行操作时出现值被更改，值不同步的情况，进而影响程序的运行</p><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>在java中，每一个对象有且仅有一个同步锁。这也意味着，同步锁是依赖于对象而存在。<br>当我们调用某对象的synchronized方法时，就获取了该对象的同步锁。例如，synchronized(obj)就获取了“obj这个对象”的同步锁。<br>不同线程对同步锁的访问是互斥的。也就是说，某时间点，对象的同步锁只能被一个线程获取到！通过同步锁，我们就能在多线程中，实现对“对象/方法”的互斥访问。 例如，现在有两个线程A和线程B，它们都会访问“对象obj的同步锁”。假设，在某一时刻，线程A获取到“obj的同步锁”并在执行一些操作；而此时，线程B也企图获取“obj的同步锁” —— 线程B会获取失败，它必须等待，直到线程A释放了“该对象的同步锁”之后线程B才能获取到“obj的同步锁”从而才可以运行。<br>应当注意：同步锁应当尽量作用在数据出现线程不安全的地方，如果把它作用在run方法，实际上一个多线程的实现就会变成一个单线程</p><h3 id="几种使用方式"><a href="#几种使用方式" class="headerlink" title="几种使用方式"></a>几种使用方式</h3><ol><li>锁“this”对象的代码块</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//readonly shared data.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//this</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticket())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">ticket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &gt; MAX)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">" 的号码是:"</span> + (index++));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应当采取这种方式，来缩小同步范围，以减少同步消耗时间<br>同样，这种方法也是锁的对象</p><ol start="2"><li>锁一个obj对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//readonly shared data.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX = <span class="number">500</span>;</span><br><span class="line">    <span class="comment">//添加一个obj对象</span></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">final</span>  <span class="keyword">static</span>  Object OBJ=<span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//this</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticket())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">ticket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//对obj进行上锁</span></span><br><span class="line">        <span class="keyword">synchronized</span> (OBJ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (index &gt; MAX)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">" 的号码是:"</span> + (index++));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  以上两种方式效果是一样的，都能够达成同步锁的要求</p><ol start="3"><li>对某个方法上锁</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//readonly shared data.</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//this</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ticket())</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将其改为synchronized方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">ticket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (index &gt; MAX)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">" 的号码是:"</span> + (index++));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>对方法上锁的实质还是对相应的实例对象上锁，假设在这个类中有两个synchronized方法，两个线程分别调用一个实例对象的两个synchronized方法，那么是需要排队的</p><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>所谓脏读，就是读写不同步，在读取实例变量的内容时，已经被改写了<br>发生的原因：读（get）写（set）方法只同步了读方法，没有同步写方法</p><h3 id="同步锁的使用"><a href="#同步锁的使用" class="headerlink" title="同步锁的使用"></a>同步锁的使用</h3><ul><li>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的该“synchronized方法”或者“synchronized代码块”的访问将被阻塞。</li><li>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问“该对象”的非同步代码块。</li><li>当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对“该对象”的其他的“synchronized方法”或者“synchronized代码块”的访问将被阻塞。</li></ul><h4 id="演示1："><a href="#演示1：" class="headerlink" title="演示1："></a>演示1：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyRunable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>); <span class="comment">// 休眠100ms</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" loop "</span> + i);  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        Runnable demo = <span class="keyword">new</span> MyRunable();     <span class="comment">// 新建“Runnable对象”</span></span><br><span class="line"></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(demo, <span class="string">"t1"</span>);  <span class="comment">// 新建“线程t1”, t1是基于demo这个Runnable对象</span></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(demo, <span class="string">"t2"</span>);  <span class="comment">// 新建“线程t2”, t2是基于demo这个Runnable对象</span></span><br><span class="line">        t1.start();                          <span class="comment">// 启动“线程t1”</span></span><br><span class="line">        t2.start();                          <span class="comment">// 启动“线程t2” </span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">t1 loop 0</span><br><span class="line">t1 loop 1</span><br><span class="line">t1 loop 2</span><br><span class="line">t1 loop 3</span><br><span class="line">t1 loop 4</span><br><span class="line">t2 loop 0</span><br><span class="line">t2 loop 1</span><br><span class="line">t2 loop 2</span><br><span class="line">t2 loop 3</span><br><span class="line">t2 loop 4</span><br></pre></td></tr></table></figure></p><p>分析：<br>在run方法中设置了针对Runable对象的“同步锁”，一旦t1开始执行run方法，t2若要执行，就会进入阻塞状态，需要等到t1执行完毕才会执行</p><h4 id="演示2"><a href="#演示2" class="headerlink" title="演示2"></a>演示2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 含有synchronized同步块的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>); <span class="comment">// 休眠100ms</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" synMethod loop "</span> + i);  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 非同步的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonSynMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" nonSynMethod loop "</span> + i);  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">final</span> Count count = <span class="keyword">new</span> Count();</span><br><span class="line">        <span class="comment">// 新建t1, t1会调用“count对象”的synMethod()方法</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(</span><br><span class="line">                <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        count.synMethod();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="string">"t1"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建t2, t2会调用“count对象”的nonSynMethod()方法</span></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(</span><br><span class="line">                <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        count.nonSynMethod();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="string">"t2"</span>);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        t1.start();  <span class="comment">// 启动t1</span></span><br><span class="line">        t2.start();  <span class="comment">// 启动t2</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">t1 synMethod loop 0</span><br><span class="line">t2 nonSynMethod loop 0</span><br><span class="line">t1 synMethod loop 1</span><br><span class="line">t2 nonSynMethod loop 1</span><br><span class="line">t1 synMethod loop 2</span><br><span class="line">t2 nonSynMethod loop 2</span><br><span class="line">t1 synMethod loop 3</span><br><span class="line">t2 nonSynMethod loop 3</span><br><span class="line">t1 synMethod loop 4</span><br><span class="line">t2 nonSynMethod loop 4</span><br></pre></td></tr></table></figure></p><p>结果分析：<br>主线程中新建了两个子线程t1和t2。t1会调用count对象的synMethod()方法，该方法内含有同步块；而t2则会调用count对象的nonSynMethod()方法，该方法不是同步方法。t1运行时，虽然调用synchronized(this)获取“count的同步锁”；但是并没有造成t2的阻塞，因为t2没有用到“count”同步锁。</p><h4 id="演示3"><a href="#演示3" class="headerlink" title="演示3"></a>演示3</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 含有synchronized同步块的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>); <span class="comment">// 休眠100ms</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" synMethod loop "</span> + i);  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 也包含synchronized同步块的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nonSynMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;  </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" nonSynMethod loop "</span> + i);  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">final</span> Count count = <span class="keyword">new</span> Count();</span><br><span class="line">        <span class="comment">// 新建t1, t1会调用“count对象”的synMethod()方法</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> Thread(</span><br><span class="line">                <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        count.synMethod();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="string">"t1"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 新建t2, t2会调用“count对象”的nonSynMethod()方法</span></span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(</span><br><span class="line">                <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        count.nonSynMethod();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="string">"t2"</span>);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        t1.start();  <span class="comment">// 启动t1</span></span><br><span class="line">        t2.start();  <span class="comment">// 启动t2</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">t1 synMethod loop 0</span><br><span class="line">t1 synMethod loop 1</span><br><span class="line">t1 synMethod loop 2</span><br><span class="line">t1 synMethod loop 3</span><br><span class="line">t1 synMethod loop 4</span><br><span class="line">t2 nonSynMethod loop 0</span><br><span class="line">t2 nonSynMethod loop 1</span><br><span class="line">t2 nonSynMethod loop 2</span><br><span class="line">t2 nonSynMethod loop 3</span><br><span class="line">t2 nonSynMethod loop 4</span><br></pre></td></tr></table></figure></p><p>分析：<br>主线程中新建了两个子线程t1和t2。t1和t2运行时都调用synchronized(this)，这个this是Count对象(count)，而t1和t2共用count。因此，在t1运行时，t2会被阻塞，等待t1运行释放“count对象的同步锁”，t2才能运行。</p><h4 id="一个特例：static方法的锁"><a href="#一个特例：static方法的锁" class="headerlink" title="一个特例：static方法的锁"></a>一个特例：static方法的锁</h4><p>众所周知，static方法是基于一个类使用的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SychronizedStatic</span> </span>&#123;</span><br><span class="line">    <span class="comment">//静态且上锁方法m1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"进入加锁static方法的是 "</span> + Thread.currentThread().getName());</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1_000L</span>);</span><br><span class="line">                System.out.println(<span class="string">"静态方法m1暂停一秒"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上锁方法m2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span>  <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"m2 "</span> + Thread.currentThread().getName());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">10_000L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SychronizedStaticTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"T1"</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                SychronizedStatic s1=<span class="keyword">new</span> SychronizedStatic();</span><br><span class="line">                s1.m1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"T2"</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                SychronizedStatic s2=<span class="keyword">new</span> SychronizedStatic();</span><br><span class="line">                s2.m1();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"T3"</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                SychronizedStatic s3=<span class="keyword">new</span> SychronizedStatic();</span><br><span class="line">                s3.m2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>进入加锁static方法的是 T1<br>m2 T3<br>静态方法m1暂停一秒<br>静态方法m1暂停一秒<br>静态方法m1暂停一秒<br>静态方法m1暂停一秒<br>静态方法m1暂停一秒<br>进入加锁static方法的是 T2<br>静态方法m1暂停一秒<br>静态方法m1暂停一秒<br>静态方法m1暂停一秒<br>静态方法m1暂停一秒<br>静态方法m1暂停一秒</p></blockquote><p>结果分析：<br>t1,t2和t3的比较说明，对于t1,t2来说，他们的方法锁的是“类”（SychronizedStatic.class），而t3的方法锁的是实例“s3”;因此并没有锁在一起可以同时运行；对于t1,t2，虽然调用m1时，用的是不同的实例，但是m1是static方法，且锁的是“类”,故T1调用时，t2会发生堵塞</p>]]></content>
      
      
      <categories>
          
          <category> java多线程学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程学习2（死锁，线程通信，生产者/消费者实现）</title>
      <link href="/2019/03/29/a%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%883%EF%BC%89/"/>
      <url>/2019/03/29/a%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%883%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><img src="/upload/pasted-365.png" width="70%"></p><a id="more"></a><h1 id="java中线程间的死锁"><a href="#java中线程间的死锁" class="headerlink" title="java中线程间的死锁"></a>java中线程间的死锁</h1><p>实例：<br>服务1<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service_1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Service_2 service_2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Service_1</span><span class="params">(Service_2 service_2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.service_2 = service_2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(<span class="string">"m1"</span>);</span><br><span class="line">            service_2.s1();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(<span class="string">"m2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>服务2：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service_2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Service_1 service_1;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">s1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(<span class="string">"s1=========="</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">s2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(<span class="string">"s2=========="</span>);</span><br><span class="line">            service_1.m2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setService_1</span><span class="params">(Service_1 service_1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.service_1 = service_1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>测试主函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLockTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Service_2 service_2 = <span class="keyword">new</span> Service_2();</span><br><span class="line">        Service_1 service_1 = <span class="keyword">new</span> Service_1(service_2);</span><br><span class="line">        service_2.setService_1(service_1);</span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    service_1.m1();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">                    service_2.s2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>结果：</p><p><img src="/upload/pasted-269.png" alt="upload successful"></p><p>分析：两个线程已经陷入了死锁（互相等待互相结束）</p><h1 id="线程间的通信"><a href="#线程间的通信" class="headerlink" title="线程间的通信"></a>线程间的通信</h1><h2 id="Object-的两个方法"><a href="#Object-的两个方法" class="headerlink" title="Object 的两个方法"></a>Object 的两个方法</h2><h3 id="wait"><a href="#wait" class="headerlink" title="wait()"></a>wait()</h3><blockquote><p>public final void wait()<br>throws InterruptedException<br>Causes the current thread to wait until another thread invokes the notify() method or the notifyAll() method for this object. In other words, this method behaves exactly as if it simply performs the call wait(0).</p></blockquote><blockquote><p>The current thread must own this object’s monitor. The thread releases ownership of this monitor and waits until another thread notifies threads waiting on this object’s monitor to wake up either through a call to the notify method or the notifyAll method. The thread then waits until it can re-obtain ownership of the monitor and resumes execution.</p></blockquote><p>As in the one argument version, interrupts and spurious wakeups are possible, and this method should always be used in a loop:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">synchronized (obj) &#123;</span><br><span class="line">    while (&lt;condition does not hold&gt;)</span><br><span class="line">        obj.wait();</span><br><span class="line">    ... // Perform action appropriate to condition</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>This method should only be called by a thread that is the owner of this object’s monitor. See the notify method for a description of the ways in which a thread can become the owner of a monitor.</p></blockquote><p>从上面的文档可以得知<br>当线程执行wait()时，会把当前的锁释放，然后让出CPU，进入等待状态。<br>当执行notify/notifyAll方法时，会唤醒一个处于等待该 对象锁 的线程，然后继续往下执行，直到执行完退出对象锁锁住的区域（synchronized修饰的代码块）后再释放锁。<br>如果wait()时。没有持有适当的锁，则会抛出异常<br>并且也提供了一种建议的使用方式</p><h3 id="notify-notifyAll"><a href="#notify-notifyAll" class="headerlink" title="notify/notifyAll"></a>notify/notifyAll</h3><blockquote><p>public final void notify()<br>Wakes up a single thread that is waiting on this object’s monitor. If any threads are waiting on this object, one of them is chosen to be awakened. The choice is arbitrary and occurs at the discretion of the implementation. A thread waits on an object’s monitor by calling one of the wait methods.</p></blockquote><p>The awakened thread will not be able to proceed until the current thread relinquishes the lock on this object. The awakened thread will compete in the usual manner with any other threads that might be actively competing to synchronize on this object; for example, the awakened thread enjoys no reliable privilege or disadvantage in being the next thread to lock this object.</p><blockquote></blockquote><p>This method should only be called by a thread that is the owner of this object’s monitor. A thread becomes the owner of the object’s monitor in one of three ways:</p><ul><li>By executing a synchronized instance method of that object.</li><li>By executing the body of a synchronized statement that synchronizes on the object.</li><li>For objects of type Class, by executing a synchronized static method of that class.<br>Only one thread at a time can own an object’s monitor.</li></ul><p>意思很明确：唤醒某个在当前锁下wait的线程，对于notify和notifyAll的区别就是，假设有多个线程正在当前的的锁下wait，notify只会唤醒其中任意一个线程，而notifyAll则会唤醒所有正在wait的线程<br>唤醒之后，会继续接着wait执行（这就是为什么外层要用while循环而不是if）<br>和wait一样，也需要持有锁（监视器）<br>执行完wait后，会立即</p><h2 id="生产-消费实例"><a href="#生产-消费实例" class="headerlink" title="生产/消费实例"></a>生产/消费实例</h2><p>生产者消费者是典型的线程通信的例子，只要缓冲区未充满，生产者就会一直进行生产；只要缓冲区不为空，消费者就一直消费</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProduceConsumerVersion3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对产品进行编号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//当前缓冲池产品的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number=<span class="number">0</span>;</span><br><span class="line">    <span class="comment">//监视器，同步锁</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">private</span> Object LOCK = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">//缓冲池的大小</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">private</span> <span class="keyword">int</span> fullsize=<span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            <span class="keyword">while</span> (number==fullsize) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    LOCK.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            i++;</span><br><span class="line">            System.out.println(<span class="string">"P-&gt;"</span> + i);</span><br><span class="line">            number++;</span><br><span class="line">            LOCK.notifyAll();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">            <span class="keyword">while</span> (number==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    LOCK.wait();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"C-&gt;"</span> +( i-number+<span class="number">1</span>));</span><br><span class="line">            number--;</span><br><span class="line">            LOCK.notifyAll();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ProduceConsumerVersion3 pc = <span class="keyword">new</span> ProduceConsumerVersion3();</span><br><span class="line">        Stream.of(<span class="string">"P1"</span>, <span class="string">"P2"</span>, <span class="string">"P3"</span>).forEach(n -&gt;</span><br><span class="line">                <span class="keyword">new</span> Thread(n) &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                            pc.produce();</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                Thread.sleep(<span class="number">10</span>);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;.start()</span><br><span class="line">        );</span><br><span class="line">        Stream.of(<span class="string">"C1"</span>, <span class="string">"C2"</span>, <span class="string">"C3"</span>, <span class="string">"C4"</span>).forEach(n -&gt;</span><br><span class="line">                <span class="keyword">new</span> Thread(n) &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                            pc.consume();</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;.start()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="涉及到限制当前运行线程数量的实例"><a href="#涉及到限制当前运行线程数量的实例" class="headerlink" title="涉及到限制当前运行线程数量的实例"></a>涉及到限制当前运行线程数量的实例</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaptureService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">private</span> LinkedList&lt;Control&gt; CONTROLS = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_WORKER = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        List&lt;Thread&gt; worker = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.asList(<span class="string">"M1"</span>, <span class="string">"M2"</span>, <span class="string">"M3"</span>, <span class="string">"M4"</span>, <span class="string">"M5"</span>, <span class="string">"M6"</span>, <span class="string">"M7"</span>, <span class="string">"M8"</span>, <span class="string">"M9"</span>, <span class="string">"M10"</span>).stream()</span><br><span class="line">                .map(CaptureService::createCaptureThread)</span><br><span class="line">                .forEach(t -&gt; &#123;</span><br><span class="line">                    t.start();</span><br><span class="line">                    worker.add(t);</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line">        worker.stream().forEach(t -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.join();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Optional.of(<span class="string">"All of capture work finished"</span>).ifPresent(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Thread <span class="title">createCaptureThread</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            Optional.of(<span class="string">"The worker ["</span> + Thread.currentThread().getName() + <span class="string">"] BEGIN capture data."</span>)</span><br><span class="line">                    .ifPresent(System.out::println);</span><br><span class="line">            <span class="keyword">synchronized</span> (CONTROLS) &#123;</span><br><span class="line">                <span class="keyword">while</span> (CONTROLS.size() &gt; MAX_WORKER) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        CONTROLS.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                CONTROLS.addLast(<span class="keyword">new</span> Control());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Optional.of(<span class="string">"The worker ["</span> + Thread.currentThread().getName() + <span class="string">"] is working..."</span>)</span><br><span class="line">                    .ifPresent(System.out::println);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">synchronized</span> (CONTROLS) &#123;</span><br><span class="line">                Optional.of(<span class="string">"The worker ["</span> + Thread.currentThread().getName() + <span class="string">"] END capture data."</span>)</span><br><span class="line">                        .ifPresent(System.out::println);</span><br><span class="line">                CONTROLS.removeFirst();</span><br><span class="line">                CONTROLS.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Control</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设计思路是用一个linkedlist来作为锁，在线程的run方法中，有两个地方需要进行锁操作，一个是开始时判定线程数量需要判断是否进行wait（如果不需要，一个元素加入linkedlist），另一个是当前线程结束需要让出运行（linkedlist删除元素，并唤醒等待的线程）</p><h2 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h2><ul><li><p>sleep是Thread的方法，wait是Object的方法</p></li><li><p>sleep不会放锁，wait会放锁<br>解释：在一个synchronized方法块中，调用sleep的话，一个进程进入该方法的sleep这部分，其他线程是进不来的，而在锁中调用wait的话，其他进程是可以进来的</p></li><li><p>sleep不需要依附于锁，但是wait需要<br>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      m2();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              System.out.println(<span class="string">"The Thread "</span> + Thread.currentThread().getName() + <span class="string">" enter."</span>);</span><br><span class="line">              LOCK.wait();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></li></ul><p>会抛异常：java.lang.IllegalMonitorStateException</p><ul><li>sleep不需要唤醒操作，但是wait需要</li></ul>]]></content>
      
      
      <categories>
          
          <category> java多线程学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java多线程学习1（线程概念，多线程实现）</title>
      <link href="/2019/03/27/va%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89/"/>
      <url>/2019/03/27/va%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p><img src="/upload/pasted-364.png" width="70%"></p><a id="more"></a><h1 id="线程相关概念复习（操作系统）"><a href="#线程相关概念复习（操作系统）" class="headerlink" title="线程相关概念复习（操作系统）"></a>线程相关概念复习（操作系统）</h1><h2 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h2><p>并行：两个或多个事件，在同一时刻发生<br>并发：两个或者多个事件在同一时间间隔发生<br>比如在一个单处理机系统中，每一时刻只能有一个程序运行，在一秒的时间内，0~15ms运行A,15~30ms运行B.30~45ms运行C,45~60ms运行D，就可以说ABCD是并发的</p><h2 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h2><p>为了多个程序能并发执行，以提高资源利用率和系统吞吐量，操作系统引入了进程的概念<br>进程，是指系统中能独立运行并作为资源分配的基本单位，是由一组机器指令，数据和堆栈组成，是一个能独立运行的实体</p><h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><p><img src="/upload/pasted-259.png" alt="upload successful"></p><h2 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h2><p>为了减少程序在并发执行时所付出的时空开销，使os具有更好的并发性，引入了线程的概念<br>在引入线程的os中，已经把线程作为调度和分派的基本单位，因而线程是能独立运行的基本单位；不仅进程可以并发执行，一个进程中的多个线程也可以并发执行，不同进程中的线程也能并发执行，线程并不拥有系统资源，而是仅维持一点自身必须的资源</p><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p><img src="/upload/pasted-260.png" alt="upload successful"></p><ol><li><strong>新建状态(New)</strong>         : 线程对象被创建后，就进入了新建状态。例如，Thread thread = new Thread()。</li><li><strong>就绪状态(Runnable)</strong>: 也被称为“可执行状态”。线程对象被创建后，其它线程调用了该对象的start()方法，从而来启动该线程。例如，thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。</li><li><strong>运行状态(Running)</strong> : 线程获取CPU权限进行执行。需要注意的是，线程只能从就绪状态进入到运行状态。</li><li><strong>阻塞状态(Blocked)</strong>  : 阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会转到运行状态。阻塞的情况分三种：<ul><li>等待阻塞 – 通过调用线程的wait()方法，让线程等待某工作的完成。</li><li>同步阻塞 – 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态。</li><li>其他阻塞 – 通过调用线程的sleep()或join()或发出了I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。</li></ul></li><li><strong>死亡状态(Dead)</strong>    : 线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</li></ol><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p><img src="/upload/pasted-268.png" alt="upload successful"><br>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程</p><h1 id="java线程"><a href="#java线程" class="headerlink" title="java线程"></a>java线程</h1><h2 id="简单认识java线程"><a href="#简单认识java线程" class="headerlink" title="简单认识java线程"></a>简单认识java线程</h2><p>java官方文档中，一段对于Thread api的描述</p><blockquote><p>A thread is a thread of execution in a program. The Java Virtual Machine allows an application to have multiple threads of execution running concurrently.</p><p>Every thread has a priority. Threads with higher priority are executed in preference to threads with lower priority. Each thread may or may not also be marked as a daemon. When code running in some thread creates a new Thread object, the new thread has its priority initially set equal to the priority of the creating thread, and is a daemon thread if and only if the creating thread is a daemon.</p><p>When a Java Virtual Machine starts up, there is usually a single non-daemon thread (which typically calls the method named main of some designated class). </p></blockquote><p>从上面的概念中可以知道，java支持多线程，且线程有优先级的概念，以及受保护线程和main线程的概念<br>一段简单的入门程序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TryConcurrency</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t=<span class="keyword">new</span> Thread(<span class="string">"READ-Thread"</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                println(Thread.currentThread().getName());<span class="comment">//main</span></span><br><span class="line">                readFromDataBase();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">     <span class="comment">//内部匿名类</span></span><br><span class="line">     <span class="keyword">new</span> Thread(<span class="string">"WRITE-Thread"</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                writeDataToFile();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">readFromDataBase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//read data from database and handle it.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            println(<span class="string">"Begin read data from db."</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span> * <span class="number">30L</span>);</span><br><span class="line">            println(<span class="string">"Read data done and start handle it."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"The data handle finish and successfully."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writeDataToFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            println(<span class="string">"Begin write data to file."</span>);</span><br><span class="line">            Thread.sleep(<span class="number">2000</span> * <span class="number">20L</span>);</span><br><span class="line">            println(<span class="string">"Write data done and start handle it."</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        println(<span class="string">"The data handle finish and successfully."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">println</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从这个例子中，可以学习几点</p><ul><li>java可以通过继承Thread并重写run方法来支持线程的运行</li><li>创建线程对象后，需要运行（start()）才能使线程跑起来</li></ul><h2 id="start-方法"><a href="#start-方法" class="headerlink" title="start()方法"></a>start()方法</h2><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>来自官方文档的说明</p><blockquote><p>Causes this thread to begin execution; the Java Virtual Machine calls the run method of this thread.</p><p>The result is that two threads are running concurrently: the current thread (which returns from the call to the start method) and the other thread (which executes its run method).</p><p>It is never legal to start a thread more than once. In particular, a thread may not be restarted once it has completed execution.</p></blockquote><p>从这段说明中，可以获得以下信息</p><ul><li>start()方法的作用是使当前线程开始执行，此时jvm会调用该线程下的run()方法</li><li>执行之后，会有两个线程进入并发的执行状态：调用start()方法的线程（当前线程），执行下属run()方法的线程（新线程）</li><li>一个线程要是start（）两次是会抛异常的</li></ul><p>关于当前线程和新线程的问题<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t=<span class="keyword">new</span> Thread(<span class="string">"READ-Thread"</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//获取当前线程的名字</span></span><br><span class="line">                println(Thread.currentThread().getName());</span><br><span class="line">                readFromDataBase();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        t.start();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>这个结果输出的是“READ-Thread”</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread t=<span class="keyword">new</span> Thread(<span class="string">"READ-Thread"</span>)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//获取当前线程的名字</span></span><br><span class="line">                println(Thread.currentThread().getName());</span><br><span class="line">                readFromDataBase();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//与上一个例子的不同之处</span></span><br><span class="line">        t.run();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这个输出的是main</p><p>由此可以得出结论：创建一个新线程后，<strong>只有执行start()方法，才算是执行了这个新线程</strong></p><h3 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * This method is not invoked for the main method thread or "system"</span></span><br><span class="line"><span class="comment">         * group threads created/set up by the VM. Any new functionality added</span></span><br><span class="line"><span class="comment">         * to this method in the future may have to also be added to the VM.</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * A zero status value corresponds to state "NEW".</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (threadStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Notify the group that this thread is about to be started</span></span><br><span class="line"><span class="comment">         * so that it can be added to the group's list of threads</span></span><br><span class="line"><span class="comment">         * and the group's unstarted count can be decremented. */</span></span><br><span class="line">        group.add(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            start0();</span><br><span class="line">            started = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!started) &#123;</span><br><span class="line">                    group.threadStartFailed(<span class="keyword">this</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">                <span class="comment">/* do nothing. If start0 threw a Throwable then</span></span><br><span class="line"><span class="comment">                  it will be passed up the call stack */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">start0</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * If this thread was constructed using a separate</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;Runnable&lt;/code&gt; run object, then that</span></span><br><span class="line"><span class="comment">     * &lt;code&gt;Runnable&lt;/code&gt; object's &lt;code&gt;run&lt;/code&gt; method is called;</span></span><br><span class="line"><span class="comment">     * otherwise, this method does nothing and returns.</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * Subclasses of &lt;code&gt;Thread&lt;/code&gt; should override this method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     #start()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     #stop()</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span>     #Thread(ThreadGroup, Runnable, String)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">            target.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从源码可以看出，start()方法内部首先验证当前调用的线程是否已经执行，如果已经执行，则抛出异常，然后就去执行本地方法start0()，在start0()中，会调用run()方法</p><h3 id="启发"><a href="#启发" class="headerlink" title="启发"></a>启发</h3><p>对于start()和run()方法的这种设计，我们学习到一种“模板”的思想，即start()方法实际上就是已经定好的模板，而对于我们自己使用的情况下，我们覆盖run()方法实现自己的业务逻辑</p><h2 id="java线程实现的三种方式"><a href="#java线程实现的三种方式" class="headerlink" title="java线程实现的三种方式"></a>java线程实现的三种方式</h2><p>众所周知的两种方式：<br>实现Runable 接口<br>继承Thread 类<br>以及改进前两种方式的第三种方式：实现Callable接口<br>下面模拟一个银行叫号系统进行说明</p><h3 id="继承Thread"><a href="#继承Thread" class="headerlink" title="继承Thread"></a>继承Thread</h3><p>首先写一个窗口的线程实现<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketWindow</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TicketWindow</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (index &lt;= MAX) &#123;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"柜台："</span> + name + <span class="string">"当前的号码是:"</span> + (index++));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>主函数，在主函数中，开辟三个线程进行叫号的模拟<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        TicketWindow ticketWindow1 = <span class="keyword">new</span> TicketWindow(<span class="string">"一号柜台"</span>);</span><br><span class="line">        ticketWindow1.start();</span><br><span class="line"></span><br><span class="line">        TicketWindow ticketWindow2 = <span class="keyword">new</span> TicketWindow(<span class="string">"二号柜台"</span>);</span><br><span class="line">        ticketWindow2.start();</span><br><span class="line"></span><br><span class="line">        TicketWindow ticketWindow3 = <span class="keyword">new</span> TicketWindow(<span class="string">"三号柜台"</span>);</span><br><span class="line">        ticketWindow3.start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果：</p><p><img src="/upload/pasted-261.png" alt="upload successful"></p><p><strong>一些思考</strong></p><ol><li><p>多个线程共享一个变量、<br>从这里可以看出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> index = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>关键是在static关键字上，使用static关键字定义的变量。static可以修饰变量和方法，也有static静态代码块。被static修饰的成员变量和成员方法独立于该类的任何对象。也就是说，它<strong>不依赖类特定的实例</strong>，被类的所有实例共享。只要这个类被加载，Java虚拟机就能根据类名在运行时数据区的方法区内定找到他们。因此，static对象可以在它的任何对象创建之前访问，无需引用任何对象。用public修饰的static成员变量和成员方法本质是全局变量和全局方法，当声明它的类的对象时，不生成static变量的副本，而是类的所有实例共享同一个static变量。<br>假设没有static，那么作为一个普通的成员变量，伴随着每次新的实例的产生，会在堆上分配空间，即此时这个变量是和对象实例绑定的</p></li><li><p>输出是乱序的</p></li><li><p>用static设置静态变量有一个问题，该变量会伴随着jvm的整个过程，生命周期过长</p></li></ol><h3 id="实现Runable接口"><a href="#实现Runable接口" class="headerlink" title="实现Runable接口"></a>实现Runable接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TicketWindowRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (index &lt;= MAX) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">" 的号码是:"</span> + (index++));</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BankVersion2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只需一个业务实例对象</span></span><br><span class="line">    <span class="keyword">final</span> TicketWindowRunnable ticketWindow = <span class="keyword">new</span> TicketWindowRunnable();</span><br><span class="line"></span><br><span class="line">        Thread windowThread1 = <span class="keyword">new</span> Thread(ticketWindow, <span class="string">"一号窗口"</span>);</span><br><span class="line">        Thread windowThread2 = <span class="keyword">new</span> Thread(ticketWindow, <span class="string">"二号窗口"</span>);</span><br><span class="line">        Thread windowThread3 = <span class="keyword">new</span> Thread(ticketWindow, <span class="string">"三号窗口"</span>);</span><br><span class="line">        windowThread1.start();</span><br><span class="line">        windowThread2.start();</span><br><span class="line">        windowThread3.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果</p><p><img src="/upload/pasted-262.png" alt="upload successful"></p><p>利用这种实现方式，可以将线程的逻辑执行单元从控制中抽离出来（应用了策略模式）<br>然而这里存在一个线程安全的问题</p><h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><p>Thread类和Runnable接口都不允许声明检查型异常，也不能定义返回值。没有返回值这点稍微有点麻烦。不能声明抛出检查型异常则更麻烦一些。</p><p>public void run()方法契约意味着你必须捕获并处理检查型异常。即使你小心地保存了异常信息（在捕获异常时）以便稍后检查，但也不能保证这个类（Runnable对象）的所有使用者都读取异常信息。</p><p>你也可以修改Runnable实现的getter，让它们都能抛出任务执行中的异常。但这种方法除了繁琐也不是十分安全可靠，你不能强迫使用者调用这些方法，程序员很可能会调用join()方法等待线程结束然后就不管了。</p><p>但是现在不用担心了，以上的问题终于在1.5中解决了。Callable接口和Future接口的引入以及他们对线程池的支持优雅地解决了这两个问题。<br>不管用哪种方式创建线程，其本质都是Callable接口与Runable接口。两者都是可被其它线程执行的任务！！区别是：</p><ul><li><p>Callable规定的方法是call()，而Runnable规定的方法是run()。</p></li><li><p>Callable的任务执行后可返回值，而Runnable的任务是不能返回值的。</p></li><li><p>call()方法可抛出异常，而run()方法是不能抛出异常的。</p></li><li><p>运行Callable任务可拿到一个Future对象。<br><a href="https://www.cnblogs.com/felixzh/p/6044371.html" target="_blank" rel="noopener">https://www.cnblogs.com/felixzh/p/6044371.html</a><br>线程池部分再说</p></li></ul><h2 id="Thread的构造方法"><a href="#Thread的构造方法" class="headerlink" title="Thread的构造方法"></a>Thread的构造方法</h2><h3 id="Thread构造方法及其重载方法的参数"><a href="#Thread构造方法及其重载方法的参数" class="headerlink" title="Thread构造方法及其重载方法的参数"></a>Thread构造方法及其重载方法的参数</h3><p>源码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Allocates a new &#123;<span class="doctag">@code</span> Thread&#125; object. This constructor has the same</span></span><br><span class="line"><span class="comment"> * effect as &#123;<span class="doctag">@linkplain</span> #Thread(ThreadGroup,Runnable,String) Thread&#125;</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> (null, null, gname)&#125;, where &#123;<span class="doctag">@code</span> gname&#125; is a newly generated</span></span><br><span class="line"><span class="comment"> * name. Automatically generated names are of the form</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> "Thread-"+&#125;&lt;i&gt;n&lt;/i&gt;, where &lt;i&gt;n&lt;/i&gt; is an integer.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    init(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/* For autonumbering anonymous threads. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> threadInitNumber;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">nextThreadNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> threadInitNumber++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes a Thread with the current AccessControlContext.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #init(ThreadGroup,Runnable,String,long,AccessControlContext,boolean)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">long</span> stackSize)</span> </span>&#123;</span><br><span class="line">    init(g, target, name, stackSize, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initializes a Thread.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> g the Thread group</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> target the object whose run() method gets called</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name the name of the new Thread</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> stackSize the desired stack size for the new thread, or</span></span><br><span class="line"><span class="comment"> *        zero to indicate that this parameter is to be ignored.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> acc the AccessControlContext to inherit, or</span></span><br><span class="line"><span class="comment"> *            AccessController.getContext() if null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inheritThreadLocals if &#123;<span class="doctag">@code</span> true&#125;, inherit initial values for</span></span><br><span class="line"><span class="comment"> *            inheritable thread-locals from the constructing thread</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"name cannot be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">    Thread parent = currentThread();</span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">/* Determine if it's an applet or not */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If there is a security manager, ask the security manager</span></span><br><span class="line"><span class="comment">           what to do. */</span></span><br><span class="line">        <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = security.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* If the security doesn't have a strong opinion of the matter</span></span><br><span class="line"><span class="comment">           use the parent thread group. */</span></span><br><span class="line">        <span class="keyword">if</span> (g == <span class="keyword">null</span>) &#123;</span><br><span class="line">            g = parent.getThreadGroup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* checkAccess regardless of whether or not threadgroup is</span></span><br><span class="line"><span class="comment">       explicitly passed in. */</span></span><br><span class="line">    g.checkAccess();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Do we have the required permissions?</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isCCLOverridden(getClass())) &#123;</span><br><span class="line">            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    g.addUnstarted();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.group = g;</span><br><span class="line">    <span class="keyword">this</span>.daemon = parent.isDaemon();</span><br><span class="line">    <span class="keyword">this</span>.priority = parent.getPriority();</span><br><span class="line">    <span class="keyword">if</span> (security == <span class="keyword">null</span> || isCCLOverridden(parent.getClass()))</span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.getContextClassLoader();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">this</span>.contextClassLoader = parent.contextClassLoader;</span><br><span class="line">    <span class="keyword">this</span>.inheritedAccessControlContext =</span><br><span class="line">            acc != <span class="keyword">null</span> ? acc : AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line">    setPriority(priority);</span><br><span class="line">    <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">    <span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line">    <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Set thread ID */</span></span><br><span class="line">    tid = nextThreadID();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可传递的参数：</p><ul><li>name：线程名称，若没有传递参数，关于线程对象自动生成名称，以Thread-开头，从0 开始计数（静态变量threadInitNumber）</li><li>Runable实例：可以参照上面的实现部分理解（如果在构造Thread时没有传递Runable或者没有重写run方法。该Thread将不会执行任何东西（一个Thread若没传入Runable参数，则会设置为null），如果传递了Runable实例（如上面的例子所示）或者重写了run方法，则执行对应的新逻辑单元）</li><li><p>线程组 ThreadGroup(通过看源码可以得出，若传入ThreadGroup为空，就会为新键进程附上parent的线程组，而parent指的就是“当前线程”,当前进程和新线程的理解，另外，可以通过线程组获取当前的线程运行数量）</p></li><li><p>int stacksize：即为线程开辟的 虚拟机栈（JVM概念） 的大小（构造Thread时传入的该值定义着虚拟机栈的大小，如果未指定，则默认为0，0表示会忽略该参数，由jvm自己去设定）（假设调用的是一个没有结束的递归函数，则会不断在虚拟机栈中压入栈帧，最终导致stackoverflow）</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java多线程学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm学习（类的加载机制）</title>
      <link href="/2019/03/26/m%E5%AD%A6%E4%B9%A0%EF%BC%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%89/"/>
      <url>/2019/03/26/m%E5%AD%A6%E4%B9%A0%EF%BC%88%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h1><h2 id="一般概念"><a href="#一般概念" class="headerlink" title="一般概念"></a>一般概念</h2><p>虚拟机把描述类的数据从文件加载到内存，并对数据进行解析，校验和初始化，最终形成可以被虚拟机使用的java类型，这就是虚拟机类的加载的一般过程</p><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p><img src="/upload/pasted-253.png" alt="upload successful"></p><h3 id="加载（Loading）"><a href="#加载（Loading）" class="headerlink" title="加载（Loading）"></a>加载（Loading）</h3><p>类加载阶段就是由类加载器负责根据一个类的全限定名来读取此类的二进制字节流到JVM内部，并存储在运行时内存区的方法区，然后将其转换为一个与目标类型对应的java.lang.Class对象实例,这个Class对象在日后就会作为方法区中该类的各种数据的访问入口。<br>加载的方式非常广泛，只要有满足二进制字节流，都可以执行类加载</p><p>多种加载源：</p><ul><li>文件<ul><li>class文件</li><li>jar文件</li></ul></li><li>网络传输</li><li>计算生成一个二进制流  <ul><li>$proxy</li></ul></li><li>数据库</li></ul><p><img src="/upload/pasted-254.png" alt="upload successful"></p><h3 id="连接（Linking）"><a href="#连接（Linking）" class="headerlink" title="连接（Linking）"></a>连接（Linking）</h3><p>1.验证过程<br>这一阶段的目的是确保.class文文件的字节流中包含的信息符合虚拟机规范且不会影响虚拟机的自身安全<br><img src="/upload/pasted-255.png" alt="upload successful"></p><p>2.准备过程<br>为类中的所有静态变量(static)分配内存空间，并为其设置一个初始值（默认值）（由于还没有产生对象，实例变量不在此操作范围内）<br>被final修饰的静态变量，会直接赋予原值；类字段的字段属性表中存在ConstantValue属性，则在准备阶段，其值就是ConstantValue的值</p><p>3.解析过程<br>解析过程是虚拟机将常量池内的符号引用替换为直接引用的过程</p><ul><li><p>符号引用（Symbolic References）：<br>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。例如，在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现。符号引用与虚拟机的内存布局无关，引用的目标并不一定加载到内存中。在Java中，一个java类将会编译成一个class文件。在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language（假设是这个，当然实际中是由类似于CONSTANT_Class_info的常量来表示的）来表示Language类的地址。各种虚拟机实现的内存布局可能有所不同，但是它们能接受的符号引用都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。</p></li><li><p>直接引用：<br>直接引用可以是<br>（1）直接指向目标的指针（比如，指向“类型”【Class对象】、类变量、类方法的直接引用可能是指向方法区的指针）<br>（2）相对偏移量（比如，指向实例变量、实例方法的直接引用都是偏移量）<br>（3）一个能间接定位到目标的句柄<br>直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了。</p></li><li><p>解析内容</p><ul><li>类和接口的解析</li><li>字段的解析</li><li>类方法的解析</li><li>接口方法的解析</li></ul></li></ul><h3 id="初始化（Initialzation）"><a href="#初始化（Initialzation）" class="headerlink" title="初始化（Initialzation）"></a>初始化（Initialzation）</h3><p>即执行类构造器”clinit”()方法的过程。类加载过程最后一步，前面的过程完全由虚拟机主导和控制（除了通过自定义加载器参与外），初始化阶段才真正开始执行类中定义的Java代码（或者说是字节码）</p><h4 id="类构造器”clinit”-方法"><a href="#类构造器”clinit”-方法" class="headerlink" title="类构造器”clinit”()方法"></a>类构造器”clinit”()方法</h4><ul><li>“clinit”()方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块（Static｛｝块）中的的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在静态语句块可以赋值，但是不能访问。</li></ul><p>例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span>&#123;</span><br><span class="line">     i=<span class="number">0</span>;</span><br><span class="line">     System.out.println(i); </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在这个例子中，“i=0”处不会报错，而输出语句地方会报错</p><ul><li>“clinit”()方法对于类和接口不是必需的，如果没有static修饰的方法、代码块、变量。编译器可以不为其生成”clinit”方法</li><li>无需显式的调用父类构造器，虚拟机会保证在子类”clinit”()方法执行前，父类的”clinit”方法已经执行完， 虚拟机中第一个执行”clinit”()方法的肯定是java.lang.Object，父类中定义的静态语句块先于子类的变量赋值操作<br>例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Partent</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        a=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sub</span> <span class="keyword">extends</span> <span class="title">Parent</span></span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> b=a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">        System.out.println(Sub.b);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>输出结果为2</p><ul><li>如果多个线程同时初始化一个类，只有一个线程执行这个类的“cinit”方法，其他线程需要等待其执行完毕，如果方法执行时间过长，就会造成线程堵塞</li></ul><p>例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoThread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span>  <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">"init"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        ExecutorService threadPool= Executors.newFixedThreadPool(<span class="number">20</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"start。。。。。。"</span>);</span><br><span class="line">                    Hello h=<span class="keyword">new</span> Hello();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()+<span class="string">"end。。。。。。"</span>);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>执行以后，会发现会输出“start。。。。。。”,当一个完成“init”后，才会进行初始化</p><h4 id="初始化的条件"><a href="#初始化的条件" class="headerlink" title="初始化的条件"></a>初始化的条件</h4><ul><li>在执行下列需要引用类或接口的 Java 虚拟机指令时： new， getstatic， putstatic或 invokestatic。这些指令通过字段或方法引用来直接或间接地引用其它类。执行上面所述的 new 指令，在类或接口没有被初始化过时就初始化它。执行上面的 getstatic，putstatic 或 invokestatic 指令时，那些解析好的字段或方法中的类或接口如果还没有被初始化那就初始化它。</li><li><p>在初次调用 java.lang.invoke.MethodHandle 实例时，它的执行结果为通过 Java虚拟机解析出类型是 2（REF_getStatic）、 4（REF_putStatic）或者 6（REF_invokeStatic）的方法句柄。</p></li><li><p>在调用 JDK 核心类库中的反射方法时，例如， Class 类或 java.lang.reflect 包。</p></li><li>在对于类的某个子类的初始化时。</li><li>在它被选定为 Java 虚拟机启动时的初始类时<h4 id="不初始化的几个例子"><a href="#不初始化的几个例子" class="headerlink" title="不初始化的几个例子"></a>不初始化的几个例子</h4></li><li>通过子类引用父类的静态字段</li><li>通过数组定义来引用类</li><li>调用类的常量</li></ul><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>根据一个类的全限定名来读取此类二进制字节流到jvm内部，然后转换为一个与目标类对应的java.lang.Class对象实例.<br>Java 虚拟机支持两种类加载器： Java 虚拟机提供的引导类加载器（Bootstrap Class Loader）和用户自定义类加载器（User-Defined Class Loader）。每个用户自定义的类加载器应该是抽象类 ClassLoader 的某个子类的实例。应用程序使用用户自定义类加载器是为了便于扩展 Java 虚拟机的功能，支持动态加载并创建类。当然，它也可以从用户自定义的数据来源来获取类的二进制表示并创建类。例如，用户自定义类加载器可以通过网络下载、动态产生或是从一个加密文件中提取类的信息</p><ul><li><p><strong>启动类加载器</strong>（Bootstrap ClassLoader）：由C++语言实现（针对HotSpot）,负责将存放在&lt;JAVA_HOME&gt;\lib目录或-Xbootclasspath参数指定的路径中的类库加载到内存中。</p></li><li><p>其他类加载器：由Java语言实现，继承自抽象类ClassLoader。<br>如：<br><strong>扩展类加载器</strong>（Extension ClassLoader）：负责加载&lt;JAVA_HOME&gt;\lib\ext目录或java.ext.dirs系统变量指定的路径中的所有类库。<br><strong>应用程序类加载器</strong>（Application ClassLoader）。负责加载用户类路径（classpath）上的指定类库，我们可以直接使用这个类加载器。一般情况，如果我们没有自定义类加载器默认就是用这个加载器。</p></li></ul><p><img src="/upload/pasted-322.png" alt="upload successful"></p><p>一个自定义类的加载器的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span>  <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        ClassLoader mycl=<span class="keyword">new</span> ClassLoader() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                <span class="comment">//获取类的简单名称</span></span><br><span class="line">                String className=name.substring(name.lastIndexOf(<span class="string">"."</span>)+<span class="number">1</span>)+<span class="string">".class"</span>;</span><br><span class="line">                <span class="comment">//获取类的流</span></span><br><span class="line">                InputStream ins=getClass().getResourceAsStream(className);</span><br><span class="line">                <span class="keyword">if</span>(ins==<span class="keyword">null</span>)&#123;<span class="comment">//如果当前包下没有，则由父类进行加载</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">byte</span>[] buff=<span class="keyword">new</span> <span class="keyword">byte</span>[ins.available()];</span><br><span class="line">                    ins.read();</span><br><span class="line">                    <span class="comment">//实例化与当前类对应的class对象</span></span><br><span class="line">                    <span class="keyword">return</span> defineClass(name,buff,<span class="number">0</span>,buff.length);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                   <span class="keyword">throw</span>  <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p><img src="/upload/pasted-257.png" alt="upload successful"></p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。</p><p>双亲委派模型的工作过程是：</p><ul><li><p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成。</p></li><li><p>每一个层次的类加载器都是如此。因此，所有的加载请求最终都应该传送到顶层的启动类加载器中。</p></li><li><p>只有当父加载器反馈自己无法完成这个加载请求时（搜索范围中没有找到所需的类），子加载器才会尝试自己去加载。</p></li></ul><h4 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h4><p>在JVM中，判断一个对象是否是某个类型时，如果该对象的实际类型与待比较的类型的类加载器不同，那么会返回false。<br>比如<br>  ClassLoader1、ClassLoader2都加载java.lang.String类，对应Class1、Class2对象。那么Class1对象不属于ClassLoad2对象加载的java.lang.String类型。</p><p><strong>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在虚拟机中的唯一性</strong>，每一个类加载器，都拥有一个独立的类名称空间。因此，使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处：类随着它的类加载器一起具备了一种带有优先级的层次关系。</p><p>例如类java.lang.Object，它由启动类加载器加载。双亲委派模型保证任何类加载器收到的对java.lang.Object的加载请求，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。</p><p>相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并用自定义的类加载器加载，那系统中将会出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将会变得一片混乱。</p><h4 id="自定义类加载器的完整-实现"><a href="#自定义类加载器的完整-实现" class="headerlink" title="自定义类加载器的完整 实现"></a>自定义类加载器的完整 实现</h4><p>关于自定义类加载器的几个函数</p><p>1.loadClass()<br>默认实现:<br>根据全限定名创建该类的class对象<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>loadClass(String name, boolean resolve)<br>基本过程</p><ul><li>1.首先，检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载，直接返回。</li><li><p>2.如果此类没有加载过，那么，再判断一下是否有父加载器；如果有父加载器，则由父加载器加载（即调用parent.loadClass(name, false);）.或者是调用bootstrap类加载器来加载。</p></li><li><p>3.如果父加载器及bootstrap类加载器都没有找到指定的类，那么调用当前类加载器的findClass方法来完成类加载。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>2 findClass()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，抽象类ClassLoader的findClass函数默认是抛出异常的。而前面我们知道，loadClass在父加载器无法加载类的时候，就会调用我们自定义的类加载器中的findeClass函数，因此我们必须要在loadClass这个函数里面实现将一个指定类名称转换为Class对象.</p><p>如果是是读取一个指定的名称的类为字节数组的话，这很好办。但是如何将字节数组转为Class对象呢？很简单，Java提供了defineClass方法，通过这个方法，就可以把一个字节数组转为Class对象</p><p>3 defineClass()<br>将一个字节数组转为Class对象，这个字节数组是class文件读取后最终的字节数组。如，假设class文件是加密过的，则需要解密后作为形参传入defineClass函数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Class&lt;?&gt; defineClass(String name, <span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span><br><span class="line">        <span class="keyword">throws</span> ClassFormatError  &#123;</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, b, off, len, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>完整函数调用过程</p><p><img src="/upload/pasted-258.png" alt="upload successful"></p>]]></content>
      
      
      <categories>
          
          <category> jvm学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm类的加载机制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm学习笔记（字节码文件）</title>
      <link href="/2019/03/24/jvm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%EF%BC%89/"/>
      <url>/2019/03/24/jvm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="字节码文件（ByteCode）"><a href="#字节码文件（ByteCode）" class="headerlink" title="字节码文件（ByteCode）"></a>字节码文件（ByteCode）</h1><h2 id="基本理解"><a href="#基本理解" class="headerlink" title="基本理解"></a>基本理解</h2><p>字节码文件（.class）实际上就是java源码文件（.java）经过编译而形成的 ，可以被虚拟机所理解的文件。字节码文件结构比较特殊，内部不包含任何的分段符，字节顺序和数量都是严格规定的，所有16位，32位，64位长度的数据都将构成2个，4个，8个8字节单位来表示，多字节数据项按照big-endian顺序（高位字节的地址在低位，低位字节的地址在最高位）</p><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p><img src="/upload/pasted-243.png" alt="upload successful"><br>在该结构体中，只有两种数据结构，分别是无符号数和表，其中无符号数属于字节码的基本类型，u1,u2分别表说一个字节和两个字节无符号类型，表是由多个无符号是或者其他表作为数据项的复合数据结构，所有表都是用“_info”进行结尾</p><h3 id="magic"><a href="#magic" class="headerlink" title="magic"></a>magic</h3><p>用来标识文件为一个字节码文件，是固定的，为“0xCAFEBABE”，并不是采用文件后缀名标识字节码文件，因为文件后缀可以手动修改</p><h3 id="minor-version-和-major-version"><a href="#minor-version-和-major-version" class="headerlink" title="minor_version 和 major_version"></a>minor_version 和 major_version</h3><p>紧接着魔数的四个字节是class文件的此版本号和主版本号。一般来说，高版本可以向下兼容低版本，而当低版本jvm处理高版本的字节码文件时，就会抛出“java.lang.UnsupportedClassVersionError”异常</p><h3 id="constant-pool-count-常量池计数器-和constant-pool-常量池"><a href="#constant-pool-count-常量池计数器-和constant-pool-常量池" class="headerlink" title="constant_pool_count(常量池计数器)和constant_pool(常量池)"></a>constant_pool_count(常量池计数器)和constant_pool(常量池)</h3><p>常量池是字节码文件中非常重要的，也是字节码文件中与其他项关联的最多和占用字节码空间最大的数据项，常量池中主要存放字面量（Literal），包含文字字符串，final常量值，和符号引用（Symbolic）包含类和接口的全限定名（Full Qualified Name）,字段的名称和描述符（Descriptor）以及方法的名称和描述符，访问是通过索引进行访问<br>常量池计数器是记录常量池中到底有多少数据常量，从1开始计数，但是0也是使用的，为了满足后续其他项在不引用常量池中的任何常量项时，默认可以把常量池中的访问索引设为0</p><p><img src="/upload/pasted-244.png" alt="upload successful"></p><p><img src="/upload/pasted-245.png" alt="upload successful"></p><p><img src="/upload/pasted-246.png" alt="upload successful"><br>可以通过命令<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -verbose xxx.class</span><br></pre></td></tr></table></figure></p><p>查看常量池中的信息</p><h3 id="access-flags-访问标志"><a href="#access-flags-访问标志" class="headerlink" title="access_flags(访问标志)"></a>access_flags(访问标志)</h3><p><img src="/upload/pasted-247.png" alt="upload successful"><br>这一位一般是表中一个或者几个的组合</p><h3 id="this-class-类索引-和super-class-超类索引"><a href="#this-class-类索引-和super-class-超类索引" class="headerlink" title="this_class(类索引)和super_class(超类索引)"></a>this_class(类索引)和super_class(超类索引)</h3><p> 分别保存了类和超类的全限定名</p><p><img src="/upload/pasted-248.png" alt="upload successful"><br>如果一个类并没有显式的继承其他类，则它的直接超类就是Object，此时父类的索引值就是0，这时就没有引用常量池中的常量</p><h3 id="interfaces-count-接口计数器-和interfaces（接口表）"><a href="#interfaces-count-接口计数器-和interfaces（接口表）" class="headerlink" title="interfaces_count(接口计数器)和interfaces（接口表）"></a>interfaces_count(接口计数器)和interfaces（接口表）</h3><p>interfaces_count 指的是当前类实现的接口数目<br>interfaces[] 是包含interfaces_count个接口的全局限定名的索引的数组</p><h3 id="fields-count（字段计数器）-和fields（字段表）"><a href="#fields-count（字段计数器）-和fields（字段表）" class="headerlink" title="fields_count（字段计数器） 和fields（字段表）"></a>fields_count（字段计数器） 和fields（字段表）</h3><p>字段表计数器用来表示一个字节码文件中field_info的个数，是一个类中类变量和实例变量的总和，字段表是一个数组集合，字段表中的每一个成员必须是field_info数据项，用来表示一个字段的完整信息，包括字段的标识符，访问修饰符（public private protected），类变量还是实例变量（static），是否为常量（final），字段表中，只含有当前类的字段，并不含有超类的字段<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">field_info &#123;</span><br><span class="line">   u2 access_flags;</span><br><span class="line">   u2 name_index;</span><br><span class="line">   u2 descriptor_index;</span><br><span class="line">   u2 attributes_count;</span><br><span class="line">   attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="methods-count-方法计数器-和methods-方法表"><a href="#methods-count-方法计数器-和methods-方法表" class="headerlink" title="methods_count(方法计数器)和methods(方法表)"></a>methods_count(方法计数器)和methods(方法表)</h3><p>methods_count是该类或者接口显示定义的方法的数量。<br>method[]是包含方法信息的一个详细列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">method_info &#123;</span><br><span class="line">   u2 access_flags;</span><br><span class="line">   u2 name_index;</span><br><span class="line">   u2 descriptor_index;</span><br><span class="line">   u2 attributes_count;</span><br><span class="line">   attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="attrubutes-count和attributes"><a href="#attrubutes-count和attributes" class="headerlink" title="attrubutes_count和attributes"></a>attrubutes_count和attributes</h3><p>class文件的最后一部分是属性，它描述了该类或者接口所定义的一些属性信息。attributes_count指的是attributes列表中包含的attribute_info的数量。<br>属性可以出现在class文件的很多地方，而不只是出现在attributes列表里。如果是attributes表里的属性，那么它就是对整个class文件所对应的类或者接口的描述；如果出现在fileds的某一项里，那么它就是对该字段额外信息的描述；如果出现在methods的某一项里，那么它就是对该方法额外信息的描述。</p><p><img src="/upload/pasted-251.png" alt="upload successful"><br>必须要被虚拟机所识别的三个属性<br>Code：<br>Code 属性是一个变长属性，位于 method_info结构的属性表。一个 Code 属性<br>只为唯一一个方法、实例类初始化方法或类初始化方法保存 Java 虚拟机指令及相关辅<br>助信息。 所有 Java 虚拟机实现都必须能够识别 Code 属性。如果方法被声明为 native 或者<br>abstract 类型，那么对应的 method_info 结构不能有明确的 Code 属性，其它情况下，<br>method_info 有必须有明确的 Code 属性。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Code_attribute &#123;</span><br><span class="line">   u2 attribute_name_index;//必须是对常量池的有效索引， 常量池在该索引处的项</span><br><span class="line">必须是 CONSTANT_Utf8_info结构，表示字符串“Code”。</span><br><span class="line">   u4 attribute_length;//表示当前属性的长度，不包括开始的 6 个字节</span><br><span class="line">   u2 max_stack;//给出了当前方法的操作数栈在运行执行的任何时间点的最大深度</span><br><span class="line">   u2 max_locals;//给出了分配在当前方法引用的局部变量表中的局部变量个数，包括</span><br><span class="line">调用此方法时用于传递参数的局部变量</span><br><span class="line">   u4 code_length;//给出了当前方法的 code[]数组的字节数①， code_length 的值必须</span><br><span class="line">大于 0，即 code[]数组不能为空。</span><br><span class="line">   u1 code[code_length]; //code[]数组给出了实现当前方法的 Java 虚拟机字节码。</span><br><span class="line">code[]数组以按字节寻址的方式读入机器内存，如果 code[]数组的第一个字节是按以</span><br><span class="line">4 字节边界对齐的话，那么 tableswitch 和 lookupswitch 指令中所有涉及到的 32</span><br><span class="line">位偏移量也都是按 4 字节长度对齐的（关于 code[]数组边界对齐对字节码的影响， 请参</span><br><span class="line">考相关的指令描述）。</span><br><span class="line">   u2 exception_table_length;//给出了 exception_table[]数组的成员个数量。</span><br><span class="line">  &#123;    u2 start_pc;</span><br><span class="line">       u2 end_pc;</span><br><span class="line">       u2 handler_pc;</span><br><span class="line">       u2 catch_type;</span><br><span class="line">  &#125; exception_table[exception_table_length];//数组的每个成员表示 code[]数组中的一个异常处理器</span><br><span class="line">（Exception Handler）。 exception_table[]数组中， 异常处理器顺序是有意义的</span><br><span class="line">  u2 attributes_count;</span><br><span class="line">  attribute_info attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ConstantValue<br>Execptions</p>]]></content>
      
      
      <categories>
          
          <category> jvm学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm内存相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm学习笔记（垃圾回收）</title>
      <link href="/2019/03/21/m%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%89/"/>
      <url>/2019/03/21/m%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="GC的评估"><a href="#GC的评估" class="headerlink" title="GC的评估"></a>GC的评估</h2><ul><li>吞吐量：程序的运行时间/（程序的运行时间+内存的回收时间）</li><li>垃圾回收开销：吞吐量的补数，垃圾收集时间和总时间的比例</li><li>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间</li><li>收集频率：相对于应用程序的执行，收集操作的发生频率</li><li>堆空间：java堆区所占的内存大小</li><li>快速：一个对象从诞生到被回收所经历的时间</li></ul><h2 id="如何判定垃圾对象"><a href="#如何判定垃圾对象" class="headerlink" title="如何判定垃圾对象"></a>如何判定垃圾对象</h2><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>在对象中添加一个引用计数器，当有地方引用这个对象时，引用计数器的数值+1，引用失效时，计数器的值-1<br>虽然效率很高，但是存在较大弊端，如果有两个潜在垃圾相互引用，那么他们的计数器不为1，不会被标记为垃圾 </p><h3 id="可达分析法（根搜索法）"><a href="#可达分析法（根搜索法）" class="headerlink" title="可达分析法（根搜索法）"></a>可达分析法（根搜索法）</h3><p><img src="/upload/pasted-215.png" alt="upload successful"><br>以根对象集合为起始点，按照从上到下的方式搜索被根对象集合所连接的目标对象是否可达（根搜索后，内存中存活的对象都会和根对象集合直接或者间接的连接着），若不可达，则意味着目标对象已经死亡，会被标记为垃圾对象<br>跟对象集合中包括：</p><ul><li>Java栈中对象的引用</li><li>本地方法栈中的对象引用</li><li>运行常量池中的对象引用</li><li>方法区中类静态属性的对象引用</li><li>与一个类对象的唯一数据类型的Class对象</li></ul><h2 id="回收方式"><a href="#回收方式" class="headerlink" title="回收方式"></a>回收方式</h2><h3 id="回收策略"><a href="#回收策略" class="headerlink" title="回收策略"></a>回收策略</h3><h4 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h4><p>是基础的垃圾收集算法，过程正如名字所说的两个过程，但是其效率低下，而且会产生不连续的内存块</p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><h5 id="堆的具体分区"><a href="#堆的具体分区" class="headerlink" title="堆的具体分区"></a>堆的具体分区</h5><p><img src="/upload/pasted-218.png" alt="upload successful"></p><h5 id="复制算法过程"><a href="#复制算法过程" class="headerlink" title="复制算法过程"></a>复制算法过程</h5><p>当执行一次Minor GC（新生代的垃圾回收），Eden中存活的对象会被复制到To空间，并且之前已经经历过一次Minor GC并在Form空间中存活下来的对象如果还存活的话会被复制到To空间中<br><img src="/upload/pasted-216.png" alt="upload successful"><br>Minor GC执行完毕后Eden空间和From空间会被清空，存活下来的对象已经全部复制到了To中,接下来From空间和To空间会交换位置，复制算法的本质就是保证From和To有一块空间是空的<br><img src="/upload/pasted-217.png" alt="upload successful"><br>Minor GC却不适用于老年代的垃圾回收，因为老年代的对象生命周期都很长</p><h4 id="标记整理算法（标记-压缩算存法）"><a href="#标记整理算法（标记-压缩算存法）" class="headerlink" title="标记整理算法（标记-压缩算存法）"></a>标记整理算法（标记-压缩算存法）</h4><p>当成功标记出内存的垃圾对象后，该算法会将所有活对象移动到一个规整且连续的空间中去，然后执行Full GC（老年代回收算法，Major GC）回收无用对象所占的内存，当成功执行压缩后，已用的内存和未用的内存会各占一边，彼此维护着一个标记指针，当新对象分配空间时，则可以通过指针碰撞方式（Bump the Pointer）</p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>根据分代的概念，依照每个代的特点，选择合适的收集算法，比如为新生代选择算法就要以速度为先，因为新生代中所存储的瞬时对象生命周期都非常短，且内存空间较小，则使用复制算法；而老年代中对象的生命周期都较长，而且老年代所占的堆内存也较大，因此老年代中的垃圾回收并不频繁，但是执行消费的时间却很长，所以选择标记压缩算法<br>新生代GC(Minor GC) 指发生在新生代的垃圾收集动作，因为java对象大多具备朝生夕灭的特性，所以MinorGC非常频繁<br>老年代GC(Full GC，Major GC) 指发生在老年代的GC，FullGC一般比MinorGC慢上十倍</p><h3 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h3><p><img src="/upload/pasted-219.png" alt="upload successful"></p><h4 id="串行回收与并行回收"><a href="#串行回收与并行回收" class="headerlink" title="串行回收与并行回收"></a>串行回收与并行回收</h4><p>串行回收是，当多个CPU可以执行垃圾回收操作时，也只能有一个CPU执行垃圾回收操作，在执行垃圾回收时，工作线程需要全部暂停，垃圾收集完成后才可继续<br>并行回收是指多个cpu可以同时进行垃圾回收，提升了程序的吞吐量<br><img src="/upload/pasted-220.png" alt="upload successful"></p><h4 id="并发和“Stop-the-World”"><a href="#并发和“Stop-the-World”" class="headerlink" title="并发和“Stop the World”"></a>并发和“Stop the World”</h4><p>“Stop the World”指的是垃圾回收进行时，会暂停所有进行中的线程<br>并发回收只不过是减少了“Stop the World”的时间</p><h4 id="Serial"><a href="#Serial" class="headerlink" title="Serial"></a>Serial</h4><ul><li>最基本的垃圾收集器</li><li>作用在新生代中，采用复制算法，串行回收（单线程）和“Stop the World”机制进行回收</li><li>在老年代提供Serial Old收集器，采用标记压缩算法，串行回收（单线程）和“Stop the World”机制进行回收</li><li>适合单个CPU的宿主环境</li></ul><h4 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h4><ul><li>适合在并行的条件的垃圾收集器</li><li>算法和机制与Serial相同</li><li>适合多个cpu的环境</li></ul><h4 id="Parallel"><a href="#Parallel" class="headerlink" title="Parallel"></a>Parallel</h4><ul><li>采用复制算法，并行回收和“stop the world”机制</li><li>可以控制程序的吞吐量（-XX GCTimeRatio）,提高吞吐量，可以降低内存回收的执行频率，但是会增加每次执行的时间</li><li>老年代采用Parallel old收集器，采用标记压缩，并行收集</li><li>Parallel 和Parallel Old适合Server下的内存回收</li></ul><h4 id="CMS（Concurrent-Mark-Sweep）"><a href="#CMS（Concurrent-Mark-Sweep）" class="headerlink" title="CMS（Concurrent-Mark-Sweep）"></a>CMS（Concurrent-Mark-Sweep）</h4><p>特点</p><ul><li>+为并发而生</li><li>+低延迟（每次执行时间较短）</li><li>-占用cpu内存较大</li><li>-会出现浮动垃圾</li><li>-产生内存碎片</li></ul><p><img src="/upload/pasted-226.png" alt="upload successful"><br>过程：</p><ul><li>初始标记（Initial-Mark）：程序中所有工作进程会暂停，并根据根搜素法标记对不可达对象进行标记，标记完毕后恢复暂停进程</li><li>并发标记（Concurrent-Marking）：将之前不可达对象标记为垃圾对象</li><li>再次标记（Remark）：并发标记并不能保证所有垃圾对象都已经被标记，因此该过程将进入“stop the world”再次进行标记</li><li>并发清除（Concurrent-Sweep）：清除标记垃圾对象</li></ul><h4 id="G1（Garbage-First）"><a href="#G1（Garbage-First）" class="headerlink" title="G1（Garbage First）"></a>G1（Garbage First）</h4><p>特点：</p><ul><li><p>并行于并发：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。</p></li><li><p>分代收集：分代概念在G1中依然得以保留。虽然G1可以不需要其它收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。也就是说G1可以自己管理新生代和老年代了。</p></li><li><p>空间整合：由于G1使用了独立区域（Region）概念，将java堆区划分为2048块大小相同的独立Region块,这样 可以更好的提升GC的回收效率和缩短线程暂停时间以换取更大的程序吞吐量，因而能更好的控制暂停时间G1从整体来看是基于“标记-整理”算法实现收集，从局部（两个Region）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片。</p></li><li><p>可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用这明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。</p></li></ul><p><img src="/upload/pasted-227.png" alt="upload successful"></p><ul><li>为了避免全堆扫描，G1使用了Remembered Set来管理相关的对象引用信息。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆扫描也不会有遗漏了。</li></ul><p>过程：</p><p><img src="/upload/pasted-228.png" alt="upload successful"></p><ul><li><p>初始标记（Initial Making）：标记一下GC Roots能直接关联到的对象，并且修改TAMS（Next Top Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可以用的Region中创建新对象，这个阶段需要停顿线程，但耗时很短</p></li><li><p>并发标记（Concurrent Marking）：并发标记阶段是从GC Roots开始对堆中对象进行可达性分析，找出存活对象，这一阶段耗时较长但能与用户线程并发运行。而最终标记阶段需要吧Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但可并行执行</p></li><li><p>最终标记（Final Marking）：最后筛选回收阶段首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，这一过程同样是需要停顿线程</p></li><li><p>筛选回收（Live Data Counting and Evacuation）</p></li></ul><p>GC模式</p><ul><li>youngGC:发生在年轻代的GC算法，一般对象（除了巨型对象）都是在eden region中分配内存，当所有eden region被耗尽无法申请内存时，就会触发一次young gc，这种触发机制和之前的young gc差不多，执行完一次young gc，活跃对象会被拷贝到survivor region或者晋升到old region中，空闲的region会被放入空闲列表中，等待下次被使用。</li><li>mixGC:就是上面的标准过程</li><li>FullGC:如果对象内存分配速度过快，mixed gc来不及回收，导致老年代被填满，就会触发一次full gc，G1的full gc算法就是单线程执行的serial old gc，会导致异常长时间的暂停时间，需要进行不断的调优，尽可能的避免full gc.</li></ul><h1 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h1><ul><li>新对象优先在Eden区分配 ：新对象都会在Eden区进行分配，若Eden区已满，则会执行Minor GC</li><li>大对象直接进入老年代：大对象指的是需要占用大量内存的java对象，典型的是大字符串，可以通过“-XX:PretenureSizeTHreshold”设置保存在老年区的大小，应当尽量避免大对象的出现</li><li>长期存活的对象会进入老年代：虚拟机实际上为每个对象设置了一个Age计数器，如果对象在Eden出生且经过第一次垃圾回收仍存活的话，并且能被Survivor容纳的话，就会进入Survivor，将对象年龄设为1，对象在Survivor存活过一次垃圾回收，年龄就+1，年龄增加到一定程度时，就会进入老年区,可以通过“-XX:MaxTeburingThreshold”设置老年区年龄</li><li>动态对象的年龄判定：如果在Survivor中相同年龄对象大小总和大于survivor空间的一半，年龄大于或者等于该年龄的对象直接进入老年代</li><li>空间分配担保：当新生代的大部分对象都存活时，就需要老年代进行担保，把survivor无法容纳的对象直接分入老年代</li><li>逃逸分析和栈上分配：逃逸分析（Escape Analysis）是jvm在执行性能优化之前的一种分析技术，它的具体目标是分析出对象的作用域，当一个对象被定义在方法体内部之后，它的受访权限仅限于方法体内，一旦被外部成员引用后，这个对象就发生了逃逸，反之，如果方法体内的对象并没有被外部成员引用，jvm就会为其在栈帧中分配空间</li></ul>]]></content>
      
      
      <categories>
          
          <category> jvm学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 垃圾回收 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm学习笔记（内存）</title>
      <link href="/2019/03/20/vm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%86%85%E5%AD%98%EF%BC%89/"/>
      <url>/2019/03/20/vm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%86%85%E5%AD%98%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="JVM的内存管理"><a href="#JVM的内存管理" class="headerlink" title="JVM的内存管理"></a>JVM的内存管理</h1><h2 id="基本五大区"><a href="#基本五大区" class="headerlink" title="基本五大区"></a>基本五大区</h2><p><img src="/upload/pasted-209.png" alt="upload successful"></p><h3 id="线程共享区和线程独占区"><a href="#线程共享区和线程独占区" class="headerlink" title="线程共享区和线程独占区"></a>线程共享区和线程独占区</h3><p>线程，是操作系统中能够进行调度的最小单位，线程共享区是指所有线程共同使用的区域，线程独占区是指每个线程单独创建和使用的内存区域</p><h3 id="程序计数器（Program-Counter-Register）"><a href="#程序计数器（Program-Counter-Register）" class="headerlink" title="程序计数器（Program Counter Register）"></a>程序计数器（Program Counter Register）</h3><p>是内存中一块较小空间，可以理解为是记录当前线程所执行的字节码的<strong>行号</strong>指示器，如果线程执行的是一个java方法，计数器记录的是正在执行的虚拟机指令码的<strong>地址</strong>； 如果是Native方法，计数器为空（undefined），程序计数器是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域</p><h3 id="Java虚拟机栈（Java-Virtual-Machine-Stacks）"><a href="#Java虚拟机栈（Java-Virtual-Machine-Stacks）" class="headerlink" title="Java虚拟机栈（Java Virtual Machine Stacks）"></a>Java虚拟机栈（Java Virtual Machine Stacks）</h3><p>虚拟机栈描述的是java方法执行的内存模型<br>栈帧（Stack Frame）：每个方法在执行完成时，都会创建一个栈帧，伴随着方法从创建到执行的完成，用于储存局部变量表【存放编译器可知道的各种基本类型，引用类型，returnAddress（一条字节码指令的地址）类型，在编译器完成分配，在方法运行期间大小不会改变】，操作数栈，动态链接，方法出口等<br>【结合栈的先进先出特性理解】<br>异常状况：线程请求的栈的深度大于虚拟机所允许的最大深度，则发生StackOverflowError【一个没有结束的递归函数】】如果虚拟机栈可以动态扩展，而扩展到无法申请到足够内存时，抛出OutOfMemoryError</p><h3 id="本地方法栈（Native-Method-Stack）"><a href="#本地方法栈（Native-Method-Stack）" class="headerlink" title="本地方法栈（Native Method Stack）"></a>本地方法栈（Native Method Stack）</h3><p>和虚拟机栈类似，区别是虚拟机栈为虚拟机执行java方法而服务，本地方法栈则为使用到的Native方法服务，在hot spot 中，两者是一体的</p><h3 id="java堆（Java-Heap）"><a href="#java堆（Java-Heap）" class="headerlink" title="java堆（Java Heap）"></a>java堆（Java Heap）</h3><p>用来存储对象的<strong>实例</strong>，是java虚拟机所管理的最大的内存区域</p><ul><li>大部分对象实例在此分配内存</li><li>垃圾收集器管理的主要区域</li><li>内存不够时，会抛出OutOfMemoryError异常</li><li>可以通过-Xmx和-XMS控制动态控制<h3 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h3>用以储存已被虚拟机加载的<strong>类信息【版本，字段，方法，接口】，常量，静态变量</strong>，即时编译器编译后的代码等数据<br>称作“永久代”（Permanent Generation）:在hot spot中GC分代收集扩展到了方法区，或者说使用了永久代而已，两者并不等价<br>会抛出OutOfMemoryError</li></ul><h2 id="重点区域"><a href="#重点区域" class="headerlink" title="重点区域"></a>重点区域</h2><h3 id="运行时常量池（Runtime-Constant-Pool）"><a href="#运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="运行时常量池（Runtime Constant Pool）"></a>运行时常量池（Runtime Constant Pool）</h3><p>位于方法区，用来存放编译期生成的各种字面量和符号引用<br>比如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s1=&quot;abc&quot;;</span><br><span class="line">String s2=&quot;abc&quot;;</span><br><span class="line">System.out.println(s1==s2)</span><br></pre></td></tr></table></figure></p><p>要按照上面的说法，虚拟机在创建s1时，会先将在虚拟机栈中的局部变量表中创建引用s1，然后再在堆中创建实例“abc”，同理s2也是，这样来看，判定s1==s2的话，由于string是引用类型，因此会比较两个的地址，则创建的两个实例虽然内容相同，但是地址是不同的，所以应当是false，但是实际操作中，却是true。答案就在于“abc”属于可以在编译器直接翻译出的字面量，会存在运行常量池中，而在运行常量池中，实际上维持的是一个Stingtable（对于string来说），而其底层是HashSet(无序性，不重复性的集合)，因此，两个引用实际上指向的是同一个“abc”，故地址相同，判定为true<br>而对于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s3=new String(&quot;abc&quot;)；</span><br><span class="line">System.out.println(s1==s3)</span><br></pre></td></tr></table></figure></p><p>其结果为false<br>关键在于关键字“new”,通过这种方式，就需要按照上面说的那样，引用在栈，实例在堆，因此地址是不相等<br>但是如果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(s1==s3.intern())</span><br></pre></td></tr></table></figure></p><p>结果为true，这是因为运行时常量池的另一个特性：动态性，它可以在运行期把常量放入常量池中，而intern()主要做的事情就是对于一个string，它会查看在栈（局部常量表）中查找是否有值相等的值，若没有，则创建并返回其在栈中的地址，若有则直接返回栈中地址</p><h3 id="直接内存（Direct-Memory）"><a href="#直接内存（Direct-Memory）" class="headerlink" title="直接内存（Direct Memory）"></a>直接内存（Direct Memory）</h3><p>实际上它不属于虚拟机运行时数据的一部分，也不是java虚拟机规范中定义的内存区域，但是还是用的到，既然是内存，会受到本机总内存影响，也会抛出OutOfMemoryError</p><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p><img src="/upload/pasted-211.png" alt="upload successful"></p><h3 id="分配内存过程"><a href="#分配内存过程" class="headerlink" title="分配内存过程"></a>分配内存过程</h3><p>对象所需的内存大小在类加载完成后就已经完全确定<br>指针碰撞（Bump the Pointer）： 如果在堆中内存时绝对齐整的，所用的内存在一边，空闲的内存在另一边，中间有一个指针作为分界，分配内存实际上就是指针向空闲内存区域移动与对象大小相等的一个空间<br>空闲列表（Free List）：在堆内存中，更多时候是不规整的，虚拟机可以维护一个列表进行记录，记录那些内存块是可用的，分配内存时，从；列表中找出一块可用区域即可<br>采取何种方式取决于堆内存是否规整，而堆内存是否规整又取决于垃圾收集器是否有压缩整理功能</p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>在分配时，由于多线，可能会引发线程安全问题<br>解决方法：</p><ul><li>线程同步，但是效率太低</li><li>本地线程分配缓冲（Thread Local Allocation Buffer）,即每个线程在java堆中预先分配一小块内存，若预分配的TALB满了，则采用同步策略</li></ul><h3 id="初始化对象"><a href="#初始化对象" class="headerlink" title="初始化对象"></a>初始化对象</h3><h3 id="对象的结构"><a href="#对象的结构" class="headerlink" title="对象的结构"></a>对象的结构</h3><p><img src="/upload/pasted-212.png" alt="upload successful"></p><ul><li>对象头（Header）<ul><li>自身运行时的数据（Mark Word）<ul><li>哈希值</li><li>GC分代年龄</li><li>锁状态标志</li><li>线程持有锁</li><li>偏向线程ID</li><li>偏向时间戳</li></ul></li><li>类型指针</li></ul></li><li>instance data:对象的有效信息</li><li>padding：填充作用,因为要求对象的内存大小要是8的整数倍</li></ul><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>这个过程指的是从reference到堆上实例的过程<br>句柄访问：<br>在java堆中划分出一块内存来作为句柄池，reference储存的对象就是句柄地址，而句柄中包含了对象实例数据和类型数据的地址<br>这种方法的好处是reference储存的是稳定的句柄地址，对象发生移动时，只会改变句柄中实例数据指针，不会改变reference<br><img src="/upload/pasted-213.png" alt="upload successful"></p><p>直接指针访问：<br>reference储存的直接是对象的地址<br>这种方法的好处是速度较快，因为节省了一次指针定位，hotspot中采用的是这种方式<br><img src="/upload/pasted-214.png" alt="upload successful"></p>]]></content>
      
      
      <categories>
          
          <category> jvm学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm内存相关 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jvm学习笔记（入门）</title>
      <link href="/2019/03/20/jvm%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <url>/2019/03/20/jvm%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="入门概念"><a href="#入门概念" class="headerlink" title="入门概念"></a>入门概念</h1><h2 id="字节码（ByteCode）"><a href="#字节码（ByteCode）" class="headerlink" title="字节码（ByteCode）"></a>字节码（ByteCode）</h2><p>java的跨平台特性（Write Once，Run Anywhere）的根本原因就是字节码，字节码是java源代码编译以后的结果，对于不同的平台，jvm的内部实现机制可能有所不同，但是编译出的字节码却是相同的<br>大部分情况下，字节码都是储存在本地的.class文件，每一个字节码对应着全局唯一一个类或者接口的定义信息<br>扩大来说，任何编程语言只要编译结果满足并包含java虚拟机的内部指令，符号表以及其他辅助信息，这就是个有效的字节码文件，就能够被虚拟机所识别并装载运行</p><h2 id="Java-API"><a href="#Java-API" class="headerlink" title="Java API"></a>Java API</h2><p>即java应用编程接口，是预先定义好的接口，目的是让人用来进行开发，而又无需访问或者理解其内部源码（虽然为了我们自己的进步还是要去看源码）</p><h2 id="java虚拟机（JVM，java-Virtual-Machine）"><a href="#java虚拟机（JVM，java-Virtual-Machine）" class="headerlink" title="java虚拟机（JVM，java Virtual Machine）"></a>java虚拟机（JVM，java Virtual Machine）</h2><p>这是java技术的核心所在，因为所有的java程序都运行在java虚拟机内部，之所以说是虚拟机，是因为它是一组规范所定义的抽象计算机，jvm的主要任务是将字节码装载到内部，编译为对应平台的机器指令</p><p><img src="/upload/pasted-208.png" alt="upload successful"></p><h2 id="Java相对于其他几种语言的优势"><a href="#Java相对于其他几种语言的优势" class="headerlink" title="Java相对于其他几种语言的优势"></a>Java相对于其他几种语言的优势</h2><ul><li>1 体系结构独立</li><li>2 安全性优越</li><li>3 多线程</li><li>4 分布式</li><li>5 丰富的第三方开源组件</li></ul>]]></content>
      
      
      <categories>
          
          <category> jvm学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>绘卷水浒传 20周年企划 第五章 翻译</title>
      <link href="/2019/03/18/%E5%8D%B7%E6%B0%B4%E6%B5%92%E4%BC%A0-20%E5%91%A8%E5%B9%B4%E4%BC%81%E5%88%92-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BF%BB%E8%AF%91/"/>
      <url>/2019/03/18/%E5%8D%B7%E6%B0%B4%E6%B5%92%E4%BC%A0-20%E5%91%A8%E5%B9%B4%E4%BC%81%E5%88%92-%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BF%BB%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<p><img src="/upload/pasted-231.png" width="70%"></p><a id="more"></a><hr><p><font color="#FF0000">原文作者 森下翠和插画作者 正子公也 版权所有<br><br>个人翻译<br><br>仅供个人娱乐及同好者欣赏<br></font><br><br><br><a href="http://suikoden.com/" target="_blank" rel="noopener">原文地址</a></p><hr><h1 id="第五章-龙门决战"><a href="#第五章-龙门决战" class="headerlink" title="第五章 龙门决战"></a>第五章 龙门决战</h1><p>天刚微微亮<br>山间灰蒙蒙的，在漫天飞舞的朝霭中，史进他们被敌人包围着。<br>看着般若雷迸溅出的血花，官兵们战战兢兢的后退了<br>“是援军——敌援到了！”<br>金山大师的脸上，没有慈悲，没有愤怒，而是无念无想——那双眼睛没有犹豫和后悔，只有如利刃般的光辉<br>官军一撤退，包围史进的圈子松散了，石秀他们也向着包围圈涌去，一下子，官军就崩溃了，陈达，杨春，僧兵们也跟了上来，张开弓，并排着长枪组成枪阵，团结一致向前突破着<br>增援过来的是一百多武僧，是棍棒和拳法的高手<br>“保护金山大师！”<br>金山大师前进着，史进，石秀左右守护，人们源源不断的。但是，从街道的远处传来了马蹄声和轰鸣的呐喊声。官军的增援也到了，每次剧烈的震荡，都是不下千人的军队在行进着<br>石秀盯着天上的星辰<br>“就要死在这里了吗？”</p><p>金山大师带头向敌人中心猛冲着，蜂拥而来的敌人就像怒涛一般，般若雷拨开箭矢，迸溅出火花，每次金棒一闪，就会倒下一片士兵<br>“这个罗刹，会下地狱的”<br>官军将领破口大骂，那个声音，回响在黎明的山间<br>“这个罗刹，会下地狱的”<br>对于回声，有了回应的话<br>“你在说洒家吗？”<br>与此同时，在官军的后方，一群人发出呐喊，他们突然向前方的官军发起攻击，无论是史进他们还是官军自己都以为他们是援军，他们也是官军的打扮，那群呐喊的人中，站着个巨汉，悠然的站着，一把扔掉了士兵的头盔，史进眼前一亮<br>“鲁智深！”</p><p><img src="/upload/pasted-205.png" alt="upload successful"><br>“来迟了！”<br>伴随着这一声，六十二斤的镔铁禅杖也卷起疾风的舞动起来，鲁智深趁机在懵逼中的官军中开辟一条道路，其他人也卸下官兵的伪装，出现了一伙“丐帮”军团，大多是乞丐，以洛阳，东京的乞丐为主力还有其他反对废佛的壮士，共计三千多人<br>“什么情况？”<br>伏兵的指挥官发出悲鸣，突然想起来了，先前林灵素亲兵中的一个小头目，组织起来一批无赖和乞丐，对他们予以重金赏赐，由于待遇很好，很快就聚集了不少人，真不愧是自傲的道士——得意忘形的太早了<br>丐帮军团恢复了原有的半裸状态，将官军冲散<br>“拿你们钱就是为了吃口饭罢了，现在咱们要消灭敌人”<br>冲在最前面的鲁智深，犹如砍瓜切菜一般挥舞着禅杖，在官军篝火的映照之下，他犹如罗汉一般<br>在这群人中，也有“活闪婆”王定六的身影，此外，还有登州莱山的“解家双雄”——“双头蛇”解珍和“双尾蝎”解宝</p><p><img src="/upload/pasted-206.png" alt="upload successful"></p><p><img src="/upload/pasted-207.png" alt="upload successful"><br>解珍解宝两兄弟位居梁山泊第34,35位，见者必死的双头蛇和拥有两条毒尾的蝎子便是这兄弟二人，他们纵横于山间之中，用猎叉和弓捕获猎物，是纯粹的猎人<br>官军陷入大乱，由于自己的内部出现敌人，他们的阵型被瓦解，四处乱窜。<br>金山大师自己也在战斗着，看见了鲁智深，鲁智深也看见了金山大师。在敌我厮杀激烈的山腰，上山的人和下山的人碰撞着，一片混乱，不久就散开了<br>金山大师和鲁智深，终于在后参道口相遇了，二人罗汉般的身姿，确实像是守护嵩山的仁王</p><hr><p>响起了胜利的呐喊，不是“万岁”而是“阿弥陀佛”<br>由于史进等人的奋进和鲁智深的援军突然杀入，官军撤退了，本以为设伏打击没有防备的僧众，不想却以自己受到袭击的方式结尾，官军暂时无法重整态势<br>官军撤出后参道后，在南方的街道布阵<br>史进等人也和“丐帮军”一同撤退到了“佛掌角”，在解氏兄弟的指挥下，后参道口处封锁道路的木材被移除了，兄弟二人为了查看是否还有其他的道路官军可用来侵入，马上消失在山中<br>史进也得到了暂时的休整，为与鲁智深再会而感到高兴<br>“得救了，智深师傅，你们怎么会在这里？”<br>王定六也混在乞丐当中<br>“骨头都要断了”<br>为了联合解氏兄弟，鲁智深，并安排各个丐帮的壮士混入道士军，“活闪婆”王定六已经快跑不动了<br>“吴军师简直不是人”<br>王定六一边和鲁智深同行，一边又要和丐帮和梁山泊取得联系，梁山泊也通知了鲁智深前往少林寺，预料到少林寺将会成为主战场的吴用，也派遣了精通山岳的解氏兄弟【注：两个人最后都死在了悬崖边上，一个生生掉下去摔死的，一个活活被乱箭钉在了悬崖上，绘卷水浒传的方腊篇也有两人死时的插画】，当然，吴用也预测到了能够动用的援军<br>“能见面，还是多亏了军师，是吧，和尚”<br>鲁智深一脸不悦，把腰间的酒葫芦扔给史进<br>“明明就是冲着洒家来了，哪里那么多废话”<br>“哼”<br>鲁智深的腰间总是备着酒葫芦。“荤酒勿入山门”——就是为了防备这个的，鲁智深自己也喝了起来，润湿了干渴的喉咙，他并没有看向史进，而是看向了金山大师<br>金山大师似乎认为突然出现的“丐帮军”是某个寺庙来的援军，在向和尚外貌的鲁智深行过礼后，就着手指挥着手下受轻伤的僧人进行救助工作，而且还派出侦察和监视的人，丝毫没有因为官军的撤退而疏忽大意<br>石秀也和陈达，杨春负责起周围的境界，他们举着火把，巡视着后参道附近，突然发现草丛在动，石秀拿着刀冲了过来，此时，听见了熟悉的声音<br>“等一下，是我”<br>“‘张神剑’，你还活着？”<br>从草丛中爬出来的，正是去探索桀街道的雇佣兵队长“张神剑”<br>“下面全是士兵，他们已经陆陆续续的在集结了”<br>回少林寺侦察的莫志，不久也返回了“佛掌角”<br>“林灵素的本部队正在从北麓登上来，我们没有回头路了”<br>接到报告的金山大师坐在大岩石上，沉默不语<br>他们已经被包围在了这“佛掌角”，“张神剑”是军人出身，很了解官军的作风<br>“等早晨一到，他们就会从山上杀过来，或者在林子中放火，即使想去龙门，也不能走正道了，还有别的路吗？”<br>“张神剑”问金山大师。向西延伸的山脊被树木覆盖，浮在微明天空上的山脊陡峭地耸立着。<br>“道路——”<br>金山大师正要说时，有声音从黑暗中传来<br>“——没有”<br>在火炬的光芒下，是身着虎皮的解宝，背后站着手持叉子的解珍<br>“没有别的路”<br>兄弟二人出生于登州莱山，是和山中的野兽相伴成长的，自己也犹如野兽一般，走过了无数的险路<br>他们说道<br>“即使没有人造的路，山也有它的出路”<br>兄弟二人鼓起气来，从胸腔中发出了犹如野兽般的咆哮，对于这个连周围空气都能震动的“葛氏禁气啸”，嵩山群峰的野兽们也开始回应，整个嵩山上下，咆哮声接连不断，此起彼伏<br>深山之中，是人们所不了解的野兽之道<br>哥哥解珍向薛永打听，因为薛永出生于河南，熟悉周边环境<br>“薛永兄弟，龙门就是在这里往西的方向吗？”<br>薛永点点头<br>解珍仰望消失在曙光中的星星，指着一座山峰。<br>“那边是西边”<br>并没有出路<br>但是。莱山的解氏兄弟却在天空，在山间，读着前进的“道”</p><hr><p>只点着一只火把<br>金山大师闭上眼睛，感觉到野兽的咆哮渐渐消失了，在渐渐恢复的寂静中，他睁开眼睛，眼前正站着鲁智深<br>金山大师低声沉吟着什么<br>在火把的光芒中，鲁智深的脸闪闪发光。虽然擦了脸颊的血迹，但灰色僧袍还是红黑潮湿的。<br>（是毘沙门天【多闻天王，为佛教护法之大神，是四天尊王之一，熟悉日本战国的朋友应该知道，就是上杉谦信经常cos的】，还是罗刹？）<br>从天而降的神明，到底是出于何种目的——那是金山大师眼前刹那间的幻像【侧面证明了就阴阳学而言，金山大师还是和智真长老有差距的】<br>“你是哪个寺庙的僧人？”<br>“洒家便是在五台山出家，智真长老的弟子——‘花和尚’鲁智深”</p><p><img src="/upload/pasted-210.png" alt="upload successful"><br>“智真的……”<br>“正是”<br>鲁智深把手伸进怀中，摸出一颗念珠<br>“这是智真长老的念珠，这上面画着的，就是达摩吧”<br>鲁智深简单的说明了在东京的斗法状况，金山大师摸索着念珠，端详了一会<br>“这念珠，是本僧与智真进行宗论时，最终没有胜负，相互交换的”<br>智真长老和金山大师的宗论，是关于“智”与“武”的，佛说着慈悲，可身边的护法却手持利剑，智与武真的能共存吗，谁又能更胜一筹，真正带来和平的，又是哪个呢？<br>金山提倡的是修行本身就是战胜烦恼的过程，而智真则认为一切不昧，烦恼，已经烦恼了<br>然后，两人各自完成了自己的修行，做出了自己的选择<br>金山踏上了苦行恶行的武道，智真选择的是只管打坐冥想的智道<br>但是，在没有岔路的道路上，在天地间无边无际的荒野上，昂首前进的人，现在正站在金山的面前<br>“鲁智深啊——”<br>金山大师双手合十<br>“无道，亦无止境——你是唯一踏上旅途的人吧”<br>“什么东西啊，洒家也不晓得”<br>鲁智深擦了擦被酒弄湿的胡子，然后，像孩子一样笑了<br>“洒家就是找你的”<br>金山大师也豁然的笑了<br>“那么，金山大师啊，今后怎么办啊”<br>武僧们，受伤的尼姑们，佛教信徒们以及丐帮的兄弟们，都在看着二人，金山大师看了看手中的念珠，站在大家面前。那颗心自然已经做出了决定<br>“出发吧”<br>这样说道<br>鲁智深手中握着装满酒的葫芦，眼睛盯着大师<br>“佛法本为苦难烦恼之人而生，如果这泱泱大国的人无忧无虑的追名逐利，无忧无虑的贪图享乐。佛法已经没有必要了，吾等会毁灭，但是，吾等不能白白的死去，点燃最后的灯火，向西进发吧”<br>金山大师抬起头，指着已经被黎明染了色的西峰，那是没有出路的嵩山群峰，而龙门就在那西面，而更遥远的西面是天竺，最后的西方净土<br>“好吧！”<br>一线阳光照在了鲁智深的脸上<br>“地狱之道上，就由洒家当先锋吧”</p><hr><p>天一亮起来，战场上的惨状也就看的一清二楚了，清爽的晨光中，四处遍布尸体，是死去的僧侣，官军，尼姑，以及雇佣军<br>银树咬着嘴唇，呆呆的望着眼前的情景，有死不瞑目的尸体，也有像睡着一般宁静的尸体<br>周围的血迹，染湿了银树的鞋子，一群乌鸦犹如乌云一般开始覆盖朝阳<br>薛永的脸上也沾满了血<br>银树拿出自己的手巾为他擦去血迹，指尖犹如寒冰一样冰凉<br>“这世上，惨不忍睹的事……还真是多啊”<br>“好的是事情也很多啊”<br>“——是啊”<br>薛永和银树一起，为受伤的彭尼贴上膏药，薛家的膏药止血镇痛的效果很好，彭尼微微睁开眼睛，旋即又闭上了<br>李忠正在砍伐周围的树木制作担架，用来运送伤者，龙门之旅，是一场死亡之行。尽管如此，所有人呢都认为这也比被官军杀死好，薛永正在给伤员贴上自家的膏药，石秀站了起来<br>“薛永，你和那孩子赶紧先跑吧”<br>“石秀大哥？”<br>“两个人去什么地方都好，千万不要再去龙门送死了”<br>人群在解氏兄弟的带领下开始行动起来，向西，越过险峻的山峰<br>银树为一个老僧贴上最后一贴膏药后，站了起来，问石秀<br>“那你打算怎么办？”<br>“这种事情，我总能应付的”<br>“史进也要去吗？”<br>“他的师父好像在龙门，不去打声招呼的话，作为弟子就有些过分了”<br>银树朝着远处的天空望去，天空晴朗，朝阳耀眼<br>“——这样啊”<br>银树却笑了。插在头发上的野花，在晨风中散落。<br><img src="/upload/pasted-222.png" alt="upload successful"><br>“那我就去东京吧”</p><hr><p>“金山大师，我要去东京了”<br>银树告诉走在前面的金山大师<br>“我要去见我的父亲，我有好多事要告诉他，这种事情不能再发生下去了，人自己的信仰，不该由人自己所决定吗，我无法忍受大家就像不存在一样被抹杀，被淡忘”<br>银树正气凛然，声音中充满的强烈的决心<br>“所以我要去东京”<br>薛永很了解银树。史进说道<br>“公主殿下，报仇的事只能放一下了”<br>银树点了点头<br>“那种事，已经无关紧要了”<br>金山大师默默听银树说完，把手伸到怀里，拿出一颗念珠<br>这是金山大师和智真长老当前交换，然后智真长老有托付给鲁智深，鲁智深又返还给金山大师的念珠，上面刻着达摩祖师，连念珠也已经被血染红了，大师用粗大的手指擦去念珠上的血迹，把它放在银树的手中<br>“……人的生命，就犹如这念珠一样，人与人相识相遇，就好像一个个念珠串联起来的串，连续不断，公主啊，你的生命”<br>金山大师双手握着银树的手和念珠<br>“不要忘了自己也是这串念珠中的一颗啊”<br>随着手掌的温暖，银树也明白了，大师是想告诉自己“活下去”，不论发生什么都要坚持活下去<br>银树一直想问<br>“天有三日，满月辉耀”<br>能够知道当初“不祥预言”的机会也就只有现在了<br>“大师”<br>本打算要问，但是银树取而代之的是微笑，她紧紧的握住念珠<br>“向父亲请愿停止废佛后，我一定会回来的”<br>史进猛地推了薛永一把<br>“你也跟她一起去吧”<br>薛永正在犹豫，史进把头转到了后面的伤者方向，彭尼正要挣扎的站起来，被李忠阻止了<br>“你难道打算让彭尼去吗？薛永，除了你以外，谁还能拼命的保护银树呢？”<br>“但是，我”<br>“去吧”<br>史进把棒子扔到薛永手中</p><hr><p>在朝霞之中，薛永和银树下山到了南边的山脚，位于官军的北面，他们避开街道，沿着险峻的山腰顺着谷川而下，薛永走在前面，拨开杂草，为银树开路，两个人的身影很快就消失在山间了<br>“是个会照顾人的男人啊”<br>李忠发出不知是叹息还是哈欠的气息，伸了伸懒腰<br>“年轻还真好啊”<br>清晨的空气在这种时候让人觉得很清爽<br>“其他受伤的人……”<br>“活着的人没人比你伤的更加严重了”<br>李忠吩咐手下把彭尼抬上担架<br>解珍解宝走在前面，爬到山尖上，走了一会就回头举着叉子挥动几下，发出可以通行的信号<br>大家默默的跟着，背着朝阳前进，有背负着伤员的，有扶着拐杖的，大家互相搀扶，朝着西边的山脊一点点前进着<br>时迁和王定六正在四处侦察<br>他们是“传令”，无论周遭发生什么事情，他们都要第一时间把情况通报给梁山泊，赶得上赶不上从来不是问题<br>“你要去哪啊”<br>“不用你管”<br>“我可比你快啊”<br>时迁把肩上的老鼠放在怀中<br>“我身材瘦小，行动起来会更加方便”<br>这样说着，时迁一个人消失在覆盖山峦的草丛中。<br>史进向薛永他们离去的南方一眼后，也准备开始上路了<br><img src="/upload/pasted-223.png" alt="upload successful"><br>“向龙门出发！”</p><hr><p>林灵素到达少林寺时，太阳已经升了起来<br>本来想活捉金山大师， 品尝胜利的滋味，可此时的嵩山却空空如也<br>林灵素本来打算等待节度使的军队到达后发起总攻，但是，由于僧侣们已经准备开始逃脱了，急忙派遣了伏兵，正面的本队也发起了进攻，杀过来时，最后院中不过三个人，连一只狗都没有留下<br>（没关系，关键还是金山）<br>金山大师是“谋反”的主谋，只要讨伐了金山大师，“镇压谋反”就算大功告成了<br>林灵素走进已经烧毁的达摩堂，去检查金山大师的首级，林灵素知道金山大师什么样子<br>“这不是金山大师！”<br>林灵素一脚踢开被搬过来的天穹和尚的头，骨碌骨碌的滚着，碰到了达摩像的脚停了下来，空洞的眼神，正在向着林灵素笑着<br>林灵素相当着急，明天，郭道士已经受命在东京做法发生“奇迹”，与此同时，“林元帅成功讨伐逆贼的”的奏折，将会呈到御前<br>“赶快找到金山！”<br>林灵素命令手下的道士<br>“不论死活，抓住赏金百两”<br>道士们立刻兴奋起来，争先恐后的行动着，达摩堂的门一晃，猫儿从缝隙中无声的滑了进来<br>“节度使的军队呢？”<br>林灵素一脸不悦，却也没有招呼别人<br>“他们马上会出战的”<br>猫儿观察仔细的眼睛，在达摩堂中闪闪发光<br>“这是贵妃大人的忠告：‘不要催促，要下命令’。因为你是陛下任命的元帅，如果他们不服从命令的话，他们就是造反”<br>“那慕容贵妃现在何处”<br>“我的任务完成了，我要出发了，有更重要的事情，荣德公主已经向东京进发了”<br>“公主？”<br>猫儿急切的点了点头<br>慕容贵妃是到最后都能精明盘算的人，为了应对这种不测之事，派出了自己心腹猫儿<br>“公主想要向他父亲控诉你的恶行，而且她也知道贵妃还在四处活动”<br>“这可就不好了”<br>“公主正在一路向东，只有一个护卫，应该很好杀掉”<br>“你是不是也知道金山大师的去向啊？”<br>“我去调查一下，知道了就告诉你”<br>猫儿心不在焉<br>（我的任务是加重骚乱，引发战争）<br>战事拖长，战争形势扩大，如果节度使们不出兵，就无法完成慕容贵妃的野心<br>林灵素用怀疑的目光凝视着猫儿的脸。<br>“慕容贵妃的真正目的是什么？”<br>猫儿咂了咂嘴。<br>“磨磨蹭蹭的，会来不及的”<br>与贵妃相似的狂妄的口吻触动了林灵素的肝火<br>“你曾经是那人的弟子，那个契丹人……是叫狐狸还是狗来着？”</p><p><img src="/upload/pasted-221.png" alt="upload successful"><br>“白骨猫”【这个人是绘卷水浒自创人物，是个忍者类型的，也是喜欢四处搞事】<br>“对了，那人可是个高手，飞刀，投毒，化妆都样样精通，当年不就是她，化妆成侍女‘月仙’，让王皇后吃下毒月饼，你怎么不化妆成个尼姑把公主杀掉呢？”<br>“师父是师父，我不像她那样，但是问题不大，赶紧派人追公主吧”<br>扔下这句话，猫儿又从达摩堂无声地滑了出来。<br>她躲在院子中的松树梢上观察着【也不知是个什么操作……】不一会就有五十人的队伍出发，看到这个，猫儿离家少林寺，躲着士兵的监视，就这样悠闲的下了山<br>（可怜的金奴公主）<br>猫儿手中握着一个红衣布娃娃<br>猫儿也从师父“白骨猫”那里学来了化妆术，小时候曾化妆成小宦官潜入后宫，向慕容贵妃递送情报的也是猫儿<br>她还记得陪她一起玩耍的金奴<br>猫儿偷了玩偶，金奴还护着她<br>（我不能违抗贵妃大人……但是我绝不会杀你的）<br>猫儿深信不疑，这至少是一种“友情”<br>（再见了，金奴公主）<br>猫儿拿着娃娃走在耀眼的阳光下。然后，忽然觉得听到风的声音，想回头看向后面。<br>她的瞳孔，突然扩大了，下一个瞬间，猫儿的头就被砍下了，像皮球一样滚在地上<br>手中握着的玩偶，不可思议的睁开眼睛，映照着晚夏的蓝天<br>“你已经杀掉那个女孩了吗？”<br>林灵素看着手持沾满鲜血的弯刀的怪道士，皱起了眉头<br>“贵妃的目的还不知道，所以还不到杀她的时候啊”<br>“知道秘密的人越少越好”<br>兜帽下的怪道士似乎在嘲笑林灵素的懦弱<br>林灵素也没在说什么了<br>追兵应该已经追上金奴公主了吧<br>“通真达灵元妙先生”林灵素也在一点点的接近成功</p><hr><p>薛永和银树在山脚的农家下借了匹马，取道向东<br>金山大师告诉他们家中种麻的人家寄存着少林寺的马<br>从简陋的马厩中牵出一匹马，是一匹漂亮的白马，用来运送经典，牵引高僧的马车，负责照料的独眼老农说出了它的名字<br>“帕鲁亚提，梵语的意思是‘示现’，你们叫它示现就好了”<br>“示现”是一匹很静的马，但脚力非凡，由于只有一匹马，薛永把银树放在马鞍前，即使载着两人，速度也一点不慢</p><p><img src="/upload/pasted-224.png" alt="upload successful"><br>两个人共骑一匹马在路上奔驰，既不是士兵，也不是僧侣，没有被人追查盘问的担心，在旁人看来，只不过是私奔的年轻情侣罢了<br>从西京洛阳到东京开封，距离四百多里，其间道路平整，骑快马的话半日就能到<br>太白也紧紧跟在后面，突然叫了起来，薛永回头一看，后面尘土飞扬，沙尘越来越近。不一会就能看见人影了，是追兵到了<br>“抓住那个女孩！”<br>“追兵？怎么会有追兵？”<br>箭从他们身边飞过，薛永鞭策马，但已经开始疲惫的“示现”反而越来越慢<br>（这样下去，会被追上的）<br>薛永让银树握住缰绳<br>“练过骑马吗？”<br>“在宫中稍微练过”<br>“太好了”<br>薛永拿起挂着马鞍上的棍子，从开始减速的马上跳了下来，银树马上就知道什么情况了，自己也想从马上跳下来<br>“薛永，我也要战斗”<br>“你赶快沿着路跑吧”<br>前进吧——薛永用棒子狠狠的打了示现的屁股</p><p>银树回头一看，薛永拿着棍子，站在道路中间<br>向要经过的追兵发起攻击，用棍子把敌人从马上打下来，士兵们拔出剑，包围了薛永<br>（薛永！薛永！）<br>“示现”急速的奔跑着，和那个名字正相反，薛永的身姿消失在后面<br>（千万不要死了）<br>银树挥泪向前，风呼啸而过</p><p><img src="/upload/pasted-225.png" alt="upload successful"><br>（谁都不能再死掉了）<br>银树紧握着缰绳，泪珠在风中消散<br>视野逐渐模糊，也看不清楚前方，道路也渐渐扭曲，“示现”正在狂奔<br>奔向让人生厌的东京<br>前往令人绝望的皇宫<br>回到对人无情的父亲身边</p><hr><p>伊水河畔传来轻轻的诵经声<br>这是抚慰受伤的心灵，安抚逝去的灵魂的声音<br>龙门的僧侣，无论是谁都很安定，他们在这里做着最后的法事，即身成佛。必然能在天界轮回。<br>从长安大慈恩寺来的高僧正在木台上说道，周围聚集着从迫害中逃出的信徒们<br>“人最大的罪过就是杀生，而杀生中，杀人是最沉重的罪，这是为什么呢？因为灵魂寄宿在肉体上，是比深海底的神龟每百年上浮一次，被洞中漂浮的木板敲中头部更加难得的奇迹，那么为什么‘贵为人’呢，这是因为人能听取教化，有所领悟，能从轮回当中解脱”<br>夏末的河畔，吹过凉爽的风<br>那里已经是净土<br>死去的心也已经平静下来<br>绝望似乎是甜美的，就这么什么也不做，只是等待着结束而已——临终时，会有乘着五色云彩的佛来迎接他们<br>人们正在默默的诵经<br>鼻腔猛地被浓烈的血味刺激到了<br>抬头一看，也不知哪里来的僧侣，正沿着河岸，朝着石窟进发，一开始看到一个人，接着又看着几个人结伴而来，大家互相搀扶着前进<br>仿佛混淆与亡者之间，疲惫不堪的人们正在游荡，有僧人，有老者，有乞丐，也有武者<br>龙门的人们都忘了诵经，注视着他们的身影</p><hr><p>这一天，梦魇笼罩在皇帝的寝宫中<br>徽宗皇帝被噩梦吓醒，出了一身冷汗。宦官们为擦干身体，换上衣服后，外戚王都尉来了<br>王皇后的哥哥王晋卿是个有才之人，从年轻时代就受皇帝亲信，连寝宫也允许出入<br>“听闻陛下身体不适就赶过来了……陛下身体如何？”<br>在昏暗的烛光中，王都尉正对着龙塌上的皇上低语着什么<br>“不过是一场梦罢了”<br>“嗯……虽然记不清楚但是总感觉看见了冲天的火光”<br>“难道是天神？”<br>王都尉大吃一惊，沉默不语<br>“怎么了”<br>“没什么，不是大事”<br>“你说实话”<br>王都尉带来的小侍从在房间的角落点起了香，甜甜的香味让人昏昏欲睡，皇帝心里却产生了莫名其妙的骚动，根本就无法入睡<br>最近，无论宫中的宴席，还是东京名媛李师师，他都没有去碰，控制着自己的“悠闲自在”，忧虑的事情是在太多了<br>“太子也因废佛而悲伤，卧病在床，大臣中的反对者也很多，宿元景太尉等人，甚至还写了厚厚的奏疏来揭发道士们的恶行，虽然撤销了蔡京但是听说政事也因此拖沓，可是朝令夕改不好吧”<br>“古人云，君子豹变【比喻润饰事业、文字或迁善去恶，出处：《周易·革》】”<br>皇帝含着侍从献上的甜蜜药水，叹了口气<br>“为什么智真会反对？不就是林灵素创造的奇迹镇住了怪相吗，不过是佛道合一，把称呼改变一下而已……这种事真的怨气很大吗？”<br>“陛下能否见上智真长老一面？”<br>“朕吗？”<br>“如果陛下被说服的话，请一定……”<br>王都尉的声音飘飘悠悠，好像很远，又好像很近<br>并且，从很远的地方，传来了如天人般美丽的声音<br>“智真长老到了”</p><p><img src="/upload/pasted-229.png" alt="upload successful"><br>门一开，一只狮子跳了进来，皇帝惊呼一声，吓得后退，咆哮的狮子的鬃毛正在燃烧，其上站立着文殊菩萨，左持莲华，右持利剑，眼睛流露着笑意【文殊菩萨：惊不惊喜，意不意外？（误）】，皇帝却因为极度的恐慌而晕倒了</p><p>醒来时，皇帝已经躺在了床上，有阳光从窗户中射进来，也不知是早晨还是傍晚，不久，郑皇后就来了，这是在王皇后去世后新册封的一个皇后，没能生子，但为人贤良<br>皇帝拉着郑皇后的手<br>“王都尉不在这里吗？”<br>“没有，陛下又做了什么梦吧”<br>问了宦官，也说没人来过<br>“陛下一直在歇息，从未有人打扰”<br>皇后说，来的时候看见了不可思议的景象<br>“在走廊中，看见了一个高个子白衣老者，只是背影，未能看清面孔，简直像天上的云朵，一转眼就消失了”<br>宫中还有那样的老人吗——郑皇后默默的低下了头</p><hr><p>要抵抗到最后<br>怀着这样的决心，逃离少林寺的人们终于到了龙门，他们在解氏兄弟的带领下，傍晚时躲在剑山周边，他们就这样走在人生最艰难的路上，一路疲惫不堪，倒下的人也很多<br>尽管如此，仰望着夕阳下石窟的脸，也是感到很安心和喜悦</p><p><img src="/upload/pasted-230.png" alt="upload successful"><br>龙门石窟是在伊水两岸耸立的岩山上建造的巨大的石窟寺院。<br>开凿于北魏时期，在佛教兴盛的唐朝又建造了很多石窟，大大小小的佛像坐落在岩洞里，墙面画着五彩缤纷的极乐图<br>这人间的极乐世界，不久就会成为大宋佛法断绝之地<br>率领这群殉教者的金山大师，衣服上的血迹已经干涸，手中的般若雷掷地有声，虽然般若雷已经打翻了数十个敌人，但是棒上并没有沾染血迹，正在夕阳下闪闪发光<br>石秀在旁守护着金山大师，史进在队伍尾断后<br>队尾是伤者，由于负伤，移动缓慢，李忠背着彭尼，彭尼看上去十分痛苦，但也不曾落泪<br>他们翻山越岭，道路渐渐平缓，能看见山脚的平原了，斜坡上已经有了秋天的花，史进摘了几朵悬崖边上的红花，塞给彭尼<br>“……故乡的山上也开着这样的花”<br>虽然是件不值一提的小事，但是彭尼还是很高兴<br>“以前，我喜欢把花插在头发上”<br>“要不要高歌一曲？”<br>已经可以远远看到镶嵌着银边的伊水了<br>龙门周围还没有官兵的身影<br>但是这也只是时间问题了吧</p><p>龙门的石窟寺院中已经来了数百名僧侣，与法难做斗争的人在少林寺，而想要守护经典的人则聚集在龙门<br>现在一汇合，已经有三千多人了<br>这可给隐居于此的僧侣带来不少麻烦<br>他们已经放弃了抵抗，为了成为即身佛而坚持绝食和诵经，已经有人饿死了，被安葬在伊水河畔<br>虽然食物储备很少，但是先下山的乞丐也不知在哪里搞来了食物，除了原有的锅外还用上了青铜香炉，煮着杂粮和豆子混合的粥，巨大的石佛脚下，冒起了热腾腾的气<br>“释迦牟尼之所以敢于舍弃自身，是为了抚慰饥饿的老虎，他的自我牺牲并不是为了拯救迷途的鹿——而是为了成全自己”【没找到这个典故】<br>金山大师给绝食的僧人送上了粥<br>史进等人在大石窟前的车座上，用金盆代锅煮着杂烩粥，乞丐们还不知从哪里搞来了肉和鸡蛋<br>石秀在贡物盘子里盛满了粥，递给鲁智深<br>“最后一餐，爽吃一顿吧”<br>石秀又用勺子在锅底捞出一大块肉，放在史进的盘子里<br>陈达他们默默的吃着，佛像正代替柴火在篝火中燃烧着<br>李忠看着火焰<br>“胜算几成？”<br>杨春回答道<br>“谁还在乎这个”<br>再来一盘——陈达向锅伸出了手<br>鲁智深一边喝着仅剩的一点酒，一边眺望着金色的伊水，沐浴着夕阳，犹如流淌的黄金一般<br>河滩上有人行进着，有僧侣，有信徒<br>金山大师也站在卢遮那佛【龙门最大的佛像】面前，看着它<br>他们是为了死而聚集在此地<br>（不，是为了活下去）<br>直到最后，为了更好的活着，抛弃过去，抛弃未来，只是为了活在当下<br>（如果强大……）<br>大师这样想着<br>大师深信“强大可以战胜一切烦恼”，大师不禁想起了曾经和自己交过手的对手，许多已经不记得面孔了<br>本打算为了追求什么，守护什么而战斗，但现在手里却什么也没有。<br>大师的手静静地胸口上<br>鲁智深手持空葫芦，慢慢的站在大师的旁边<br>“没有酒吗？”<br>金山大师在黄昏中回首，笑了。<br>“有酒的话，会很开心吧。”<br>夕阳无限好</p><p><img src="/upload/pasted-231.png" alt="upload successful"><br>在这无限风光的夕阳之下，自己好像活过来一般，无论是严厉的修行，戒律，冥想，坐禅，都没有真正的解答他的疑惑<br>石窟中，人们为遇难者简单的举行了法事，将剩下的香全部烧掉，香气正在静静的流淌<br>（无论是多么强大，多么有智慧，大概都会输给“非道”吧）<br>这是正是生命的教诲<br>（但是）<br>人——只有“生存”下去，才能被真正救赎吧</p><hr><p>节度使“老风流”王焕正在思考<br>“和尚和道士在打架？这种事在另一个世界也可以做”<br>漂亮的侍女们围着王焕，有用扇子扇风的，有倒茶的，还有剥水果的，心情愉悦<br>“白马寺已经被破坏，少林寺也已经一片火海”<br>“啊，那还真是可怕啊”<br>听到“月李”说的话，“百合”微微皱眉<br>王家上下，从王焕到侍女，大多都信奉佛教，虽然也不是全信，但也是有事没事去寺庙烧上一炷香<br>“已经没有放生的机会了吗”<br>“海棠”也同情这些佛教徒，王焕问身边的部下<br>“太原的徐京怎么说？”<br>“他只是报病‘因病不能上阵’，可是接连不断的传令催促上阵，谁又能违抗敕令呢？”<br>“徐京也是个义侠心很强的男人，一定很为难吧。山西边境上又有契丹人转来转去，徐京管辖内又有个叫田虎的山贼在胡闹。近日，有谣言说要那家伙称王。这时，肯定不想随便离开任地吧。为了道士争夺权力”<br>“芍药”一边为王焕揉肩一边这样想着，青年时，王焕因风流而闻名，他是绝对不会管这种无聊的事的<br>而且，僧侣们败局已定，这是显而易见的<br>王焕手中拿着一个漂亮的梳子，是一个早年间流行的梳子<br>“好，就这么决定了”<br>王焕紧紧的攥住梳子，“牡丹”问道<br>“要去哪里？”<br><img src="/upload/pasted-232.png" alt="upload successful"><br>“当然是龙门了，要着手准备出发了”<br>侍女们熟练的为王焕换上甲胄，“水仙”和“茶花”两人带来了王焕平时爱用的长枪<br>准备完毕后，王焕捋着胡子，大步迈出宅邸<br>侍女耳边响起了王焕豪迈的声音<br>“我就是老将王焕，你们这些人觉悟吧”<br>侍女们都在歪着头，想着同样的问题<br>“老爷要做哪一边的援军呢？”</p><hr><p>银树继续奔驰在通向东京的大道上<br>太阳渐渐倾斜了，已经是下午了，街道上热闹非凡，好像什么事情也没发生一样，人们来来往往<br>人们惊讶的看着拼命抱住马的少女<br>银树所在的尼姑寺当然没有马，但是银树的骑术却很厉害<br>在宫中和哥哥练习骑马的日子好像复苏过来，哥哥因为害怕骑马吓哭了【这里好像是指的宋钦宗吧】，金奴却满不在乎的在御苑中骑着马跑来跑去<br>金奴公主真的是既聪明又勇敢<br>（一定要找到父亲，揭露慕容贵妃的阴谋，阻止官军）<br>银树第一次不是为了亡母而是为了现世的人们生存而奔走<br>白马“示现”马不停蹄，途中，在一个农家得到了水和饲料，就这么一口气跑完了四百里的路</p><p><img src="/upload/pasted-233.png" alt="upload successful"><br>夕阳下，已经可以看见东京开封的城墙了，城门开着。银树从新郑门进入，一面问路，一边跨过州桥，取道大相国寺朝着宫城走去，由于当初出奔时是在深夜，所以这也是她第一次看到东京的街道，绚丽多姿，人山人海，看起来很愉快，似乎从未想象过这个世界上的某个角落会发生战斗。<br>宫城位于开封城的北方，被称为龙台的高台。<br>银树疲劳得几乎要昏过去，竭尽全力走到了宫城。墙壁和瓦片的模样，隐约地存在于记忆中。银树找到门跑了过来。可是，有卫兵，当然，她被拦了下来<br>“我是永德公主，我要见我父亲”<br>她在马上向卫兵通报<br>从马上告诉他们，卫兵们吓得目瞪口呆，但是不一会就回过神来<br>“美丽的公主殿下呀，您找哪位父亲啊？”<br>“这还用说，当然是当今圣上了，赶快开门”<br>卫兵们笑了起来<br>“怎么会有你这么个不整洁的公主啊，太可怜了，脑子出了些问题啊”<br>银树就这样被人泼了盆冷水，赶出了宫门<br>路人也在笑话银树，她就这么默默的走在街道上，头发凌乱，衣服上也沾满灰尘，连个耳环也没有，马具是村民的简陋货，现在这个样子，真的也比乞丐强不到哪里去<br>银树离开宫门，又向人问路，从城内向西走。那是大臣们的宅邸并排的一角，以其中最奢华的住宅之一为目标。可是守门人挡住了他<br>“你个要饭的，滚一边去”<br>看门人还想揍银树<br>“赶紧的，闪一边去”<br>银树又被赶了出来，这时，门开了，出来一只华丽的队伍，打扮豪华的人们骑着漂亮的马出来了，这只队伍中心，有她的舅父——“王都尉”王晋卿<br>王晋卿是亡故的王皇后的兄长，也是皇帝很宠幸的，他有众多护卫，周围又围上来看热闹的<br>银树倒在路上，本想大叫，不想却被看门人用棍子压在地上<br>队伍陆陆续续的穿过东京的街道，王晋卿正直了身子，驱马前进，有一瞬间，目光转向了倒在地上的少女，就这样从她身边经过</p><p><img src="/upload/pasted-234.png" alt="upload successful"><br>(是乞丐吗？)<br>他曾命令对于后门的乞丐，不论谁都要施舍些东西，这个女孩大概还不知道这个规定吧<br>队伍一离开，看门人也放开了银树<br>“赶紧到后门要饭去吧”<br>银树摇摇晃晃的站了起来，她已经走投无路了，连舅父也忘了她。实际上这十年间也没有见过面，也没有写过信，不过是以管家的名义，每个季节在送东西也就仅此而已，明明知道自己在尼姑庵中，却对法难无动于衷<br>十年的时光，足以让人忘记一个不幸的侄女<br>银树感觉到了无力，现在公主已经没有家人了东京百万人，而爱金奴的只有一个<br>（母亲……）<br>刚要哭起来的银树，突然抬起头，像是在寻找着什么，从府邸的围墙的对面，散发出令人怀念的香味。七里香——银木犀的香气。<br>银树咬紧牙关，再次站了起来，队伍已经离开好远了<br>人们都在议论<br>“王都尉要去艮狱了。今天，林教主预言会发生奇迹”<br>“听说皇帝也会御驾前往”</p><hr><p>艮狱是位于宫城东北的大庭园<br>皇帝按照道士的预言建造了园子。园林方圆六里。内部设置了假山、树林、湖沼等。用从全国寄来的奇石和珍奇的植物装饰，又放养稀有动物，使之成为地上的乐园，花石纲的灾难，可以说就是为了营造这个庭院而发生的<br>平时是皇族和贵族官僚的场所，节日有时也对平民开放。<br>今天，皇帝为了让民众看到“天仙的奇迹”，特意开了门<br>在园内的寿山，郭京已经率领众道士等待皇帝的到来<br>今天，在皇帝面前，寿山前的巨大太湖石会粉碎，从中出现青华帝君的玉像，为了表现空中飘动的五色云彩，已经准备了上了色的米粉和仙鹤，正在皇帝为眼前的景象感到震惊时，会有“使者”呈上关于林灵素“谋反已被镇压”的捷报<br>（玉像的脸和林教主一模一样，肯定没问题的）<br>而且，玉像做成了中空的，里面有镜子和蜡烛，双眼看上去应该闪闪发光，郭道士也很擅长这种“表演”<br>（还是要向林教主学习啊）<br>虽然不知道林灵素何时才能取得“实质的胜利”，但是前前后后有这么多把戏，总能说明些问题的<br>（陛下还没到吗？）<br>御门突然变得热闹起来</p><p>皇帝从宫城出，乘着轿子直奔艮狱，宠臣王都尉和护卫金吾部队在旁护送着，带领护卫部队的是金吾将军曹晟，也是皇帝亲信的年轻将校，他的祖父是被誉为“宋良将第一”的曹彬，是一名仁将，拔下城池，却不曾杀过一人，在军中颇有威望，因家族的熏陶，曹晟也是名门子弟中少有的有骨气的年轻人，所率领的部队也都是精悍的年轻人，在他们的护卫下，皇帝的轿子缓缓的向寿山进发<br>道路已经提前清扫干净，周围摆上了兰花，又有孔雀正在啄食。确实是神仙世界的情调，但是，轿中的皇帝脸色并不好<br>跟随的王都尉，为了排遣皇帝的心情而搭话<br>“到底是什么奇迹呢？要是让智真长老也来看看，说不定能改变他的心意呢”<br>“长老已经停止饮食数日，一心念着文殊菩萨，已经到了无法站立的地步”<br>“那么，不远了……”<br>即使皇帝亲自劝说，智真长老也拒绝改宗，他憔悴的样子给了天生感性的皇帝以强烈的冲击<br>自打那天起，皇帝就一直为噩梦所困扰<br>智真长老的背后，冲天的文殊菩萨站了起来，目光炯炯如雷，就这么注视着皇帝<br>（朕，究竟错了什么？）<br>但是今天，如果能看到“奇迹”的话，说不定能解开自己心中疑惑</p><p>队伍正在行进着<br>银树在草丛中爬着，无论如何也要接近皇帝的轿子<br>（即使被杀也无妨）<br>周遭的树枝正刺着银树<br>她突然从草丛中跳出，推开护卫，向轿子飞奔而去<br>“请马上停止废佛，救救大家！”</p><p><img src="/upload/pasted-235.png" alt="upload successful"><br>周围护卫马上反应过来，抓住了银树，把她按在地上，情况突然有变，曹晟拔出剑来，守卫们把银树压在一旁，给轿子开路<br>“陛下，请继续上路吧”<br>皇帝拨开珠帘，露出脸来<br>“什么情况，那女孩是什么人”<br>“也不知是哪里疯掉的乞丐……”<br>皇帝瞥见了正在被按倒在地的女儿的脸，王都尉也觉得很可疑，轿子就这样从银树身边经过<br>银树想放声大喊，但是喉咙犹如堵住了一般发不出声音，银树哭了起来，一边哭一边哇哇的叫着<br>轿子渐行渐远<br>突然停了下来<br>皇帝从轿子中惊奇的看着银树</p><p><img src="/upload/pasted-236.png" alt="upload successful"><br>“是金奴吗？！”</p><p><img src="/upload/pasted-237.png" alt="upload successful"><br>最吃惊的还是银树——金奴自己<br>感到冷寂的十年时光一瞬间散开了，后宫中母亲微笑的脸，父亲抚摸头发的手<br>晴朗的天空，回响着一个声音<br>“……父皇！”<br>皇帝用龙袍擦干女儿脸上的泪水，露出了和去世皇后一模一样的脸<br>皇帝怀抱着抽泣的女儿，望着天空<br>“‘奇迹’说的就是这个吧”</p><hr><p>傍晚时候，东京的郭道士赶紧派人向林灵素汇报了情况<br>结果就是，皇帝并没有看见林灵素精心安排的“奇迹”，却把十年未见的女儿带回了宫中，之后的情况也不清楚了<br>但是知道的情况就是，王都尉，宿元景等“反废佛派”的大臣被召见，因反对废佛而被罢免的蔡京也被招了回来<br>（“法难”就这样结束了吗？）<br>郭道士望着夕阳<br>（不，他们已经来不及了）<br>最后的战斗恐怕已经开始了，或者说已经结束了<br>人少的僧侣们是不可能取胜的<br>（和尚们被全灭，结果还是“废佛”）</p><p><img src="/upload/pasted-238.png" alt="upload successful"><br>与此同时，夕阳也将伊水染成了金色，由于夏季河枯，水量少，它反射着太阳的光辉，显得更加美丽<br>但是，这一带的空气却被杀伐的战尘包围着<br>龙门的僧侣们吃完最后一餐没过多久，林灵素就率领着官军陆续抵达伊水河畔<br>官军在广阔的南岸布阵，龙门石窟建在伊水两岸，卢遮那佛所在的北岸聚集着主要的石窟。僧侣们固守的也是这个北岸。<br>最后的僧侣向龙门进发的消息很早就到了林灵素耳朵里，他在等着全部的僧侣聚集到龙门，如果“叛军”人数较少的话，即使全歼，也没什么意思<br>林灵素打算渡过伊水，直攻北岸<br>龙门石窟是著名的佛教圣地。作为佛法灭亡的舞台是无可挑剔的。而且，战后，作为“林灵素奇迹的圣地”，应该也会名留青史吧。<br>“那些节度使，已经指望不上了”<br>林灵素很得意，除了一万五千个官军之外，还聚集手下亲信的道士，组成了名为“六甲神兵”的亲卫队，其中人戒着道袍，以铜剑为兵器，为了防止有奸细混入，这里只有有道观度牒身份明确的道士<br>“这也是一万五千人”<br>林灵素在手下的道士面前。骄傲的宣言道<br>“明天，就是大宋佛教存在的最后一天了”<br>也是自己成为这个国家的“神”的日子</p><hr><p>夜无声无息的深了下来<br>夜空的星星，不知是为战争的气息而战栗，还是感到人们的不安，总是不停地闪烁着。<br>星空之下，史进正掰着手指头盘算着<br>“敌人是三万，我们是三千……不”<br>在昏暗的灯光照耀下的石窟中<br>“能够上阵的也就两千”<br>石秀啃着作为供品留下来的水果。李忠向史进也扔了个果子。<br>“和尚们也未必都能战斗，也有很多伤员啊”<br>“我要战斗”<br>莫志断然的说道<br>“吐蕃的法僧，拉金帕尔马德鲁杰，用弓箭杀死了坚持废佛的王，挽救了佛法。他没有受到佛罚。而被誉为圣人。我也会战斗的”<br>灯油快烧完了，火苗飘忽不定的摇摆着，在这缥缈的灯火下，佛像的表情看上去很不可思议<br>此后，以金山大师为中心，召开了短暂的军师会议，分发了全部的兵器，战斗准备完毕后，史进最后去看望了彭尼<br>星空之下，石窟终于迎来了短暂的休息时间<br>彭尼和其他伤员一起被运进岩山上方的石窟。僧尼们用途中得到的一点草药，尽可能的治疗<br>史进单膝跪在躺倒在地的彭尼身边<br>彭尼很平静，不过脸却因为失血而显得很苍白，石窟墙壁上画着的阿弥陀如来，供奉着红色的曼珠沙华。<br>彭尼注意到史进过来了，缓缓睁开眼睛<br>“真不好意思，这次不能战斗了”<br>史进扶起彭尼的身体</p><p><img src="/upload/pasted-239.png" alt="upload successful"><br>“你要是个男人的话，我们说不定会成为拜把子兄弟”<br>“我也这么觉得”<br>“还讨厌男人吗？”<br>彭尼仰望史进的脸，微微一笑。<br>“我本是樵夫的女儿。十三岁的时候，在山上，杀死了袭击父亲的猛虎，作为孝女受到了表扬……村里也立起了牌坊，知府就像列女传上所记载的那样，在朝廷上奏，但是，结果就是有个混蛋当官的要求‘把那孝女收做妾’罢了”<br>“所以就当了尼姑？”<br>彭尼把眼光转向了红花，花瓣被夜露打湿了<br>“救赎的是今生，还是来世？”<br>“的确啊，但是我只能帮助活着的人”<br>在没有颜色的石窟中，只有花朵娇艳的红色。两个人默默地凝视着花朵。<br>彭尼闭上眼睛喃喃道<br>“希望金奴公主能够幸福”<br>“原来如此，希望你也一样”<br>彭尼好像睡着一般，周围的尼姑们也开始默默的诵经祈祷<br>史进一出石窟，星光炯然。<br>也不知哪里的石窟传来了雕刻的声音，史进还没有找到王进，但是，他能感觉的到，师父就在身边<br>夜尽天明，最后的战斗就要开始了</p><hr><p>紫气东来，天已经亮了</p><p><img src="/upload/pasted-240.png" alt="upload successful"><br>黎明，本是一天中最具有生机的时候，也是充满喜悦的时候<br>太阳毫不吝啬的将阳光倾洒在伊水两岸的每一个身上，南岸的官军正在埋锅造饭，北岸的僧侣开始了诵经<br>不久，官军陆续抵达，填满了南岸的河岸，僧侣们诵经的声音在平静的波纹间静静的流淌着<br>庄严肃穆的诵经对于林灵素来说，是刺耳的杂音<br>“看来这些谋反的和尚已经有所觉悟了，赶快送他们上西天吧”<br>官军方面也很清楚自己是三万对阵和尚们的三千，他们悠然的向着河岸行进着，伊水由于夏季干枯，水量减少，很多地方水不是很深<br>“一口气跨过去！”<br>部队行进呐喊的声音一下子就把诵经的声音抹杀掉了<br>先锋是五千洛阳军队，后面跟着一万禁军<br>林灵素心情平静，虽说是“初阵”，尽管不知行军打仗的策略，但是手下有众多将军帐前听令，又有一万五千的“六甲神兵”护卫<br>这将是通向荣光的黎明<br>（东京，也事先准备了“奇迹”）<br>昨日，在东京的皇帝眼前，出现了和林灵素一模一样的“青华帝君”，同时也有“谋反已经被镇压”的捷报，相信不久，赞誉“通真达灵元妙先生”的特使就要到了<br>（在敕使到达之前，必须结束这场战争。）<br>林灵素站在本阵的高台上，向前挥动着手中的拂尘</p><p><img src="/upload/pasted-241.png" alt="upload successful"><br>（占领石窟，竖起太极旗帜，拆了那卢遮那佛）</p><h1 id="下集预告"><a href="#下集预告" class="headerlink" title="下集预告"></a>下集预告</h1><p>第六章 月下天堂 预告</p><p><img src="/upload/pasted-242.png" alt="upload successful"><br>佛教最后的堡垒——龙门，此地将为最后的灭佛战场，官军三万对阵僧众三千<br>“末世降临了吗？”<br>龙门石窟前喊声震天<br>“九纹龙”史进，“花和尚”鲁智深等梁山众好汉战斗在最前线<br>准备趁乱夺取少林秘经《精武大宝经典》的“一块云”满天星也在盘算着<br>皇帝会听取“荣德公主”银树赌上性命的请求吗？<br>最后王进和史进师徒两个能否重逢？<br>以废佛为开端，道教和佛教的最终对决，最终取胜的，到底是——<br>《绘卷水浒传》20周年纪念企划，下回完结</p>]]></content>
      
      
      <categories>
          
          <category> 绘卷水浒传 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 绘卷水浒传 二十周年番外 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>绘卷水浒传 第一回 王进 翻译</title>
      <link href="/2019/03/12/%E6%B0%B4%E6%B5%92%E4%BC%A0-%E7%AC%AC%E4%B8%80%E5%9B%9E-%E7%8E%8B%E8%BF%9B-%E7%BF%BB%E8%AF%91/"/>
      <url>/2019/03/12/%E6%B0%B4%E6%B5%92%E4%BC%A0-%E7%AC%AC%E4%B8%80%E5%9B%9E-%E7%8E%8B%E8%BF%9B-%E7%BF%BB%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<p><img src="/upload/pasted-199.png" width="70%"><br><a id="more"></a></p><p><font color="#FF0000">原文作者 森下翠和插画作者 正子公也 版权所有<br><br>个人翻译<br><br>仅供个人娱乐及同好者欣赏<br></font><br><br><br><a href="http://suikoden.com/" target="_blank" rel="noopener">原文地址</a></p><hr><p><img src="/upload/pasted-136.png" alt="upload successful"></p><h1 id="第一回-王进"><a href="#第一回-王进" class="headerlink" title="第一回 王进"></a>第一回 王进</h1><p>茫茫黄沙间，走来一人<br>但见此人一身灰尘，头发凌乱，腰间挂着一柄长剑，如此而已，并无其他零碎，不时的看向远方，便低头接着赶路<br>太阳正当空<br>远处的树林传来蝉鸣<br>突然，这人停了下来</p><p><img src="/upload/pasted-137.png" alt="upload successful"><br>一个，两个……数到第十个人时，他下意识的拔出腰间的剑</p><p><img src="/upload/pasted-138.png" alt="upload successful"><br>“王进！”<br>干涸的大地上卷起的杀气，好像遮住了太阳一般<br>“觉悟吧！！”</p><p><img src="/upload/pasted-139.png" alt="upload successful"><br>飞扬的尘土中杀将出几人，片刻时间，此人已经干净利落的右出一刀，劈开一个敌人，尸体落在沙尘中，蝉鸣戛然而止<br>此人轻轻的垂下沾满鲜血的剑，伫立在杀气腾腾的包围圈中<br>这群刺客，大概有十四五个人，他们就围着此人，心里算着距离。尽管都有些身手，但也没有人贸然行动，盛夏的烈阳照在他们头上<br>此人的脸上滚过一滴汗珠<br>“就这么一个禁军教头……”<br>在要沸腾的空气中，此人——王进眯着眼睛<br>“到底值多少钱？”<br>剑开始动了，刺客们也行动起来，王进一弯身子，躲过了头上闪过的白刃，又反手出剑杀死了他，剑落下时一个拖刀又杀一人，他精准的砍向要害，招招毙命。面对更多的敌人，也是一击制敌，一点不拖泥带水。这是他长时间逃亡时学会的招式，不断的有剑刃逼近，暗出，还击，弹起，王进犹如死神附体般且战且停，不断的杀死着敌人</p><p><img src="/upload/pasted-140.png" alt="upload successful"><br>就这么战斗着，越发觉得手上的剑变得越来越重，顺手杀死背后袭来的敌人<br>就这样，也不知杀了多杀人，也不知还要杀多少人才能结束<br>这次战斗时间很长，以前从未有过<br>他的嗓子犹如着火一般，气喘吁吁着<br>一人一边叫喊着一边拿着长枪突杀过来，王进好像无法躲避一般，就在即将被刺中的一刹那出剑，砍向这人的腹部，由于这人反应迅速，本来要砍向鸠尾，却只砍到了肋骨，王进迅速扫到他，顺势骑在他身上，用身体的重量结果了他<br>颈椎破碎的声音，在远方微妙的回荡着<br>男人痉挛，停下了动作<br>王进用剑支撑着强站起身来<br>太阳愈发耀眼<br>尽管如此，热气消散后，背上却用一种毛骨悚然的冷颤<br>周围已经陈列着超过十具尸体<br>本以为终于结束了，却突然从角落里感到了什么，又重新拿起剑<br>只剩下一人了，似乎是这群刺客的领头人歪着脸笑了起来，他在远处望着手下们的死去，看着王进一点点体力不支<br>王进慢慢的转动脖子，低头看了眼手中的剑，剑上已经满是鲜血。他就这么站着，也没什么反应<br>（——终于要结束了吗？）<br>已经三年了，他已经逃亡了三年了<br>终于，走到这里，在这片无名的荒野丧命<br>赢了的，究竟是自己，还是“那个男人”——<br>刺客面无表情的握着剑<br>闪耀的太阳，太阳下反射阳光的刀刃，渗入王进的视野<br>突然听到起风了，风中夹杂着什么声音<br>好像有什么人呼唤着王进</p><p><img src="/upload/pasted-141.png" alt="upload successful"><br>应该还能打<br>他是这么想的<br>风在清吟着，王进只觉得自己轻飘飘的，好像长了翅膀飞起来一样<br>王进本想站起身来，看看谁在唤他<br>可身体却重重的摔在了黄土上</p><hr><p>浓雾之中，王进强站起身子<br>眼前白茫茫的犹如流水一般<br>本来想隔着雾看看远处，忽然听到什么细碎的声响，也不知从哪里滚过一个小东西</p><p><img src="/upload/pasted-154.png" alt="upload successful"><br>低头一看，那是个花绣球<br>王进伸出手，打算捡起那个滚到脚边的球<br>但是手无法动弹<br>雾气越来越深<br>不安感像波浪般涌来<br>不久昏暗就变成了黑暗，只有脚边的球奇异的亮着，王进呆呆的看着那个熠熠生辉，向有生命一样飞来飞去的球<br>突然，包围着王进的黑暗消散眼前突然浮现出刺眼的七色彩虹，锐利的光芒贯穿双眼<br>（住手……啊！）<br>王进猛的惊醒<br>发现自己躺在柔软的床上，傍晚柔和的夕阳正透过窗帘射进屋里，窗边插着一只野花<br>他听见了少女的声音<br>“大侠，您醒了吗？”<br>下意识的想要爬起来，右肩膀却突然疼了起来，裹着的布上渗出殷红的鲜血<br>枕边站着一位貌似是小间使的少女。少女服侍王进躺下后，对着庭院用快活的声音呼唤着。<br>“大老爷，客人醒了”<br>王进环视四周。<br>（这里……）<br>这个小客房配备了一些简单的家具，应当是在某个富庶人家，枕边的长桌上，放着王进的剑，但是已经被擦拭干净<br>门打开了，屋外是宽阔的庭院是，虽然是田舍的构造，但是已经经过了精细的装修，花绿相间，生机盎然，不久，花丛之间，出现了一个白胡子老人，看着大概六十多岁，是个面向温和的老人</p><p><img src="/upload/pasted-155.png" alt="upload successful"><br>“不要硬撑着”<br>想要从床上爬起身子的王进，被老人赶忙制止了<br>是个稳健，善良的老者，可王进还是无意识的估量着自己与剑的距离<br>老人自称是这华阴县史家村的村长，人们都称作史太公，好像颇有些资产<br>“老先生，您救了我？”<br>“不，是拙子救下了你”<br>“令郎？”<br>“唉，是个不争气的孩子啊”<br>老人一边这么说，一边笑了起来<br>“单字一个进，虽说是独生子，但从来不帮忙家事，只只由着自己的性子，真让人头疼，今天带着家丁出去打猎，偶然间遇上了大侠”<br>老人眯着眼睛点了点头<br>“被强盗袭击，真是不幸啊”<br>老人把椅子拉过来，坐在王进旁边<br>“一会让他过来跟您打个招呼，他身上刺着九条龙，那是我特地从城里找来的纹身师绣上去的，做的很漂亮，人们都叫他‘九纹龙’<br>王进答谢了老人，并告诉老人他本是客商，姓张，正打算去延安府做生意”<br>史太公大方的点了点头<br>“您现在身受重伤，哪也去不了了，还是养些时日，过后再上路”<br>“给您添麻烦了”<br>“要是招待不周的话，会被我那儿子数落的”<br>老人笑着走出房间<br>（看来通缉文书还没到这边）<br>王进取过剑，看了看刀刃还好，就抱着剑睡下了，这是他的习惯<br>怀中抱着剑，王进终于安下心来，把头托付给了枕头<br>院子里树梢上，有一只蝉悠闲地叫着。<br>蝴蝶懒洋洋地在盛开的五颜六色的花上飞去。<br>隐约的花香，混杂在风中<br>王进闭上眼睛，突然，悄悄的拔出剑<br>他听见了悄悄靠近的脚步声，紧紧的握着刀柄，调整了呼吸<br>进来的是一个端着碗的侍女，为了不让药汤撒出来，她慢慢的走过来<br>王进为了不让少女察觉，又把剑放了回去<br>“这药很苦”<br>少女把药汤送到王进的口边<br>王进慢慢地站起来，接过药汤。只是这么一动，全身就出现了尖锐的疼痛。<br>“疼吗？”<br>少女天真地注视着王进的脸<br>“还好——只是稍微有些疼而已。”<br>王进略微踌躇了一下，一口气喝干了药汤。</p><hr><p>已经歇息几日了，王进逐渐了解到这家本是农家，却有着侠义的家风。让来历不明的王进留在这里，并且热情款待，什么也不过问，可以说是很豪迈大气的家风了<br>史太公虽说儿子不久就会过来打招呼，可是丝毫没有那个迹象，王进却比较在意，如果救下了他，那就该知道王进不是什么商人，而那群人也不是什么盗贼<br>有一天，王进问了一个服侍他的侍女<br>“你家少爷，是个什么样的人？”<br>“这个……我不太清楚，因为他从来不跟女人说话”<br>侍女耸了耸肩<br>据侍女说，少爷是个很奇怪的人，和村中任何男人都不一样，一天到晚，只是挥刀弄棒，据说这还不够，他还要四处找旅行的武者带回家，学习新的功夫<br>（原来如此）<br>王进了解了<br>对于武术如此狂热的“九纹龙”，应当对自己也有所期待<br>（但是，我没告诉任何人）<br>即使不知道理由，史太公也慷慨相待，进出房间的也只有侍女，从来没人问过王进的来历<br>秋风初起之际，王进的伤口明显愈合，恢复到站起来在院子里走路的程度。</p><p><img src="/upload/pasted-156.png" alt="upload successful"></p><p>中秋之夜<br>王进坐在皎洁的月光中，大概是三更时间。正房中的中秋宴会也已经结束了，院子里一下子变的静悄悄的<br>王进坐在床上，看着在地板上流淌的月光<br>王进慢慢拔出了剑，月光散落在被磨平的刀刃上，轻轻一挥，风在清吟，光在摇曳<br>在白银般的光芒中，他看见了血<br>他看见的，是至今已经倒下的追杀者的血，以及今后自己所流淌的血<br>也许是飘来一块云，屋中暗了下来<br>王进收起剑，扛起行李站了起来<br>伤的最严重的肩膀还没有痊愈，但是应该还能战斗吧<br>王进瞥了一眼收拾整齐的床铺，朝门走去，突然站住了，朝着熟悉的小房间看了看。院子里虫子在叫。<br>王进又回到屋中，把剑放在了床上<br>满是划痕的剑鞘，磨损的剑柄——那是王进如生命般宝贵的东西。不过，他也没有什么别的东西可以留下了<br>放下剑后，他来到院子中<br>因长期卧病在床而疲倦的身体，清凉的夜风让人心情舒畅<br>王进穿过树林，悄悄地走着，王进在安静的院子中寻找着大门，不久，停下了脚步<br>从什么地方传过来切开空气的声响，那是在拱形墙的深处的中庭里传来的，王进悄悄挨了上去，从围墙往院里看，透过云层的月光，浮现出几道黑色巨岩的影子，有一个白色的身影在岩石间跃动<br>这时，一阵凉风吹动了月亮上的云彩<br>射过来一道月光<br>王进不由的屏住呼吸<br><img src="/upload/pasted-157.png" alt="upload successful"></p><p><img src="/upload/pasted-158.png" alt="upload successful"><br>那是月光下跃动的龙<br>（“九纹龙”——）<br>那是个背上刺了九条龙，看上去不过十七八岁的年轻人，光着膀子，手上拿着一根齐眉棒子，九条龙犹如白玉一般在年轻人背后跃动着<br>（这就是——史进吗？）<br>每次一动，栩栩如生的龙就会飞跃起来，从身上升起的热气反射着月光，仿佛全身都闪耀着光芒。<br>王进驻足侧耳倾听棒子切断的风的轰鸣，注视着年轻人跳跃的样子。<br>只是，他皱着眉头<br>“……真可惜啊”</p><p><img src="/upload/pasted-159.png" alt="upload successful"><br>年轻人突然停了下来，慢慢的在月光中回过头来，眼睛有明显的敌意</p><p><img src="/upload/pasted-160.png" alt="upload successful"><br>“是谁？”<br>王进后悔自己说了话，本想就这样默默的离开，可年轻人若无其事的走向王进，反而挡在他的前面<br>“你刚才说啥？”<br>“动作很优美，但这不过是追求虚荣艺人的奇巧罢了”<br>“那你让我领教一下你的手段”<br>年轻人——史进拿起靠在墙上的棒子，向王进扔了出去。王进并没有理会，棒子打在王进的肩头，应声落地<br>“哼~”<br>史进手扶着腰，用冷漠的眼光瞥视了王进的肩膀。<br>“赢了受伤的人，也没什么可骄傲的啊”<br>“强大可不是用来骄傲的”<br>“你说什么？”<br>史进止步不前，回头一看，说时迟那时快，王进用鞋尖轻巧的挑起滚在地上的棒子，左手迅速抓住棒子，就那样朝着史进的脸上扔去，犹如有生命一般神速飞出的棒子，突然在距离史进鼻尖半寸的地方紧紧地止住了<br>“——去捡根棒子”<br>王进的低沉声音在月下回响。<br>史进凝视着王进的眼睛，弯下膝盖，捡起棒子<br>“来吧”<br>王进一下子收回了棒子，这次又向史进的肚子攻来，史进向后一倾，迅速躲开，不料王进马上用回转的棒子扫到了他的侧腹，史进无法承受那种速度，快速向后躲去，两人的距离比棒子的长度要稍大一些，因而，史进放松了警惕，准备起身攻击时，不想王进却迈出一步，手中的棒子也飞了出来<br>不会达到的吧</p><p><img src="/upload/pasted-161.png" alt="upload successful"><br>还在想着，棒子就打到了史进前胸，史进漂亮的躺倒在地<br>“‘飞龙登门’这样可以使棒子的长度当原来的两倍来用”<br>王进只是用两根手指夹住棒子的一寸，支撑着八尺多的棒子<br>史进凝视着王进的脸。<br>“你腰的位置太高了。集中精力于丹田，腰落下，依靠肚脐处的力量站着就好了”<br>王进淡淡的说着，把棒子放回了武器架。<br>“直觉也好，气魄也好。只要有合乎道理的排练技巧，就一定会变得更强”<br>“还能比你强吗？”<br>“啊？——那是一定”<br>“那么，可以收我为徒吗？”<br>史进站起身来，在玲珑的月光下，不情愿的行了徒弟礼<br>“我曾有过许多师父，但你是第一个让我感觉必须要拜为师父的”<br>王进抬头仰望月亮。<br>漆黑的天空皎洁的月亮既美丽又无情。<br>王进深深地叹了一口气。<br>“那么，首先别再叫‘你’了”<br>“我还不知道师父的真正名字”<br>“姓王，名——和你一样”</p><p><img src="/upload/pasted-162.png" alt="upload successful"><br>“王……进”</p><p><img src="/upload/pasted-163.png" alt="upload successful"><br>王进笑了起来<br>三年来第一次笑</p><hr><p>史进大吃一惊<br>史进看见王进正面打倒了十几个人，知道他的厉害。可是，作为师父，他的指导却和史进以前遇上的那些师父截然不同，不，在史进看来，这种教育方式并不是“指导”,以前的师父大多都是先传授华丽的“必杀技”和“绝招”，可是王进，别说招式，就连棒子也不让史进碰<br>把石头放在腹部训练腹肌；倒立，单脚站立；在院子中奔跑一整天，抬着水桶在圆木棒上走；也曾练过“筷子夹豆子”，右手在锅中夹起豆子，然后左手握住筷子放回去<br>起初史进也是默默的按照王进的命令做下去，但是一个月后，史进终于受不了了<br>那天，王进交给史进木头和小刀，让他刻龙，史进刻出来的却像蛇一样，莫名其妙的东西，又刻了一次，但是无论怎么刻都不成型<br>史进终于扔下木头，瞪着王进的脸<br>“我可不是为了干这个才认你为师的”<br>王进端详了史进一会<br>“那你去把棒子拿过来吧”<br>史进取来棒子后，王进说你做个样子看看，史进展示了几个拿手的招式，不一会，脸逐渐阴沉先来，撇下了棒子<br>“怎么了，继续啊”<br>“不行了”<br>史进抱怨道<br>“完全没有感觉了，一个月没碰，身体的感觉已经没了”<br>史进瞪着王进的脸，修行好几年的成果，仅仅一个月，就因为这种莫名其妙的训练废掉了<br>王进慢慢弯下腰，拾起棒子<br>“——这样就对了”<br>“你什么意思？”<br>王进向准备反驳的史进打了一棒，用的正是在中秋夜的那招“飞龙登门”，只是这次，史进不过后退了四五步而已，没有滚到一边<br>“腰力有些长进啊”<br>史进低头看自己的腹部，觉得好不可思议<br>“你究竟……”<br>“你问题太多了”<br>史进赶忙闭上了嘴<br>“你所谓的技巧，全都是习惯罢了，因为你以自己的方式掌握了诸多门派不同师父的技巧，如果不消除这个习惯，你是绝对不会变强的，所以我才说那样就对了”<br>王进继续说道<br>“首先要彻底掌握基本的身形”<br>王进开始演示基本三十二形，史进也在一旁模仿起来，无论哪个动作，乍一看都是基本的身法。王进对史进手腕和脚的位置进行了严格的修正。接下来是坐在椅子上练习二十四形，通常的棒术，都是为步战做准备的，可是，王进的流派却包含了马战。花了两个月的时间，史进终于掌握了全部的基本身形，可以开始对打形式的练习了</p><p><img src="/upload/pasted-174.png" alt="upload successful"><br>现在的史进，对自己很有信心，但是无论试多少次，史进的棒子都无法触及王进的一根毫毛，史进已经无数次的被王进击倒，一站起来，脚又被打，又摔倒了。尽管如此，史进也没有放弃，一天之内，被打倒数百次，即使全身都是伤，也还是默默的练习，在王进说好之前，即使被打的失去意识，也不会停歇，倒了一会后又站了起来，摇摇晃晃的，但那张脸却让人很感兴趣<br>（可笑的家伙）<br>王进坐在庭院的石头上，专心致志的看着已经初具形态的年轻人背后跃动的龙<br>雪悄悄的下了起来</p><hr><p><img src="/upload/pasted-175.png" alt="upload successful"><br>岁月转眼即逝，冬去春来，又是一年<br>对于王进来说，这是一个久违的平和的春节，元旦的早晨，身着盛装的史进来到王进身边致辞<br>这一年，史进已经十八岁了【看看人家十八岁，再想想自己-_-|||| 】，少年的身形和相貌一天天发生着改变，最大的变化则是武艺上的精进<br>史进是王进所看重“练武奇才”，尽管已经修炼多年，掌握了基本的招式，可他还是坚持了王进的高强度训练，史进也向王进展现了自身惊人的进步<br>不过，还是史进自己最为感到吃惊<br>起初，也是不知道自己该干什么，只是一味的模仿王进，但是，有一次，史进终于领悟了，棒子可不是以前认为的“物”,而是自己身体的一部分，从棒子到腕，胸，腰，足，零散的部位合为一体，自由自在的行动，不用太用力，就能比以前更快，出力更大，现在用起棒子来，就如同呼吸一般流畅自然<br>（师父毕竟不是一般人）<br>王进不仅擅长棒子，十八般兵器样样精通<br>除了棍子外，剑、枪、矛、戈、戟、鞭、简、弓、弩、斧、锤、链、扠，矛，白打，根据流派不同，着十八样技能成为十八般武艺<br>从正月开始，王进除了棒术外，也开始传授这些武艺，史进几乎一整天都在和王进训练，如果是一般人的话，即使是一样兵器也需要数年才能学成，但是现在，史进无论学习什么武艺都如同水渗沙子一般领悟的很透彻<br>不久已经是梅花盛开的时节，史进的武艺已经相当成熟了<br>今年庭院中红梅初开时，史进首次在练习中打中了王进的手腕<br>从开始练习已经四个月过去了，这是史进第一次打中王进，是真的第一次，史进大吃一惊，但是，比他更吃惊的是王进，史进飞升的速度，已经超过了王进的预想<br>正如史进第一次尝到武术的神秘一样，王进也第一次感觉到喜悦<br>一天傍晚<br>为了进行练习，王进总在院子中等着，可今天的史进却一副心神不定的样子<br>“怎么了？”<br>王进问道，史进从怀里取出一张纸，是华阴县县衙下发的通缉文书，写着抓捕少华山山贼的奖金<br>“头目三人，共值三千贯，他们可真的不值钱啊”<br>史进放下了通缉文书，拿起棒子练习起来，但是总是无法集中，王进察觉到了这一点<br>“你隐瞒什么了吗？”<br>“没有什么”<br>王进坐在庭院中的石头上，就那样看着史进，面对这种观望，史进最终从怀里又取出一份文书<br>“……是我吗？”<br>通缉文书上盖有东京开封府的章，有人的面孔特征和罪状，那张脸毫无疑问是王进的<br>“原禁军教头王进，犯有盗窃，杀人，欺诈，通奸……奖金已经增加到了五千贯吗？”<br>王进已经意识到是时候要离开了<br>王进将通缉文书还给史进，拂袖而去<br>“我已经没什么可以教你的了，明日便启程离开”<br>“我可不信这个文书”<br>史进跟在王进后面<br>“追杀师父的那些人，已经被我们埋在了树林里，剩下的一个大汉，也被我射杀了，因此，没人知道师父在这”<br>王进停下脚步<br>“为什么现在才告诉我？”<br>“我不想对师父做忘恩负义的事”<br>“你已经成器了”<br>“能教导你，实属荣幸”<br>史进从未见过王进如此平静，王进背对着史进，又重新回到远方，无名的不安感，冲到了史进的胸头<br>“——师父！！”<br>王进终未回头</p><hr><p>第二天早上，东方天空刚刚泛白之时，王进已经打点好行装，站在门口<br>初春大气清凉，星光闪耀<br>昨晚，他向在冬初染上风寒，至今仍未康复的史老太，侍女也过来送别，但是，却没有看见史进的身影<br>（心里不痛快吗？）<br>王进微微一笑，快步离开了宅邸<br>过了一会儿，路边的树荫下出现了人影。王进手持剑，快步奔跑<br>“师父，我也跟你一同去”</p><p><img src="/upload/pasted-177.png" alt="upload successful"><br>史进出现了，他拿着棒子，提着行李，也是一身准备出远门的行装<br>“你也想让人追杀吗？”<br>王进冷冷的说道<br>“通缉书上描述的罪状，我一点也不相信，师父不会做那些无聊的事的”<br>王进脸上笼罩着阴影<br>“那么，我到底做了什么，你知道吗？”<br>面对王进不寻常的声音，史进停下了要迈出的脚步。</p><hr><p>王进徐徐道来<br>那是在距今十几年前的时候，那是王进和现在的史进同龄<br>王进也有个师父<br>名叫王升<br>并没有血缘关系<br>王升是王家棍法的第三十六代传人，王家棍法并不是为世人所知晓，因为继承者大多隐姓埋名，打着别家流派的幌子，暗中从弟子中选出一人传承<br>正确的叫法应该是王家春秋棍法，据说起源于春秋末期的乱世。棒法是枪尖被敌人砍掉时，为了继续战斗而诞生的武术。没有刃的武器，可以保护身体，但不能杀人。<br>可是，王家的棍法打出的却是取人性命的招式<br>如果正是天下太平，那么就要把这种必杀技传承给正确的人，他们不问血缘关系，只是从王姓人中选一个人品能力都很优秀的人作为传承者，王进就是被选中的，也是“奇才”<br>“王进啊”</p><p><img src="/upload/pasted-180.png" alt="upload successful"><br>在昏暗的武馆中，老师父对王进说道<br>“已经没有什么可以教你的了”<br>那是王进已经完成所有修行的日子<br>“你现在已经比我强多了，过去的三十五个徒弟，恐怕比他们任何一个人都要厉害。但是，这种强大对你来说却是危险，这种强大折磨着你，恐怕会毁掉我们王家棍法”<br>王进默默的低下头，他被禁止和武馆其他的同辈对决，只能和老师父一起修行，即使是这位老师父，和王进对决不过三胜一，王进即使被说强，也没有感觉<br>“你的使命是传承，为了应对接下来的乱世，传承王家棍法，不要去战斗——你可千万要谨慎而行啊”<br>当王进成为第三十七代传人后，王升好像完成使命一样，不久离开了人世<br>之后，王进成为了禁军教头，所谓禁军，是指直属于皇帝的亲军，进入枪棒班进行教授，是为了生计，也是为了寻找下一个继承人。王进教的大多是下级士兵，是贫困人家的次子，三子，很多都是只会炫耀本领的流氓，能够继承王家棍法的人，怎么找也找不到，也并不是，只有一个“奇才”，可这人姓林不姓王<br>王进按照他的方式热心的教导他，心中却空落落的，就这样，一天天的过着<br>不知不觉，王进就把继承人的事给忘了<br>那是某年春天<br>王进完成公务，正要回家时，看见桥边人山人海，人海之内，传来年轻人欢乐的笑声，好像在进行着什么比试，王进家在桥对面，无意间拨开人群，走到近前<br>在桥上，五六个年轻人围着圈站着，都是有钱人家的纨绔子弟，在他们之间，一个球飞来飞去。原来是在玩蹴鞠，只用脚，且能保证球不落地的传递，是最近流行的玩法，踢皮球的招式也很多，飞起来踢，反身踢<br>为了玩而妨碍人们过桥，这群人真是很烦啊，还有人们怎么不过去呢，也是不可思议。这样想着，王进上了桥<br>年轻人一直在踢球，王进又发现一件不可思议的事，有老人的哭泣声混杂在年轻人的声音中，近前一看，才知道理由，年轻人间，有个老人在地上打滚<br>王进也曾见过，是街边唱小曲的瞎老头，已经八十多岁了，衣服破破烂烂的，总是在桥栏杆旁坐着，王进也曾给过好几次钱，也不知老头从哪里学来的一手风雅的胡琴<br>有五六个年轻人在欺负老人，踢着皮球打老人，头是十分，脚是二分，他们在比看谁踢的分数高<br>王进走上前去。伸出胳膊，一把抓住了球<br>“如果你们是在闲的没事干的话，就该去学武，皮球不过儿戏，不是男人该学的”<br>“你又是什么东西啊？”<br>王进无视年轻人，把球扔进了河里，卖唱的老人一边哭一边爬到栏杆边，王进本想直接过桥走了，一扭脸，一个球飞了过来，王进一把用棍子把球打在一边<br>踢这脚球的，是一个鼻子略大，眼神让人厌恶的年轻人，大概比王进年轻几岁，一边咬着橄榄，一边慢慢接近王进</p><p><img src="/upload/pasted-181.png" alt="upload successful"><br>“是耍棍子的吗？”<br>男人说着，被抢去球的年轻人围上前去<br>“大哥”<br>“你们给我滚一边去”<br>男人把橄榄扔了，王进迎着男人险恶的目光，他和其他人明显不同<br>“这些是你的手下吗？请不要在做这种事了”<br>“大家只是痛快的踢了几脚球罢了，只是头脑不太清醒”<br>“你们在这里踢，大家过不了桥，而且，那个老人很可怜”<br>“那个老头？”<br>那人哼着鼻子嘲笑道<br>“那我付钱还不行？”<br>“你道歉吧”<br>王进指着靠着栏杆卖唱的老人<br>“道歉？”<br>男人一听来劲了<br>“你跟我说道歉了吗？”<br>手下们哄堂大笑<br>“我昨天揍了我爹三拳都没道歉”<br>男人向手下们努了努下巴，转过身去<br>“走了走了，完全没兴致了”<br>“慢着”<br>王进把手按在这个人的肩上，就在那一瞬间，那人顺手超起栏杆边的棍子，嗖的转了一下，甩开了王进的手，王进意识到这个人速度很快，退过身去，取过棒子。男人扭头笑了<br>以此为号，这群人开始袭击王进，手持棍子，一起打来，王进棒子一闪，扫倒右手边三人，还用手推倒了左手边的四人，王进的棒子宛如活过来一般，击中年轻人的要害，手下们在桥上相继昏倒。这不过是一瞬间发生的事。</p><p><img src="/upload/pasted-182.png" alt="upload successful"><br>王进跨过倒在地下的喽啰，一鼓作气的打了过来，又轻又快，而且，是毫不留情的冷酷打法，是在纵情于痛打对手，彰显自己厉害的，除了在武馆中学到的技巧外，又加入了自己的个人风格。<br>好久没和别人打过了，在武馆时，他从未和王升以外的人对决过，私下的格斗也被严令禁止，现在是禁军教头，也不会个手下的士兵战斗，好久都没有战斗了——不，应该说是第一次，而且，对方是个陌生人，也不知会采取什么样的战斗方式，在十合，二十合的战斗过程中，王进感到了一种不可思议的浮游感【东北话说叫飘了】，一股巨大的力量，从王进到棒，从棒到王进，一直涌现着，此时他心中已经无他，只有全力以赴的战斗<br>王进自己也不知道，不知不觉的展现了自己真正的实力<br>老师父说王进很强，但是，从未和别人对决过的却浑然不知，但是王进现在却感觉到了，包围全身的热气一下子高涨起来，源源不断的集中在棒上<br>那个时候，王进发现了真正的自己<br>那个人倒在桥上，王进的棒子指着那人的眉间，以棒子为中心的区域一点点青肿起来，如果晚一下停下来，那人大概会脑浆迸溅吧<br>那人呆呆的睁着眼睛，愣愣不动，因为吓得失禁，衣服已经湿透了<br><img src="/upload/pasted-196.png" alt="upload successful"><br>人们远离两人，屏住呼吸注视着，这时，王进第一次意识到自己在笑。没有发出声音，只有脸在笑。王进感到恐怖。深深地吸气，吐出。于是，他揪起男子的领子，向老人的地方拖去。<br>“谢罪”<br>自己的声音，听起来像是别人的一样<br>“——对，对不起”<br>那人呻吟地说。然后被手下们带走了。本来，那人想赶走那些想帮助他的手下们，但他已经站不起来了。<br>王进过了桥，回到了家<br>那天晚上，王进想起了老师父亲的话。于是，为了不再用棒子伤害别人，他强烈地告诫自己。<br>王进的日常生活过得很平静。不久时光流逝，桥上的事不知不觉忘记了，那伙泼皮和受伤的老人，也再也没有见过<br>他每天去禁军校场，教导手下新兵武艺，照顾老母的起居生活，就这样过着每一天，要说遇上的不寻常的事，大概就是皇帝驾崩，新皇帝登基，就这样一年后<br>有天，因母亲卧病在床，王进向上级报假，上午，有通报的士兵前来，说是在王进请假期间，他所属的殿帅府的最高长官——殿帅府的太尉换人了，今天是新太尉的就职典礼，说是只有王进没有到，因为新太尉下了命令，又派人来接，王母对犹豫不决的王进说<br>“去吧，新的太尉大人，一定找你有要事”<br>“但是，母亲……”<br>“昨晚做梦，梦见有条龙下到我们的屋顶，一定是好是的”<br>王进煮了药，服侍母亲吃完就去了。殿帅府的庭院中，各级将校整齐的站列着，王进鞠了一躬，打算进入禁军教头的队列，却被左右士兵扭倒在地，被束缚的王进抬不起头，低头跪在那里。<br>遥远的正堂内传来声音<br>“王进吗？”<br>是冷淡的声音<br>“为什么不来本帅的就职典礼”<br>“我已经请过假了，母亲生病了——”<br>“本帅怎么不知道？”<br>当时有很多士兵，官员在场，但是一片冷寂，没人敢为他出头辩解<br>“教头是负有培养对天下有用士兵的重大责任，是奠定军队基础的重要任务，本帅看了你的工作表，结果都是请假，工作态度也不认真，教出的士兵也一无是处，比起其他的教头，成绩也非常差，你这是怠慢值守的重罪”<br>王进懵了，这个新太尉为什么会这么说，简直莫名其妙<br>“我事先请过假了，母亲生病了——”<br>“就算士兵打败仗，也要怪你娘的病吗？”<br>“那是……”<br>“你这厮不该全身心的教导士兵吗？”<br>王进无语了<br>“你这厮如此狂妄，领着国家的俸禄，却不做人事，左右，与我痛打他几十大板”<br>王进不由分说的就被拉下石阶，被杖打着，浑身上下都挨着痛打，这种杖罚，三十下就会失去意识，一百下就会被活活打死，王进受了四五十下，浑身是血，莫名其妙的望着堂中的太尉<br>想要求救，但是没说出口</p><p><img src="/upload/pasted-197.png" alt="upload successful"><br>王进第一次看到新任太尉的脸，那张脸和以前在桥上痛打的那个泼皮长得一模一样<br>在沾满鲜血的视线中，那人露出与当时一样的笑容。<br>王进确认自己注意到的时候，没有发出声音，只是动着嘴低声私语。<br>“谢罪吧”</p><hr><p>史进震惊了<br>“怎么这厮就成了太尉了？”<br>王进也是后来从被人那里知道了来龙去脉<br>新太尉叫高俅，就是当年在开封的那个泼皮无赖，不过，当时本叫高毬，因为其擅长蹴鞠，踢得一手好球。后来他因为四处欺诈被放逐出开封城，不允许入城，不过，这也是他的契机<br>有一天偶然去了一家酒楼，偶然遇上了一个意气相投的贵人，那个贵人喜欢有特长的人，看见高毬会蹴鞠，就很喜欢。于是就招高毬当个侍从，本来他也是个善于来事的人，很快就深受主人的新任<br>就这么有一天，他的主子有幸迎娶皇帝的女儿——公主为妻，成为驸马，后来一天他和主人一同去端王——一个年轻皇子的宅邸，这位皇子是个爱玩的人，还有个外号叫做“浪子”，那一阵子对蹴鞠特别感兴趣，正巧高俅他们过去时，看见端王正在蹴鞠，也是偶然，球就向着高毬飞过来了，高毬轻巧的接住球，又华丽的把球踢出，秀了一段球技，这位皇子也是从未见过<br>“踢得漂亮！”<br>端王很喜欢高俅，便请求把他留在身边，高毬很快就成了端王最亲近的宠臣<br>最近，高毬又把毬改成了俅<br>端王是皇帝的异母弟弟，但是因为母亲身份很低，几年前刚刚被册封为王，也是没有什么事情的皇子，过着悠闲的生活，但是，因为哥哥宋哲宗年仅二十五岁就驾崩了，又没有儿子，于是命运突变，端王就成了皇帝<br>端王才二十岁，本来就没想当皇帝，还是“浪子”的天性，就像平常发礼物一样，宠臣一个接一个获得了高官厚禄，对于最中意的宠臣高俅，他的赏赐就是禁军的统帅——殿帅府太尉<br>这也改变了王进命运<br>高俅并未忘记当年的王进<br>此时，王进已经被打昏在地<br>这个时候，都教头张彻【林冲的岳父】从教头的队伍中站了出来，他头发和胡子都已经斑白，是个沉默寡言的军人，他的严格治军，不说禁军中，就是开封也人人知晓。面对高俅，老将静静的低下头说：</p><p><img src="/upload/pasted-198.png" alt="upload successful"></p><p>“今天是太尉到任的大喜日子，不宜在公堂之上流血，还请太尉三思”<br>面对这种说话的风格，沉静的腔调，高俅眼中责备的眼光消失了，人们也纷纷抓住机会，为王进求情<br>“啊，好吧，就依着你们，不要坏了本帅的大事”<br>高俅摸着胡子，深深的坐在椅子上<br>“今天给你们个面子吧。”<br>高求满足地注视着为王进求情的人们。<br>王进在张彻和众弟子的扶持下回家了<br>张彻让众弟子回去，告诉了因为背上的重伤而无法躺下的王进，高俅是怎么成了太尉的<br>“你怕是以前什么时候得罪了那厮，那人尖酸刻薄，你最终会被杀的”<br>王进说了自己和高俅的遭遇<br>房间的角落中，王母低声哭泣着<br>不久，一个弟子回来了。张彻低声问道。<br>“什么情况？”<br>“有两个人在”<br>门前有两个士兵<br>“应当是那厮派来监视的”<br>张彻点了点头，向王进进言到<br>“赶快逃命吧”<br>张彻从怀里拿出布包，让王进握在手里。里面有一些银子。实际上王进和张彻不过是同事，平常只是点头之交罢了。<br>“张教头，你这是？”<br>“你的棒法出众，可惜了”<br>凝视的双眼让王进不禁想起了师父王升</p><hr><p><img src="/upload/pasted-199.png" alt="upload successful"><br>凌晨时，王进趁机杀死了监视的两个人，城门打开的同时，和母亲骑着马逃离了开封<br>也就是从那天起，王进开始了他的逃亡之旅<br>高俅因此更加记恨王进，不断的提高赏金抓拿他<br>“你埋在树林里的那些人，就是想要拿下我的赏金猎人”<br>王进凝视着史进的脸<br>“我的罪过，就是当年打了一个泼皮，就这些事”</p><p><img src="/upload/pasted-200.png" alt="upload successful"><br>比起从脚下爬上来的冷气，那声音更冷，更沉重<br>患病的母亲不到半年就死在了安旅篮的角落。埋葬在连名字都不知道的山的松树根下，王进在墓前，立起了自己贴身的棒子，作为王家棍法的传承者，他也埋葬了作为禁军教头的自己<br>“看到高俅的脸的时候……我，爬上去谢罪说不定就行了。但是，没能做到。所以，我选择了逃走。从今以后也只能──继续逃避”<br>王进转过头去，又开始了自己的逃亡之旅<br>“被这么个混蛋缠上，也是无能为力啊”<br>“——师父”<br>王进渐行渐远<br>“师父！！”<br>“史进啊”<br>王进背过身去，用强大，温和的声音呼唤着史进<br>“我要感谢你，不管如何，有你这么徒弟，即使最终被人杀掉，我也能此生无憾，含笑九泉了”</p><p><img src="/upload/pasted-201.png" alt="upload successful"><br>王进其实也不能雕刻出木龙，那是他摒弃以前的自己，是否有能力收徒的最后测试，只有天真无邪，从无到有的人才能成为传承者，史进也不能雕刻出木龙，那是王进已经削好上好的木材，一切准备妥当，却在快要完成的时候不得不作罢<br>但是，王升把武功传给王进，而王进又把武功传给史进<br>曾经，王升无法雕刻出龙<br>但是，现在的话——<br>仰望星空，王进静静的微笑了<br>然后，在黑暗中沉没的黎明之路上，加快步伐，一路向北</p>]]></content>
      
      
      <categories>
          
          <category> 绘卷水浒传 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 绘卷水浒传 正篇 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>绘卷水浒传 20周年企划 第四章 翻译</title>
      <link href="/2019/03/06/%E6%B0%B4%E6%B5%92%E4%BC%A0-20%E5%91%A8%E5%B9%B4%E4%BC%81%E5%88%92-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BF%BB%E8%AF%91/"/>
      <url>/2019/03/06/%E6%B0%B4%E6%B5%92%E4%BC%A0-20%E5%91%A8%E5%B9%B4%E4%BC%81%E5%88%92-%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E7%BF%BB%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<p><img src="/upload/pasted-114.png" width="70%"></p><a id="more"></a><hr><p><font color="#FF0000">原文作者 森下翠和插画作者 正子公也 版权所有<br><br>个人翻译<br><br>仅供个人娱乐及同好者欣赏<br></font><br><br><br><a href="http://suikoden.com/" target="_blank" rel="noopener">原文地址</a></p><hr><h1 id="第四章-地狱罗汉"><a href="#第四章-地狱罗汉" class="headerlink" title="第四章 地狱罗汉"></a>第四章 地狱罗汉</h1><p>洛阳，是一座大都市<br>曾经是许多代王朝的首都，虽时有战乱之煎熬，但闻名的精华却脉脉不断的成长着，尽管不及西都长安的繁华富裕，可她那清雅的姿态是其他城市所不能企及的<br>佛教繁盛时，洛阳曾有“千寻塔”之称，但是现在，城内到处都是自以为是的道士<br>道观多了起来，强改为道观的寺院也多了起来，甚至酒楼，妓院，瓦市等游乐场所也多了起来。道士们漫步其中，阔步向前<br>其中金冠道士们更是飞黄腾达，他们是“通真达灵元妙先生”林灵素挑选出的嫡传弟子<br>今夜，洛阳城中心的大酒楼“大汉楼”也聚集着这些金冠道士，有一张不满的脸孔，冷眼旁观着。一众道士围着一个年轻道士<br>“喂，郭京啊，“通真达灵元妙先生”中意你，所以你大概知道吧，林教主为什么把那么一个穷酸道士安排在身边呢？”<br>嘴上蓄着漂亮胡须的年轻道士摇了摇头<br>“这个，我也完全不明白”<br>“如果连你也不知道，那就更奇怪了，说起来，咱们怎么突然来洛阳？”<br>道士们把目光转向了里屋的客厅<br>深屋之内，林灵素与一个怪道士面对而坐<br>“接下来怎么办？”<br>林灵素很焦急的样子，用好像被什么紧紧抓住的声音说道<br>“好不容易才把这些反对废佛的和尚聚集在少林寺，却也不顺利”<br>林灵素是为了少林寺的灭亡——即“道教的大胜利”，从东京而来<br>发出假的檄文，把反抗的和尚聚集在少林寺。这是林灵素的计谋，以此为契机，一举将这些反对者消灭<br>“这样一来，废佛之事就算完成了，世上也当全为道教的颜色，因废佛之功绩，我也会成为宋的唯一国师，荣华富贵，应有尽有”<br>但是，少林寺在初战时却击退官军，严守山林，封锁要道。嵩山地势险要，洛阳军队也停下了进攻的脚步，只剩下数日的对峙<br>因宇文将军战死，正都指挥使上阵了，不过，他本来就不想打这场战争，他声称要耗尽敌人的粮草再一举攻克，于是没有采取任何进攻行动。少林寺本来就是靠山吃山，自给自足，在此期间，朝廷内的反佛势力也慢慢削弱<br>“没办法了吗？”<br>坐在林灵素面前的是一个戴着兜帽的怪人，也不知其来历，就成了拉青牛嚼子的仆人。在那场斗法大战中出现了降雨的怪相，以天子为首的人们都认为这是林灵素的法术，但实际上他没有那个法力<br>也是那个时候，林灵素知道那个丑陋的仆人才是“真人”，从此以礼相待<br>但是，怪人沉吟不语<br>林灵素皱起眉头<br>（虽说有点用处，但实在是让人觉得恶心，说不定他打算……总之不能不提防他）<br>林灵素也算是身经百战的道士，年幼就被送进了佛寺，但是他受不了严酷的修行出奔了，此后进入道观，成为了一个有名道士的弟子，不过他主修的是“魔术”——欺骗大众的障眼法<br>（到最后还是这些伎俩最有利于处事）<br>地板崩塌是因为事先挖了坑，流血泪的神像则是事先安排了猪血，仙鹤也是事先准备好的<br>（真的有“术”吗？）<br>“相信我”<br>小声品酒的怪人，用咕嘟咕嘟的声音嘟囔着。</p><p><img src="/upload/pasted-102.png" alt="upload successful"><br>“信则成”<br>然后，破布下的双眼，锐利的注视着门的方向<br>门开了，一个美丽的小间使拿着铫子进来了<br>“是这屋的客官要添酒吗”<br>微笑之后，小间使感到了屋中异样的氛围，突然变了脸色，接着说弄错房间了，急忙关上门跑掉了</p><p>小巧的身影轻快的登上楼梯，滑进了“大汉楼”最上层的房间，虽然很小，但却是最奢华的单间，是高官贵族们密会的地方，今天这里，有一个美女正用玉杯饮酒<br>“——是猫儿吗”<br>化装成小间使的猫儿把带来的铫子献给了主人慕容贵妃。<br>“没错，那人正是林灵素，还带着个可疑的道士”<br>“那是谁”<br>“不清楚，但是眼神缥缈不定”<br>在陈列着美酒佳肴的客厅中，慕容贵妃和几名侍女在等着猫儿的回报，慕容贵妃享受着这种奢华，委身于铺满长椅的丝绸被褥中，窗户边琉璃色的香炉燃着高香<br>猫儿的鼻子很灵敏<br>“贵妃，这香味是？”<br>“很怀念吧，这是从红菊中提炼出的味道，也是突然想起了后宫的生活啊”<br>“马上就可以回到那种生活了”<br>贵妃用鼻子止住了猫儿说的话<br>“那个小姑娘——金奴离开少林寺了吗？”<br>“没有，我本以为在开战前就会下山的……还没有”<br>“当时在尼姑庵的时候，稍微收拾一下就好了，没有找到她的住处”<br>慕容贵妃懊悔的饮尽杯中酒<br>“那个金山大师还巧妙的把她藏了起来，王皇后，王都尉，太子以及公主……这些王家的人，都在妨碍我”<br>“还有那个老婆的预言，请您放心，一有机会猫儿就会收拾她”<br>“你是我心腹之人的第一弟子，可你师傅‘白骨猫’却背叛我们逃跑了，你是忠心之人吗？”<br>“养育身为孤儿的我的，是贵妃大人，这份恩情，即使牺牲性命——”<br>“好了，那就把那扇门打开吧”<br>猫儿一开门，林灵素一个人站在那里。潇洒的道服被悬挂的灯笼照射着，给人一种仙人临世的感觉，那张嘴边，浮现着淡淡的笑容<br>“还在想怎么又是那个奇怪的小间使呢……哎呀哎呀，遇到贵人了”<br>林灵素关上身后的门<br>慕容贵妃的眼中泛起秋波，婉然的微笑着<br><img src="/upload/pasted-103.png" alt="upload successful"><br>“灵素啊，和我再会不觉得欣喜吗？”<br>“用一封可疑的信，把我唤到洛阳的，就是你吧”<br>林灵素用蜡烛把那封信点燃，信上只写了一手诗<br>“很怀念吧，那首诗是你过去写给我的”<br>“不要幼稚了”<br>“那么，怎么不让陛下把孩子处理掉，本来是打了胎的……可那孩子现在是朝气蓬勃”<br>林灵素脸上的淡笑消失了，贵妃瞳孔中的秋波也消失了，这一对男女，就像摘掉面具一样，展现出他们原本的面孔<br>林灵素坐在椅子上，拿起贵妃喝酒的铫子，自饮自酌<br>“那么，有什么事吗？”<br>“我想告诉你一件好事”<br>林灵素为贵妃也倒了杯酒<br>“是你要返回宫中了吗？”<br>“我现在被朝廷追捕，已经是苟活的人了，已经没有什么野心了”<br>“你除了野心，大概也没别的东西了”<br>“你不也是一样吗？”<br>贵妃眯着眼睛，第一次真心的呵呵的笑了<br>“灵素啊，我知道你想攻下少林寺，除了东京的禁军，再把河南节度使王焕，太原节度使徐京的军队也招来，你来做统帅”，如果被那样的军队进攻，那少林寺就如沙子筑成的塔一般一催击垮，换句话说，那座山如果不是大军讨伐，是无法攻下的”<br>“调遣节度使，那可是个难题”<br>“为什么？”<br>“这些节度使是守卫边关的重要将领，和洛阳军的行动是划分开的，朝中也有反对派，各种各样的麻烦事，甚至宰相蔡京也反对废佛，与其说是担心佛教存亡，不如说是担心世间动荡不安的大臣也不少。即使是陛下，也并不是那么憎恨佛教”<br>“那么，就用幻术吧”<br>“什么样的幻术？”<br>“真是个迟钝的男人啊，关在东京监牢里的智真长老和少林寺的金山大师是莫逆之交，可现在这位金山大师却企图‘谋反’，召集少林寺的武僧，煽动全国百万的佛教徒，打算颠覆大宋，计划袭击东京开封”<br>林灵素思考起来，慕容贵妃有密谋的才能，他是最清楚的<br>“原来如此，但是陛下会相信吗？”<br>“你这家伙，真是让人着急啊，‘仙人传信’不是掌握在你手里吗？天书下凡，地上突然出现刻着‘金山谋反’的石板……历史上有不少先例吧，如果能镇压这场叛乱，必定能功成名就，成为武勋赫赫的救国英雄，定能获得国师以上的荣誉，也能凌驾于蔡京童贯之上”<br>“救国英雄——救世主吗？”<br>林灵素摸着胡子<br>“不错”<br>“可不要忘了我的恩情”<br>两人满脸笑意，干了杯中酒<br>“如果进展顺利，下一步就为你考虑‘仙人传信’”<br>“呵呵，我很期待啊”<br>猫儿伫立在房间的角落里，侧耳倾听着两人的对话。<br>（无论哪一边，估计都不是真心的啊）<br>猫儿忍住笑意，在配餐台上重新温热了冷却了的铫子<br>案子上的蜡烛周围，两只蛾像嬉戏一样飞舞着。</p><p><img src="/upload/pasted-104.png" alt="upload successful"></p><p>深夜，林灵素凭栏而望，目送贵妃一行人离去<br>（那个女人究竟什么目的）<br>马车之后，有一个黑影尾随着，这是林灵素派遣的密探<br>（但是，她还是一如既往的擅长‘诡计’啊）<br>林灵素返回房间，心腹郭道士正在待命<br>“通真达灵元妙先生，您的命令是？”<br>“——回东京”<br>林灵素在写一封密信的同时，在年轻弟子的耳边嘀咕着什么</p><p>数日之后，童贯受皇帝之命，下令两节度使王焕徐京出征<br>皇帝从林灵素那里收到“少林寺谋反”的神谕的秘信，不过，他一度拒绝了调遣节度使的请求，大臣们也是极力谏言先要调查此事再做决断<br>但是，同一天，皇帝在东京万岁山散步时，发现神木的树干上浮现出“金山叛”的字样，人们还在惊愕时，文字突然消失了——但是在场的人都看见那几个字<br>因此，皇帝终于下定决心，下达了讨伐少林寺的宣言<br>这个玄幻的“带话”，不过是“虫文字”——受林灵素之命的道士郭京，事先用蜂蜜在树干上写下文字，没人注意有虫子聚在那里</p><hr><p>那个夜晚，终于下了些小雨<br>薛永站在哨岗上。官军虽然围堵了嵩山的出入口，但这边防守坚固，看不见官军的进攻<br>雨越发的大了，他到了有屋顶的监视小屋，在地上铺的破布上，太白团成一团。薛永走进屋里，太白只是抬了抬眼皮，银树蜷着身子熟睡着<br>战斗以来，即使尼姑们阻拦，她也要待在薛永身边<br>山间夜晚很冷，薛永把肩上的布盖在银树身上<br>银树微微睁开双眼<br>“把你吵醒了啊”<br>“……谈谈薛永你吧”<br>银树裹在布里低声私语<br>“我？”<br>银树点了点头，睡意朦胧地闭上了眼睛。伸出的手指紧紧抓住薛永的下摆。<br>“薛永是在哪里出生，又是怎样活下来的呢……快说！”<br>“我……我出生在洛阳，祖父是一名出色的武官。可是，不善处世，被上司疏远，被罢黜了。我父亲不能做官，开始做生意了，但是失败了，破产了。家人都离散了，我的家已经没有了”<br>“这样就成了艺人了吗？”<br>“那时，讨债人只给我剩了一根棒子，我走投无路，就在那洛水畔坐着，这时，有只又瘦又脏的小狗靠近我的膝盖，我抱着小狗回到街上，模仿着人家卖艺，赚到了自己的第一桶金”<br>“那是太白吗？”<br>银树用双手抱住太白的脸，皱巴巴的鼻子贴近脸颊，银树看上去就像个年幼的孩子<br>“你真幸福啊——你”<br>雨敲打着屋顶。在这个广阔的世界里，只有这里才是安全的巢穴。银树又开始静静的入睡了<br>（一定要守护她）</p><p><img src="/upload/pasted-105.png" alt="upload successful"><br>在一切的伤害中——<br>也不知能不能做到，薛永感到很不安，他知道自己既没有史进的那一身武艺，也没有石秀的胆量<br>（索性带她上梁山）<br>突然出现了那个名字，薛永也觉得很吃惊<br>大宋朝廷和“贼寇”梁山泊是不共戴天的敌人，怎么说也是不能把堂堂大宋的公主带上梁山的<br>薛永屏住呼吸，注视着银树的侧颜<br>不知不觉雨已停歇，轻微的月光透过窗子，静静的照耀着两人</p><p>雨后，史进沿着泥泞的道路走向山腰的食堂<br>好久没有酒喝了，想喝上两碗<br>问了在井旁刷锅的小和尚，他指向了屋子那边<br>“水屋里，还有为客人准备的酒”<br>“我能喝一些吗？”<br>“可以啊，反正客人已经来不了了……”<br>小僧又开始刷锅<br>史进拿到酒后，无意看了深处的碗橱一眼<br>“喂，这是？”<br>小和尚拿着洗碗的锅进了屋，看见史进的手中，握着随意摆放在碗橱上的木雕龙<br>“啊，那是管灶台的木龙行者雕刻的，看，那边也有……有不少呢”<br>史进环视四周，确实，在灶台上，窗框角落处，放置着好几条龙，好像守护神一般，无论哪个，都栩栩如生，出神入化<br>史进想起了王进的手，王进身为武者，有纤细的手指和柔软的手掌，史进靠近小和尚<br>“那个行者是个什么样的人呢？善使棍棒？”<br>“大概不是吧，是个沉默寡言的人，只是坐在灶前刻着木头，五十多岁……也不知是何许人”<br>“那此人现在何处？”<br>“数月之前，突然走了，最近，好像有人看见他在龙门雕刻佛像……”<br>“龙门？那是什么地方？”<br>“您不知道吗？是有着雄伟石窟的寺院。在悬崖边上，雕刻着大佛像”<br>史进早已把喝酒的事抛在脑后，拿着木雕走出房间<br>雨后天空，月光皎洁<br>“龙门啊！”</p><p>黎明——<br>“少林寺谋反!”<br>正是那天早上，东京禁军，河南节度使老将王焕，太原节度使“徐京”共计五万大军出征的情报，被作为间谍在山外活动的王定六通报到少林寺</p><hr><p><img src="/upload/pasted-106.png" alt="upload successful"></p><p>已到黎明，仍然一片黑暗，有几个人悄悄的行动着<br>那是横穿荒野的街道旁的旅馆。后面是堤坝，下面是茶色的河流。<br>旅馆是两层建筑，而且还附有马厩，显得特别大，有人悄悄潜入角落的房间中，黑暗中，有女人在低声私语<br>“来了——请做好准备”<br>“这么早啊”<br>一个困倦的声音作答<br>“连夜赶来的吧，这么着急”<br>院子里一片喧哗。这里是郊外街道附近的驿站，是官员和军队主要使用的停歇换马的地方。门前吵闹起来的原因是运送货物的部队到达了这里。<br>“您们来的真早”<br>店家亲切地去迎接，把士兵们带到一楼的餐厅。<br>“马已经派人栓好了，请用餐吧”<br>餐厅早已准备好了酒菜，盛妆打扮的老板娘对着饥肠辘辘的士兵们温柔的劝酒<br>“都累了吧，赶快趁热吃吧”<br>老板娘把做好的饭菜端到士兵中间，士兵们争先恐后的喝酒吃菜<br>“多吃些，也喝些酒”<br>老板娘一边殷勤的服务着，一边听着士兵们的对话<br>“连夜赶路，可是累死了”<br>“没办法啊，这是急令”<br>“禁军已经集结完毕了吧，洛阳军加上东京禁军的人数是大概有三万吧……真是了不得啊，再加上节度使的军队，那少林寺就更不堪一击了”<br>这些事官军的辎重部队，是做各种杂事的地方杂兵“厢军”<br>“武器要多少有多少，在下一站换班，咱们加油吧”<br>“不过是真的太困了”<br>不一会士兵们相继昏倒，摔下椅子<br>屋里静悄悄的，不知哪里的门开了，传来粗壮厚实的男声<br>“完事了吗？‘小尉迟’？”<br>“可以了，过来搭把手”<br>旅店的主人——“小尉迟”孙新，跨过倒下的士兵，走了出去。端着饭菜的妻子顾大嫂也挽着袖子忙碌着</p><p><img src="/upload/pasted-107.png" alt="upload successful"></p><p>“小尉迟”孙新，梁山泊座次一百，他受哥哥“病尉迟”孙立传授，善用铁鞭，本是黑赌坊店家</p><p><img src="/upload/pasted-108.png" alt="upload successful"><br>其妻顾大嫂，座次一百零一，她是被唤做“母大虫”即雌虎的女中豪杰，撸起袖子干架的话，丈夫孙新自不必说，普通男人是不能与之较量的<br>孙新夫妇检查了辎重，大多是箭，枪，盔甲等装备，信号一发出，后面的堤坝上出现了几男人，把辎重都藏在了渔船中<br>划船的，是“立地太岁”阮小二</p><p><img src="/upload/pasted-109.png" alt="upload successful"><br>梁山泊座次第二十七，是梁山泊水军统领阮氏三雄的兄长，本是石碣村的渔民，年轻时总被人唤做“祸星”，阮小二巧妙的把那些辎重藏了起来<br>“那么，小二哥，之后就交给你了”<br>顾大嫂把做好的饭菜递给了阮小二<br>“我们走了，去找下一个猎物了”<br>阮小二拿起撸，茶色的水缓缓的流淌着，不由的让他想起了故乡石碣村<br>后面的船上，刚刚被顾大嫂叫醒的“玉幡竿”孟康无精打采的坐了起来<br><img src="/upload/pasted-110.png" alt="upload successful"><br>梁山泊座次七十位，船匠出身，善使高丽拳法，也曾坐船出海，远赴异国他乡，也是梁山泊的挖苦家，现在正对这条河流恶语相向<br>“这脏泥河，看一眼都觉得要倒霉”<br>“这是吴学究的命令，听得话总归是好事”<br>“行吧”<br>【<font color="#FF0000">注：以上两人已经在绘卷水浒正篇的方腊篇中双双阵亡，且死相异常的猎奇，且还被画了出来(ಥ_ಥ)</font>】<br>船要开了，孙新向他们道别<br>“到下一个码头，一定要到‘店’里去，新的情报应该到了”<br>吴用每掌握新的情报，都会发出新的指示，这个指示会通过信鸽，快马等各种手段传达。实际行动的人，完全不明白事态的发展<br>“‘走钢丝’啊，我又不是哪门子卖艺人”<br>孟康让手下人掌舵，靠在船边<br>天亮了，毒辣的朝霞，好像燃烧一般<br>孙新和顾大嫂收拾行李，离开了旅馆。<br>而被麻药麻翻的士兵们，醒来就会发现自己全省疼痛，被扔在荒郊野岭的屋子里<br>到那时，他们的辎重和马匹，早已离他们远去了<br>孟康闭上双眼<br>玄幻的旅店，不光是这里一个，最近，在大宋西部的各个地方，官军的各种辎重，都莫名其妙的没了，被盗的东西，大概是被梁山泊的人乔装打扮带到洛阳<br>人们默默地在荒凉干燥的黄土高原上前进。船逆流而上。<br>从天上鸟瞰，这些赶路的人，就像小河涓涓而流，汇入大江</p><hr><p>清晨的少林寺，被一片诵经和叹息声笼罩，被派往少林寺的官军，除了洛阳军外，再加上东京的禁军，两个节度使的部队，少说也有五万<br>“如此大军压境，即使是嵩山，也是无法坚守的”<br>被冠以“谋反”“叛贼”的污名，山中一片悲寂之感<br>“我们有什么过错，给国家带来灾祸的，还不是那些和奸臣结党的道士”<br>当天，也有想要逃出山的人，金山大师也并未加以阻挠，但是最终，尝试逃跑的人，又回来了<br>通往山脚的路，大小的参道，几乎全部被官军封锁<br>官军陆续集结，终于，“元帅”林灵素出现了，他们有神仙庇护——画着八卦太极的旗子已经遍布山脚，少林寺那边看的清清楚楚<br>史进也出来侦察，官兵数以万计，团团围在山脚<br>即便是如此令人绝望的情形，金山大师也没有一丝动摇</p><p>林灵素的驻营设在了李村的道观中。“通真达灵元妙先生”的到来，这边的道士也是竭尽全力的款待<br>林灵素悠然地坐在法座上<br>清净旁人的房间中，还有两个道士，一个是蓄着漂亮胡须的郭道士，还有一个头上裹着布的道士。郭道士刚从东京回来，东京据此不算遥远，而且洛阳和开封之间道路通畅，如果骑快马不过是半天左右的距离<br>郭道士完成了在东京的“重任”，意气风发的进行了回报<br>“按照您的吩咐，我已近全部完成了，由于童枢密使上奏，皇上立即派遣王焕，徐京两个节度使出征”<br>“好，干的不错”<br>在林灵素的道冠之下，隐藏着一个不小的伤疤，因家境贫寒，他在年幼时就被抛弃在了寺院，可是，他却染上了自私堕落的恶习，被长老用锡杖狠狠的教训了一顿，因此，他逃出寺院，为了复仇而成为一个道士，时至今日，伤疤处的疼痛，长久的怨念，他也不曾忘记<br>“军队集结完毕，就开始发动攻击吧”<br>如今，林灵素已经有了复仇的资本<br>“你们这些和尚，尽情的恐惧吧，现在开始，你们真正的‘法难’就要降临了”</p><hr><p>戴宗返回梁山泊</p><p><img src="/upload/pasted-111.png" alt="upload successful"></p><p>梁山泊座次二十位，是拥有“神行太保”之名的韦驮天。<br>只要脚上绑上甲马，就能日行八百里，因此，他正在收集东京周边的情报<br>聚义厅中，吴用常在此待命，接到通报后，宋江，朱武等人也聚集过来<br>“节度使已经发兵，此时的少林寺就如风中残烛一般”<br>听到戴宗的汇报，宋江满面愁容<br>“一般官军还好说，但是节度使的话就有些麻烦了，听说他们都是山贼出身，有些能耐，吴军师，咱们得赶快采取一些措施啊”<br>吴用沉默了一会儿。虽然吹入聚议厅的风很热，但白羽扇却没有动。<br>“林灵素、法难、慕容贵妃、节度使……如此多的人物聚集在一起，这也许是超乎想象的大阴谋”<br>吴用已经获悉慕容贵妃已成为辽国的走狗。<br>扇子开始动了<br>他命令待命的“铁扇子”宋清准备信鸽<br>“需要几只鸽子？”<br>“有几只用几只”<br>吴用已经开始动笔了</p><p>黄昏时刻，无数鸽子从聚义厅起飞出发<br>“对了，再补一手吧”<br>吴用想起来，立刻唤来“铁叫子”乐和</p><p><img src="/upload/pasted-112.png" alt="upload successful"><br>梁山泊座次第七十七位，是天下第一的歌者，一个有着天籁之声的年轻人<br>接到指示后乐和叹了口气<br>“去东京倒是没问题……让我来做吗？需要我做什么？”<br>“还是要靠你啊”<br>接着“锦豹子”杨林也被叫了上来</p><p><img src="/upload/pasted-113.png" alt="upload successful"><br>杨林座次五十一位，本是一说书人，和搭档乌鸦“小乌龙”执笔走天下，因此宋国自不必说，就连外国的地理，风俗他也清清楚楚。他记忆力超群，可以说过目不忘，而且说出来也是明明白白<br>【<font color="#FF0000">注：此人为绘卷水浒传的潜在作者，即绘卷水浒传可以说是他的回忆录</font>】<br>见杨林到了，吴用拿过一张地图<br>“洛阳周边，有可以以寡敌众的地方吗？”<br>“洛阳是古都，自古便战争不断，周边土地平坦，视野开阔，不依仗城池是不好打的”<br>“抱着死亡觉悟的僧众们，必定会坚守营寨的”<br>“这可是一出叫座的好戏了”<br>杨林想了一下，把手指放在了地图的一点<br>伊水之畔——龙门石窟<br>河边画着优美的大佛</p><hr><p>傍晚时分，少林寺<br>随着黑暗涌来，笼罩在少林寺上空的绝望愈加强烈<br>人们聚集在达摩堂那里，盼着金山大师能指出一条生路，金山大师从容不迫的姿态，就宛如发现光明一般<br>在智真长老被捕入狱，龙门大长老迁化的现在，只有金山大师是护法的导师，这个关键的夜晚，会有什么样的觉悟呢——人么在篝火下等待着<br>史进也混在人群当中<br>薛永和银树在一起，石秀，李忠等人也齐聚一堂<br>“张神剑”等雇佣兵聚集在别的地方，商量着善后的对策<br>他们也邀请了史进，不过史进拒绝了<br>（金山大师，接下来会怎么样啊）<br>他比较在意<br>史进的目光一直注视着大师<br>坐禅的大师，久久未动，一旁守护的天穹和尚，手持长棍，如隔扇佛一般伫立着<br>“——问诸位”<br>金山大师终于开口了<br>外面挤满了人，但达摩堂却安静下来<br>“非我问，是佛问，我们有三条路：其一，与官军作战，违犯不杀生戒堕落到地狱的轮回之道；其二，投降，改信道教，其三，不战不降，与伽蓝共入毁灭之道，是时候做出选择了”<br>顿时人声鼎沸<br>“官军是不可能接受投降的”<br>“殉教也可，这正是我等的信念啊”<br>达摩堂中充满了悲观绝望的声音，史进愤然道<br>“这样一来，正中了那林灵素的下怀，你们死了，那群腐败的道士举杯庆祝，不后悔吗？”<br>“那怎么办”<br>史进也哑口无言，银树突然向前<br>“路还有一条——逃”<br>僧侣们又开始吵闹起来<br>“原来是这样”<br>史进不禁笑了出来，看了石秀一眼<br>“石秀，你说怎么样”<br>“我虽厌恶逃跑，但就这么白白等死，我更不能接受”<br>“时迁”<br>时迁刚刚侦察归来<br>“是这样的，在西南的山脚下，看不到官军的身影。因为很险峻，没有路啊”<br>达摩堂里无数的眼睛，在摇曳的灯光中看着史进<br>“那就这样吧，那么我们——出逃吧”<br>一出门，正碰见“张神剑”等佣兵，“张神剑”越过敞开的门向金山大师抱拳<br>“事到如今，我们也帮不上什么忙了，也不能一直在这里待着”<br>然后向史进咨询了对策<br>“咱们摸着黑四处散去吧，如若你跟我们到甘肃，我们必定请你做个队长”<br>“我会考虑的，满天星，你怎么打算的”<br>满天星并没有从达摩堂中走出，而是站在门框边，尼姑们一边滚着念珠，一边痛苦流涕<br>“我……我不能弃她们而去”<br>即使是逃跑，也可能会死，但是没人想坐以待毙，无数双眼睛诉说着求生的欲望<br>无数的目光汇聚在金山大师身上，大师似乎在等着什么<br>“天穹，去把东西拿过来”<br>接到命令后，天穹从达摩像中取出一个小柜子，看那柜子，一个人可搬不动。一打开，溢出了金银<br>“这些是我寺的应急资金，就拿这些雇佣你们吧”<br>金山大师把箱子搬到“张神剑”他们面前<br>“我希望这座山里一人不留，让他们逃出生天”<br>只有在敌人集结完毕前逃走大家才能生存下去<br>佣兵们面面相觑，不久“张神剑”打头，一人一把的递送黄金，史进，满天星，石秀他们没拿<br>“我们可不算是‘工作’，应当算是发酒疯吧”<br>这样说着，史进谢绝了“张神剑”递来的钱<br>然后问金山大师<br>“有能够放下这么多人，还能抵御官军的地方吗？”<br>“只有一个地方”<br>“哪里？”<br>“龙门”<br>史进眼睛亮了起来，怀里抱着木龙道人雕刻的龙<br>“听说龙门有石窟？”<br>金山大师点点头<br>“那是北魏时代开凿的石窟寺院。以山为基，在河流前建造了的坚固地方，那本是古都长安洛阳发生变故时，僧众们所固守的要塞！”</p><hr><p>嵩山之上，星空闪耀<br>星空之下，六个男人并排站着</p><p><img src="/upload/pasted-114.png" alt="upload successful"><br>“大家都到齐了”<br>史进看着每个人的脸。石秀，薛永，李忠，陈达，杨春——都是老样子</p><p><img src="/upload/pasted-115.png" alt="upload successful"></p><p><img src="/upload/pasted-116.png" alt="upload successful"><br>陈达说道<br>“这不是很豪华的阵容吗？”<br>李忠把棒子抵在地上，一脸涩涩的望着院子内<br>他们安静地屏住气息，正准备逃离<br>调查山脚下官军情况的“满天星”又回来了。<br>“没有发现，大部分士兵都睡着了。”<br>人们趁着夜色，离开了大山。<br>塔林是历代僧侣的坟墓，有无数的塔林鳞次栉比。他们经过这里，沿着少溪河取道下参道，越过少室山就到了大路边。<br>僧尼们被分为几队，跟随“张神剑”等雇佣兵依次离开了寺庙。彭尼担任了尼姑们的护卫。<br>银树决定和金山大师一起去。彭尼手拿着心爱的大钺，向银树行了个礼。<br>“公主殿下，我先走一步”<br>“嗯”<br>银树看着彭尼的脸<br>“彭尼，一直以来谢谢你了”<br>彭尼惊讶的回头看着银树，银树笑了<br>“很快就能在龙门见面了”</p><p><img src="/upload/pasted-117.png" alt="upload successful"></p><p>月亮微微的照亮了他们的去路<br>在院内，金山大师留到了最后，为了欺骗官军<br>需要有敲钟的人，一开始，就有一个九十多岁高龄的老僧请求留到最后，但大师却把他和伤者一同安排撤离了<br>天穹和尚正带着年轻力壮的武僧搬运密藏经典和佛像，也是为了保护这些东西，就像白马寺的僧人把《四十二章经》运送到龙门一样，篝火熊熊的燃烧着，四周几乎无人，为了不让火熄灭，有两个人在添柴<br>金山大师所允许留下的，并不是真正的僧人，而是两个还了俗的人<br>在逃到此地的僧人中，有两个被唤做“心色清”、“神灵静”的僧人，被大家所厌恶，这两人本是一寺住持高僧，“心色清”却犯下了邪淫戒，“神灵静”犯下了偷盗戒。他们虽然被破门，但求佛的心灵仍然忍受法难之耻，奔赴此地<br>“金山大师啊，请赐予我们切断因果的缘由”<br>“心色清”右手无指尖，“心灵静”的独眼一片白浊。深知自己是罪孽深重的人就如此惩罚自己<br>即便如此，他们还是认为自己的罪行不会消失，只有为佛法而献身方能赎清自身罪过。</p><p>金山大师敲响了深夜的钟声<br>所有的人都已经离开，只剩下天穹和尚和史进的队伍，天穹和尚本打算和大师一起留守，但他不能违抗大师的命令<br>“——那么就出发去龙门了”<br>拜见了金山大师，天穹和尚和众高僧一起走了。莫志也向史进等人打了招呼，跟在后面。<br>这支部队由雇佣兵中留到最后的满天星担任护卫。<br>“大师打算和少林寺共同赴死吗？”<br>“满天星”回头看了看远离的少林寺。沉默寡言的天穹和尚没有回答，道路一片黑暗，异常凶险，已经没有回头路了，在龙门保护这些经典，佛像，就是他的修行<br>越过险峻的山岭后，下到南麓的斜面上，有一个被当地居民称为“佛掌角”的略宽阔的山脊。平安翻越过山的人们聚集在那里，要向龙门进发<br>护卫的“满天星”询问走在前面天穹和尚<br>“珍贵的经典都在这里了吗？”<br>“都在这里了”<br>就在这时，眼神好的莫志看见了远方点起的火<br>“那是什么情况”<br>在“佛掌脚”的方向，看见了火光<br>“难道是官军？”<br>突然，有人在背后袭击天穹和尚，背上的柜子掉到了地上<br>“‘满天星’你想干什么？”<br>发起攻击的正是满天星，跟随天穹的少林武僧立刻准备战斗，但是满天星早已拿起柜子跑出去好远<br>“难道，你？”</p><p><img src="/upload/pasted-118.png" alt="upload successful"><br>“只要拿到《精武大宝藏经》，少林寺对我就没有利用价值了，再见”<br>就这样背着柜子消失了，武僧们本打算追上去，但是，埋伏在“佛掌角”的官军已经开始了屠杀</p><hr><p>随着钟声的余韵消失，史进竖起了耳朵。<br>虽然觉得听到了什么，可嵩山的天空却沉吟不语<br>在香炉后闭目养神的李忠站起身来<br>“那么，我们也该出发了”<br>看到僧侣们已经撤离，他们也在盘算着出发时间，直到响起最后的钟声，他们都要尽力争取时间<br>大师刚刚敲响了最后的钟声，<br>好汉们行动起来<br>金山大师从钟楼上下来，走到史进他们身边<br>“去吧”<br>说的是史进所预想到的话<br>“大师，请和我们一同撤离吧”<br>金山大师手持般若雷，掷地有声<br>“一旦你们离开，我会让这里一片火海，即使夷为平地，也不会变成道观的”<br>大师一开始就做好了与少林寺共存亡的觉悟<br>寺院起火，肯定会让官兵误以为僧侣自杀，能推延他们的追进<br>史进并没有同意<br>为了让金山大师和银树也平安逃离，他们留到了最后，可是，大师却从篝火中拿起一根火把，沉默的走向达摩堂<br>石秀也催促着史进<br>“想死的人，就让他去死吧”<br>“不行！”<br>史进想追随大师。杨春抓住了他的手臂。杨春的目光注视着北麓。<br>“官军来了！”<br>官军的篝火登上大参道。起初像星星一样稀稀落落，数量逐渐增加，变成了一条火河。<br>“夜袭吗？”<br>听了史进的话，陈达摇了摇头<br>“唉，可是袭击正在包围的寡军，根本就没意义啊”<br>“那他们这是干什么？”<br>他们有种不祥的预感，把视线击中在了南侧的参道上，听见了声音<br>“——大师！”<br>那是被莫志搀扶的天穹和尚的声音<br>“‘佛掌角’有伏兵……满天星背叛我们了”</p><hr><p>“找不到……”<br>满天星一边听着四处凄惨的喊叫声，一边喃喃自语，他手持火把，在树林中检查柜子中的经典，找完最后一个柜子后，他面目狰狞，好像地狱的阿修罗一般<br>“根本就没有！”<br>满天星一脚踢翻散落在地上的经典<br>“《精武大宝藏经》不在这里！”<br>《精武大宝藏经》是一部被少林寺所秘藏的传说中的武术书，相传，读罢此书，将会拥有最高的武艺，因此有不少武者，或出家为僧，或偷偷潜入进入少林寺，企图获得《精武大宝藏经》，但最终都断绝了消息，不知所踪<br>满天星也是以法难为契机，混入了少林寺，也暗中给官军传信，告诉了他们僧侣们的逃脱地点<br>（《精武大宝藏经》到底在哪里？）<br>如果是珍贵的经典，肯定会被带出来的<br>（不过……）<br>满天星盯着四处火光的少林寺<br>正当这时，午夜的钟声响了<br>敲响这钟声的，就是那个金山大师<br>“是这样啊，为了自己的武艺天下第一，就亲自保护吗？”<br>那可不行——咬牙切齿的满天星，恢复了原本的端庄<br>然后，“一块云”满天星再一次消失在黑暗中</p><hr><p>被砍中肩膀的天穹和尚，血正在从身上披着的袈裟上渗出<br>不久，天微微亮了<br>嵩山最黑暗的时候也来临了<br>“——来了！”<br>石秀低声说道<br>陈达和杨春手持武器面向山门<br>黑暗中，如同火海般汹涌而来的，正是林灵素所率领的一万精锐禁军，目标是压制金山大师和少林寺<br>原本担心陷阱的官军的进军速度却加快了<br>，甲胄撞击的声音迫近，似乎连迸溅的火星也看到一清二楚。声势浩大犹如鲸鱼掀起的波涛<br>“砍下谋反者‘金山’的首级”<br>夜鸦从少林寺的屋顶成群的飞走<br>而且，从西南麓传来呼唤声,战斗的声音，悲鸣，微弱的诵经，很快就消失了。<br>退路有埋伏，正面是大军压境——大家都在望着金山大师<br>大师脱下袈裟，披在了因失血而颤抖的天穹和尚身上<br>“快跑——要抱着牺牲的觉悟”<br>【<font color="#FF0000">这金山大师是真的不地道啊orz<br>  </font>】<br>天穹和尚握住竖立在钟楼柱子上的般若雷，站了起来，猛地向破败的山门跑去<br>“大师，再见了，我总有一天还会重归净土的”<br>破戒僧“心色清”和“神灵静”两人也跑了起来，天穹和尚竭尽全力，用般若雷打碎了冲在前面的官兵的脑袋<br>天穹和尚就这样突入敌阵，面对正面的对抗，官军一瞬间胆怯了，但还是很快做出反击，”心色清”和”神灵静”一下就被砍倒了<br>“抓住金山！”<br>天穹和尚的背后，是烈火中熊熊燃烧的少林寺，他静静的矗立在参道上</p><p><img src="/upload/pasted-119.png" alt="upload successful"><br>“我就是金山！”</p><p>熊熊烈火，星光朦胧<br>金山大师正在钟楼和附近的建筑放火，急忙的向着山门反方向的南方赶去，这是通往僧侣们逃离的“佛掌角”的道路。<br>背后可以清晰的听到官兵的叫嚣<br>薛永牵着银树的手。那只手虽然像孩子一样纤细，但银树反握的力量很强。<br>薛永也紧握住银树的手</p><p>“佛掌角”和少林寺隔着一座山岭，其间是一片没有路的山林，如果设法进入山里，就不怕追兵了<br>以金山大师为首，一行人健步如飞<br>头上松籁喧嚣，脚下草丛密集。但是，长期在少林寺修行的大师却能看到看不见的道路<br>他们在山顶停顿片刻，遥望着焚烧少林寺的火焰。<br>被青白色的月光照耀着越过山峰，不经意间，眼下战场一览无余。<br>战斗的人遍地是，可是尸体的数量却更多，雇佣兵们，武僧们，护国禅师们，尸体遍布在这残酷的战场上<br>大师在月光下读着战报、<br>“敌人的数量是我们的三倍，这里已经是死地了，最终不过是全灭”<br>史进他们从斜面赶到战场<br>此处是少溪河被削出的山谷，在仅仅一小片平地上聚集了僧人和士兵。官军拦截着往下走的山谷出口，迅速地攻了进去，正如“佛掌台”的名字一样，道路贴在了手腕的位置，入口很小，官兵进军很难<br>武僧们的迎击也集中在了那一点，雇佣兵队长的“张神剑”正在积极布阵，防卫的主力是武僧和“白光尊师”等白衣护国禅僧。在位于“手指”的狭窄地带，尼姑和受伤者正在歇息<br>为了护卫尼姑们的彭尼，挥舞着大钺，挡住进发的敌军，此时已经全身受伤，脚又被枪击中<br>“彭尼！”<br>银树不禁叫出声来<br>薛永和银树一起赶到彭尼身边。李忠不知道要去哪里。是守护尼姑们，还是和僧侣们并肩战斗？薛永说道<br>“李忠大哥，我们守在这里即可”<br>“战斗异常残酷，但是，拜托你们了”<br>李忠环顾战场四周。史进冲到了防守的第一线，那里战斗最为激烈，那里正是凄惨的地狱，官军凭借人数蜂拥而至，南北少林的武僧们不断的向官兵发起攻击，他们的棍子和拳头上都沾满了鲜血，梵净寺的护国禅僧们抛开绳索，用锡杖戳倒官兵。“白光尊师”像幽鬼一样在空中，用锡杖打碎了敌人的脑门，一击一人，一刀三人。此时，“天三奇”本觉上人的身姿异样，巨大的身躯一动不动，护着周围的尼姑，徒手抓住攻上来的敌人的脖子，一击打断骨头，撕裂身体，双手迸溅的血液，滴落在上人的笑脸上<br>薛永用手掌挡住银树的眼睛<br>“不能看！”<br>这是一个修罗，恶鬼的世界<br>清廉的护国禅僧们，正是以前从漠北的监狱集体逃跑了的死刑犯们。笑容满面的本觉上人本是在江湖成为传说的杀手吗，这正是他们真正的样子，数年的修行犹如梦一场<br>官军陆续从街道上来。从通向龙门的街道到小路上到处都是敌人<br>正如大师所预想的那样，狭窄的“佛掌角”是无处可逃的，武僧，雇佣兵们和官兵肉搏，一个个的倒下，无法战斗的尼姑也无处可逃，一个个被杀<br>有不少人专挑着这些没有战斗力的人下手，薛永舞枪阻止着他们。棒子之类的东西是没用的，如果不能让敌人站不起来，就没什么意义了。银树也拔出剑来，可是，薛永却让她退到后面<br>银树不想杀人<br>薛永犹如鬼神一般战斗。平日温柔的青年的面容消失了，他的眼睛里不是——病虎，而是闪耀着野虎的光辉。</p><p><img src="/upload/pasted-120.png" alt="upload successful"></p><p>史进的注意力集中在通往街道的小路上<br>（走到街上，就能逃掉了）<br>只要离开这个死地，哪里都有退路可逃<br>注意到这一点的人们也跟着史进，帮助着他，护国禅僧开辟了一条道路，他们的白色外衣被染得通红。“白光尊师”头发和皮肤都染成了红色，最终战死在敌人的尸体上<br>本觉上人在将最后一个敌人劈成两半后，全身中枪而亡，那张脸，就像弥勒佛的笑颜。<br>史进在另一侧，放眼望去，密密麻麻的敌军，好像都涌向史进一样<br>“史进大哥！”<br>史进一边飞出了一支箭，一箭一人，他解除了被母亲封禁的双手，第一次射人<br>眼前突然浮现出母亲悲伤的脸。突然，他听到背后有悲鸣声，一回头，一个被彭尼砍翻的士兵倒在地上，银树还是无法杀人。彭尼和银树相拥，看着莫志。<br>莫志搭起下一只箭</p><p><img src="/upload/pasted-121.png" alt="upload successful"><br>“啊，我不是杀了你们……我是救赎了你们，救赎你们”<br>此时，史进仍然在战斗，没有停止前进<br>石秀也跟在史进身边，但是，史进觉得周围遍布敌人。碰撞身体的冲击，迸溅的火花，驱使着史进加速狂奔<br>面对无尽的敌人，向着更远方，加速奔跑。棍子打断了，就拾起了地上的枪<br>史进的每一击，都是致命的一击，一边跑着，一边打到五六十个敌人，开辟着前进的道路<br>就好像有王进在一旁一同战斗<br>“师父！”<br>打倒下一个敌人后，史进大叫<br>“史进，站住！”<br>陈达在呼唤他，但史进好像无视了一般<br>“无论如何也不能停下来啊”<br>陈达和杨春也追随着史进<br>天快亮了，也看不到战斗的结束<br>史进在前面带路，试图杀出一条血路，后面还跟着杨春，陈达，少林寺的武僧们。他们团结一致，把官军又推回了山脚<br>不久，他终于看见了后参道的入口<br>可以看到官军的篝火熊熊地燃烧着。<br>“不要冲出去，会被当成靶子！”<br>他也不听石秀的话，径直杀入敌阵，天已经开始亮了<br>官军埋没了视野，无论哪里都有官军<br>史进一个人突出，正跳进了当中。无论是陈达，还是杨春，谁也赶不上史进的势头。<br>官军的怒吼好像卷起旋涡一般<br>“终于来了，赶快灭了他们”<br>史进一瞬间被包围了。包围缩小，一圈长枪指着史进。<br>就在这时，史进周围突然发出了头骨崩裂的声音，宛如被大手拂过一般，一连五六个人倒下了<br>在史进的血雨朦胧的眼中，映出了巨大的僧形的身姿。</p><p><img src="/upload/pasted-122.png" alt="upload successful"><br>月亮渐渐沉入低空<br>金山大师站在那白色的光芒中，举着沾满鲜血的般若雷。</p><p>【<font color="#FF0000">下集 龙门决战 预告</font>】</p><p><img src="/upload/pasted-123.png" alt="upload successful"><br>命运六星，齐聚嵩山<br>“——走吧，出发到龙门”<br>龙门——那里是佛教的“圣地”。北魏时代，伊水岸建造了石窟寺院。<br>而且那里是佛教的“最后的堡垒”。<br>舞台到了决战之地——龙门！</p><p>独自一人，想要走自己的路的银树，她向着前方……<br>下章「龙门决战」，敬请期待！</p>]]></content>
      
      
      <categories>
          
          <category> 绘卷水浒传 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 绘卷水浒传 二十周年番外 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>绘卷水浒传 20周年企划 第三章 翻译</title>
      <link href="/2019/03/05/%E6%B0%B4%E6%B5%92%E4%BC%A0-20%E5%91%A8%E5%B9%B4%E4%BC%81%E5%88%92-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%BF%BB%E8%AF%91/"/>
      <url>/2019/03/05/%E6%B0%B4%E6%B5%92%E4%BC%A0-20%E5%91%A8%E5%B9%B4%E4%BC%81%E5%88%92-%E7%AC%AC%E4%B8%89%E7%AB%A0-%E7%BF%BB%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<p><img src="/upload/pasted-89.png" width="70%"><br><a id="more"></a></p><h1 id="第三章-少林战云"><a href="#第三章-少林战云" class="headerlink" title="第三章 少林战云"></a>第三章 少林战云</h1><hr><p><font color="#FF0000">原文作者 森下翠和插画作者 正子公也 版权所有<br><br>个人翻译<br><br>仅供个人娱乐及同好者欣赏<br></font><br><br><br><a href="http://suikoden.com/" target="_blank" rel="noopener">原文地址</a></p><hr><p>少林寺的夜晚。天上银河闪耀。<br><img src="/upload/pasted-80.png" alt="upload successful"><br>黎明前，薛永做了一个悲伤的梦，猛地惊醒了<br>即使醒来也没有梦的记忆，只是一个人，残留下来的寂寞，漂浮在胸口。<br>无意识地把手伸向地板，发现应该在那里睡觉的太白不见了。<br>小小的四阿天花板在星光下漂浮着【四阿：屋宇或棺椁四边的檐溜可使水从四面流下】<br>薛永为了不让同宿的史进和石秀起床，离开了代替卧铺的长椅<br>山上的夜气已经很冷了<br>走出房间后，地上的黯然和天上的星星，和着夜风一起涌向薛永<br>随风吹来的，还有敲击铁栅栏的锤声，少林寺并没有入睡，篝火在钟楼附近耸立，传来了人们来去的气息。这是为了应对官军的攻击。<br>听到了天穹和尚的声音<br>“要充分调动起那些能利用的人”<br>山脚下，有萤火虫般的光在乱舞。是官军的火把<br>战斗，也许会在早上打响吧<br>薛永摆脱了紧张的气氛，他向山上爬了一会儿。本以为岩石上并排着石佛，走近一看原来是数十个坐禅的瘦削和尚。<br>经过他们的搀扶，薛永又向前进了一步。<br>一种嘎啦嘎啦的不可思议的声音混入风中。薛永追寻过去，来到了竹林。但见伸向天空的竹子，随风摇曳，相互碰撞，发出幽玄的声音。<br>薛永倾听着风吹奏的竹子的旋律。<br>然后，不知为什么，薛永抬起头看了看竹林深处<br>林立的竹子对面，飘着一件白色的衣服。长长的黑发，在夜风中跳舞<br>看到她的侧脸，薛永也不知道那是谁。<br>竹子的枝叶像波浪一样纷乱<br>（银树——不，金奴公主）<br><img src="/upload/pasted-81.png" alt="upload successful"><br>但是，丝毫没有平日里那个活泼少女的样子，不是因为解开了平常的辫子，才看起来那样的<br>一种让人产生这样一种错觉:死了的皇后的高贵亡灵伫立在那里，环绕着银树的身体<br>薛永犹豫着是否要上前说话<br>最先注意到的是坐在银树脚下的太白<br>太白敲着鼻子，银树也转向了薛永。薛永艰难地向银树迈开了几步。银树注视着薛永。<br>“不冷吗？”<br>银树没有回答，只是摇摇头<br>自从银树的公主身份公开之后，银树的行为举止和以前有所不同。像孩子一样的天真无邪没有改变，但她的天真无邪反而让薛永感到迷惑<br>“我们回房间吧。我想彭尼一定会担心的。”<br>“我还想再待一会儿这里。”<br>声音和往常一样，薛永松了一口气。<br>两人站在高崖上。从悬崖上吹来的狂风，在竹林造成一片骚动。竹叶飞舞着，那另一端闪烁着星星。篝火在漆黑的夜空下燃烧着。<br>在即将面临毁灭的不稳定的世界中，两个人孤零零地并排站着。<br>薛永觉得应该说点什么<br>“因为你是公主……如果投靠官军，会保护你的”<br>银树微微一笑，薛永惊讶不已<br>“你不害怕吗？”<br>“为什么会害怕呢？”<br>“战斗马上就要开始了……”<br>即便是微风，也引起了竹梢也剧烈颤动<br>银树又向着夜空。目光远远地看着星星。<br>“这里和我成长的孤女峰很像。那里，真的只能看到山。只有山和天空。我总是一个人，眺望着从山上涌出的云彩。非常安静，整天侧耳倾听，只能听到风声、鸟鸣和佛经”<br>银树轻轻闭上眼睛，竹叶像小鸟一样飞来飞去。<br>“所以，我交了个‘朋友’。她是“银树”。银木犀的精灵，总是对我说。‘金奴，你没错。杀死母亲的不是你’”<br>薛永想起了彭尼所说的金奴公主的成长经历。<br>现在薛永所看到的，是受伤，被家人抛弃的孤独的少女——是‘银树’从未展现的金奴公主真正的样子<br>“那皇上呢？……你父亲不记得你吗？”<br>“父亲有六十个孩子。他一定连我的名字都不记得。即使记得，也不允许报仇。回到东京，我又被送到寺庙里，作为“杀害母亲的不吉之子”，被当做尼姑。读着佛经，上了年纪，被人遗忘，然后死去”<br>银树用纤细的手指压住飘动的头发<br>“我的愿望就是为母亲报仇。别无所求”<br>银树抬起头，笑了。<br>在凝视薛永的银树的大眼睛深处，星光闪烁<br>“我现在——现在很幸福”<br>大风吹过了。感觉就像风把银树绑在一起一样，薛永不由地抱住了银树。<br>银树小声说道<br>“如果不变强……不变的更强的话”<br>竹叶泠泠作响<br>这个安静的耳语，既像音乐，又像警钟</p><p><img src="/upload/pasted-82.png" alt="upload successful"></p><hr><p>清晨，在仍然昏暗的街道上，有两个人影向西行进着<br>前面打头的那个很壮大，后面跟着的那个细长细长的，在路边，好像是从某个寺庙里拿出来的佛像和经典被扔掉了。<br>“太过分了”<br>“活闪婆”王定六一边走，一边嚼着甜玉米。<br>“我说佛教和道教就像兄弟一样，嘛，佛教有点像兄长。现在居然是父母偏袒弟弟，让兄弟吵架”<br>王定六所说的“父母”就是朝廷。<br>如果寻求心灵的安息的话，那就去佛寺，追求现世利益，那就去道观，纵观历史，两者都有过被朝廷所压迫、成为暴乱的温床和作为国教受到保护的情况，“皇帝菩萨”梁武帝偏向佛教，举国倾斜。唐武宗受道士劝诱对丹药狂热，早逝。<br>“和尚也好，道士也好，在山里修行的时候都很好。一旦混在世俗中，就会想要跟普通人一样尝点甜头”<br>鲁智深默默地走在前面。两人结伴从东京出发，向西前进。两人虽然心知肚明，但说话的只有王定六。<br>“我知道啦，哥哥，你是和尚，不要救我啊……有恩的智真长老，救他吧”<br>而且──，王定六看了看满是灰尘的道路。<br>“我也知道。道士与现世利益、赚钱结缘。和尚说为了安乐地死去，就要舍弃这种欲望，不能喝酒，吃肉，赚钱，玩女人，安乐地死就满足了。据说，名叫释迦牟尼的人，舍弃了王子的身份和妻子，离开了家。就是凡人也难以接受”<br>途中，看到宣扬救济灵魂的僧人被扔石头，鲁智深也多次被道士缠住，苦于贫困的人们，因为道观捐赠的一点点钱和粥，所以道士们唯命是从。<br>“贪婪投机的和尚迅速转宗，抵抗的尽是认真修行的穷和尚……且慢，我懂了”<br>太阳升起，街道又开始充满活力<br>路边的树荫下，聚集着乞丐们。在小小的广场上出现了几家小摊子，可以看到吃早饭的旅人和艺人<br>乞丐们注意到了鲁智深，站起来低下了头，为了配合东京丐帮，全国的乞丐们都行动起来了【原文意思】，帮着收集情报<br>“智真长老情况如何”<br>“被关在朝廷的地下牢房里。据说由于拒绝改宗，而进行了绝食斗争，有传言说不久将会身亡，也有的说在这之前就会被杀”<br>鲁智深愤然地将禅杖立于地上。<br>“这样可不行”<br>“杀害高僧之事前所未闻，僧侣方面也容易引起反对。特别是河南自古以来佛教就十分盛行。和尚们抵抗废佛，很多寺庙被官军烧毁。残党聚集在少林寺，这将成为最后的抵抗——大家都在流传着这样的谣言”<br>王定六窥视了鲁智深的脸。<br>“哥哥，不用担心。少林寺都是武僧，已经习惯了‘战斗’。况且，如果史进找到了‘王教头’，那可就不简单了。”<br>“可是……”<br>牙齿脱落的乞丐驱散了肩头的苍蝇<br>“已经有一万大军包围了少林寺所在的嵩山”<br>鲁智深的眉毛一下子向上翘了起来。<br>“是哪里的军队？”<br>“西京洛阳”<br>“知道了，替洒家向河南的帮主道谢”<br>鲁智深扛着禅杖，大步走过抬着头的乞丐们。然后站在前面的旅馆前，蹲在地上吃饭的中年男子在前面。<br>中年男子一边用筷子夹着饭粒，一边望凝视着卖艺人挥舞棒子。<br>“山上是怎么吩咐的？”<br>听到鲁智深的声音，男子一边吃饭一边回头。这是鲁智深的一位老朋友，梁山泊的李忠</p><p><img src="/upload/pasted-83.png" alt="upload successful"><br>“打虎将”李忠——梁山泊位列的八十六位，曾作为卖艺人四处流浪，辗转各地，最终在桃花山上落草为寇，成了拥有五百手下的山大王。<br>“好怀念啊，不知不觉就看完了”<br>李忠捏着粘在下巴上的饭粒吃，懒洋洋地站了起来。然后从怀里拿出钱包，掏出几个银粒扔到卖艺人手里的笊篱里。<br>“哇，李忠难得的慷慨嘛”<br>“那个男人就像过去的我”<br>突然获得重赏的卖艺人，连礼节都忘了，茫然地站着。不幸沾染的脸上，比起喜悦，不安更浓<br>李忠把碗还给摊子上，在井边洗了脸<br>“山上的消息：枢密使童贯，向洛阳军发出了出征命令”<br>鲁智深瞪大了眼睛<br>“这是吴军师掌握的确切情报”<br>“人数是？”<br>“一万”<br>“这么多”<br>“反对废佛的和尚从全国汇集到少林寺。从朝廷的角度来看，如果放任不管的话，也会在民众间引发骚乱吧”<br>“话虽如此，动作还是很快的”<br>“吴军师觉得，这背后有黑手”<br>“是谁？”<br>“现在正在调查”<br>鲁智深一声呜咽，瞪着漫漫黄沙的道路远方<br>“不要演变成战争啊”<br>“不管少林寺的武僧有多强，终归还是僧侣。洛阳军是精锐之师。如果变成少林寺和官军的战争，胜败显而易见”<br>“如果少林寺败了，佛法就会从这个国家一扫而光”<br>智真长老的性命也保不住了<br>鲁智深的手掌上握着刻有达摩祖师的念珠。<br>“李忠，你先行出发去嵩山”<br>“要带什么话”<br>鲁智深扛起禅杖，迈向黄沙中。</p><p><img src="/upload/pasted-84.png" alt="upload successful"><br>“我会带着‘援军’前往，在这之前，请坚持住”</p><hr><p>同一早晨，烟雾缭绕的嵩山<br>佛寺的早晨向来很早。山脚被一万洛阳军包围的少林寺也不例外。<br>穿着破旧僧衣的老僧，朝着升起的朝阳开始诵经。那就是起床的信号。<br>史进醒来的时候，僧尼们已经洗完脸，结束了早上的坐禅和工作，开始准备早饭。<br>“好热闹啊”<br>史进打开窗户<br>隔壁有藏经塔，薛永在那前面教银树棒。银树的住处被安置在藏经塔里，彭尼和尼姑们紧跟着。<br>回头一看，石秀正在狭窄的地板上盖着被子睡觉。时迁作为侦察兵被指派到了金山大师那里，昨晚没有回来<br>史进猛吸了一口晨风<br>风中还混杂着烧焦的味道，煮饭的味道，不可思议的活力笼罩着少林寺。<br>史进为了伸展伸展，向朝霭中去了<br>银树似乎是第一次使用棒子，一本正经地模仿薛永的姿势<br>“身形很不错。薛永，你收了个得意弟子了”<br>薛永露出了暧昧的笑容<br>昨晚，银树说想学薛永的棒术。银树只会用剑。学习棒子，这样枪和长柄的武器也能使用了<br>“怎么样，薛永，这样正确吗”<br>重新扎起辫子的少女果然是薛永所认识的天真的王银树<br>尽管如此，总觉得他的笑容和昨天完全不同，薛永显得那么耀眼。</p><p>离开两人之后，史进向大雄宝殿走去，昨晚，史进他们因为太累很早就睡着了，可是彻夜都在梦中听到锤音<br>“——哇”<br>史进环视了院内。和昨天完全变了样子，一夜之间少林寺变成了“要塞”。<br>少林寺占地广阔，嵩山各处散布着大大小小的寺院。中心是昨天被烧毁的大雄殿，周围有很多御堂、佛塔、钟楼等<br>这一带被改造成“本营”。山门被封锁，参道上也建有障碍和栅栏。在佛塔上，有僧人监视着山脚下的官军，向全山传达命令的钟楼上守卫着强壮的武僧。<br>（真不愧是少林寺，果然名不虚传）<br>寺内来往的僧侣数量也在增加<br>（师父真的不在这里吗）<br>史进盯着擦肩而过的僧人。不仅是少林寺的武僧，其他宗派的僧尼也很多。是昨晚逃避官军的追踪，冒着生命危险逃往少林寺的人们。<br>少林寺本来寄宿着是由普陀山、九华山、庐山等反对本寺改宗的僧侣。这次，陕西和河南的僧人加入了。既有大慈恩寺、香积寺、长武昭仁寺等名刹的高僧，也有小村寺的住持<br>背后传来了快活的声音。<br>“史进大哥，早上好”<br>回头一看，莫志跑了过来。莫志昨晚进入少林寺，成为了天穹和尚的弟子，高兴地对史进说道<br>“天穷师父是金山大师的助手，我能成为他的弟子是一件非常光荣的事情。大师为了向白马寺表示敬意，特别照顾了我”<br> 广场的钟楼前，天穹和尚带着几个书记僧人，正在统计他寺的僧尼的名单<br>“这是金山大师的命令。要搞清楚从各个佛寺来了多少人”<br>“不管外表如何，都是很认真啊。那些家伙是？”<br>史进指着一群红衣僧人，<br>在众多的僧侣中，也是特别引人注目的一队。大概是准备早餐吧，双手提着水桶，头顶上放着装满蔬菜的笼子，轻快地走着。脚力很强，看得出来，也有些功夫。<br>“啊，那是南少林寺僧人。以前是与少林寺分开了的分派,不过，据说得知本山的危机，渡过了长江。在江南是有名的武斗派。不只是那个。瞧，用纯白的布包裹着全身的，是从西域的诸寺撒沙尘赶来的碧眼僧侣们。也有兴教寺的高丽僧、大福先寺和青龙寺的日本僧人”<br>史进凝视着异国的僧侣们，从看守塔里传来了声音。<br>“又有新的避难者到了”<br>被关闭的山门迅速打开，有二、三十个尼姑跑了进来。史进注意到了跑在前头的男人</p><p><img src="/upload/pasted-85.png" alt="upload successful"><br>护卫尼姑们的是拿着巨大刀的年轻俊俏青年。把黑发梳成一个漂亮的发型，虽然有武艺者风度，但是装束很潇洒，他在尼姑队伍的后面断后，帮着尼姑们进入山门，本以为要离开了，不想又背着一个掉队的老尼姑重新进来<br>“这就是全部了，关上山门吧！”<br>响起了有张力的美声。<br>“官军连‘小鹅岭口’也封锁了！”<br>青年收起刀后，对赶来的天穹和尚用优美的动作抱拳。<br>“我是后生‘一块云’满天星，在修行的途中，遇到了受苦受难的尼姑们，出于侠义之心，保护着他们一道赶来”<br>一丝不苟的仪表和姿态，只是，左手的无名指尖象被撕裂了一样地缺乏，成为唯一的一点缺憾。<br>“阿弥陀佛，多谢少侠出手相助”<br>天穷和尚答谢道，那些从汝州逃出来的尼姑们，也流着泪仰望着满天星。满天星谨慎地回应着,不过，注意到史进之后，他就过来打招呼<br>“同是武林中人？”<br>“只是路过而已”<br>“敢问阁下尊姓大名”<br>“只是无名之辈”<br>“为人谦逊啊”<br>满天星在凉爽的眼睛里浮现出高雅的笑容。<br>“那边是同伴吗？”<br>在满天星的指引下，史进将目光转向了院内的一角。</p><p><img src="/upload/pasted-86.png" alt="upload successful"><br>在栅栏之前，携带武器的男人们聚集着<br>在僧侣中，有发男子的身影十分显眼，史进也十分在意<br>确实是一群粗鲁的人，毫不客气的吃着配给的早饭，吃的到处都是。僧侣们合掌礼拜之后开始吃起粗粮，也有不满餐饭的人在烤着自己捕猎的野鸟<br>兴奋的莫志低声说道<br>“那些是四处来的镖客，雇佣兵，有传言说如果为少林寺而战，就能拿到很大一笔钱”<br>“赏钱？谁发的赏钱？”<br>“这好像是个‘秘密’”<br>莫志歪着头，有头发的男人大约有三百多人，青色战袍，表情严肃。为首的是一个嘴唇带有伤痕的男人<br>满天星好像对他们有印象<br>“那些人在江湖上有些名气，身穿蓝衣的是甘肃雇佣兵队长“神剑”张霸道，嘴唇受伤的是三门峡镖局大当家‘草上飞’律大谈”<br>据说无论哪个，都是附近有名的豪杰<br>“还有赏金猎人‘十年老’‘王铁子’‘黄再生’这些都是收人钱财，替人消灾的人……经常进出少林寺”<br>“啊，那样的话”<br>莫志回答<br>“跟你一样，他们也是既保卫僧侣，又带着信徒，真的好像在哪里收了钱一样”<br>背后传来了笑声<br>“啊，就连小白脸满天星也来了”<br>坐在大车后的是像乌鸦一样的二人组，满眼卑微，蜷着背窃笑着。莫志低声告诉史进<br>“那是咸阳做武器交易的，听说要打仗了，就来卖武器了，但是，大师好像并没有召见”<br>二人组的行李车上，各式各样的武器堆积如山。满天星也认识他们<br>“‘乌鸦嘴’和‘风凉话’还是生意兴隆吧”<br>“乌鸦嘴”净说不吉利的话，风凉话说着不负责的谣言<br>有争端的地方，就有这二人组，这两个也是在江湖上出了名的讨厌的人<br>“托您的福”<br>二人相视而笑，讽刺的笑着<br>“如果少林寺取胜的话，能拿到大笔钱是真的，动手要花多少钱，成功了要拿多少钱……不过，谁也不会说谁会出这笔钱”<br>满天星满脸通红<br>“我和他们不一样”<br>“啊，的确，少爷家里有些资产，只是想提高武名吗”<br>满天星不在理会二人，向史进解释道<br>“不好意思……我只是不能看到手无寸铁的尼姑被人迫害”<br>“咱们算是意气相投”<br>“愿结友”<br>“我是史进”<br>史进自报姓名后，聚集的男人们一齐回过头来</p><p><img src="/upload/pasted-87.png" alt="upload successful"><br>“史进？！”<br>“‘史进’，说起来——……”<br>赏金猎人“黄再生”歪着黄色浑浊得到单眼<br>“少华山的‘九纹龙’……现在是梁山泊的一个山贼头领”<br>“你看我像个山贼吗？”<br>“十年老”也用胡子遮住了一半的脸点头道<br>“像啊”<br>男人们直起腰，笑嘻嘻的围在史进周围<br>“王铁子”蹭进史进<br>“史进兄弟，能让我们拜见一下身后的九纹龙吗”<br>“拒绝”<br>“风凉话”插进话来<br>“要是纹着‘九纹龙’的话，那就值钱了”<br>“托你的福，我的伙伴‘史进’是五纹龙”<br>“我所知道的史进已经秃头了”<br>男人们叽叽喳喳的吵着，这时，石秀溜达过来了<br>“——从早上开始就很热闹啊”<br>“啊，真难为你石秀了，竟然起这么早”<br>“石秀！？”<br>男人们的眼神又变了</p><p><img src="/upload/pasted-88.png" alt="upload successful"><br>“‘不要命’的石秀？”<br>“史进，石秀？这地方真是卧虎藏龙”<br>“那边还有个美男子，那家伙应该是浪子燕青”<br>“很遗憾，他不是”<br>“那家伙叫薛永”<br>“王铁子”和“黄再生”互相对视，歪着头<br>“薛永，没听说过”<br>“你们真是无聊啊”<br>男人们哄堂大笑，异口同声也纷纷开始“自我介绍”。<br>“我是打虎的武松”<br>“及时雨宋江就是我”<br>男人们笑着拍着史进的背，回到了各自的地方。最后，“张神剑”好像有意思地笑了。<br>“我很喜欢‘史进’啊”<br>骚动平息了，石秀去拿早饭了。两个人在一起时，莫志拉着史进的袖子。<br>“对了，史进大哥，刚才我说，南少林的僧兵中……啊，回头见”<br>说到这里，莫志慌忙的走开了，石秀端着两碗饭回来了，只见大麦饭上，盖有豆腐木耳等素菜。石秀看了一眼满天星，把大麦饭交给史进，然后自己也开始吃了起来<br>“你也抓紧吃饭吧，今天会很忙的”<br>但是，史进一口都没有吃完，监视塔里传来喊声<br>“敌袭！！”<br>石秀一口气把饭扒拉干净<br>“这些家伙行动总是这么早啊”</p><hr><p>朝霞初起<br>史进等人面向钟楼，金山大师马上出现了</p><p><img src="/upload/pasted-89.png" alt="upload successful"><br>跟在身后的是少林寺的五百武僧，他们身着僧衣，手持长棍，其他寺院的僧人和雇佣兵也赶来了</p><p>众目睽睽之下的金山大师，看起来比昨天还要强壮。<br>“官军从‘西郭店口’向正面的大参道进攻。其数量大约为五千”<br>时迁和手脚灵活的僧侣回报，大师掌握了正确的情报<br>“必须保卫嵩山”<br>金山大师用强有力的声音向僧兵们宣告了迎击命令<br>“战争也是‘方便’，是引导众生的菩萨道”<br>然后他又把目光转向了准备出发的雇佣兵<br>“俗人啊，你们并非出家人，下山向官军投向吧”<br>佣兵们发出了不满的声音<br>“我们是帮你们的啊”<br>“张神剑”从佣兵中走出来<br>“在官军来看，我们就是护卫僧侣们的，现在已经不可能投降了”<br>“那你们就藏在山洞里，吃些饭吧”<br>金山大师以锐利的目光让男人们沉默，登上钟楼，然后两手举着“般若雷”，敲响了开山以来最大的大梵钟<br>“南无阿弥陀佛，诸师，精进吧”<br>冲在最前头的是身穿僧衣的少林武僧，他们挑起的根子像树林一样，朝着山门走去。赤衣的南少林僧人也接连不断，他们是体术的精锐<br>天穹和尚也光着身子，在肌肉强劲的胸部和背部，有着巨大的刀伤，天穹和尚手拿一根更粗的樫棒，他叫来了莫志<br>“年轻的弟子啊，我和随流本是守护金山大师的‘阿吽’【阿吽（梵a hu^m!）：‘阿’，是开口时首先发出的声音，为一切字、一切声的本源；‘吽’，是闭口时所发出的最后字音。因此此二字在密教中象征诸法的本初与终极。】，作为‘阿’的随流已经遁入轮回了，莫志，请上前”<br>天穹和尚把一组弓箭交给了莫志<br>“‘破烦宝弓宝箭’——要以此来保护好大师”</p><p>天穹率领着僧众走向山门<br>莫志手持弓箭奔回钟楼的广场，他山的僧人们也陆续集合过来，金山大师把银树叫了过来<br>“荣德公主，你下山去吧”<br>僧尼们必须为生存而战，但是银树没有守护少林寺的理由。<br>银树抬起头看金山大师的脸<br>“不”<br>银树回答的很清楚<br>“我也要和大家并肩作战”<br>金山大师回顾了少女清澈的眼神。天真烂漫的眼睛里隐藏着坚定的意志。<br>“但是……”<br>“请您不要担心”<br>银树对犹豫不决的金山大师微笑着去，指着旁边的薛永<br>“这个人会保护我”</p><p>僧兵们杀了出去<br>“史进大哥”<br>手持弓箭的莫志跑到史进身边<br>“接着刚才说的，南少林的僧兵中有一个被唤作‘王无伤’的枪棒高手”<br>“你说什么？”<br>“虽说从未受过伤，但是脸上有严重的伤痕，因为是有前科的人，所以也有传言他是故意为之”<br>“南少林寺吗？”<br>正好赤衣的僧兵们集结向山门走去，石秀抓住了想要追随而去的史进<br>“等等，一会再找人”<br>“少林寺的所有战斗力，都集结在这场战斗中”<br>是生是死，佛法是存在还是毁灭——他们坚信“人世终结”是必然的，人们的祈祷和恐惧交织在一起<br>其中心屹立的须弥山，就是金山大师【古印度神话中位于世界中心的山位于一小世界的中央（一千个一小世界称为一小千世界，一千个小千世界称为一中千世界，一千个中千世界为一大千世界，这就是“三千大千世界”的由来）】<br>金山大师迎着史进投来的目光<br>广场上回响着金山大师的声音<br>“金刚曼陀罗阵，起”</p><p>嵩山东西两山相连，东称太室山，西称少室山。少林寺是建于少室山五乳峰的寺院。参道在北侧，南侧是险峻的山和溪谷。官军用大军推进着正面的参道。<br>率领洛阳军的宇文将军是正直中年的将领，战争经验丰富，但是由于家世教低，常年身居“副”都指挥使，此次是因为正都指挥使不愿意出阵，才得到了机会<br>接到朝廷下达讨伐少林寺命令的正都指挥使，因自己虔诚信佛的祖母震怒不已，只好放弃了出征<br>马上的宇文将军是个无神论者，不信佛，不信道，只是凭借战功立于世的将军<br>“就算是少林寺的武僧，也不可能了解战争，僧侣们不好好的在寺庙中念经参禅，非要走出山门，胜负已定”<br>隔墙那边的少林寺山门已经开了，少林寺的僧人已经严阵以待了</p><p>战斗在清晨的参道展开了<br>几百年善男信女走过的路竟然成了战场<br>洛阳军本阵留了一半预备队，剩下五千人从正面蜂拥而至，弓兵在前，朝着跑下来的僧兵射箭，僧侣们也早已料到了这一手，拿着手里的门板和棍棒一边拨开乱箭，一边前进<br>那些动作整齐划一。从幼年时就和几十年同吃同住的同门师兄弟组建起来的，是一支稳健不乱的队伍<br>金山大师把其他僧众编成了6个队伍，即“四天王”“忉利天”“夜摩天”“兜率天”“乐变化天”“他化自在天”的六天部<br>率领先锋“四天王部”的是“吽”天穹和尚，队伍中是南少林的武僧，有一千人。传僧衣的僧人比一般的士兵行进速度更快，高举盾牌的僧侣犹如雪崩之势，两军在山腰上猛烈冲突<br>史进他们在钟楼上。钟楼在高处，可以眺望战场，成为金山大师的指挥台<br>（‘王无伤’在哪里）<br>众多的僧兵混杂在一起，找不到他<br>战斗异常激烈，僧侣们的棒术和拳法都很出色，但是由于他们要遵守不杀生戒，只是击倒敌人，折断其手臂，虽然僧兵们数量较少，但由于僧道狭窄，洛阳军无法展开，因此有一定的优势<br>终于，战在阵头的天穹和尚的棒子折断了。莫志马上想拿弓箭支援，但是，天穹和尚早已抛下棍子，张开双膝，轻轻的向前伸出双手，发出了尖锐的呐喊</p><p><img src="/upload/pasted-90.png" alt="upload successful"><br>只见逼近眼前的官兵飞起了一丈多高，以天穹和尚为首的少林僧人都是气功高手【真*气功】<br>南少林的僧兵们是拳术师，腿上功夫也很好。踢胸止住敌人呼吸，踢头使敌人昏迷，就在这群赤手空拳的僧兵中，只见一人手持长棍，在人群中挥舞着，一棍子下去，一棍子下去，聚集的官兵就犹如麦子一样被收割<br>（“王无伤”吗）【应该是王无双才对】<br>史进瞩目凝视着<br>官兵数量众多，前仆后继，僧兵们被打压着<br>寺院的僧侣们几乎都出动了，彭尼和薛永受命守卫寺院，银树也跟着他们，留下的只有史进，石秀，满天星等“俗人”，石秀握着刀<br>“我们也杀出去吧”<br>金山大师伸手一挡<br>“等一下”<br>史进听见覆盖山体的竹林沙沙作响，这是少林寺周边你远近闻名的竹林。绿叶上狂风呼啸——正如叶子般瘦削，剽悍的僧人们，从官兵头顶发动突袭</p><p><img src="/upload/pasted-91.png" alt="upload successful"><br>“第二阵——“忉利天部””<br>白衣僧侣们手握锡杖和绳索<br>“梵净山的‘护国禅僧’。是在超俗的秘境修行的幻之僧侣难得在人前露面的隐士，因法难降临红云金顶”<br>像风一样，像飞鸟一般的僧侣们，与其说是僧侣，倒不如说长得犹如隐士一般的容貌，却有着刺客一般的举止。他们从潜藏的竹林中飞出，锡杖声响起，官兵应声倒地，又用绳索将敌人的四肢捆绑起来<br>率领这只队伍的是“白光尊师”，眉毛睫毛都已经一片花白，是拥有晓眼的神僧<br>“济度众生”<br>动作快的令人目不暇接</p><p>面对僧兵们的抵抗，官兵们进展迟缓<br>“宇文将军，不能在前进了”<br>对于探子回报，宇文将军沉着的下达了下一个命令<br>“中军向前，从岔路出”<br>他们调查发现参道侧下有一个向南的急坡面，上面有着相当广阔的田地，从那里到山顶有工作用的专门小道<br>“就是践踏田地，也要夺走敌人的给养”<br>副将马上率领中军千人上前绕过参道开始爬斜坡收割庄稼，但是近前一看，并没有蔬菜田，只有在阳光照耀下显露茶色的山表面，原来，昨晚僧侣们早已收割了这块地。在那片泥洼的田地中，有一个和尚静静的躺着</p><p><img src="/upload/pasted-92.png" alt="upload successful"><br>形态酷似弥勒佛，是个胖乎乎的和尚，坦胸露腹，正打着瞌睡，在他身边，刚收割的作物堆积如山<br>“一个可疑的和尚，要小心啊”<br>“吓死人了，没有军力，就想唱‘空城计’来弥补。前进！！”<br>官军方面也了解少林寺有多少军力，如果把战斗力都集中在参道上，那么也就没有余力保护嵩山的其他道路了，这都是预料之中的<br>官军们蜂拥而至，大腹便便的和尚也站了起来，回到了寺庙，胖的和尚走的很慢，一边追的官军怒气冲天<br>“追上去吧，就能追到寺庙了”<br>士兵踏出的脚，踩在铺在地上的稻草和菜茎。一踩到底，下面竟然是陷阱，本以为有竹枪有刀——掉下去的士兵，没有想到有更大的惊喜迎接着他们<br>陷阱中是装满肥料的巨大肥料池<br>胖和尚回过头来，用手指着哈哈大笑<br>“厌秽欣净”<br>这个大胖和尚【不是鲁智深】，就是独自埋伏的“夜摩天部”。是从“天水的奇山”麦积山来访的“天三奇”本觉上人——一日三变的奇异怪僧<br>虽然可以将刀枪之类的锐器埋在陷阱底下，但是出于上人的菩提之心，那些锐器变成了金黄色肥料<br>中军只能避开恶臭的陷阱，沿着细长的农道排队前进。道路的前方，是通往寺庙的通用门。用圆木和石灯笼加固，墙内堆积着石头。环绕寺院的门、护墙的是“兜率天部”。由留在院内的老弱僧尼、小和尚们组成，由彭尼指挥。<br>敌人一逼近，守卫就会敲打木鱼。等待的寺院男子、小和尚、尼姑们就会向敌人扔石头。他们嘴里念佛，替换着举起手臂。<br>虽说是老僧尼，他们平时也是在打水、打扫、干农活等方面锻炼身体的，也同样装备着布和绳索制成的投石器。石头飞的很猛，官兵根本无法接近。薛永站在围墙上，目光炯炯地寻找着有没有薄弱的地方。彭尼手持大钺，精悍的侧脸，有着不顾杀生戒的气魄，她猛灌一口挂在腰上的葫芦酒<br>“我十三岁时，在山上杀死了袭击父亲的猛虎，我不后悔”<br>在薛永旁边，银树手握石头站着<br>“银树，退到后面去”<br>“嘿嘿，薛永，你要保护我哟”<br>银树使劲把石头抛出，可是，力量不足，石头无法打中，途中掉了下来<br>“再试一次”<br>银树重新握住投石器，狠狠的扔了下去。一旁，彭尼选了一块拳头大小的石头，投石器在头顶上高高的挥动着。猛然，彭尼的石头划破天空，让率先行进的官兵喷出了血。<br>这样一开头，胆怯的小和尚和尼姑们也开始扔起石头。这是把对方看做法敌的投掷，这是为了生存而决死的石头，官兵们停住了脚步<br>官兵副将命令<br>“整顿队伍，盾牌上前”<br>那面盾牌上，石块也猛烈的突出着。日本僧侣们在后方把瓦片摔碎，想办法提高效果。【侧面表现了。。。嗯】一边念着地藏经，一边把石头劈开，期望那些石头像利刃一样突破盾牌<br>官军无法行进，拥堵在狭窄的农道上<br>钟楼的钟声突然响了，犹如风一般经过，一批白僧团杀将下来<br>他们就是从东边的参道赶过来的“白光尊师”等护国禅僧们。</p><p>莫志传来看守塔的报告<br>“农道的敌人又杀回来了”<br>人员的配置和防守的指示，全部是境内的钟楼里的金山大师的指挥，作为侦察队伍的“乐化天部”的僧人和时迁一起回到了本营<br>“不行啊，敌人会从北边的参道上上来。封锁小鹅岭口的官军开始行动了”<br>“他们看到大参道，田间岔道进攻受阻，就发出了传令，我们要保护山脚大门的人们啊”<br>“哎呀，被干掉了，全军覆灭了”<br>小参道是逃跑的僧侣、信徒的入口。官军的监视也比较松懈。那是为了把反对派聚集在少林寺，故意放开的，金山大师漏看了<br>（所谓攻击，就是说已经没有逃走的信徒了）<br>佛法之光渺茫——金山大师注视着被战云包围的嵩山<br>但是，大师还犯了一个“错误”官军根本没想过毁灭少林寺，不过是为了威胁一下，促使其投降，连蔡京都因为反对废佛被罢免了宰相，朝廷的保守势力也很强大<br>（大宋真的抛弃佛法了吗？）<br>大师为自己过高的期望而感到后悔。如果小参道被攻破，不久敌人就会攻到这里。少林寺将会失守，佛法将会灭亡，但是，为了应对这种意外的危机，大师预留了一只队伍——“外化自在天部”。</p><hr><p>由“小鹅岭口”登上的小参道是条细道<br>在干燥的茶色山体上，生长着深绿的松柏。太阳直升，热气开始升起。<br>为了让逃亡过来的僧侣、信徒进入，这条路的防备推迟了。今早，官军用两千士兵封锁了“小鹅岭口”。现在那个支军队排成纵队开始登上道路<br>不久之后，宇文将军会从“西郭店口”带援军赶来。但是，士兵们的脚步是沉重的。他们是从洛阳来的士兵。洛阳在北魏时期就有“城内一千寺”的说法，是佛教的一大圣地<br>“杀光僧侣”命令，对他们的良心来说可是沉重的谴责<br>路，连绵不断，平缓地延续着。<br>从山顶的寺庙里传来清澈的诵经声。山景、寺庙的瓦片、僧侣们庄严的诵经，洛阳军的士兵们动摇了。这是通往极乐世界的十万亿土，还是通往地狱的24万由旬——哪一条路？<br>有人叹了一口气。</p><p>史进和石秀，还有满天星等“俗人”队伍一起下山<br>共计三百五十人。由史进领头，石秀和满天星紧跟在后。路对面有敌军的气息，史进乘着向下的势头袭击官军，跳跃着地，随手当头一棒，打倒了最前面的兵，接着将左右的士兵打倒在地<br>石秀是第二个，满天星紧随其后<br>“都麻利点”<br>“一块云”满天星拔出刀，“张神剑”握着剑，“草上飞”手持戟，史进手中握着一根棒子，“乌鸦嘴”扔过一支枪<br>“接着，帮金山大师一手”<br>是一把上好的精致亮银枪<br>山上梵钟大作<br>“神剑”张霸道，“草上飞”律大谈是一群老江湖。手下训练得很好。常年转战边境，攻击手段也是简单粗暴。<br>“喂，我们不是光头，手下留情啊”<br>“十年老”“王铁子”“黄再生”等也是内行。在江湖中脱颖而出的的男人们，特别擅长游击战。即使是今天第一次见面的人，内行人士也能感觉到对方的实力，在官军进攻之前，就感受到了危险的气息</p><p><img src="/upload/pasted-93.png" alt="upload successful"><br>史进也一味的向前推进，山道上的死伤者层出不穷，“黄再生”已经倒下，“草上飞”已经失掉了手臂<br>满天星全身朱红色，但身上的并不是自己的血，即使是这样，依然浴血奋战，那种战斗方式和清秀的外表成了鲜明的对比<br>官军陆续上前，史进和石秀背靠背作战。站在最前线的两人被敌人团团包围。一场壮烈的战斗，即使队友倒下，也没有救起的余地，碰撞的身体，碰撞的武器，狭窄的战场上满是尸体<br>史进扔掉了折断的枪，用脚捡起掉下的铁枪<br>已经有一半的人手倒下了，被突破只是时间问题<br>“这里我一个人就够了，石秀，带大家离开，从山上袭击侧面”<br>“你想让我？”</p><p><img src="/upload/pasted-94.png" alt="upload successful"><br>石秀砍到面前的敌兵，一手脱下浑身是血的外衣<br>“我已经受了无数的伤，不过后背一处伤也没有”<br>石秀又砍到左右包夹的两个人，一身是血<br>“我从不背对敌人！”<br>战斗过程中，史进不知不觉也上身赤裸，在出汗的背上，九条鲜艳的龙在悦动<br>满天星也靠上前来<br>“也算我一个”<br>太阳格外的刺眼<br>满天星数着史进身上的龙</p><p><img src="/upload/pasted-95.png" alt="upload successful"><br>（果然真的是‘九纹龙’史进吗）<br>前进受阻的官军牺牲也很多，逐步向后退却，与史进等人拉开距离。在此期间，“神剑”张霸道重整了队伍，结了一个显着人多的“影子阵”，持枪的士兵正在接近<br>史进和石秀并排站在道路中央<br>“谁也不准从此经过”<br>在官军的后方，看到了将军旗。宇文将军率领的二千援军到达了。将军在马上叱咤<br>“把这群秃驴清理干净！”<br>本来开始退却的官兵，看见援军到来后气势高涨，再次开始前进<br>“这边的和尚会杀人，千万不要手下留情”<br>就在这时，从斜面的松林里杀将出来两个男人，大声叫到<br>“在这呢，在这呢！”<br>史进一听，连忙打招呼<br>“陈达，杨春！”<br>登上这条不是路的路前来救援的，正是少华山上结交的兄弟</p><p><img src="/upload/pasted-96.png" alt="upload successful"><br>“跳涧虎”陈达。梁山泊席次第七十二位。正如“跳过山谷的虎”的称呼一样，他是一位善用点钢枪，以非凡脚力而闻名的豪杰</p><p><img src="/upload/pasted-97.png" alt="upload successful"><br>“白花蛇”杨春。梁山泊席次第七十三位。被冠以剧毒蛇之名的身着青白的男子<br>两人率领着少华山的手下。“打虎将”李忠也一同赶到<br>陈达他们挥舞着长枪，给了官兵一场血祭，与和尚“不破杀生戒”形成鲜明对比。官兵们被突然的袭击吓懵了<br>“敌人的援军到了”<br>树林哗啦哗啦的作响，也不知里面隐藏着多少敌军，官军顿时乱了阵脚，以宇文将军带头开始向山脚下逃跑<br>史进杀了上去<br>破竹之势般击倒前后左右的官军，在山路上飞奔着，无人可挡，绝望的宇文将军回头望去，对逼近的男人发出了悲鸣<br>“要慈悲啊”<br>“阿弥陀佛”<br>史进的枪轰鸣着，贯穿了宇文将军的胸膛</p><hr><p>那天早上，梁山泊的军师“智多星”吴用也很忙碌<br>吴用的书房虽然离聚义厅较远，但几乎整天都待在聚义厅旁边的侧屋。不断有传令和领命的人进进出出，来自全国各地的“店”“鸡狗”收集的情报，首先要回报到吴用这里<br>一段时间后，宋江到来。弟弟“铁扇子”宋清搬着午餐的餐桌。吴用这才注意到已到正午<br>“已经到了吃饭的时间了吗”<br>吴用把椅子移到宋江旁边。阳光透过半开的窗户直射到桌子上<br>“是啊，吴学究”<br>宋江坐在椅子上，目不转睛的看着桌子上堆积的报告密信之类的东西。在堆叠的信函中，有鲁智深王定六的报告，也有关于史进的报告。分析重建这些信息，“智多星”吴用正在头脑中描绘事情的发展方向<br>宋江担心的问道<br>“战斗已经打响了吗”<br>吴用最初预测“法难”将与官军和僧侣展开战斗。所有的情报都一致认为抵抗中心是少林寺。<br>“是啊，发出的援军也因该到了吧”<br>发出有偿救援少林寺信息的，也是吴用<br>即使想动用梁山泊本部的军队，山东和河南之间也有距离，况且还有诸多官军势力和如“田虎”的山贼势力<br>“赏金”则是为了解围发出的奇谋<br>“在石勇的人脉中悄悄放出消息，这些赏金猎人要是知道被骗了大概会很生气吧”<br>“无妨，赏钱我们来出”<br>宋江笑着看着吴用写着，好像在计划什么东西<br>“这是什么”<br>“中秋节的准备，中秋节是晁天王的忌日……今年正好三周年，打算盛大举行一下，我正想和公明哥哥商量一下，可以招些僧侣举行法事或者举行什么其他的活动……”<br>“热闹一些吧，大办一场赏月宴席，晁天王可是受不了寂静啊”<br>宋江犹如感到晁盖还活着一般<br>吴用点点头，用勺子舀了一些碗里的清汤，清澈的汤汁中，柔软的肉片轻轻漂浮着<br>正要品尝时，又有传令上前<br>“‘鼓上蚤’的报告”<br>吴用看了看报告<br>“慕容贵妃有动静？”<br>听到那个名字，宋江的脸色阴沉下来<br>“还没有死吗？”<br>“好像还活着，大概‘风流天子’又动了风流心，无法降罪这女人吧，还有，林灵素原本就是慕容贵妃提拔出来的人……”<br>“这又是什么意思，慕容贵妃，是想重返后宫？”<br>“她有暗杀皇后，青州谋反的罪名，朝中又有王皇后的哥哥王都尉和王皇后亲生的皇太子坐镇，她回不去”<br>“那她到底想干什么”<br>吴用轻轻挥着羽扇，午饭的碗又被他忘在脑后</p><hr><p>梵钟缓缓的敲了三声<br>僧兵们护着伤员回到寺庙，少林寺的山门再次被紧紧地关闭了。<br>群龙无首的官军已经退到山脚<br>“好久不见，陈达，杨春还有李忠师父”<br>在治疗伤员，煮饭一片匆忙的院内，史进环视着这些怀念的脸<br>“即使是摆着这幅臭脸，一段时间看不见也挺想念的”<br>“太没礼貌了”<br>陈达用拳头擦了擦脸上的血<br>他们受吴军师的命令下山前来支援，途中还和王定六碰了头，又遇上了李忠<br>到达时，参道已经被官军封锁，好在嵩山宽广，总有通路<br>“就这么一百人，果然是能让人放心的‘援军’啊”<br>“不要这么说”<br>陈达搔了搔头<br>“藏在官军里，偷偷行动，就得人少”<br>本来就是意料之外的援军，不管一百还是二百，史进都没有什么不满的<br>“有这些和尚在，我就放心了。李忠师父，鲁智深怎么了”<br>“马上就到了”<br>李忠仰望着佛塔<br>“会带来‘援军’的，他来之前这么说”</p><p>院内开始响起了诵经声<br>僧侣方面死者很多。参道上还有遗体。为了敌我双方，全部的死者，幸存下来的僧尼们一个又一个加入了念经，声音变得响彻嵩山。<br>莫志匆匆赶到史进身边<br>“你总是这么着急”<br>“史进大哥不好了，‘王无伤’……”<br>“怎么了！”<br>“听说倒下了，遗体在那边”<br>一听莫志这么说，史进飞快的赶了<br>在院内收集遗体的地方，有一角聚集着一群赤衣僧人<br>“最后打倒了三十六个敌人……可惜了，已经遁入修罗道了”<br>“超度吧”<br>史进挤进了这些和尚当中<br>“让开”</p><p><img src="/upload/pasted-98.png" alt="upload successful"><br>史进拿下了遗体上的席子。身材好像王进，脸上布满血污，眼睛闭着，好像睡着了一般<br>史进擦拭了血迹，发现整个脸上都有伤，好像是烧伤，脸已经毁了一半<br>石秀也追了过来<br>“——史进，怎么样”<br>史进拉着王无伤的右手。是个武者的手，一双非常结实的大手<br>“不是，不是我师父”<br>史进站了起来<br>“确定吗？”<br>“啊，我不会弄错的”<br>史进又用席子盖上尸体，然后想到了王无伤——已经逝去的高手——一生的事，这个男人也有父母，也有师父，大概也有几个弟子吧<br>但是，没有一个人知道他现在在这里断气了。</p><p>梵净山的护国禅僧们回到了竹林，又开始了坐禅<br>诵经还在继续，钟楼主营的周围笼罩着阴郁的气息，广场上，金山大师收到了天穷和尚、彭尼、本觉上人的报告。<br>僧兵和雇佣兵都失去了近半数。官军撤退到山脚，继续封锁参道口。<br>满身是血的僧兵，不耐烦的把视线从那些满身杀伐之气的雇佣兵身上移开<br>“竟然杀了那么多人——会下地狱的”<br>一旁的雇佣兵也在吵闹着<br>所有的报告都已经结束，金山大师依然沉默着<br>好像在问自己<br>官军暂且撤退了吧<br>但是，总会再次攻上来的<br>林灵素废除佛教，统一宗教，想要通过支配佛教取得绝对的权威。辽国让僧侣和官军作战，打算使宋国陷入混乱暗中阴谋着。<br>（护法与护国──实现两件事，这可能吗？）<br>在金山大师的周围，没有人靠上前去<br>在寂静中，金山大师双手合十<br>“无念寂静——不战不从”【非暴力不合作思想在亚洲的第一次体现，早了印度的圣雄甘地几百年，早了南非的纳尔逊曼德拉几百年（误）】<br>放弃执念，不再战斗，也不遵从废佛。金山大师就那样下了决断。<br>“我们把少林寺作为护法的最后一盏明灯，成为全国的佛教信徒的希望。坚守城池，坚守山峦，决不允许官军进入。然后慢慢等待法难消亡”<br>暮色逼近，山脚下官军的篝火熊熊燃烧<br>僧侣们仍然不安<br>“废佛是敕令……若是不遵循就是逆贼……”<br>金山大师揉捻着念珠<br>一道清净妙莲不染——一切皆为佛之御心<br>【金山大师：其实我是有剧本的】</p><p>下一章【第四章 地狱罗汉】预告<br><img src="/upload/pasted-79.png" alt="upload successful"><br>“无念寂静——不战不从”<br>金山大师终于做出了痛苦的决断。<br>作为辽国的爪牙暗中活动的“罗刹女”慕容嫣辉。<br>以及”通真达灵元妙先生”林灵素，来临少林寺！<br>是投降，还是殉教——风雨飘摇的少林寺。<br>利用奸计阴招企图废佛，帷幕之后的<br>“少林寺，谋反！”</p>]]></content>
      
      
      <categories>
          
          <category> 绘卷水浒传 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 绘卷水浒传 二十周年番外 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>绘卷水浒传 20周年企划 第二章 翻译</title>
      <link href="/2019/03/04/%E6%B0%B4%E6%B5%92%E8%BD%AC-20%E5%91%A8%E5%B9%B4%E4%BC%81%E5%88%92-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BF%BB%E8%AF%91/"/>
      <url>/2019/03/04/%E6%B0%B4%E6%B5%92%E8%BD%AC-20%E5%91%A8%E5%B9%B4%E4%BC%81%E5%88%92-%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BF%BB%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<p><img src="/upload/pasted-59.png" width="70%"><br><a id="more"></a></p><h1 id="第二章-宣和法难"><a href="#第二章-宣和法难" class="headerlink" title="第二章 宣和法难"></a>第二章 宣和法难</h1><hr><p><font color="#FF0000">原文作者 森下翠和插画作者 正子公也 版权所有<br><br>个人翻译<br><br>仅供个人娱乐及同好者欣赏<br></font><br><br><br><a href="http://suikoden.com/" target="_blank" rel="noopener">原文地址</a></p><hr><p>绘卷水浒传二十周年纪念企划 第二章 宣和法难<br>马车逃走了<br>（看来这赏金也没指望了）<br>事情变得复杂了——史进这么想着。少女还在一边生气<br>“好不容易才追上，现在倒好又让她们跑掉了”<br>“真是对不起”<br>史进摘下围巾·，遮住那大个子“劫匪”的胸口。大个子也摘下面罩，史进一看，是那个在小酒肆里碰上的尼姑<br>“大小姐，咱们稍做休息吧”<br>“我一想就是你，真的是有些本事啊”<br>尼姑把葫芦递给少女，少女咕噜咕噜喝了起来<br><img src="/upload/pasted-51.png" alt="upload successful"><br>“这酒，应当是杀了那家伙，为母亲报仇的庆功酒”<br>“姑娘好酒量”<br>史进笑了<br>“可是你这能耐还差得远呢”<br>“这话我就不爱听了，你觉得我练了几年？我可是练了十年了”<br>“大小姐，他可没看出来”<br>少女本想再对史进说些什么，却发现了那只在她脚边摇着尾巴的太白，“啊”的叫出声来，跑到了一边，薛永慌忙上前，按住太白的脖子<br>“没事没事，它不咬人”<br>“这就是‘狗’吗”<br>（好奇怪的姑娘）<br>虽然这姑娘看着也不小了，但还是一副没见过世面的样子<br>（这“仇”怕是非同一般）<br>史进端详着手中的小剑。这剑和宋产的剑样式有些不同，上面镶嵌了纤细的金属<br>（看来是异国的东西啊）<br>情况发展成这样了，也就没什么可说的的了，但是，如果真的是个“大小姐”，那她应该不差钱吧<br>史进于是开始和她们“商谈”<br>“敢问姑娘芳名，为何要袭击那马车”<br>“这都是‘秘密’，怎么让陌生人知道”<br>“我叫史进，那家伙叫薛永，我们是……”<br>薛永赶忙拦下史进，但是史进还在说着<br>“我们都是云游的武人，正奔洛阳，寻些差事”<br>比起他们的真实身份，少女更在意的是薛永的狗<br>“这位叫太白，你可以摸摸它”<br>“这狗怎么这么大”<br>“那是因为……”<br>少女战战兢兢地伸出手，轻轻地摸了摸太白的脖子。<br>在这期间，史进在跟尼姑搭话。<br>“看你们这个’秘密’，我们可以帮你们，你且说来听听。”<br>少女刚要开口，尼姑扫了一眼史进，拦下了少女<br>“大小姐，咱们不能轻信他”<br>“没关系，狗是不会跟坏人亲近的【小剥皮：终于有人说我不是坏人了】，我叫银树，她是彭尼，我们在追坏人”<br>“敢问贵姓？”<br>“免贵姓王”<br>“王银树，真是个豪气的名字啊，说说你们那‘秘密’吧”<br>“跟你说真的有用？”<br>“交给我们就好，你已经领教了我的本事了，我们都是‘行家’”<br>“什么的行家”<br>“报仇”<br>银树翘起嘴唇，盯着这两个人<br>“行，那马车上有我母亲的仇敌，是我父亲的一个妾室，非常坏的一个女人。她毒杀了我母亲，又觉得我碍事，把我赶进了尼姑庵。被你们放跑的，就是这么个恶人”<br>“卧槽，还真是一个天大的‘秘密’，那个妾也被赶出家门了？”<br>“对了，刚才你说要钱，你想要多少，你们在这干什么，那么需要钱”<br>银树刚一说完，彭尼似乎也有些想法<br>“小姐是在尼姑庵长大的，对于世事不太了解，失礼之处，还望包涵，我们的复仇，得由我们两个完成”<br>“你说你个尼姑家，好像多懂这世道似的”<br>彭尼没吭气，她把围巾还给史进，那双手上，史进看出了她可是没少修炼，彭尼用剑绳把撕破的一幅绑在身上，催促银树上路<br>“我们赶紧追过去吧”<br>“等等，等等”<br>史进握住彭尼的手<br>“我们并不是唯利是图的人，看中的人，我们也会竭命帮助的”<br>银树插到两人之间<br>“此话当真？”<br>“好汉一口吐沫一个钉”<br>“‘好汉’又是什么”<br><img src="/upload/pasted-52.png" alt="upload successful"><br>“就是不说谎的男人”<br>“真的会帮我吗？”<br>“那是当然”<br>银树扑哧一下笑了<br>“彭尼，我太高兴了，咱这不就有了两个免费的保镖？”<br>“啥？”<br>“其实，我们也是身无分文，那么，我们赶紧追马车去吧”<br>银树领着头，高高兴兴的走在这荒路上<br>“一定得把那女人的皮扒了”</p><p>从梁山泊出走的，并不是只有史进<br>史进的去向很快就知道了，但是当天鲁智深也出走了，梁山泊的情报网，也不知道他去了哪里<br>大宋幅员辽阔，若不住店，就没有信息，不好找的到。但是军师吴用并不担心鲁智深。<br>鲁智深长时间东奔西走，当过提辖，当过乞丐，也是个僧人，人脉很广，他所帮助的，也多是不见光的人<br>即便如此——吴用还是受宋江之托寻找智深<br>“神行太保”戴宗，没打听到鲁智深去哪了，但是通报了一个意外的消息<br>“梁山泊外面出了大事了，法难，法难啊”【法难：佛教史上对三武一宗之厄的说法，由于这故事是编的，所以法难指代的是大规模的排斥打压佛教】<br><img src="/upload/pasted-53.png" alt="upload successful"><br>聚义厅里，除了吴用之外，还有副头领“玉麒麟”卢俊义，“神机军师”朱武等梁山泊的领导参谋高层<br>戴宗将所掌握的情报详细叙述<br>“当今圣上是‘道教狂’是众所周知的，但是现在竟然狂热到要取缔佛教，将其融入道教。要把释迦牟尼改叫大觉真仙，其他的佛叫做仙人，大士之类的，要把僧侣改称德士，行童改叫德童，尼姑改叫女德，有要求他们重蓄头发，穿上道服，寺院也要改为道观”<br>东京开始了“废佛”风潮，吴用已经知道了，但是历史悠久信徒众多的佛教突然要被废除，全部纳入道教也是毫无道理的事<br>“大臣中就有很多佛教徒，这样实现起来应该很困难吧”<br>“可是……”<br>戴宗，也算是这些“道士”的一员<br>“进来，在禁城内，后宫失火，有几个宫女被烧死，后来宋贵妃，王贵妃相继死去，灾厄接连不断。于是那‘通真达灵元妙先生’ 林灵素就召集八百弟子，举行召唤天神的玉清神宵秘法，说是要把那个著名神仙吕洞宾引至凡间，他说这么多国难发生都是因为对道教的信仰不足——好像那天上神仙下了什么神谕一样，说废佛是为了护国，天子深信不疑”<br>“智多星”吴用轻摇羽扇<br>“这道教，就是那四奸送给皇帝的‘玩具’罢了，为的就是让皇帝不问政事，蔡京童贯等人利用林灵素，‘天子朝臣都会重生为仙，这国难不过是天上神仙给予的考验，所以没必要担心’——来说服皇帝。这个‘废佛’之举，大概是林灵素想掌握更大的权利吧，那个林灵素，可真是个胆大包天的人啊”<br>吴用好像又想到什么，说道<br>“或者……有人在幕后操纵。戴院长买有别的消息吗？”<br>“为了阻止废佛，僧侣的代表要在东京和道士斗法”<br>听见了“斗法”，宋江问道<br>“戴院长，你方才说斗法，道士这边肯定是林灵素了，僧侣那边是谁？”<br>“是五台山文殊院的主持方丈，鲁智深的恩师智真长老”<br>在智深还叫鲁达的时候，因为大义杀了人，成了逃犯，一来二去，就到五台山出家了。据说，只有智真长老看中这个粗鲁暴躁爱惹事的“花和尚”，说他日后能成正果<br>“原来如此，现在我明白了。”<br>鲁智深可不是为了喝酒突然跑出去了<br>“这和尚，定是去了东京开封府”<br>“东京开封？！”、<br>这是大宋的都城所在，戴宗仰天长叹<br>“这家伙……怕是要惹出大事”</p><hr><p>大宋都城，东京开封<br>在极其繁华的城内，有一座不相匹配的寂静的寺院，在破败的院子里，排列着几个简陋的窝棚，成了跳蚤，老鼠，野猫乞丐的乐园<br>今天早上，这里聚集了很多乞丐，在他们当中，站着“花和尚”鲁智深<br>鲁智深用倒塌的灯笼代替代替茶几，睥睨着包围着的乞丐。乞丐目光如狸，旁若无事，鲁智深把酒倒在手里的破茶碗里<br>鲁智深咕嘟咕嘟地把酒干了，鲁智深是真的爱喝酒，没事总是喝两杯，现在可不是，他是心急如焚，借酒浇愁<br>虽然还是清晨，但是阳光很强烈，今年有旱灾——乞丐们在靠着背阴处歇着<br>不一会，可算是有消息了，一个瘦弱的乞丐跑过来<br>“已经准备好了，就等师傅了”<br>鲁智深扔下茶碗站了起来。<br>随之，周围的乞丐也纷纷散开。<br>鲁智深独自走出歪斜的寺门。那是离城墙很近的下町，是清寂的贫民街。鲁智深大摇大摆地走过了孩子们玩耍的街道。<br>离开梁山泊的鲁智深潜入了东京城内。他暗中是“东京丐帮”的帮主，所谓“丐帮”，就是城内数千乞丐们的帮会，据说他们一面乞讨，一面在城中的各个地方打听情报，从高官的秘密到邻居晚饭吃什么，他们无所不知，鲁智深被赶出相国寺，成为乞讨和尚时，意外的被奉为东京丐帮的帮主<br>乞丐们知道智真长老是鲁智深的恩师<br>听了他们的回报后，鲁智深就来到东京</p><p>在城里，对佛教的迫害已经开始了，东京的僧侣原先是比一般的平民生活的更好，借此机会，民众纷纷进入寺院，抢夺钱财，破坏神像，殴打僧侣，发泄他们的愤怒【似曾相识，过于真实】，很多和尚为了避难，立刻把寺庙的名字改为“观”，纷纷换上道服<br>鲁智深很看不上<br>（这群怂包秃驴们）<br>鲁智深走在大道上，有巡逻的士兵注意到了他<br>“现在上面要求，乞丐，和尚都得去当打扮成道士”<br>“什么玩意？”<br>“你得蓄发，戴帽子，扔掉袈裟念珠，穿上道服”<br>再看这个士兵，身上早已点着太极八卦，神仙护符。如今，这可是投机的快捷方式，迫害和尚也是一条途径<br>鲁智深也没鸟他，就迈开脚步<br>“现在还在蓄发吗？”<br>“谁敢违抗”<br>“不是僧人输了才开始施行吗？”<br>“还用看吗，肯定要输啊”<br>“你在说什么鸟话”<br>有个男人迅速在背后按住要动手打人的鲁智深<br>“大哥，你怎么还这身打扮，现在装道士能多得到些啊”<br>回头一看，那是掌管梁山泊打探消息的酒肆的“活闪婆”王定六。王定六咯吱咯吱的挠着瘦了吧唧的侧腹，士兵们害怕跳蚤传染，走了几步<br>“我道是个乞讨的和尚，原来只是个乞丐”<br>士兵们扔下这句话后就走了，鲁智深默不作声的继续走着。王定六和鲁智深是老交情，很清楚他在想什么<br>“我也不问为什么了，正如你所知，几位哥哥担心你，这才把我送下山来，害得我跑了好久”<br><img src="/upload/pasted-54.png" alt="upload successful"><br>活闪婆王定六——梁山泊第一百零四位好汉，被誉为“会奔跑的稻草人”的王定六，是梁山泊引以为豪的打探消息的头目，拥有两种特技：奔跑和扒窃。曾经在五台山河畔，救起倒下的“哥哥”，就是后来的鲁智深【另一条世界线】，五台山，也是王定六忘不了的地方<br>王定六默默的跟在鲁智深后面<br>人群也向那边去了<br>“道士和僧侣的斗法”不久将会在宫城门前的广场上开始</p><p>五台山的智真长老是鲁智深的师父<br>他耐心的教导性情暴躁的鲁智深，教他礼法，教他识字，教他经文<br>“因为打碎山门前的仁王，被赶出寺的时候，也就师父一个人来送我”<br>就如黑夜中打着的小灯笼一般，照亮了鲁智深前进的方向<br>夹杂在人群中的导师很是得意<br>“那和尚能翻起什么浪来，输是肯定的了”<br>人们在不安的窃窃私语着<br>“输了就危险了，……长老不会不来了吧”<br>但是，鲁智深坚信长老一定会来<br>果不其然，远远的看见在人海里有一个小个的老和尚<br>身上穿着身灰衣，外罩意见朴素的袈裟，光着脚踩在草鞋上，缓慢的在人群中走着，除了他脚下的影子，没人跟随他<br>鲁智深凝视着长老的身影。<br>广场中央，林灵素已经带着一百个道士在此等候了，斗法内容为求雨。近来天气干旱，人们一直盼着一场雨<br>在斗法开始时，有一场隆重的仪式，不过，长老像是一直木鸡一样站着一动不动<br>皇帝带着宠幸的刘贵妃在背后的楼阁上看着他们<br>被任命主持斗法的宦官杨森告诉长老<br>“那么，请智真长老先做法，在大线香烧尽之前，求一场雨”<br>广场中间放着一个空鼎<br>“如果佛法灵验的话，雨水就会装满这鼎……开始做法吧”<br>数千只眼睛，在烈日下，注视着老僧<br>智真长老静静的在石阶上坐禅<br>从怀里，拿出了一串和瘦弱的身体不相匹配的粗壮的念珠，长老第一次开口了<br>“文殊菩萨菩提之心，不舍众生”<br>那是一句低沉，严肃充满慈爱的话<br>然后，长老开始念经了<br><img src="/upload/pasted-55.png" alt="upload successful"><br>剑即智慧，莲华即觉悟<br>真理亘古不变<br>这是五台山本尊文殊菩萨的经文【我尝试找了，找不到】，文殊菩萨凭借智慧，引导人们向悟道前进<br>附：文殊菩萨铜像：右手持剑，左手持？莲华，<br>智慧的象征<br><img src="/upload/pasted-56.png" alt="upload successful"></p><p>如风一样，抑或说如波浪一般的诵经声，在广场流淌，那是抚慰人心，净化灵魂的声音。<br>然而不久，就出现了异变<br>许多人站在广场的石阶上，突然那边地面坍塌，人们掉进下面的洞里去了，喊着救命。智真长老依旧端坐着继续诵经。想要逃跑的人们，有发现了别的异端，又惊吓的叫起来<br>“看那边，流血了”<br>皇帝坐镇的楼阁门前，装饰着青华帝君，圣祖赵玄朗等众神的巨大铜像。那一双双眼睛，突然滴滴答答的流起血来。又不知哪里传来了毛骨悚然的恸哭声，甚至盖过了诵经的声音。<br>发生了接二连三的不详现象，人们也不说话，纷纷奔逃。楼阁上的皇帝也龙颜不悦，打算要走<br>就在那时<br>叮铃叮铃，响起了轻快的铃铛声<br><img src="/upload/pasted-57.png" alt="upload successful"><br>林灵素骑着蓝色的神牛出现在广场中央，然后开始庄严的念着什么咒语，坍塌的地板，流血，奇异的哭声这些怪异事件全部平息了<br>“看那边”<br>人们指着天空，欢呼起来，几十只仙鹤在楼阁上空飞舞，而且，本来空着的大鼎，也滚滚的涌出水来<br>“奇迹，奇迹发生了”<br>杨森立刻代表皇帝宣布，林灵素获胜，宣告着道教的胜利<br>“道教自即日起作为我大宋的国教，废除佛教，取缔僧侣”<br>“这他娘的是假的”<br>鲁智深咆哮着，接着在场的僧侣，佛教信徒，乞丐们也开始骚动<br>“肯定有什么装置，应该打碎神像，调查那个鼎”<br>“这个鹤应该是训练过的”<br>人们纷纷涌到神像前，暴动起来<br>突然天空乌云密布，雷声轰鸣，暴雨骤作，倾倒在广场的石阶上，道教派的也喊了起来<br><img src="/upload/pasted-58.png" alt="upload successful"><br>“下雨了，奇迹出现了！！”<br>林灵素向天空张开双手，胜利般的高声叫喊着<br>“智真乃祸国殃民之妖人，左右与我拿下，关入监牢”</p><p>鲁智深行动起来了，他比那些要抓捕智真长老的士兵行动更为迅速，乞丐们也在跟着行动。智真长老犹如木像一样一动不动，突然站起身来<br>为了阻止想要跑过来的鲁智深，智真长老一手举在胸前。鲁智深自然停住了脚步，虽然相隔很远，但是脚却像被压住了一样动不了<br>“师父为何要阻止我”<br>鲁智深正要发问时，智真长老的念珠突然破碎，一百零八颗珠子四处飞散<br>在飞散的念珠雨中，长老注视着鲁智深，大喊一声<br><img src="/upload/pasted-59.png" alt="upload successful"><br>“问金山！”<br>矮小的身姿，看上去却像冲天的巨人<br>【正子老师这张插画角度真的帅到啊】<br>在鲁智深脚下，滚过一颗念珠<br>当鲁智深弯腰拾珠子时，智真长老被抓走了。王定六和众乞丐围着鲁智深<br>雨过天晴，观众也一哄而散<br>王定六看着林灵素被弟子们包围着回到宫城内。头上裹着破布的道士牵着青牛的缰绳<br><img src="/upload/pasted-60.png" alt="upload successful"><br>在身穿华服的道士们中，其身姿格外地显眼<br>（还真是有穷道士）<br>王定六目光转向鲁智深，鲁智深正在凝视手中的珠子<br>“大哥，你怎么没帮长老啊”<br>王定六无意中窥视了鲁智深的手掌<br>“哦，这是达摩祖师”<br>珠子上刻着异样的苦行者。<br>达摩大师，就是在河南的少林寺坐禅的异国伟人<br>鲁智深用紧握珠子的手，远远地向被带走的智真长老行礼，背对着仍然燥热的广场<br>“大哥，去哪？”<br>鲁智深用响彻心扉的声音回答了王定六<br>“西方净土”</p><hr><p>大宋越向西越干燥，大地越荒凉。虽说拥有长安、洛阳等古都，历史文化丰富，但黄土扩散，有时连天空都是黄色的。<br>河南、陕西——佛教最初从西方传入的地区，也是在这个地区开枝散叶。<br>洛阳有佛教传来的白马寺，有龙门的大石窟，有达摩大师开禅宗的少林寺。长安有玄奘从天竺带回的教典，大慈音寺、收纳指舍利的法门寺等佛教圣地。<br>然而在那圣域，法难早就开始了。<br>寺院被强制改成道观，僧侣和尼姑成为道士，道婆，被强制还俗。可是，在这一带抵抗根深蒂固，以命抵抗高僧也不少。朝廷试图用武力压制。<br>下午。天空中出现了一点云，但没有下雨的气息，很热。<br>沿街的旅馆前，立着写有废佛命令的高牌子，风吹拂着沙尘。而那命令被年轻的僧侣撕毁，消失在沙尘中<br>客栈二楼的小窗户上，站着一个年轻的侍女。她虽然长得很漂亮，但举止一丝不苟。用略微眯缝的双眼，看着碎裂的命令随风飘散开来。<br>“猫儿”<br>侍女的视线又转回房间。这是个鲜为人知的客栈，也是这个客栈最高级的房间。一角设有木制浴缸，一个美女在热气中休息。<br>“那个暴徒，你知道他的真实身份了吗?我觉得是女人，但不是宋国刺客吧?”<br>“我也已经注意过了，之后就再也没有出现了。如果是女人的话，或许是峨眉山的幸存者。或者是对您有什么怨恨的人….您有什么线索吗?”<br>“猫儿啊!你服侍我多少年了。恨着我的女人，比流星的数量还多。你还记得那些消失的星尘吗?”<br><img src="/upload/pasted-61.png" alt="upload successful"><br>在热气腾腾中，美女浮现出凄惨的笑容。水里浮着鲜红的花瓣，颜色像血一样鲜艳。<br>“这边好多灰尘啊。真想早点回京城。”<br>“很快了，只要完成这个‘任务’就好了。”<br>“是啊，哎呀，那声音。”<br>在这个客栈，一楼是食堂。从那一边传来了铃的声音和一些说话声。猫儿马上去看了。<br>“算命的来了，说要给您算命。”<br>“唤她过来。”<br>“太太，请您小心。”<br>“嗯嗯”<br>猫儿立刻带着一个老婆婆进了房间。老婆婆穿着打扮像个乞丐，但眼神非常锐利。美女依旧泡在池子里，命令老婆婆上前。<br>“怎么样?你看我这命运如何?”<br>“哇……好高贵的面相。”<br>老婆婆瞪大了眼睛。然后，又传来一种听不懂的喃喃自语。美女委婉地笑着。老婆婆继续说。<br>“你是女人，同时也是位极人臣的女人。但是请您注意。夺取你生命的是——年纪轻轻、年纪轻轻的高贵少女。”<br>“给她奖赏，猫儿。”<br>老婆婆的跪了下来，伸出手。突然有把短刀刺穿她的胸腔。她倒下后身穿青衣的侍女们出现，用布包着老婆婆离去，擦拭她的血迹。<br>美女又躺在浴缸里，闭上了眼睛。<br>“位极人臣的女人……”<br>令人毛骨悚然的笑声震动了荒野上的月亮。正要在盆中填热水的猫儿，看到水面上移动的影子，立刻把短刀掷向了天花板。短刀刺进房梁，发出吱的声音和逃跑的脚步声。<br>“老鼠?”<br>美女用扫兴的脸从浴池里出来，让侍女们擦去身体。<br>“明天早上早些出发了。这种穷困的旅店，不能再待了。</p><hr><p>西京河南——洛阳郊外。<br>这个客栈离河南府还有一天的行程。在那座桥的旁边，一组艺人正在表演耍棒子。因为是很热闹的客栈，所以杂耍艺人并不稀奇。来往的客人们也都见过些市面，也并没有兴趣一直观看。但是今天不同平常，围上去了二三十人<br>“这家伙真漂亮”<br>练过武的男人们默默的赞叹着，而酒楼上的那些女子，则准备好了钱。<br><img src="/upload/pasted-62.png" alt="upload successful"><br>史进脱掉上衣，露出令人目眩的九条龙。仅仅这样，就有好几个人驻足观看。史进手拿棒子，飞跃，舞步，接二连三的展示华丽的技艺。他发出气沉丹田的叫喊，技术扎实，也就不会耍些花拳绣腿。另外一个就是薛永。他表现的事纤细的技巧。他用尽全身力气，像风车一样快速转动着木棒。单脚站立，扫向四面八法，用棍子支撑身体倒立着。<br>男人们发出喝彩，女人们发出娇声。<br>“珠珠姐您喜欢哪个?我是一个刺青的人。”<br>“多福喜欢养不良少年!我喜欢带狗的人。”<br>一阵华丽的技术后，史进一下子向后退去了。随后出场的是薛永和太白。<br>“我这祖传膏药，贴哪治哪……”<br>在史进擦汗时，薛永兴高采烈的回来了。薛永总是带些祖传膏药上路，那些膏药几乎都卖光了。在太白所叼的笊篱中，有相当一部分钱。史进用双手把赚头一捞。<br>“好，去买饭吧。这附近的河鱼有土味，还是得吃肉，吃肉。”<br>两人走进卖羊的商店，买了肉、烤饼和酱菜等。史进买了当地的浊酒，薛永又加了点心。于是，两人又回到了郊外的“藏身处”。<br>“都等得不耐烦了!”<br>在无人居住的古庙里，银树一个人出来迎接。<br>“哇，买了这么多”<br>银树接过薛永的篮子，抱着坐在了地上。<br>“这个是粽子，这个是……”<br>取出食物后，银树开始用手抓着吃。史进提起篮子。<br>“等一下彭尼，你不能吃独食，没礼貌。”<br>银树转过脸去，哼了一声。然后她坐在薛永旁边小声说。<br>“对不起啊，但是我真的饿了”<br>彭尼正在去找去往洛阳方向的马车行踪<br>彭尼去找洛阳方面马车的行踪。<br>银树抱着膝盖坐了下来，叹了口气。薛永从怀中拿出一个糕点包。<br>“吃这个吧。”<br>“可以吗?”<br>“这是为你买的，还热着呢。”<br><img src="/upload/pasted-63.png" alt="upload successful"><br>银树脸颊一亮，打开小包，嘴里塞满了点心。<br>“薛永，这是什么?”<br>“油炸肉丸子。”<br>“第一次吃这么好吃的东西。”<br>薛永把落在地上的树枝削成筷子，交给银树。有千金小姐气质的银树，坐在满是灰尘的地板上，却没见过用手抓着吃东西。<br>薛永原来也是良家子弟，他有过沦为卖艺人的经历。如果在江州没有见到宋江，不知现在会是什么样子。<br>(虽然很逞强，但是一定很辛苦吧)<br>在银树旁边，太白正巧地坐着摆着前足。这时，银树把点心切成两半，放在太白前面。<br>“最后一个，给你一半吧。”<br>史进对银树说。<br>“如果有从‘大小姐的娘家’来援助的话，那样的点心都能吃到饱。不能拜托的你的父亲，给你出钱复仇吗?”<br>“我已经有十年没见过父亲了，他怕是已经把我忘了。”<br>“怎么可能?”<br>薛永安慰了银树。<br>“没有父母会忘记自己的孩子。家在哪里?我送你回去吧。”<br>“我不能说。”<br>银树紧抿着嘴。<br>“你这么说真是让我震惊。像我父亲这样的人根本就不可靠。如果他知道我在这里，就会把我送到尼姑庵，除此之外别无任何好处。”<br>这时候，彭尼终于快步赶到。史进没有放过彭尼微妙的表情。<br>“怎么了?找到了吗?”<br>“那个女人在洛阳附近的寺庙里到处寻找。虽然追赶了这样的马车，但从缝隙中一看，里面没有人。”<br>“这大概是诱饵啊，太鸡贼了。不过，所谓在寺庙四处寻找，她是打算藏在尼姑庵吗?那个女人，虽说没什么证据，模模糊糊的?但她应该是杀人犯吧?”<br>彭尼、银树都没有回答史进的问题。史进和薛永意识到，两人还隐藏着“秘密”。<br>“算了，算了照这样子，还得花一些时间。薛永，大小姐就交给你照顾；额。”<br>史进开始收拾自己的行李。银树惊讶地问。<br>“你要去哪里?”<br>“我去少林寺找我的师父。”<br>“你不是说要帮助我们报仇吗?”<br>“一找到师父，我就回来。路上，我会帮你寻找仇人的下落。”<br>史进抓起木棒，走出祠堂。</p><hr><p>“真的已经走了!”<br>银树盯着半开的门，看了一会儿史进是否会回来。但随着脚步声越来越远，只是风摇动着门而已。<br>银树叹了口气，回头看着薛永。<br>“薛永也要走吗?”<br>“我……”<br>薛永突然把棒子扔向门。他感觉到门外头有窥视的气息。棒子“嗖”的一声，穿过快要腐朽的门。外面藏着的人影转过身去，避开棍子，迅速地飞上房檐。<br>薛永一下子把银树挡在背后，彭尼也跑了出去。彭尼敲碎房檐，瓦片哗啦哗啦地掉下来。薛薛永对着与瓦片一起落下的小小的人影，挥舞着棒子<br>发出了悲鸣。<br>“别这样。哎呀，好可怕!”<br>“——时迁。”<br><img src="/upload/pasted-64.png" alt="upload successful"><br>“鼓上蚤”时迁——在墙头飞奔着，也就是神出鬼没的“跳蚤”。他排名一百零七位，若说暗中行动的能力，他是能跻身大宋前五的。他也是受宋江之命，追赶史进<br>“咦，史进呢，什么，搞错了吗？”<br>银树不可思议地看着这个留着胡须的小个男人的脸<br>“像老鼠”<br>“真是个不会说话的小姐啊，哎呀，我都没舍得跟同伴打招呼，就一直追在那女人后面，虽然她用了诱饵，但也是骗不了我的”<br>聪明的彭尼似乎已经知道是什么情况了<br>“那时迁先生，你打探到了什么消息？”<br>“那个啊，有点奇怪。她们的马车依次拜访着附近的寺院，这么说的话，他们马上就要到…..”<br>“违反废佛的命令，拒绝改信道教的寺院吧”<br>“什么，这你也知道？我在全国各地都有些耳目，我让他们调查了一下，从四川到陕西，河南，陕西的名刹，都被勒令改宗，眼见着和尚和官军的冲突越来越大”<br>薛永将目光转向了银树<br>“真的，那只是‘妾’吗？”<br>银树没有回答。彭尼问时迁<br>“您知道他们接下来要去哪吗？”<br>“看那方向应该是奔着嵩山去了，没错”<br>银树眼睛一亮<br>“少林寺啊”<br>“哎呀，史进也去那边了”<br>“那我们马上追上去”<br>银树拿起剑，风风火火地冲出祠堂，落叶也跟着飞了起来，那门终于支撑不知，倒了下来<br>“真是个有气势的小姐啊，你知道少林寺在哪吗？”<br>“您不是知道吗？”<br>彭尼用脚踢散了堵住出口的门的残骸后，匆匆跟在银树身后。</p><hr><p>另一方面，史进离开祠堂，朝着少林寺加快了道路。<br>少林寺在洛阳的方向<br>“从什么地方拐个弯，然后再向南去”<br>因为是有名的寺，又是在嵩山，所以只要朝那座山进发即可<br>虽然想的很容易，但史进天生路痴。问别人也没问的很明白，也没有地图。<br>总之朝着那个方向去就没问题了<br>街道上总觉得有些嘈杂，在客栈，道士们得意洋洋，也有很多士兵，可以看到被背手绑着被带走的僧侣和尼姑的身影。<br>“这是拒绝改宗的和尚们。要被带到洛阳去，好像都被判死罪了”<br>“德高望重的龙门大禅师也去世了……这世上要没有佛了吗？”<br>人们在低声私语着，好像避开牵连<br>看来，这一带对废佛的反抗力很强，官军和抵抗的寺院之间也发生了冲突<br>史进虽然不相信神佛，但和鲁智深是好朋友，看上去很老实的僧侣们被骂得口无遮拦，像牛马一样被赶走，被关起来，看着很不舒服<br>（但是，现在首要的是找到师父）<br>接着赶路，和被绑起来牵着走的僧侣擦肩而过。受伤的人很多，并且被全副武装的士兵监视着。史进站在路边，看着一行人走过。大概有一百多人吧，大家神情绝望，一边走一边诵经，却被士兵们殴打<br>“喂，不要打了”<br>史进不由自主的向着士兵喊到<br>“原来这人也支持和尚”<br>“看见你的假发我就想揍你”<br>说着话，史进就把士兵打倒了<br>已经傍晚了，路上也没什么行人了，史进手握棒子，迅速的数了数士兵的数量，骑着马的队长一个，手下有数百人。在数完之前，就倒了一半，吓得骑着马的队长丢下僧侣跑了，剩下的士兵也开始跑<br>“那么，你们也赶紧逃吧”<br>史进拔出短刀，给和尚们松绑。可是僧侣们并没有逃跑，而是追着逃跑的那个队长就去了，但是他们是追不上马的，尽管如此，他们还是追着，即使摔倒了，也要爬起来继续追<br>史进也很奇怪。这时，一个年轻的和尚叫他<br>“请也帮我解开绳子吧”<br>只见这个和尚，双手被紧紧的绑着<br>“你也要追过去吗？”<br>“不追，已经追不上了”<br>史进一砍绳子，和尚就踩了一个倒下的士兵一脚，然后拿起他背上的弓和箭，迅速摆好架势，拉满玄<br>“是这样”<br><img src="/upload/pasted-65.png" alt="upload successful"><br>练过十八般武艺的史进，也还记得怎么用弓<br>（这家伙也会啊）<br>可是，这个和尚在最后的最后，停止了动作，凝视着路的彼方<br>史进一把从僧人的手里拿过弓箭，迅速放了一箭，箭破风而飞，射中了正在逃跑的队长的脖子，队长从马鞍上滚落，马就那样跑了，僧侣们喊道<br>“别让马跑了”<br>史进正在犹豫要不要射马<br>“给我”<br>在和尚抢夺史进的弓时，一个男子出现在那匹疾驰的马的前面，男子等到那匹狂马来到眼前，将布盖在了鼻面上。然后抓起马辔，用力拉扯下去。他对马的处理已经相当习惯了。<br>僧侣们追上了马，从马鞍袋里掏出了一个锦包<br>“拿到圣典《四十二章教》！”<br>史进把弓箭还给和尚<br>“原来如此，你是要拿这个”<br>和尚安心的抬头看着史进，看年龄应该和遇见王进的史进差不多大吧，善射箭的人大多眼睛明亮澄澈，不过他的那个表情，却漫无边际<br>史进又向着把马停下的那个男人转过身。那人牵着马，信步走来<br>“好慢啊史进，我等的都快睡着了”<br>“石秀”<br><img src="/upload/pasted-66.png" alt="upload successful"><br>这男人就是梁山泊的“拼命三郎”石秀<br>“你也是来多管闲事的吗？”<br>“那可不是，我是受吴军师之命”<br>石秀笑了<br>僧侣们收回圣典后，转身面向史进他们，用尖锐的声音喊道<br>“莫志啊，你可打破杀生戒了”<br>弓箭从年轻和尚的手里掉下来<br>“不是，射中那人的不是我”<br>“不要辩解了，你已经被逐出师门了”</p><p>白马寺坐落于洛阳郊外，是后汉时期由佛教传入时建造的，是中国最古老的寺院。据说，两名僧侣骑着白马，献上了《四十二章经》门前至今还有纪念此举的白马石像。唐代的名僧，从天竺返回的玄奘也曾在此修行<br>河南的寺院不愿改宗，这其中的代表，就是这白马寺<br><img src="/upload/pasted-67.png" alt="upload successful"></p><p>白马寺周围一片静谧<br>外围的伽蓝已经烧没了<br>“以前就听说过白马寺前的白马像”<br>史进抚摸着被火烧到门前的矮个白马石像<br>“还真是小啊”<br>史进在去少林寺的路上，和年轻的见习僧——莫志一起顺道去了白马寺。那里是圣域，也是战场的遗址。<br>史进所帮助的僧侣们就是白马寺的“幸存者”。<br>但是，被解救的僧侣们并没有表现出高兴的样子，回来的时候，用棒子狠狠地打了莫志。<br>“莫志啊，你杀生了，你已经被逐出师门了。我们按照禅师的遗言，去龙门石窟隐藏圣典。法难结束之前，卢舍那佛会守护圣典的。你速速离开吧”<br>于是，僧侣们抱着夺回的锦缎包裹，去了了没有路的荒野，史进无论怎么解释，说人是他杀的，都没人相信。<br>独自被留下的莫志，双手合十向着火灾痕迹前进。<br>“无法拯救龙门禅师，违背戒律，甚至还有保护圣典的遗言……我是个没用的人”<br>“那样的话，你把那人射下马就好了”<br>“我办不到”<br>“为什么？”<br>“我从小就喜欢弓箭，因为杀死过多的鸟兽，母亲担心我会遭报应而把我送到寺里出家，白马寺的长老龙门大禅师也严禁杀生。大禅师是个和蔼的人，走路的时候为了不杀死地上的虫子，都是抬起脚走路，我不能违背母亲和老师的教诲”<br>“但是，那个大禅师不是被害了？”<br>听到这话，莫志的脸变得严肃起来<br>“禅师反对废佛，最终还是想和平解决，他离开寺院前往东京，想亲自向天子说废佛的错误……..可是路上被人抓住，严词拒绝改宗，最终受刑而死，不久，寺里也来了士兵……”<br>“杀戮和尚，这大宋的皇帝可是会下地狱的，你们抢回来的锦包里装的什么？”<br>“是圣典《四十二章经》，禅师去东京前，吩咐我们要把圣典藏在龙门石窟内，直到法难平息”<br>在得知德高望重的大禅师殉难后，这一带的寺院的反废佛的呼声日益高涨，因此，僧侣们已经和官军产生了很多次矛盾<br>“我也打算加入义军”<br>“还组建了义军？”<br>“是的，有传言说不少因官军烧毁寺院的僧人都聚集在少林寺”<br>“少林寺？我有种不祥的预感”<br>少林寺虽然是以武术闻名，但如果和官军战斗，势必会处于下风，王进在那里的话，也一定会卷入冲突<br>“喂，石秀，咱们得抓紧了”<br>史进招呼站在远处的石秀，莫志像一只小狗一样跟在两人后面<br>石秀转过身去<br>“不要跟过来”<br><img src="/upload/pasted-68.png" alt="upload successful"><br>“啊？”<br>莫志抬头看了看石秀。史进挤进了二人的中间<br>“对不起，莫志。这家伙讨厌小孩”<br>“我不是小孩子”<br>“我不喜欢你的眼神”<br>“算了吧，石秀。不要耍孩子气了”<br>石秀没有回答，牵着队长的马。史进笑着用手搭在莫志的肩膀上<br>“来吧，和尚一个人走路很危险。一起去吧”<br>石秀看了史进一眼，就独自站在前面开始走路</p><hr><p>少林寺是建立在嵩山上的寺院<br>天竺的菩提达摩，面朝墙壁坐了九年。这是禅宗的起源。同时，作为修行的一环进行武术的锻炼。把坐禅和武术都发挥到极致的，就是这个全国闻名的名刹<br>山门被僧兵严格地保护着。由于最近的法难，寺庙被烧毁，被镇压的僧侣们，大量地向少林寺逃跑。白马寺被烧毁后，数量越来越多。<br>寺院内，武术锻炼的气氛被紧张所代替，那天傍晚，气氛更加紧张了，一个自称“敕使”的女人的马车终于到了<br>“那个，就是传说中的──吗？”<br>僧侣们不安的面面相觑<br>美丽的侍女递交了封好的名片，长老们脸色都变了，敲响了召集弟子们的钟声。<br>“听说附近的寺庙也有同样的密使来访……到底是敌人还是朋友？”<br>钟好像晃动着嵩山的群峰<br>就在钟声消失的时候，“勅使”和少林寺住持“默和尚”在大雄宝殿大殿里面对而坐<br>“密使”是一位与寺庙不相称的美女。看到她带的敕书，高僧们改变了神色。敕书是皇帝下达的命令。文书上并没有按大宋国皇帝的玉玺，而是按下了辽国皇帝的玉玺。<br>“传言是真的”<br>敕使带着慈爱的微笑，安慰僧侣们<br>“我们大辽国的皇帝信仰佛教，大臣、民众都是虔诚的佛教徒。因此，陛下对宋国的法难感到痛心，对圣典被烧毁，僧尼被虐待感到忧虑。如果僧尼和教典一起到达我国，一定会受到重点保护的”<br>大雄宝殿里集中了全山的高僧。坐在上座美女悠然说道，在她面前，是一个坐在椅轿上的老和尚，他是少林寺的方丈“默和尚”。他专心于坐禅，很少在人前出现。他之所以出现，是因为少林寺的危机。<br><img src="/upload/pasted-69.png" alt="upload successful"><br>“违背废佛命令的寺院，已经受到了官军的全面讨伐，但是不用担心，我们辽国会出手相助，我大辽皇帝最担心佛法被毁灭，宋和辽正是同盟关系，我们会对宋皇帝劝告，如果他不听劝解我们会护送僧尼到辽国境内，决不能屈服于废佛的罪恶行为。我们一行人，为了告诉大家这件事，正在拜访各个寺院”<br>这些高僧们放心了，众所周知，契丹人崇敬佛法，如果有他们作为后盾的话，应该能充分抵抗废佛风潮<br>但是，大长老,“默和尚”一声不吭<br>他看起来已经很老了，身上只披着一件破破烂烂的衣服头上套着一块灰色的布，一动也不动的坐着，看不见脸，衰瘦的身体只露着一点点，有两个徒弟像侍奉佛祖一样，守卫在两侧<br>“怎么样‘默和尚’。白马寺已经灭亡了，长安的大慈恩寺也拒绝改宗，遭到压制，幸存者们现在应该陆续的到这里了吧……唉，你们少林寺，是肯定不屈服的吧？峨眉山已经灭亡了，普陀山，九华山改宗，这样下去，宋的佛法可就断绝了，请您听我好言相劝”<br>站在美女身后的猫儿心中窃喜<br>透过破布，可以看见那“默和尚”的肚子，瘦的就只有骨头了，每次一呼吸，灰色的皮肤就在抖动<br>（少林寺的武术天下闻名，但眼前这位“默和尚”应该和其他和尚没区别吧，在身上浇上油，也能熊熊燃烧吧）<br>“为什么不作答，虽说是异国皇帝，但是在敕书面前，你的态度有失恭敬”<br>面对美女的斥责，身边的弟子为其辩解<br>“长老是刚从苦行中来的，他在山顶的岩屋已经默然坐禅九年了”<br>“这可真是了不起，如果这样有修行的高僧率先表态，那么这场大祸一定能被终结，也才能超度智真长老和龙门大禅师”<br>这个时候，“默和尚”抬起头，发出了声音<br>“汝，即为‘大祸’”<br>美女心中暗惊<br>“怨憎会苦——罗刹已至”【怨憎会苦：指与怨憎者相遇的苦痛，罗刹：食人肉之恶鬼】<br>“那你又是什么”<br>侍女们围住主人。默和尚慢慢的站起身来<br>“在这之前，贫僧先道道你，慕容嫣辉，曾为宫中贵妃，为夺皇后之位，毒杀王皇后”<br>“什么？”<br>“你忘记这张脸了吗？”<br>从灰色的兜帽下面，一双闪闪发光的眼睛盯着女人。<br><img src="/upload/pasted-70.png" alt="upload successful"><br>“金山大师！”<br>“正是贫僧，贫僧当年亦在朝廷中做过法事，道士势力兴起后离开朝廷，回到金山寺，十年前，听闻噩耗返回东京，然王皇后之死亦堕入黑暗，被怀疑弑母的公主被驱逐出京，虽皇后料定死期将至，发出信函求救，还是无力回天”<br>“那又如何，我现在可是来帮你们的？”<br>“那么，贫僧在说说你的野心，你勾结童贯等‘四奸’，令天子沉溺于酒色，乃霍乱朝纲之人，并且又勾结兄长慕容彦达于青州谋反，于是失去了皇帝的宠爱，本应被幽禁在尼姑庵，却逃到辽国，此次作为密使挑唆废佛的反抗——目的显而易见，大宋必有祸于汝之阴谋，我们必不妥协”<br>“如果你有那个能耐，就试试吧”<br>以猫儿为首的侍女发起了攻击，少林弟子们挡在前面。猫儿手拿鸳鸯环，向金山大师袭去【鸳鸯环是一种独特的外门暗器，随时取下，远距离投掷攻击。】<br>大师一动不动，猛的伸出手臂拔出了两根座椅的担棒<br>那是削成六角的两根大长棍，弟子们拜服了<br>“大师要使‘般若雷’了”<br>只见大师用双手抓住棍子，一阵大幅度的舞动，竟将那鸳鸯环掀到一旁，产生了犹如‘般若雷’的轰鸣声，这个声音正是能打破万人的涅槃的雷鸣。<br>鸳鸯环被掀飞到天花板附近，猫儿也跳起身抓住，再次扔了出去<br>聚集在大殿僧人们堵住出口，侍女们拔出了剑进行攻击，与此同时，慕容贵妃在另一个侍女的保护下从窗户逃到了走廊<br>她头顶上，有一个蒙面刺客从房梁上跳了下来<br>“这次可不能让你跑了”<br>蒙面的刺客正是王银树。随后，彭尼和薛永也跳了下来。他们进入少林寺后，沿着梁柱偷偷溜进正殿。<br>猫儿向银树袭来。银树见仇人在前，完全进入忘我状态，猫儿拔出剑对着不顾一切冲向主人的银树砍去，薛永庇护着银树，用从彭尼那里借来的刀挡在前面，彭尼也向侍女们挥着拳头<br>侍女们挺身保护慕容贵妃，眨眼间正殿被血染红了。不知不觉中慕容贵妃的身影消失了。<br>金山大师叫了两个弟子的名字。<br>“随流！天穹！”<br><img src="/upload/pasted-71.png" alt="upload successful"><br>两个弟子追着正在离开正殿的慕容贵妃，这两个弟子都是很强壮的和尚，其他的弟子也跟着追了上去，他们从正殿一出来，发现那贵妃正在等着她他们，跑在前面的随流突如其来的飞刀击倒了，虽然肩膀中了飞刀，但仍然穷追不舍，跑出去五六步后，突然跪了下来<br>“猫儿的毒，很有效”<br>贵妃狂笑着，接着往外逃，剩下的侍女也抛开银树他们，猫儿也跟了上来<br>天穹是少林的头号高手<br>“随流啊！”<br>“吾等，不可随波逐流逝去，请代我保护金山大师”<br>随流和尚突然吐血而亡，这时，小和尚们跑了过来。<br>“大雄宝殿失火了！”<br>天穹跑回金山大师身边<br>“一定是在院中藏的人手所为”<br>金山大师对着死去的随流双手合十，然后所有人救起伤员在大殿外避难。大殿失火了，走廊也满是黑烟<br>“这个罗刹，把我们聚集到大殿，然后打算一把火毁尸灭迹来掩埋自己的秘密”<br>金山大师把目光投向了银树他们<br>“你们是什么人？”<br>彭尼取下面罩<br>“一会再说吧，我们也是以她为敌的”<br>僧侣们守护着金山大师，准备逃离燃烧的大雄殿，突然发现每个门都被锁死了<br>“门打不开”<br>火海已经逼近了他们<br>金山大师和数十名僧侣被困在业火中。但是，连最小的和尚都没有哭出来的<br>金山大师开始坐禅。<br>经文的声音在热风中回响。既不激烈，也不勇猛，是淡泊，而且是全身共鸣的声音。<br>般若波罗蜜多──不可动摇。<br>天穹也开始坐禅，其他弟子们也两两坐禅，与燃烧的大殿相对而坐。<br>寿自在、心自在、愿自在、资具自在、业自在、受生自在、解自在、神力自在、法自在、智自在【这是十相自在，具有极强的避灾能力】<br>银树颤抖着，紧紧地抱住薛永的手臂<br>“我们要死了吗？”<br>“没事的，死不了”<br>彭尼在找退路。但是，哪里都没有逃生的路。银树，看起来很热地摘下了面具<br>“好痛苦……”<br>薛永怀抱银树，希望至少保护她不受降临的火星和热风的侵袭，不知哪里，传来了太白的叫声，薛永抬起头，风从走廊的破洞中吹过<br>“对了，爬上梁，走到屋顶上也许能逃走。坐在我的肩上……谁来救救这个孩子”<br>金山大师回过头来，突然睁开了眼睛<br>然后，他站了起来，朝着燃烧的门施展了“般若雷”<br>但是，武器归根结底是棍棒，般若雷鸣响了，但门却纹丝不动。<br>门的另一边，隐约传来太白的叫声<br>然后，随着受到冲击，门剧烈晃动，从外面被破开了<br>“在这儿！”<br><img src="/upload/pasted-72.png" alt="upload successful"><br>他们用面向寺内钟楼的撞木打破门，飞跑进去的正是史进和石秀。</p><hr><p>薛永护着银树，逃出了熊熊燃烧的大雄宝殿<br>地面上倒着几个青衣的侍女，但里面却没有慕容贵妃和猫儿<br>“史大郎，赶来的好及时”<br>石秀向薛永打招呼<br>“嘿，薛永”<br>“石秀也来了”<br>他们除了抢夺队长的那批马外，还抢了路过官员的马，这才急忙赶到这里，还有在大雄宝殿外监视的时迁<br>“我半路上碰上了史进，就跟他说由我带路，真是惊险”<br>史进抓住一个少林寺的僧人，询问了王进的去向<br>“这有善用枪棒的武者吗？在哪？”<br>“少林僧人都会用棒”<br>“我说的是高手，是来历不明，非常厉害的一个人”<br>“话是这么说……”<br>史进问了别的僧人，但还是不得要领。即便如此，史进仍不放弃，还在一个接一个的问<br>金山大师走到银树面前，深深地低下了头<br>“跟当初嫁入皇室的母亲长得一模一样呢，祝您一路顺风”<br>金山大师问彭尼。<br>“你是孤女峰的‘坎虎彭尼’吗？见面还是第一次呢。一直以来都守护着公主，孤女峰的“风九尼”是在息灾吗”【息灾：为止息灾害、灭除烦恼罪业的修法】<br>彭尼冷静的脸上出现了罕见的感慨的表情<br>“少林寺的‘默和尚’原来就是金山大师，我真是无礼，孤女峰的九位老尼师，在这十年中相继去世，留下的是三尼。但已经年事已高，处理杂务的我为了保护公主，将她带到了峨眉山”<br>彭尼继续说着<br>“十五年来终于又有了新的尼姑——还是天子的旨意，于是，我下了孤女峰，来到了蛾眉山本寺”<br>银树了解情况，就走到金山大师面前<br>“是我母亲指引的，大师”<br>她模糊地记得金山大师的事情，当初赐予她那两句不吉偈语是这个僧人。但是，银树并未提及此事。<br>“我一定会为母亲报仇的”<br>“你已经在痛苦中，坚强、聪明地成长起来。愚僧可就放心了”<br>除了彭尼以外，在场的人都在看着银树。脸上黑糊糊的，头发也烧焦了。虽然长相很美，但却看不出高贵的身份。<br>金山大师把手放在银树的肩膀上，告诉人们。<br><img src="/upload/pasted-73.png" alt="upload successful"><br>“这位是当今圣上的第二皇女‘荣德公主’赵金奴殿下。是前皇后，王氏的独生女，是皇太子的妹妹。她长期寄居在峨眉山尼姑寺里的”<br>最觉得吃惊的是薛永，虽然看着她长得挺端庄，但也没想到是当今圣上的公主，银树一脸神秘地站着，像一个完全不认识的少女<br>薛永不知为何感到寂寞，去了史进他们那里。<br>“找到王教头了吗”<br>“没有，好像不在这啊”<br>薛永问莫志。<br>“这孩子是谁？”<br>“我是白马寺的见习僧。虽然刚逐出师门”<br>莫志恭敬地向薛永鞠躬<br>“我不能再拉弓了，也打破了和母亲的约定，今后该怎么办才好呢”<br>“别在意，总会有办法的”<br>史进安慰莫志后，莫志用憧憬的目光仰望史进。<br>“其实我啊，想像史进大哥那样把弓拉得更好，虽然我在家乡是最好的，但是史进大哥的弓是天下第一的”<br>“这话过了，这世界还有比我弓术更好的”<br>“骗人的吧”<br>“射中飞雁的眼睛，百步之外射中柳叶……那样的‘天下无双的神射手’是真的有哟”<br>“有这样的人？”<br>“梁山泊的‘小李广’花荣”<br>“梁山泊的，‘小李广’花荣？”<br>薛永慌忙阻止了说出“梁山泊”的史进。<br>莫志，又一次嘟哝了那个名字。<br><img src="/upload/pasted-74.png" alt="upload successful"><br>“梁山泊的……‘小李广’花荣”</p><p>钟楼的钟被敲响了。犹如雷鸣般连连作响。<br>这是自唐代废佛以来，从未鸣响过的告急的大警钟。<br>僧侣们陆续聚集过来。是嵩山各处的大小寺院的僧侣们。寺庙的男子，小僧也混在一起。也有从邻近的寺院逃跑了的各派的僧尼的身影。<br>僧侣们按次序聚集在金山大师的周围，讨论今后的存亡问题。<br>其中有一群体格健壮的僧兵。手里拿着一根棍子。有名的少林寺的武僧为了保护金山大师而筑起了铁壁<br>史进走近那些武僧们，打听有关王进的事情<br>“知不知道一个叫王进的用棒高手？可能他没有自称王进吧”<br>“不知道，他的法名是？”<br>“不知道”<br>“那我就没法回答了”<br>史进拼命地寻找，但聚集过来的僧侣中却没有王进的身影。为了询问金山大师，史进回到了大雄殿前。金山大师知道莫志是白马寺的幸存者，把莫志叫到跟前<br>“听说龙门禅师已经迁化，寺院被烧毁了，圣典《四十二章经》已经没了吗”【迁化：指人死】<br>“没有，龙门禅师的死前要我们在法难消亡之前，把圣典隐藏在龙门石窟里”<br>“不愧是龙门大禅师。如果我们有传入我国的第一本教经《四十二章经》，佛法必将受到保护”<br>金山大师敲打着黑檀的念珠合掌。粗糙的手和纤细的念珠显得不相称<br>“大禅师在去东京的途中被捕了。在那之前，那女人就去了？”<br>“是的。自称“敕使”，只有大禅师见了面”<br>“你知道些什么消息？”<br>“不知道，大禅师赶走敕使后，一个人苦恼了一阵，说什么，’要是发生战争，大宋就会灭亡‘，因此陷入了极度痛苦的境地，然后就去了东京，我们都很困惑”<br>“理由很简单。她是辽国的敕使。在废佛的风潮下，到处传达要抵抗官军，许多寺庙都相信这一点而抵抗官军。但是，禅师却对其前途担忧。如果寺院和国家争斗，就会变成战争。不能不牺牲。而且……”<br>“我不觉得辽国是要帮我们”<br>史进在一边说道，金山大师第一次把目光投向了他<br>“确实，这是辽国的陷阱吧。趁法难混乱，企图夺取宋国领土”<br>“但是，在这种状态下，少林寺不得不与官军作战”<br>“那你们又是什么情况”<br>“多管闲事罢了【官方吐槽】，在寻人的途中，莫名其妙的被这个公主雇佣了。还没收她一文钱”<br>“你们要找谁”<br>“王进”<br>“从来没听说过”<br>“好像他不在这吧”<br>“那么，早点离开比较好。这座山马上就要成为战场了”<br>金山大师拄着棍子，虽然目光非比寻常的敏锐，但却是一副苦行者虚弱的样子，史进环视了僧兵们，都是一副笃实的表情。<br>虽然莫志说少林寺有“义军”，但怎么也看不出有那样的人。<br>“虽然志向很好，但是连虫子都不舍得杀的出家人能战斗吗”<br>“出家人有出家人的战斗方式”<br>“这样啊，那我就放心了，我也要做我的事了”<br>史进的肚子，突然华丽的叫了起来，昨天什么也没吃就跑出了祠堂，骑着马跑了过来<br>金山大师叫来了一个和尚<br>“库房那边没收影响吧，你们过去看看”<br>和尚们跑到库房里，连锅带菜一起搬出来<br>“正好现在准备晚饭”<br>火星飞舞，烧焦的臭风呼啸的院内，突然就开起了野宴。釜里煮满了米饭，锅里装满了蔬菜、豆腐、魔芋、蘑菇的素菜。僧侣们互相谦让着吃，史进他们也毫不客气地吃了。<br>薛永把碗递给了银树。银树坐在薛永的旁边，和史进他们一起从锅里捞饭吃。也不知从那里弄来的酒<br>史进把酒瓶舀子递给了彭尼。<br>“肩上的担子放下来也就轻松了”<br>“嗯”<br>“你们到底藏了什么秘密，那个不懂人情世故的人可不一般”<br>“最初本打算把她送到洛阳郊外的尼姑庵，但是金山大师因为担心她，就把她转移到了峨眉山的尼姑庵，就是在那孤女峰绝壁上的小草庵，天下独孤的武术尼——“风之九尼”聚集在那里，秘密的守护培养她”<br>“原来如此，那一身武艺也是在峨眉山上训练的吗？”<br>“峨眉山的普贤尼是‘化身男子’……和男人一样，‘风之九尼’怜悯公主，努力把她培养成为一个出色的尼姑”<br>“那你也是‘化身男子’吗？”<br>彭尼一瞥史进，微微一笑，将酒杯送到了嘴边。<br>“那仇人是怎么找上门的”<br>“‘敕使’也曾到过峨眉山，扬言会支持抵抗，所以不要屈服于废佛之类的话，长老们信以为真，当敕使离开以后，又来了一个受伤的尼姑……那尼姑伤痕累累，被唤作’碎尼’，由于心灵也受到了很大的创伤，那‘碎尼’疯狂的哭了起来。碎尼是一个寺院的幸存者，那个寺院幽禁着一个高贵的女人，某天晚上，那里被神秘势力突然袭击，那女子被救走，尼姑们全被杀死……只有碎尼活了下来，向峨眉山逃来”<br>“那个被幽禁的女人，是慕容贵妃吗？”<br>“是的，但当长老们听到这个消息时，敕使已经走远了”<br>“然后你们两个就一齐追了过来？”<br>“一听说仇人，公主就毅然要下山”<br>“峨眉山情况如何”<br>“听说后来被官军攻击了，峨眉山普贤尼她们武艺高强，不会轻易输的……也传言有人在寺院的井里投了毒”<br>“身份暴露的慕容贵妃，居然动手了”<br>彭尼喝干了酒，松了一口气<br>“我因为俗世的繁琐而出家。如果把公主还给金山大师，这次一定要悄悄地生活”<br>“那可是相当困难啊”<br>史进嘟囔着——彭尼用手指摩挲着陪伴已久的刀刃，上面有许多缺口<br>“今后要怎么办呢”<br>“告诉皇帝，辽国对大宋有阴谋，教他停止废佛……行得通吗？”<br>“够呛，为了让皇帝相信，也就只有抓住那个女人了”<br>两个人举起装了酒的碗干杯<br>“也许金山大师也是这么想的。可是，对手是千年女狐。与出家人为敌，也太糟糕了”<br>史进看着一旁金山大师的吃相，不由得瞪大了双眼<br>只见金山大师盘腿而坐，抱着大锅，用碗当勺子。在他一旁的是天穹和尚，只见他们把菜放在放在饭上，猛地就吃干净了，不只是吃的量很惊人，只见金山大师肚子越吃越鼓，皮肤也越来越有光泽，全身充满精气，就像变了一个人一样<br>终于，大师放下了筷子<br>“袈裟拿来”<br>僧人们把放在石柜里的袈裟拿了过来，只见金山大师身披黄金袈裟，手拿般若雷，那起身的身姿，好像一个健壮的巨人。史进深感钦佩<br>“还真的没有成为即身佛啊”【即身佛：即身佛又叫全身舍利，是真实存在的一种东西，是自然风干成为的木乃伊。】<br><img src="/upload/pasted-75.png" alt="upload successful"><br>站在一旁的僧人向大师行礼<br>“大师在坐禅期间，从未停止过瑜伽锻炼”<br>瑜伽是从天竺传入的修行法，即倒立、单手站立、用头站立等方法，保持超人的姿势锻炼肉体，进行冥想。<br>“原来如此，那之后就交给大师吧，我们歇着去吧”<br>银树变了脸色，抓住薛永的袖子<br>“你们以后打算怎么安排啊”<br>史进回答道<br><img src="/upload/pasted-76.png" alt="upload successful"><br>“我答应要帮你报仇，定要找出那个女人，撕下那妖怪的皮！”<br>史进向山门跑去。石秀、薛永、时迁也跟着，银树的瞳孔闪耀着。<br>“好汉不撒谎！”<br>银树也向跟着跑过去，被彭尼一把抓住<br>在出山门之前，史进等人停下了脚步，黄昏的山道上，站着很多的人，大概有上千人吧，大部分是僧侣或尼姑。也有扛着佛像和法具的信徒们<br>“这些人是什么情况”<br>天穹和尚和时迁马上着手调查<br>“他们是从四川，陕西，河南，山西诸寺逃来的人。官军们在铲除抵抗废佛的寺院。试图抵抗的人们，将少林寺作为最后的堡垒”<br>山门打开后，难民们陆续逃进了少林寺<br>“大师，这边交给我们了”<br>站在佛塔上看守的僧兵喊道<br>山下已经渐变黑暗了，在这如海底一般的黑暗中，几道火把的光芒，朝着这少林寺前进，这些火光一点点的汇聚，竟成了一条火焰之河，不久，嵩山的山脚就被包围了，去侦察的僧侣匆匆赶了回来<br>“官军，官军来了，他们就在山下！”<br>包围少林寺的是挂着洛阳旗帜的大军。<br>“讨伐违反朝廷命令的少林寺！”<br>鲸浪在嵩山的群峰中轰鸣。</p>]]></content>
      
      
      <categories>
          
          <category> 绘卷水浒传 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 绘卷水浒传 二十周年番外 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>绘卷水浒传 20周年企划 第一章 翻译</title>
      <link href="/2019/03/04/%E5%8D%B7%E6%B0%B4%E6%B5%92%E8%BD%AC-20%E5%91%A8%E5%B9%B4%E4%BC%81%E5%88%92-%E7%BF%BB%E8%AF%91/"/>
      <url>/2019/03/04/%E5%8D%B7%E6%B0%B4%E6%B5%92%E8%BD%AC-20%E5%91%A8%E5%B9%B4%E4%BC%81%E5%88%92-%E7%BF%BB%E8%AF%91/</url>
      
        <content type="html"><![CDATA[<p><img src="/upload/pasted-46.png" width="70%"><br><a id="more"></a></p><h3 id="第一章-中秋望月"><a href="#第一章-中秋望月" class="headerlink" title="第一章 中秋望月"></a>第一章 中秋望月</h3><hr><p><font color="#FF0000">原文作者 森下翠和插画作者 正子公也 版权所有<br><br>个人翻译<br><br>仅供个人娱乐及同好者欣赏<br></font><br><br></p><p>后来才发现，故事中的出场人物大部分都是史书上有记载的，另外原文把公主叫“帝姬”我还以为是日本人特意这么叫，后来才知道宋徽宗那个时候就是这个说法，到了南宋才改了这个说法。<br>另外，真有金奴这么个人，我还说是作者故意的，真是啪啪打脸。<br><a href="http://suikoden.com/" target="_blank" rel="noopener">原文地址</a></p><hr><p><img src="/upload/image1.png" alt="upload successful"><br>仰视苍穹，附在黄昏的天空上小花，恰如那银色的星星<br>凉爽的秋风阵阵，引得香甜的气息扩散在暮色中<br>少女合上了双眼。<br>花的名字是银木犀，又名“七里香”。这个美丽的名字，是母亲告诉他的。<br>立于大花园一隅的银色的树，树干挺拔，树梢已经长到了屋檐那样高，在柔软的树枝上，开满了白色的花<br>少女合上眼睛，陶醉在银树所散发的香味中，在灰色的树干下，少女伫立。</p><p><img src="/upload/image2.png" alt="upload successful"><br>她容貌姣美，头饰和服装也很奢侈，不仅如此，虽然年幼，但是很有智慧<br>天空渐渐暗了下来，花园中空无一人，夕阳西下，星星开始闪烁，但是并没有人来寻找她<br>不久，少女离开树下，走了<br>闭着眼，走过树丛间的小路，走过池塘上的小桥，是她最中意的“游玩”，脚踏在土地上的触感，微波的声音，花草细微的香味，这些感觉，为她在黑暗中勾勒出一幅地图，深深的山谷，神秘的森林，波涛之测，无垠的草原——少女冷寂的嘴唇上，浮现了笑容<br>（我，一个人畅游，始终是我一个人啊）<br>可是，当脚踩在铺石路上的瞬间，少女睁开眼，敏锐的注意到了回廊那里<br>在上到回廊的台阶上，黑白的小狗在等着她，看见少女，小狗摇起了尾巴。不过它觉察到了主人的紧张，突然竖起耳朵<br>“进来吧！”<br>少女跑上石阶，穿过回廊，推开了母亲的房门，屋内很暗，床边有几个人影</p><p><img src="/upload/image3.png" alt="upload successful"><br>人影之间，有一个轻柔的声音在呼唤她<br>“——金奴”<br>是父亲，可是少女却威严的命令道<br>“把灯点亮！”<br>沉闷的空气在流动，在隐秘处的侍女碎步急行，点燃蜡烛<br>房间中亮起来了，是一间奢华的房间，屋内的人衣着也很奢华，尽管如此，房间中的空气依旧冷冷清清，让人紧张<br>少女——也就是金奴，不服的挺起胸故作滑稽的说道<br>“愿您一帆风顺，父皇，啊，应该用’陛下’称呼，因为分隔时间久了，怎样打招呼，金奴已经忘了”<br>“不必多虑，叫寡人父皇就好了”<br>父亲文雅大方的点头，对年幼的女儿藏在笑容间的讥讽，掩盖着的撒娇，他完全没有注意到，父亲，这个在帝国里最高贵的人“天子”——大宋的皇帝，全天下的主人，万民皆顺，他没有被要求“哗众取宠”<br>金奴有些失望，这时母亲看向了她<br>如果父亲是皇帝，那么作为金奴母亲的王皇后，当是母仪天下，可是她却无力的卧在床上，不安的看着丈夫，王皇后长时间卧病在床也都是因为父亲。金奴很是心疼<br>在父亲旁边，精心打扮的贵妃恰好贴近，慕容贵妃，是父亲后宫众多佳丽的一人，据说她是后宫中美女，代替病弱的母亲一手掌控后宫，慕容贵妃对金奴微笑，不过，精心化妆的眼睛却一点也没笑<br>“陛下可是为了皇后特地来看望的”<br>金奴傲慢的转过脸去<br>皇后是来自严谨官僚家的女儿，皇帝是好玩的“风流天子”，年轻时作为“浪子”——游手好闲之人广散艳闻，即位后曾经有一段时间认真的做皇帝的工作，而现在则把国家托付给大臣，尽情的置身于绘画园艺等自己的爱好中<br>“能看到父皇很高兴，是吧，母后”<br>借此机会给父母拉近关系也好，金奴的父母关系和好如初也好，在那之前，父皇亲近的宦官杨森入内<br>“杨森特向公主殿下献上玉兔和青蛙，皆由糖制成，为殿下中秋赏月助兴”<br>所谓宦官，是指在后宫服侍的阉人。杨森微胖的脸上堆满讨好的笑容，双手奉上做滑稽动作的糖工艺品，金奴看也没看一眼<br>“母后，今晚到父皇宫中参加宴会如何，有戏剧，有舞蹈的表演呢”<br>慕容贵妃的不满显露出来，王皇后轻轻的微笑了<br>“这样的话，你和哥哥一同去吧，我的身体实在是不好”<br>在床台下，作为兄长的桓王子站在柱子后面，他比金奴年长三岁，将来会被立为太子<br>可是，他软弱无能，只是装装样子罢了<br>“兄长也希望母后一同前去，恳请母后换一些别的药，改变一下心情”<br>“——说道药的话，贫道倒是从月宫得到了合适的药”<br>金奴看向那个从未见过的年轻道士，他穿着道服，手持大大的金色拂尘，留着很是别致的胡须，一脸的严肃<br>“啊，你就是那个叫做林灵素的术士，最近没少给父王奉承了不少‘好处’吧”<br>皇帝有许多的爱好，他是绘画和书法名家，又喜爱珍奇的动植物，也好收集奇石怪岩，现在又热衷于“道教”——追求着不老不死，羽化登仙的神秘仙术，为此可是没少赏赐这些道士，在这些道士中，皇帝最喜爱的，就是这个道士——“通真达灵元妙先生”林灵素。皇帝责备了女儿<br>“金奴，林先生和其他的道士可是不一样的，他是货真价实，从天上下凡的仙人，因而也是深谙医术，今天晚上特地请过来为皇后看病”<br>“正是如此，那么我们首先进行祈祷，再由我开出仙药处方”<br>金奴挡住了道士的去路<br>“母后喜爱观音经，你能读吗?”<br>“道教和佛教是不同的”<br>林道士锐利的双眼，撇了一下瞪着眼睛的金奴，这是令人恐惧的眼睛。不过，皇帝并没有察觉，为了改变话题，说道<br>“说起来，这个公主是难产所生，使得皇后信奉高僧，进行祈祷。那个高僧，曾将一句偈语给予这个孩子，不过，到了现在也不知道什么意思”<br>“什么偈语”<br>“天有三日，满月辉耀”<br>慕容贵妃皱了皱眉眉头<br>“陛下，那可不是什么吉兆啊”<br>“是这样吗，长老也没说什么不吉利啊，不过……你怎么看，林先生”<br>“那个僧人害怕引火上身吧，贫道就直说吧，’日’代表天子，三日是则是……”<br>“那月又是什么呢”<br>“月所指的是阴，满月之时是十五……说不定指的是十五岁的女子将会危及帝位，这可是大凶之兆啊”<br>皇帝不安的看着金奴，此时，王皇后立刻吩咐王子<br>“为你父皇送行，不久，就开始宴会吧”<br>慕容贵妃婉然的微笑着，扫兴的把手放在皇帝的手臂上<br>“陛下，回到御殿吧，如果登高赏月，气自然就消失了”<br>皇帝离开座位，慕容贵妃等人也随之而去<br>人们走后，金奴用小手轻轻的关上门</p><hr><p>低空之中，赤色的满月正在爬升</p><p><img src="/upload/image4.png" alt="upload successful"><br>宽广的房间中，只有金奴和王皇后，金奴伺候母亲床上休息后，静悄悄的爬上窗框，向外眺望，宫殿被高耸的围墙包围着，还看不见月亮，但耳朵可以清楚的听到远处的音乐和笑声，今晚，大家一边赏月，一边举行宴会，金奴还不曾参加过宫中的宴会<br>“很是热闹啊，但是，也没什么好羡慕的，我喜欢安静”<br>“金奴，你所说的“骗子”，还记得是在哪里吗？”<br>“当然，舅父大人”<br>皇后脸上浮现了笑容，她的哥哥是个光明磊落的人，皇帝也很亲近，现在作为巡察使巡查着各地，是母子两个能指望的人。他帮着皇后寻得有效的药，给了金奴一条小狗<br>“舅父大人，我听闻你马上要离开了，但愿一帆风顺”<br>奶妈伺候几人吃饭，皇后的饮食都是奶妈一手操办的。从外面运来的东西，也必定让狗先试毒，这也是叔父的吩咐<br>舅父说，大臣们为了得宠陪着皇帝进行各种游玩，政治被荒废，还有人上书说应另立新皇后。看着皇帝皇后不和，又有妃子谋求着皇后的位置<br>“因此说，你的母亲，处在极度的危险当中”<br>“不要紧，母后，由我来守护，我才不是什么不吉利的孩子”<br>金奴强打精神，看着很是丰盛的晚餐<br>“中秋要吃什么呢？”<br>桌子上和平时一样摆列着素食，母亲是虔诚的佛教徒，发病之后变得更加虔诚<br>“周围没有月饼啊”<br>当金奴舔着嘴唇，准备吃饭时，奶妈却用手巾抹着眼泪<br>“据说后宫其他的妃子，被陛下邀去参加宴会”<br>“哎，不管了，金奴开吃了”<br>金奴用双手抱起母亲，银木犀的香味在床帐中散布开来<br>“今年，那银树开花了，可漂亮了，明天，我陪母亲到庭院散步去吧”<br>“真是个好孩子”<br>皇后用纤细的手和善的摸着女儿的头发<br>“那棵树，是在我成为皇后时栽下的，银木犀，又叫‘七里香’，七里之外，都能闻见它的芬芳”<br>“七里，是有多远呢？”<br>“母亲我是从未出过皇宫，也不知道啊”<br>皇后的眼中泛起泪光，金奴一看情况不妙，赶紧笑了起来<br>“中秋还是要吃月饼，我去向父皇讨要”<br>金奴溜出房间。厨房中还有奶妈，其他的侍女都去宴会上帮忙了。看门的小宦官，是金奴要好的玩伴，不知什么时候金奴喜爱的红衣玩偶丢了，奶妈在小宦官的床上发现了，本来要暴揍小宦官一顿，被金奴拦下了<br>“呀，是我的错，我不小心落在这里的”<br>宦官多是穷人家的子弟，或者是孤儿，金奴有很多玩具，很是让他们羡慕<br>要求通过时，小宦官麻利的打开门，什么也不过问，小狗也跟在金奴后面<br>“你得在房间替我守护母亲大人啊”<br>小狗一听，就折返了<br>从皇后的寝宫出来，就仿佛置身于另外一个世界。外面很是华丽，树上挂着灯笼，宫殿用七色布做成的假花装饰着，音乐和宴会的气息在空气中流动，盛装打扮的人们快乐的往来着<br>在人群中，金奴看见了打扮的格外华丽的的慕容贵妃，被一群侍女环绕。</p><p><img src="/upload/image5.png" alt="upload successful"><br>七色的衣服下摆拖曳着，带着镶嵌宝石的首饰，扮做月宫的嫦娥模样，为了表示自己是晚宴的女主人，还特意在发饰上插了一朵大大的红菊，隐藏在树丛中的金奴，听到了侍女们谄媚的声音<br>“这一朵奇异的红菊，更是映衬了贵妃娘娘的美貌”<br>“就是就是，但还是金色的菊花是最漂亮的”<br>金奴的得意的笑着<br>“那金色的菊花，是母仪天下的象征，能种那样菊花的，只有母亲的庭院”<br>贵妃们走后，金奴脚步轻快的到了向着父亲的御殿走去<br>“我要赶到那些妃子之前，得到最好的月饼”<br>金奴加快了脚步，突然被什么人叫住，回头一看，一个侍女站在柱子前，是“月仙”，这是父亲所赐予的一个名字，一走进，便涌起了强烈的香气<br>“公主殿下，这边”<br>“月仙”拿出装有漆器的箱子，里面装着一个刻着美丽家徽图案的月饼<br>“这是皇帝陛下赐予的，一个意义非凡的月饼，请一定要带给皇后娘娘——”<br>金奴顿露喜色<br>“父皇呢？”<br>“已经入席了，要一起来吗”<br>满月好像悬挂在御殿的屋顶一般，金奴也是非常想去，不经意间，看了向石阶上行的贵妃一行人一眼<br>“不行不行，还是要把月饼呈到母亲面前，不能去”<br>金奴稳稳的抱住箱子，飞快的返回皇后寝宫<br>“母亲大人，这是从父皇那里讨来的月饼”<br>皇后强竖起身子，看着金奴红扑扑的脸颊微笑，因为奶妈不在，金奴寻找小刀，费力的用小手切出一大块月饼。<br>“这大块的，母亲大人吃”<br>“一会，先给哥哥切一块，让奶妈他们也来吃一些吧”<br>皇后一边听金奴自言自语，一边慢慢的吃着月饼<br>“好吃？那就多吃一些，母亲大人也要打起精神”<br>金奴也为自己准备了一小块，放在碟子上，是蛋黄馅的，小狗也摇着尾巴，扑向撒在地上的残渣<br>“我去泡茶喽？有舅父大人给的桂花茶”<br>可是金奴并没有得到回应<br>盛月饼的碟子摔在地板上，皇后口吐鲜血，倒在床上</p><hr><p>皇宫，依旧像什么都没有发生一样，赏月宴依旧继续着<br>只有皇后寝宫被封锁，金奴在后宫的地下室里接受着调查<br>一群面容恐怖的官员，围着金奴，因为是公主，所以她不会被绑起来，被严刑拷打，可是，金奴握紧裙子，紧紧咬住的嘴唇上，渗着鲜红的血<br>“这月饼，是那个侍女月仙给的”<br>金奴，拼命的忍住眼泪<br>月饼有毒，就连舔了地板上豆馅的小狗也死了<br>皇后马上从房间中被抬出，永远也不能再见了<br>“母亲……!”<br>房间中一片昏暗，谁的脸也看不真切，为什么，父亲和哥哥都不在，金奴恨恨道。一个官员说了<br>“侍女月仙，今早突然患病，请假回家了”<br>调查的官员们，像玩偶一样，缄默不言<br>皇帝疏远皇后，慕容贵妃垂涎着皇后的位子，皇帝被大臣和林灵素所迷惑，被进言皇后可是个不怎么吉利的人，不管“真相”是什么，“朝廷的丑闻”是不存在的<br>要金奴为此死掉，可以说是平息事端的上上策——不过，年幼的孩子怎么可能毒杀自己的母亲<br>“那么，该怎么办”<br>官员们可不是因为寻找那个所谓的“犯人”而感到苦恼，就在这时，悄然无声的地下室门开了，走廊的明灯，好像太阳一样刺着金奴的眼睛，一个高个子的男人，就站在着光芒之中<br>“这是——王都尉王大人！”</p><p><img src="/upload/image6.png" alt="upload successful"><br>官员们都礼貌的低下了头，是母亲的哥哥，也是她唯一依靠的舅父，可是，出自那个人的言辞，更是打垮了金奴<br>“是陛下下达了秘密处理的命令，公主太年幼，她说的话不可信。皇后……是由于生病后太过悲观，自杀而死的，发丧避开佳日，不要让人们感到不安，还有，公主马上出宫，入寺为尼”<br>“舅父大人”<br>第一次，金奴叫出声来<br>“母亲，就是被谋杀的，那毒月饼，是月仙……”<br>“金奴！宫女月仙，黄昏前就在家中死了，我已经确认过了，今天晚上，不可能在宫中”<br>很快，金奴被拉入轿子中，离开皇宫。深夜，满月，在天空的最高处闪耀着。<br>金奴茫然的坐在漆黑的轿子中，叔父透过窗格，用谁也听不到的声音低声私语道<br>“你得忍耐！先保住性命再说”<br>他也不知道真相，但是他知道，只要金奴在这宫中，就会有危险<br>（今天晚上突然返回来，真的是天助啊）<br>皇帝依旧享受着慕容贵妃奉上的美酒，沉醉在林灵素的幻术中，听闻皇后突然死亡，也没做声，只是默然的将此事交给林灵素处理<br>金奴被装上小轿子后，顺着高墙掩映的小路，逃离了皇宫<br>银木犀的香味漂浮在黑暗中。她哭做泪人<br>（杀死母亲的，到底是谁）<br>马上，香味消失了，已经置身七里之外了<br>（我所看见的月仙，究竟是谁）<br>但是，另外的味道，那股傲慢的香味，飘进了轿子中<br>“这是在哪，又要去向何方”<br>“这个围墙的对面是——贵妃的花园”<br>“这样的话，应该开着那种红色的菊花，谁能帮我摘一朵”<br>不久，一支红菊从窗子间隙递入<br>这花，就是慕容贵妃头上装饰的那种红菊，有一种让人成瘾的香味，也是从那“月仙”身上散发出的味道<br>从皇宫后门出来后，天地忽然宽广了。可夜空明月依旧。小小的公主，在黑暗中消失不见</p><p><img src="/upload/image7.png" alt="overwrote existing file"><br>此后，那让人成瘾的红菊花瓣，犹如鲜血般一点点的扩散着</p><p>与此同时，满月在西边的荒野上。也一样闪耀着<br>在月下不声不响赶路的，是一个瘦削的剑客，不年轻，也不年长，那脚步，沉重但从容。<br>手中，握着一把伴随多年的剑<br><img src="/upload/image8.png" alt="upload successful"><br>他，是个逃犯，已经逃了很长时间了。<br>被青白色的月光照射在脸上，也还是面无表情。唯一的目标不过是这么一直走下去——就像这样，一种无声的意志<br>只有这一次，他仰望夜空<br>苍白的月亮，在天空中最高处放着光芒，那清澄的月光中，映射着一张无比怀念的面孔。那张坚毅的脸上，有了希望<br>继续走着<br>一群大雁穿过月光<br>热血，在剑客的胸膛里涌起<br>我还有能看这轮明月机会呢<br>一个孤独，没有希望，没有家人，没有朋友，甚至连名字也没有的“逃亡者”<br>（我真的是无罪的吗）<br>无罪，却被掌权者陷害，仍然被通缉的不幸的人<br>在这午夜的荒野上，望着明月的那个姿态，不就是我罪的姿态吗？<br>（不该停下来吗？）<br><img src="/upload/image9.png" alt="upload successful"><br>剑客止住脚步，拔出剑来<br><img src="/upload/image10.png" alt="upload successful"><br>银色的月光散在刀刃上<br>下一秒，一刀切向藏在岩石阴影中的刺客。这个刺客不是一个人。剑客又摇摆不定的走了很长一段路，无数的眼睛看着这个男人<br>“果然还是不行啊”<br>一个人说道<br>月光中，无数的剑刃反射着月光，谁的脸也看不清楚<br>“我们可是从华州一路追过来，这一带可是到处在悬赏抓拿你”<br>“谁指示你们的？”<br>每个声音都带着杀气<br>“你的项上人头值三千贯，另外，那位大人还说，还能提拔我们，闹个禁军将校当当”<br>“一个小小教头的脑袋，竟然能值那么多钱，我在东京做了什么，上了他老婆不成？”<br>剑客的脸上，依旧面无表情<br>于是，又有声音从黑暗处传来<br>“让道，垃圾们”<br>隐藏着的人们离开杂树林，为那个男人让路。那个男人敏捷的挡住剑客的去路，低声说道<br>“你可是杀了上千的要抓捕你的人，那些人的兄弟，朋友都在这，因果报应，你是跑不掉的”<br>无数刀刃闪闪发亮，在满月的照耀下，倒影在地上<br>“明天，这里就会多一座墓碑，就是你你罪人王进的墓碑”<br>剑客手拿的剑鞘，吧嗒，掉在荒野的沙地上<br>以此为号，这场月下的死斗就开始了<br>满月之光照耀着一切，在苍茫的月光下，刺客扎在一堆，是一百人，二百人，还是三百人？<br><img src="/upload/image11.png" alt="upload successful"><br>剑客向着刺客们的刀刃方向前进，手脚麻利的斩杀挡住去路的敌人，但敌人的数量并没有减少，反而像潮水一般淹没前进的路，剑客的手腕，肩膀，额头都流着血，尽管这样，剑客也没有停下前进的脚步<br>不知不觉，剑客已经杀到了河边<br>在月光照耀下泛着银光的河流，蜿蜒前行<br>月光下，河流畔，男人们在持续砍杀着，死的人倒下了，力竭的人也倒下了<br>急促的呼吸声，刀剑碰撞的声音，脚踩在沙子上的声音一直在继续着，这是永不结束的战场<br>月光在河面凌乱，波浪在银色中闪耀着<br>剑客击败敌人，开辟着前进的路——那瘦削的背影，逐渐消失在敌人身上<br>真正的静寂到来了<br>河畔横尸一片，无人生还<br>黑暗中，依旧有呼唤某人的声音，但那是风浪的声音也说不定</p><p>十年时光，如白驹过隙，转瞬即逝<br>大宋依然繁荣着，国都东京汴梁充满了烂熟的光辉，然而，政治腐败，朝纲霍乱，内忧外患不断，亡国之种，也开始萌芽<br>这十年间，光和黑暗交错前进，向着灭亡走去<br>世间叛乱不断，人们为私欲狂奔着——没人理会黑暗中消失的公主，也没人理会波浪间奔走的剑客</p><hr><p>“——史进兄弟！！”<br>听见招呼的声音吗，年轻人回过头来<br>太阳闪耀着<br>天高地广，太阳如火团刺眼的燃烧着，这是夏天</p><p><img src="/upload/image12.png" alt="upload successful"><br>“啊”<br>年轻人回应着——“九纹龙”史进举着一只手。背后，将水面淹没了的芦苇在清爽的风中摇曳着<br>招呼他的，是一个鼻子尖有伤的年轻人<br><img src="/upload/image13.png" alt="upload successful"><br>“不去吗，史进兄弟，已经开始了”<br>“拼命三郎”石秀抱着胳膊，扬起的下巴犹如山峰一般。远处传来梁山山脚下打麦的声音，年轻人训练叫喊的声音，枪棒敲击的声音<br>“林教头的棒法班吗——？”<br>史进抽出用芦苇叶子做成的小笛，轻轻的吹着<br>“我就不去了，那个对我来说根本不算‘授业’”<br>“是这样吗？”<br>“你平时的伙伴，那个脸色很不好的人怎么了”<br>“杨雄身体不太好，在房间休息了”<br>石秀愉快的享受着从湖畔吹来的清风<br>“感觉有些无聊了？”<br>史进把小笛扔向波浪间<br>“咣咣”，枪棒相互撞击的声音在山中回响着，穿过湖面在风中穿梭着<br>史进和石秀肩并肩站着<br>“一同前去的话，你就不会感到无聊了”<br>两个年轻人一起在湖边走着。今天也是“梁山泊”平和的一天</p><p>十二世纪初，北宋正是盛世<br>在中国大陆的东部，山东地区，梁山这个孤峰的山脚下，散步着茫茫的湖沼，大小水路错综复杂于期间，生长着茂盛的芦苇，好像要把外人引向不为人知的深处一般，不过，也并没有什么外人。<br>梁山山脚下的水洼——正是这“梁山泊”<br><img src="/upload/pasted-20.png" alt="upload successful"><br>在那里，聚集着在大宋繁荣的阴影之下产生的人，为首为天下人所称颂的山东“及时雨”宋江，在此领导着各路草莽英雄</p><p><img src="/upload/pasted-21.png" alt="upload successful"><br>年轻的侠客“九纹龙”史进。中秋月下，因侠义之心，被迫烧毁家宅，逃离故土，百转周折，最终入伙梁山<br>还有挥舞那六十二斤水磨镔铁禅杖，不念经，不参禅的大“花和尚”鲁智深<br><img src="/upload/pasted-22.png" alt="upload successful"><br>曾经的八十万禁军枪棒教头“豹子头”林冲<br><img src="/upload/pasted-23.png" alt="upload successful"><br>无双的剑客“青面兽”杨志<br><img src="/upload/pasted-24.png" alt="upload successful"><br>神算鬼谋的“智多星”吴用<br><img src="/upload/pasted-25.png" alt="upload successful"><br>呼风唤雨的叛逆道士“入云龙”公孙胜<br><img src="/upload/pasted-26.png" alt="upload successful"><br>打虎壮士——武松<br><img src="/upload/pasted-27.png" alt="upload successful"><br>大宋第一神射手“小李广”花荣<br><img src="/upload/pasted-28.png" alt="upload successful"><br>手持双板斧，狂暴的“黑旋风”李逵<br><img src="/upload/pasted-29.png" alt="upload successful"><br>水之子“浪里白跳”张顺<br><img src="/upload/pasted-30.png" alt="upload successful"><br>统率连环马铁骑的“双鞭”呼延灼<br><img src="/upload/pasted-31.png" alt="upload successful"><br>在世风日下的时代，众星闪耀，豪杰辈出<br>江州战<br><img src="/upload/pasted-32.png" alt="upload successful"><br>祝家庄战<br><img src="/upload/pasted-33.png" alt="upload successful"><br>另外，青州，<br><img src="/upload/pasted-34.png" alt="upload successful"><br>华州，<br><img src="/upload/pasted-35.png" alt="upload successful"><br>在曾头市接连不断挑战强敌，愈战愈勇的河北俊雄“玉麒麟”卢俊义<br><img src="/upload/pasted-36.png" alt="upload successful"><br>武神“大刀”关胜<br><img src="/upload/pasted-37.png" alt="upload successful"><br>名震天下的英杰们接连不断的入伙梁山<br>初代头领晁盖不幸亡于征战，不过，宋江继承其遗志。因宿命而联结的人们，在战斗中相知相遇<br>“替天行道”<br>因大义而集结的豪杰们，将在这片浑浊之世开天辟地<br><img src="/upload/pasted-38.png" alt="upload successful"><br>聚集在“替天行道”杏黄大旗之下的英雄豪杰，共计一百单八<br>他们在这水泊梁山安营筑寨，兵多粮足<br>而在朝廷那边，“宋江等一百零八贼寇，在山东梁山泊横行霸道”——是大宋的“四寇”之一</p><p>“九纹龙”史进和“拼命三郎”石秀正是名列这一百零八好汉之中<br>两个人优哉游哉的去向了湖畔<br>初夏，是作为水乡的梁山泊最美的季节<br>天空湛蓝，水草丰盛，湖畔，芦苇和柳树随风摇曳。水中小鱼跳出水面，抓住小鱼的水鸟一飞而散，女人们在岸边洗洗涮涮，穿着肚兜的小孩把小鱼驱赶到水浅的地方。捕鱼归来的父亲的鱼筐里，装满了肥硕的鱼<br>他们，本是这周遭的百姓，因天灾，苛政，重税，官逼民反，最终逃向梁山泊，在这没有收黑钱的判官，没有剥削的地主<br>在金沙滩的岸边，“工作”归来的汉子们，正在从船上卸下战利品，船上，粮草堆积如山，亦有牛有猪<br>这一行人打着“清风山”的旗帜，“锦毛虎”燕顺站在船头，指挥着手下<br>石秀打了招呼<br>“大哥，这是大丰收啊”<br><img src="/upload/pasted-39.png" alt="upload successful"><br>“可不是，那石河镇的‘蒲千石’素有贪得无厌之名，今日搞了他一手，一打开仓库，你猜怎么着，那么多的物资，今晚可以大宴一场了”<br>梁山泊的田地有好收成，鱼产也很是丰饶，并且，也通过这种方式来积蓄物资<br>梁山一百单八将集结不过三年，梁山泊一片和平，保持着独立，屡次击退官军的讨伐，近来也无战事，百姓安居乐业，梁山泊也慢慢积攒着财力兵力。这“黄金三年”，每天继续着<br>大家丰衣足食，往来皆友人，没有谁能阻止这些美好日子<br>史进也想对谁打声招呼，就回过头来。一条令人清爽的水平线直到视野尽头，好生一幅美丽，宁静的景观。<br>史进也尽情的享受着着晴空的风，偶然，他感到了什么东西在嗔怪似的</p><hr><p>拂水而过的风令人身心愉悦<br>褪去上衣，史进身上那腾空而起的龙在初夏的阳光中闪耀着，这“九纹龙”的绰号正是来自他身上九条龙的刺青，这刺青是他的父亲在他十五岁母亲病故的那年专请有名的刺绣师刺出的，历时半年。史家养不起教授史进武艺的那些云游武术家，史太公也是因为史进一味专注练武感到悲观，落下了病。没几年后，史太公就去世了。<br>虽然如此，史进也并未太过悲伤，这大概是因为他与生俱来的性格和身为习武之人的气魄使然<br>“不练了，歇息一会”<br>史进在树荫的石头下坐下了<br>放眼望去，士兵们都满腔热血的挥舞着棍棒<br>“一个能打的也没有吗？”<br>史进心里，武艺是排在首位的，他追求强大，不是领军破敌的那种强大。自己武艺能高明到什么地步，谁又是最能打的，这才是史进关心的<br>入伙梁山的汉子们，那都得会两手功夫。这是梁山好汉的基本要求。因为不知道官军什么时候过来讨伐，他们来了，得干跑他们啊。这其中的一些年轻人成为梁山军队的中坚力量，第一个训练他们的，是“豹子头”林冲——曾经在大宋的禁军中担任枪棒教头的男人<br>枪棒，是大宋第一的武器，是远超其他兵器的<br>梁山的汉子们，最开始是在林冲那里学习枪棒功夫，这之后，就会到“金枪手”徐宁——曾经的禁军金枪班的教头——学习枪术。如果年轻又有些功夫，就可以接受步兵训练，成为军人，若是会弓术就会加入“小李广”花荣的部队，特意选出其中的佼佼者成为骑兵，由“病尉迟”孙立和“井木犴”郝思文来传授马上战斗的技术，然后再分配到各部队<br>虽然有很多头领带领练兵，但是士兵们最为崇敬的“师父”，只有“豹子头”林冲<br>林冲有两员副将：“病大虫”薛永和“打虎将”李忠。薛勇出身武术世家，功夫了得。李忠也是习武之人，以前还教过史进棒法，也有林冲麾下“白衣兵”的身法。所谓“白衣兵”是专挑擅使枪棒的士兵组建而成的，他们对棒的打法，手脚的位置，都很精通<br>上百士兵齐挥棍棒的场面很是壮观，史进看的也是入了神<br>林冲教授的棒法很基础，但不管是多么基本的简单招式，林冲都能表现出那种勇壮之美，几招连下来就如行云流水一样轻松自如<br>在士兵们心中，林冲那可是神一般的存在，他们都卖着力气的模仿林教头，可单是这样，还是不够的。李忠和薛永拍着士兵肩膀，把他们按照水平分成三组<br>这就算完成了士兵的“选拔考试”，二等三等的士兵们被分到各个步兵部队，在各个头领的带领下，进入实战的“最终训练”，一等的士兵是有望成为军中的小头目的，这其中很多人都是老兵，积累了不少战斗经验，他们对自己的武艺很自信<br>不知不觉，太阳倾斜下去了，黄昏的云彩开始在天空闪耀<br>“那么——”<br>薛永把大家集结在林冲面前<br>“现在开始模拟实战训练，一个接一个上前”<br>壮汉们脸上露出惊讶的表情<br>“难道林教头要出手了？”<br>汉子们兴奋的结结巴巴<br>“豹子头”林冲手持棍子站在他们面前<br><img src="/upload/pasted-40.png" alt="upload successful"><br>单是这么站着，就很彰显林教头干净利落的身段<br>首先，一个对自己有信心的后生上前，出拳要攻正面，只一下，就被打了下去，又有个人上前，只是轻碰一下，就下来了。又有个大汉上前，倒是能吃下两三棒，不过如此。没有人能坚持到最后<br>林冲认真的战斗着，淡然的取得胜利，他也试了了二等，三等班，即便败者怎么向下滚落，也没人会笑。挑战林冲，虽败犹荣<br>在炫目的晚霞中，只有木棒敲击传出的清脆声响<br>不久，金色的星星闪烁在地平线上<br>跟全体都比试过后，林冲轻轻的行了个礼，并从其中挑选几人作为自己的亲兵。林冲麾下的白衣军，是梁山泊年轻人向往的部队，向林冲讨教时，无论是谁林冲会悉心指导他们<br>就在林冲要离开时，一个男人出现在林冲面前<br>正是史进</p><p>薛永想要说什么，被李忠阻止了<br>史进举起棍子站了起来<br>然后，当和对峙的林冲对视的时候，史进突然感到背后一阵刺痛、、<br>下一瞬间，林冲的棒子猛的袭来，击中前胸，史进硬扛下了，不过，当被第二棒击中时，史进已经感觉身体轻飘飘的要倒，第三下，史进躲过去了。<br>以前，史进可是擅长十八般兵器，可以说是梁山泊数一数二的高手。那朝气蓬勃的九条龙正是他擅长多家武艺的象征，这是他融会贯通各门武艺的结果<br>且说这林冲，无论对面如何，他是一点也不乱，冷静的预判着对手的下一步行动，就这样，史进有些招架不住，，不能发挥自己所长，一直被动防守<br>李忠嘟囔道<br>“这史大郎果然有些手段”<br>薛永的表情有些奇怪<br>“那还不是正在被打压”<br>“这世上有几人能把林教头逼得如此凌厉，呀，坏了坏了，大郎出破绽了”<br>史进急于取胜，他把棒子向上甩去，用力一棒。那林冲又怎能是等闲之辈，林冲接下了他这一棒，他的动作轻快，史进完全没有突破的机会，林冲向下一踏，棒子就沉吟起来，下一步就是——刹那间，史进条件反射的使出了“那一招”<br><img src="/upload/pasted-41.png" alt="upload successful"><br>但见出手之棒，犹如箭一般袭向林冲前胸，林冲把棒子一转，史进的棒子稍微减了些气势向着林冲侧腹部袭来，林冲一点也不慌，往后一个大撤步，只见林冲向着史进鸠尾（腹部上边那一部分，亲生经历，打下去巨疼）处猛地攻了过去<br>喘不上气了<br>眼前一片金星，史进倒在地下，看着那血色一般的晚霞</p><p>史进一睁眼，发现自己在“神医”安道全的医务室<br>梁山泊的医院是一个很大的建筑，草药的气味甚至已经渗透到了柱子里。史进呆呆的望着天花板，肚子疼得厉害，呼吸也有些困难<br>在旁边的椅子上，林冲也在接受治疗<br>安道全注意到了史进醒来，盯着史进说<br>“你得谢谢林教头，要不是他，你早凉了”<br>安道全在林冲被史进打中的侧腹部贴了膏药，缠了绷带<br>“肋骨有裂痕，得静养半个月”<br>听了这话，林冲依然泰然自若，他把脸转向林冲，小声说道<br>“——‘夕阳流星’”<br>史进起身看向林冲<br>“你知道这招？”<br>“我只见过一次，在东京的禁军校场”<br>史进突然觉得很相似<br>他面前的林冲和“那个人”，不是外表，而是某种东西非常相似<br>“史进，我且问你，你是怎么会这一招”<br>对于林冲的提问，史进不禁在记忆中眩晕<br>（已经十年了吗）<br>沉浸在记忆中，史进不禁愕然<br>（怎么就忘了呢）<br><img src="/upload/pasted-42.png" alt="upload successful"><br>那个人<br>那个满月的夜晚</p><hr><p>月亮照耀着梁山<br>“王进教头曾经是我的师父，虽然时间很短，但是没有他，就不会有现在的九纹龙”<br>这是史进的真心话，林冲静静的点点头，对于“王进”之名，林冲也是无法用语言来形容<br>“王教头不是被定为罪人了吗？”<br>“我知道，我曾救下因为悬赏通缉而逃命的王师父，把他藏在家中，这已经是十年前的事情了”<br>“——是这样啊”<br>林冲把安道全煮好的药汤端到嘴边，这热气腾腾的汤药也让林冲想起了往事，他语调自然的说道<br>“王教头的棒法自成一派，由于没有接班人，我还以为王氏棒法就此断绝了，不成想今天又见到了‘夕阳流星’，你是他的继承人吗？”<br>“不是，我也不过是学到了一些技巧而已”<br>说话这档，听见门外传来了意想不到的人的声音，林冲和史进向门看去<br>“原来是这样，那可真是不可思议的缘分啊”<br>不知不觉，宋江来了，手上提着个水果篮，大概是探病的礼物<br>“那王教头，是个怎么样的人呢”<br>宋江坐在椅子上，向林冲问道<br>“他和我一样是禁军的枪棒教头，不知怎么的，惹了我们上司，也就是那禁军的太尉高俅，王教头觉得事情不妙，就逃了出来，高俅更加恨他，还故意捏造罪状，悬赏通缉他”<br>王进被高俅的爪牙严密的监视，帮着他逃跑的是林冲的师父，后来成为林冲老丈人的张澈教头，张教头很是惋惜王进的枪棒武艺<br>“在这之后……又怎么样了？”<br>几年之后，谁也没想到林冲也陷入了同样的境遇，当年他还觉得带着老母逃跑的王进很可怜，可没成想没有逃亡的自己却失去了一切<br>尽管这样，林冲还是为王进平安无事感到高兴<br>“大郎，王教头后来怎么样了？”<br>“他当时藏在我的家中，但是后来缉拿文书到了，他不想给我找来麻烦，就离开了”<br>宋江好像深受感动<br>“你去找王进先生，把他拉上我们梁山如何？”<br>宋江吩咐手下去叫“石将军”石勇，很快，石勇和吴用就到了<br><img src="/upload/pasted-43.png" alt="upload successful"><br>“石将军”石勇——位列梁山泊第九十九位，原来是个彻头彻尾的赏金猎人，为了获得高额的赏金，至今手上还有全国通缉犯的名册<br>“众所周知，王进可是很值钱的”<br>石勇是个沉默寡语的男子，但是他带来的情报却各种各样，甚是详细，史进看了看他手上拿的几张通缉令，有些写着“被捕”，有些写着“已死”<br>“怎么，你也想要抓捕我师父？”<br>“我可是从来不抓“无罪之人”的”<br>“你什么意思？”<br>“因为没人知道他为什么会被高俅记恨，还要给他捏造罪名”<br>“师父啊”<br>史进差点说不出话来，他也不知道怎么用语言来表达<br>王进瘦削的背影，就消失在荒野间，谁又清楚他背负着什么呢<br>所以史进至今没有跟任何人谈起王进<br>可是，这梁山泊，宋江，林冲，却好像知道师父的苦衷一样<br>史进想起了离别之际王进的脸孔<br>一直躲避重金悬赏的王进到底犯了什么罪，史进也没有问过，王进也没有说过，就在史进送别王进离开史家庄的时候，王进把这个“秘密”告诉了他<br>“这通缉令上的罪状就是扯淡，师父跟我说过，你们知道师父怎么说的吗？”<br>所有人都在等待史进的下一句话<br>“师父告诉我，说‘这就是被无赖盯上了’”<br>宋江似乎明白了，而林冲微微垂下双眼<br>“那个‘无赖’，就是……<br>就是当今圣上的宠臣，禁军的首领“高俅大人”，那厮本是东京的一个泼皮无赖，这个公明哥哥也是知道的，他擅长踢毬，正合着那“风流天子”心意。以前那厮还是个泼皮的时候，曾带着手下几个无赖当街欺负一个老人，被我师父撞见，为了制止，就揍了这“高毬”一顿，不成想这厮日后成了太尉，一看手下禁军官员，看见有我师父，就想着报当年的仇，报复一下，在高俅上任第一天时，那时师父身体有病，请了病假，这厮就以怠慢职务为借口要杀人，<br>就是这样”<br>宋江吓了一跳<br>史进屏住呼吸，倾听着窗外的虫鸣声<br>“是的，就是这么点破事”</p><p>夜半，窗外蝉鸣<br>叫了一会，声音中断了，接着传来湖畔海浪的声音<br>石勇不仅有官员的通缉名录，还有多年来收集到的各种各样的小道消息<br>“王进的消息，在十年前就断绝了，我在当赏金猎人的那阵，也听说王进在中秋之夜和百名刺客战斗，遇害身亡”<br>“我不相信，凭借师父的能耐，他肯定还活着”<br>石勇把通缉文书放下，又拿起一个巴掌大小的小册子，这上面写的是一些未处理的事，不可思议的事，往来全国的“可疑人物”的信息<br>虽然名字和相貌都会改变，但只要把这些小情报整理好，就能发现点东西。石勇在这么多的情报中发现一个男人<br>“从几年前开始，有个人在少林寺教授武术，有传闻说他来历不明”<br>“少林寺啊——在河南，离华州很近”<br>少林寺自古以来是因武术而闻名的古刹，能在那里教僧人们武艺的，肯定不是一般人<br>“没错，那就是他了”<br>史进从床上跳起来，顺手超起旁边的棍子，这时，吴用止住了他<br>“等会，你忘了你也是个通缉犯了吗，咱们得准备准备，安排好同行的伙伴，也好有个照应”<br>“那就麻烦吴学究了”<br>那声音，被空中绽放的烟花声掩盖了<br>梁山上，凌振放起了烟花，这是最近刚刚改良的新型烟花<br><img src="/upload/pasted-44.png" alt="upload successful"><br>宋江等人靠到床边，吴用数了数空中大花的颜色<br>“凌振说要做“七彩烟花”，这才三四种颜色”<br>尽管如此，梁山的夜空不断上升，被那耀眼的光芒填满<br>烟花停罢，吴用回头一看，史进已经不见了<br>林冲看向门的方向<br>夜风，正慢慢吹着敞开的门</p><hr><p>史进驾着小船，在星空下穿过湖泊<br>岸边有个小酒肆，房檐的灯笼下，有个脸色难看的汉子正在挥着团扇<br>“张青兄弟，智深师傅在不在”<br>汉子用团扇指了指后面<br>“你悠着点，他不太高兴”<br>这湖边的酒馆，是“菜园子”张青和“母夜叉”孙二娘两人为梁山泊开的，凉风吹过的庭院中也有桌子<br>史进的好友破戒僧人鲁智深站在那里<br>旁边的桌子上放着他心爱的六十二斤大禅杖，在他的脚下，张青的宠物兔子吃下一口青菜<br>“可是很少看见师傅一个人喝闷酒”<br><img src="/upload/pasted-45.png" alt="upload successful"><br>史进一出声，鲁智深就把空酒壶放在桌上<br>“喝闷酒？哎”<br>张青又新上了一坛酒，鲁智深也没招呼史进，史进拉把椅子，随意的坐下了<br>“我说你在这喝了多少酒啊，兄弟我要远处走一遭，本想请师傅一同前去”<br>也不知道是不是听见了史进所言，鲁智深眼睛盯着桌子上的信，那是一张皱巴巴，已经脏了的信。<br>“哦？师傅也会写字？”<br>“洒家写的字还有人夸奖过呢”<br>“兄弟我服了”<br>鲁智深挠了挠，把放在桌子上的信揣进怀里<br>“真不巧，洒家也要出远门”<br>“要是西边的话，咱就一起走吧”<br>“对不住了，洒家是急事，得坐船去”<br>正要问去哪里时——史进注意到梁山那边有一只船正向酒肆驶来，是吴用和朱武派来的“追兵”吧<br>“这样吗，师傅，祝您旅途平安”<br>史进从马厩中胡乱的牵出一匹马，闪身上马，向西奔去，辽阔的天空下，道路连绵不断的展开了<br>史进的身体好似恢复青春一般，似乎感受到了十几岁时吹过的风。从家里出来的时候，为了追求更广阔的世界而离开少华山的时候<br>“师父，我来了！！”<br>史进的声音响彻云霄<br>“啊……他走了。”<br>张青拿着钱包追了过去，但史进的身影早已消失在夜道的另一边。<br>“连盘缠都没带就去了。”<br>鲁智深一把抓住了蓝色的钱包。把钱包塞进怀里，喝完剩下的酒站了起来。<br>“师傅，你去哪里?”<br>鲁智深扛着禅杖走出了店。星空染着湖水。<br>“搞事情去——到时候你们就知道了!”</p><p>跟着史进而来的是薛永和李忠。他们去探望林冲和史进时，在那里受吴用之托把史进带回来。但当他们抵达张青的店时，史进早就不在了，甚至鲁智深也走了。<br>薛永看着路的另一边，向李忠询问了他今天一直在想的事情。<br>“李忠啊，你说好的师父是什么样的师父?”<br>“为什么要问我这种事?”<br>虽然李忠没有做答，但薛永总归是有一点感觉的，李忠也曾想自己开个武馆，可是现在却成了林冲的副将，他很明白自己水平有限<br>“好的师父，会让徒弟“超越界限”，让徒弟达到自己达不到的高度”<br>李忠扶着有些疼得腰<br>梁山上繁星闪烁<br>“但是总有人会毫不犹豫的朝着自己认为是极限的地方冲去，这样的·人，会超越师父达到什么样的境界？”<br>李忠向着岸边的船走去<br>“徒弟也好，师父也好，都会很不容易吧”</p><hr><p>他睁开眼睛，又看到了陌生的天花板。<br>(这又是哪?)<br>史进揉了揉惺忪睡眼。推开吊顶，站起身来，想起来自己找了个小旅馆歇息下了。<br>(想起来了)<br>史进离开了长久居住的梁山泊，一人向西——奔着少林寺去了。<br>史进打开窗，吸入清晨的空气。<br>街边的旅馆早上开门开的早。面向的店面前，有很多游子单的身影，也是一番车水马龙的景象。房间下方的厨房里飘来一股香喷喷的油味。拉面的声音也很吵。<br>“这种风的味道，已经好久不见了。”<br>宋代的行政划分首先是“路”。史进很早就驰行在了广为人知的“京东西路”。由于西边是具有警备森严的都城东京开封的“京畿道路”，所以特地避开北边走的“西北西路”。<br>梁山泊的东西两侧风景差距很大。<br>山东有很多岩山，山清水秀。往西走，大地变得干涸，会有沙尘暴吹来。<br>由于农田中有很多建设在江边高地的梯田，人们的衣着打扮也非常朴素。还有很多村民赶着家畜。<br>这是一场自由自在的旅行。史进饿了就吃困了就睡，有时早上也和一群陌生人喝酒，也会和一些人发生争执。虽然这样，但路上一切都很愉快，但进入“京西北路”时，情况却有所不同。<br>“京西北路”是西京河南——古都洛阳所在的府。<br>虽然史进的故乡在更西边以京兆府、长安为中心的“永兴军路”，但这一代早已形成了类似的风土人情。方言的口音，吃饭的口味，甚至刮过的干燥的风都让人怀念。<br>(哎呀，遇上麻烦了。)<br>史进没盘缠了。他的钱都在梁山泊，他本来就是一个没有隔夜财的男人。盘缠都花在了一路吃喝和酒水上，又受旅馆的店家劝诱，昨天晚上还赌了两把。<br>还是在梁山泊的感觉好啊，这的浊酒喝的他脑壳疼。<br>史进洗了脸，想吃点素面，就走到饭厅<br>“过来，先把住宿费结了”<br>“多少钱”<br>史进大口大口的吃着端上来的面条<br>“我可没钱了”<br>“你说啥”<br>“没什么”<br>在店小二的招呼下，店家掌柜板着脸过来了<br>“你说你没钱，还在这吃的这么爽”<br>“还是托您的福雇了个好厨子，看您生意兴隆，挺好挺好”<br>“这几天，吃霸王餐的人可是不少，生意是真好”<br>“怎么还有这么过分的家伙！”<br>“少废话，给钱，不给钱就把马棚子里你那匹瘦马给我”<br>“那马可值钱了，你打算找我多少钱”<br>“那么瘦的马，你还敢管我要钱，你说说你，昨天晚上的餐费，住宿费，还有酒钱，再加上你打碎的盘子，毁坏的窗户，你说说得多少钱”<br>“这样啊，那我就不管你要钱了，那马便算作你的了”<br>史进吃完面，背着小包袱出了客栈，向马棚子里一看，只看见一个小和尚正在给马喂草料<br>“真是辛苦你了”<br>告别之前的马后，史进沿街向西行<br>“这么走，也挺舒服”<br><img src="/upload/pasted-46.png" alt="upload successful"><br>外面是铺满黄沙的街道。路旁种着高耸的树，形成的树荫正好保护着旅人不受阳光的侵袭。<br>史进一边扛着棒子，一边背着小包袱，走在街道上。<br>这一路上都是干涸的黄土。<br>在被太阳晒得沸沸扬扬的烈日下，道路蜿蜒曲折地向前蔓延<br>今天太阳也很刺眼，没走多久，嗓子就已经干了。虽然路上有店家，但是没有钱。也没有水井或看起来能喝口水的河。史进一边嚼着干枯的酸叶茎，一边耐心地走着。<br>(总会有办法的。)<br>在正午后，史进在远方找到了茶座。<br>绿色的小旗在风中摇晃，好像招手一般。</p><p>店面出乎意料的大，二楼的房间已经坐满了，酒馆的桌子也已经占满了一半左右，看了看，都是当地的居民，但是奇怪的是，他们大多是道士，或者打扮成“道士“的样子<br>（那么这里也开始传播“道教”了？）<br>道教以中国神仙思想为基础的神秘宗教，据说如果坚持修行就能成为长生不老的仙人，由此抓住了人心。近年来，皇帝沉溺于神仙修行，也成为了道士林灵素的信徒。所以全国各处都优待了道士，而官吏和掌权者也为了出人头地而毅然入了道教。<br>(我们的公孙先生要是知道了，不得气死)<br>史进坐在靠边的窗户的座位上。<br>由皇帝发起的道教之乱将大臣、官吏、富人一起卷入，现在扩散到了平民和乞丐当中。在路上，他亲眼目睹了道教的发展状况。成为道士就不会有温饱吃穿问题，乞丐都要扮成道士要饭，而自己置身事外。戴着黑头巾进内。这里谁都能拿钱买饭。既能喝酒，戒律也不像佛教那样严格。<br>实际上，聚集在店里的道士们也在桌子上摆满了酒肉。<br>史进自己也点了肉和酒。道士们喧哗地叙说道教是多么多么好。<br>“总之，人还是得活着的时候享福。死后到极乐世界有什么东西。是有酒，还是有美女?”<br>史进望着窗外，喝着冰镇的酒。<br>(如果真这样的话，智深师傅可是糟了罪了)<br>史进几杯酒下肚，道士们依然在那里吹嘘着。<br>“听说，已经有七个高僧拒绝改宗，拄着拐杖祭拜，大概是奔着喜庆的极乐世界去了吧。”<br>对于下流的笑声，史进冷眼旁观。<br>他不由自主地放下杯子，一个年轻的尼姑进了店。是个二十多岁的美丽尼姑，身材苗条。即使在灰色僧衣之上，也能窥见丰满的胸部。<br>就在这时，喝醉的道士缠着尼姑。<br><img src="/upload/pasted-47.png" alt="upload successful"><br>“好漂亮的尼姑啊!要是长着长发，穿着道服就更合适了。喂，咱们给她换换衣服吧。”<br>尼姑的眼睛发着锐利的寒光。史进把棒子横到道士与尼姑之间。<br>“打住，你们丢不丢人。”<br>果然不出所料，很快就吵了起来。对方仗着数量，还喝了酒。气势汹汹地向史进扑去，但胜负仅瞬时就已见分晓。史进用棒子揍昏了十几个道士。最后一个人站在尼姑旁边，呆呆地望着同伴的倒地。就在史进与尼姑的视线交汇的一瞬间，这个道士被尼姑的念珠打破额头，赶紧溜了。<br>“彼此彼此。”<br>“谢谢你的好意。”<br>尼姑拿起倒在地上道士的衣服，擦了擦念珠上的血<br>“不用客气”<br>“我对管闲事没什么兴趣，不过你要是尼姑的话，对寺院应该很了解吧，请问少林寺怎么走？”<br>“你还是问别人吧，我有些赶时间，真的对不起”<br>店里的骚乱无人理会，店家好像也找地方躲起来了，这尼姑也自顾自的走到柜台前，把手中的葫芦装满酒，自己也用大杓盛了一杯酒喝，然后打算离开<br>史进喊了一声<br>“那尼姑站住，我且问你，你多大了”<br>“谢谢你出手相助。”<br>尼姑头也没回的飘了出去。<br>“尼姑尼姑。”<br>史进也学着尼姑往葫芦里装了酒。一不下心把道士们的饭菜打翻在地。正想就这样离开的时候，柜子里传来了声音。<br>“客官，留步……”<br>打开柜子一看，只见店老板正抱装钱的箱子躲在里面。<br>“二十人份的酒钱、碎掉的碟子和这店的修理费用……”<br>“你自己承担吧。”<br>说完史进啪的一声关上柜子，上上门闩。他在店里翻了翻地上道士的口袋，但是谁也没有带钱包。<br>“原来如此，确实以‘吃霸王餐的’居多。”<br>史进拿起棍子，看了看抱着钱箱的店主人所在的柜子。<br>“还是掌柜的借我点吧。”<br>史进把手放到柜子的门上的时候，突然有个男人走了进来。<br>“不行啊，史大郎，这可是严令禁止的。”<br>回头向那熟悉声音的方向看去，门口站着一个年轻人和一条狗。<br>“薛永。”<br><img src="/upload/pasted-48.png" alt="upload successful"><br>“病大虫”薛永把主人从柜子里上放了出来，替史进付了钱。在薛永为那“二十人份的酒钱”讨价还价时，史进匆匆走出了店门。太白跟在后面。薛永也紧跟着向史进道了歉。<br>“对不起。朱军师说大郎是个执拗的人，要我悄悄跟着不要被你发现。到了“京西北路”盘缠就完了，这个时候要我出面帮忙……”<br>“真不愧是‘神机军师’。快回去替我夸夸他。”<br>“……我是洛阳人，所以也可以带路。这条路绕远。”<br>史进连头也不回地走着。<br>“你看，我这还有票据。可以在店里拿些盘缠。”<br>当梁山泊好汉在“工作”时，梁山泊在各处的“店”会供应好汉们马匹盘缠。但是，没有票据的“好汉”是不能帮助的。最近，冒充“梁山泊好汉”的人越来越多，负责此事的“扑天雕”李应的管制也变得更加严格了。即使是真正的“梁山好汉”没有票据也绝不帮忙<br>“大郎，你的路费怕是早就没了吧”<br>薛永拿出一个有分量的包裹要给史进。史进停下脚步，接下包裹，扔进附近的水井。<br>薛永连忙伸手去救，但为时已晚，那包裹掉进了深深的井底。<br>“没钱，不住店不就得了。”<br>“你这又是为何?”<br>“因为我想靠自己的力量，找到师父。”<br>“不过，今天连伙食费也没了，晚上要去露宿吗?”<br>“我说你就这么点钱吗?”<br>薛永指了指身后的井。<br>“钱包也在那里。”<br>两人一声不吭的走在荒野的街道上。薛永窥视着史进的脸。<br>“你生气了吗?”<br>“没有。”<br>“啊，那我把这个卖了。”<br>薛永从脖子上拿下翡翠护身符。这是他从小就带在身上的护符。薛永一家没落，唯一的遗物就只有这个了。<br>“你还是收起来吧。”<br>史进说完，又开始走起来了。太阳火辣辣的晒着。<br>薛永为了缓和尴尬的沉默，向走在前面的史进搭话。<br>“我很快就知道大郎的下落了……旅客名册上有你的名字，我没想到你还敢用“本名”旅行。”<br>梁山泊的好汉，在大宋朝廷看来是“通缉犯”。因工作而外出时，通常使用假名。<br>“大郎，你没写“梁山泊”吧?”<br>“我不是笨蛋。”<br>的确，旅客住宿手册上写着“华阴县史进”。<br>(真是个直率的人啊)<br>已经进入河南境内。没有人知道“史家庄的史大郎”“少华山的九纹龙”。<br>(果然，我还是跟不上)<br>薛永不能放下他不管，加快了步伐。这时，史进突然转过身来。<br>“哎，如果是坏人就好了”<br>“呃?”<br>“从坏家伙那里抢一手不就行了?”<br>说着，史进跑了起来。<br>“救人赚盘缠，一石二鸟!”</p><p>荒野上停着一辆双轮马车。<br>一个身着昂贵彩衣的女子，驾着那车，在座椅前还垂下了青紫色的纱幕。在尽是沙土和枯树的荒凉景色中，仿佛是开着的一团鲜花。另外，在马车周围还围了十多名身穿青衣的侍女。<br>“无礼之徒，退下!”<br><img src="/upload/pasted-49.png" alt="upload successful"><br>虽然所有的人都手持剑，但都是年轻而美丽的姑娘。她们的目光被定格在两个暴徒身上。他们蒙面遮住脸，高个子的手持大鉞，矮个子的手持锐剑。两人看起来有点能耐。一点一点地拉近和马车的距离。<br>此时，史进他们冲了过来。侍女们向他们求助。<br>“请救救我们!他们是劫匪啊!”<br>“交给我吧。”<br>马车里，是有钱的贵妇人吧。不知道是什么原因，粗心大意，的在荒野旅行。如果帮她们一手，还可以盼些酬谢金。<br>身材矮小的人马上就砍向了史进。他身体灵活，看来也是练过两下的。<br>(还年轻呢，看来是“第一次工作”吗?)<br>虽然练过两下子，可他还是经验不足。不过，弥补那个的，是充满执念的杀气。但他并不是史进的对手。史进拍了一下他手，剑就掉了下去，本打算再给他肚子一下。另一个暴徒从侧面迅速地跳出来，用大鉞一击将棒子断掉。虽说是木棒，但它是最坚硬的橡木制成。只是闪了一下棒子就断了，胸前也感到了冲击。他的力气真的很大。<br>“接着!”<br>那个最年轻的侍女猛地把自己的剑投了出去。史进在空中接住，身子向后一退。此时薛永也跟上了上来。<br>史进冲着薛永说。<br>“那个小的就交给你了!”<br>史进手持侍女的剑，与暴徒的鉞对峙。本以为剑是那侍女拿来装装样子的，不过纤细的外表只是装饰，那是一把很有分量的真剑。<br>身材矮小的歹徒也捡起掉落的剑，再次逼近马车。薛永在他面前挡了下来。<br>在史进他们与暴徒们战斗的时候，守着马车侍女们逃走了。把剑扔给史进的那个侍女跳上御座，狠狠地鞭打白马。马猛地跑起来。薛永挡住了追赶马车的劫匪。太白也加入主人的行列，咬着那暴徒的上衣不放。<br>“对方不是女人吗?你们不要欺负弱者。”<br>“欺负弱者? !”<br>“劫匪”大声怒吼后，拿下遮着脸的黑布。<br><img src="/upload/pasted-50.png" alt="upload successful"><br>眼前是一个看着十五六岁的少女，面容精致的好像人偶一般<br>此时，史进向那大个子劫匪的胸口斩去，被那人的钺柄挡下了，但还是划破了上衣，露出白花花的胸口<br>“是个女人？”<br>回应史进惊奇的是那个小个子劫匪<br>“够了！”<br>少女眉毛上扬，指着薛永<br>“都怪你，坏了我们大事，她们可都是极恶之人”</p>]]></content>
      
      
      <categories>
          
          <category> 绘卷水浒传 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 绘卷水浒传 二十周年番外 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot快速上手</title>
      <link href="/2018/07/18/pringBoot%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/"/>
      <url>/2018/07/18/pringBoot%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="0-了解"><a href="#0-了解" class="headerlink" title="0.了解"></a>0.了解</h1><p>如果用过spring mvc的话，就能明显的感受到spring boot 的优点和缺点<br>优点：大部分繁琐的配置项使用者是不用管的，不像spring mvc，少一个配置项就爆炸，爆炸了不知道哪个配置出了问题<br>缺点：拦截<br>定位：轻量级</p><h1 id="1-入门创建"><a href="#1-入门创建" class="headerlink" title="1.入门创建"></a>1.入门创建</h1><p>在intelliJ里new-》project-》spring initializr-》（修改项目名和包名）-》next-》web选中web(简易配置)-》finish</p><p>也可以访问spring的官网，然后建立模板project，导出    </p><h1 id="2-Hello-World"><a href="#2-Hello-World" class="headerlink" title="2.Hello World"></a>2.Hello World</h1><p>1.创建Controller包<br>2.创建HelloWorldController.java(一个类)<br>3.<br>@Controller<br>public class PersonController {</p><pre><code>@RequestMapping(&quot;/helloworld.do&quot;)public String helloWorld() {    return &quot;Hello World!&quot;;}</code></pre><p>}<br>把该引的包引进来，注解（就是@的那些）不要忘，不要忘，而且创建路径一定要在最开始生成的目录下</p><h1 id="3-配置文件？"><a href="#3-配置文件？" class="headerlink" title="3.配置文件？"></a>3.配置文件？</h1><p>spring boot 厉害就厉害在你可以把配置项写在resource-》application.properties里<br>或者是删掉，重新建一个application.yml（写法上有区别）</p><h1 id="4-thymeleaf"><a href="#4-thymeleaf" class="headerlink" title="4.thymeleaf"></a>4.thymeleaf</h1><p>thymeleaf 是spring boot 所推荐使用的页面引擎<br>也是有一套特定的语法和操作（类似jsp的语法）<br>文件后缀依旧是html<br>参考：<br><a href="https://blog.csdn.net/u014042066/article/details/75614906" target="_blank" rel="noopener">https://blog.csdn.net/u014042066/article/details/75614906</a><br><a href="https://blog.csdn.net/chenloveit/article/details/38910803" target="_blank" rel="noopener">https://blog.csdn.net/chenloveit/article/details/38910803</a><br><a href="https://blog.csdn.net/malimingwq/article/details/79329921" target="_blank" rel="noopener">https://blog.csdn.net/malimingwq/article/details/79329921</a><br><a href="https://blog.csdn.net/chenloveit/article/details/38910803" target="_blank" rel="noopener">https://blog.csdn.net/chenloveit/article/details/38910803</a></p><p>pom.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- thymeleaf模板引擎 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>页面使用修改命名空间<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>人员列表<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h1 id="5-mysql-jpa操作"><a href="#5-mysql-jpa操作" class="headerlink" title="5.mysql + jpa操作"></a>5.mysql + jpa操作</h1><p>1.在配置项中配置属性<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/test1</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=root</span><br><span class="line">spring.jpa.hibernate.ddl-auto=update</span><br><span class="line">spring.jpa.show-sql=true</span><br></pre></td></tr></table></figure></p><p>参考：<br><a href="https://blog.csdn.net/fanduo12345/article/details/54626802" target="_blank" rel="noopener">https://blog.csdn.net/fanduo12345/article/details/54626802</a><br><a href="https://blog.csdn.net/weixin_40344177/article/details/78469815" target="_blank" rel="noopener">https://blog.csdn.net/weixin_40344177/article/details/78469815</a><br><a href="https://www.cnblogs.com/rulian/p/6557471.html" target="_blank" rel="noopener">https://www.cnblogs.com/rulian/p/6557471.html</a><br><a href="https://www.cnblogs.com/zhaobingqing/p/6864223.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhaobingqing/p/6864223.html</a></p><p>2.建立实体类时，要有entity的注解，以及@id等约束注解<br>3.@GeneratedValue(strategy=GenerationType.IDENINY)<br>也要添加上面的注解，以便主键自增</p><p>4.GenericJDBCException错误解决：<br>数据库要设置主键自增，</p><p>5.save函数可以进行更新和插入操作，主要是看主键,作为参数的实体对象，如果其主键在数据库中，则是完成更新操作，但是是根据实体对象得完整更新，实体对象的属性是什么，更新就是什么，要想部分更新请看下面的；；如果主键在数据库中不存在，则完成插入操作，这里有个问题，如果设置了主键策略是自增，那么插入时是不会按照实体对象主键值插入的，</p><p>6.原生sql和一些注解<br>（1）索引参数如下所示，索引值从1开始，查询中”?X”个数需要与方法定义的参数个数相一  致，并且顺序也要一致。<br> @Query(“SELECT p FROM Person p WHERE p.lastName = ?1 AND p.email = ?2”)   List<person> testQueryAnnotationParams1(String lastName, String email);<br>（2） // 为@Query注解传递参数的方式1：命名参数<br> @Query(“SELECT p FROM Person p WHERE p.lastName = :lastName AND p.email = :email”)<br>  List<person> testQueryAnnotationParams2(@Param(“email”) String email, @Param(“lastName”) String lastName);</person></person></p><p>（3）　　　/*<em>      </em> 设置nativeQuery=true 即可以使用原生的SQL进行查询     <em> @return     </em>/    @Query(value = “SELECT count(id) FROM jpa_persons”, nativeQuery = true)    long getTotalCount();</p><h1 id="6-跳转页面"><a href="#6-跳转页面" class="headerlink" title="6.跳转页面"></a>6.跳转页面</h1><p>跳转controller<br> return “redirect:/list”; </p><p>thymeleaf 带参数a标签写法<br><a th:href="@{/details(id=${person.id})}">详情</a></p><h1 id="7-一些工具"><a href="#7-一些工具" class="headerlink" title="7.一些工具"></a>7.一些工具</h1><p><dependency>    <groupid>org.projectlombok</groupid>    <artifactid>lombok</artifactid>    <scope>compile</scope></dependency><br>可以使用注解@Data 编译时自动生成get,set方法,构造函数,toString方法。</p><p>devtool热部署<br><a href="https://jingyan.baidu.com/article/870c6fc367b4d7b03fe4beba.html" target="_blank" rel="noopener">https://jingyan.baidu.com/article/870c6fc367b4d7b03fe4beba.html</a></p><h1 id="8-乱七八糟的知识点"><a href="#8-乱七八糟的知识点" class="headerlink" title="8.乱七八糟的知识点"></a>8.乱七八糟的知识点</h1><p>1.@controller 可以返回页面，@RestController 是@ResponseBody 和@Controller的结合</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringMVC上手</title>
      <link href="/2018/04/13/ringMVC%E4%B8%8A%E6%89%8B/"/>
      <url>/2018/04/13/ringMVC%E4%B8%8A%E6%89%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h1><p>1.参数:这里指”条件”.后台通过对这些参数的处理,可以做查询数据,添加数据,固定删除某些数据等.又指在后台操作中可以直接使用的变量.</p><p>2.数据:这里指Service层调用Dao层获取的数据,进行简单处理后,可以直接返回页面展示或使用的数据.</p><p>3.关系型数据库:建立在关系模型基础上的数据库.其特点是对应关系明确,连接性强.</p><p>4.非关系型数据库:NoSQL,内部存储方式为key-value的形式.一个键对应一个值或多个值.其特点是查询速度快,可扩展,存储空间大.</p><p>5.JSTL:简单理解.将Java后台的代码形式在页面展示.多数用于for循环,if判断,choose选择等.需要引入对应的标签（就是jsp的一些语法）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;</span><br><span class="line">&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/fmt&quot; prefix=&quot;fmt&quot;%&gt;</span><br><span class="line">&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/functions&quot; prefix=&quot;fn&quot;%&gt;</span><br></pre></td></tr></table></figure></p><h1 id="开发思路"><a href="#开发思路" class="headerlink" title="开发思路"></a>开发思路</h1><h2 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h2><p>主要掌握:<br>1.Form表单以及标签<br>2.Ajax提交表单<br>3.标签name属性与POJO联系<br>4.请求或访问路径的写法</p><p>操作返回数据的方式<br>1.EL表达式.${}<br>2.JSTL表达式.&lt;c:foreach&gt;</p><h2 id="javaweb后台"><a href="#javaweb后台" class="headerlink" title="javaweb后台"></a>javaweb后台</h2><h3 id="web控制层（Controller）"><a href="#web控制层（Controller）" class="headerlink" title="web控制层（Controller）"></a>web控制层（Controller）</h3><p>功能或作用:<br>1.接收页面发送参数<br>2.对参数进行简单的处理后传递给Service层<br>3.接收Service层处理后的数据<br>4.将数据响应给页面</p><p>常用注解:<br>1.@Controller<br>2.@RequestMapping<br>3.@Resource<br>4.@Autowired<br>5.@RequestParam</p><h3 id="业务逻辑层（Service）"><a href="#业务逻辑层（Service）" class="headerlink" title="业务逻辑层（Service）"></a>业务逻辑层（Service）</h3><p>功能或作用:<br>1.接收Controller层给定参数<br>2.调用Dao层,传递参数<br>3.获取Dao层给定的数据<br>4.对数据进行合理化处理<br>5.将处理后的数据返回到Controller</p><p>常用注解:<br>1.@Service<br>2.@Resource<br>3.@Autowired<br>4.@Transactional</p><h3 id="数据访问层（Dao）"><a href="#数据访问层（Dao）" class="headerlink" title="数据访问层（Dao）"></a>数据访问层（Dao）</h3><p>功能或作用:<br>1.接收Service参数<br>2.interface接口与XML的映射<br>3.将结果数据返回到Service层</p><p>内部结构:<br>Interface接口:Mapper编写执行方法<br>XML配置:Mapper编写Mybatis配置</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>功能或作用:<br>1.创建库以及表<br>2.添加字段.存放数据信息</p><p>常见数据库:<br>1.关系型数据库<br>     1.Mysql<br>     2.Oracle<br>     3.sql Server<br>     4.DB2<br>2.非关系型数据库<br>     1.MongoDB<br>     2.Redis<br>     3.HBase</p><h1 id="SSM框架"><a href="#SSM框架" class="headerlink" title="SSM框架"></a>SSM框架</h1><p>1.SSM:spring mvc +spring (框架)+mybatis(框架)</p><p>2.spring mvc :理论上说,spring mvc 是指spring 框架,融合了MVC 的设计模式,成为了一种特殊的与前端页面交互处理框架</p><p>3.MVC设计模式  :Model-View-Controller(模型-视图-控制器)</p><p>4.Spring框架的核心:<br>         AOP:Spring提供了面向切面的编程支持，AOP将与程序业务无关的内容分离提取。<br>                     1.面向切面编程提供声明式事务管理<br>                     2.spring支持用户自定义的切面 例如日志或事务支持。<br>         IOC:Spring通过控制反转技术促进了松耦合。负责创建对象、管理对象(通过依赖注入)、整合对象、配置对象以及管理这些对象的生命周期。</p><h1 id="springmvc和Struts2"><a href="#springmvc和Struts2" class="headerlink" title="springmvc和Struts2"></a>springmvc和Struts2</h1><h2 id="spring-mvc执行流程："><a href="#spring-mvc执行流程：" class="headerlink" title="spring mvc执行流程："></a>spring mvc执行流程：</h2><p><img src="/upload/pasted-460.png" alt="upload successful"><br>1、客户端发出一个http请求给web服务器，web服务器对http请求进行解析，如果匹配DispatcherServlet的请求映射路径（在web.xml中指定），web容器将请求转交给DispatcherServlet.<br>2、DipatcherServlet接收到这个请求之后将根据请求的信息（包括URL、Http方法、请求报文头和请求参数Cookie等）以及HandlerMapping的配置找到处理请求的处理器（Handler）。<br>3-4、DispatcherServlet根据HandlerMapping找到对应的Handler,将处理权交给Handler（Handler将具体的处理进行封装），再由具体的HandlerAdapter对Handler进行具体的调用。<br>5、Handler对数据处理完成以后将返回一个ModelAndView()对象给DispatcherServlet。<br>6、Handler返回的ModelAndView()只是一个逻辑视图并不是一个正式的视图，DispatcherSevlet通过ViewResolver将逻辑视图转化为真正的视图View。<br>7、Dispatcher通过model解析出ModelAndView()中的参数进行解析最终展现出完整的view并返回给客户端。</p><h2 id="Struts2执行流程"><a href="#Struts2执行流程" class="headerlink" title="Struts2执行流程"></a>Struts2执行流程</h2><p><img src="/upload/pasted-462.png" alt="upload successful"><br>1、用户发送请求，经过一些列过滤器。最终到达FilterDispatcher核心过滤器<br>2、FilterDispatcher询问ActionMapper映射，ActionMapper告知FilterDispatcher调用某个Action<br>3、此时，FilterDispatcher将请求交给ActionProxy（action代理对象）处理<br>4、ActionProxy会通过ConfigurationManager询问配置文件。确定执行的Action类并创建action示例对象：ActionInvocation<br>5、ActionInvocation经过一些列拦截器，调用真正的Action，并执行操作，根据配置文件信息，将结果返回<br>6、返回的结果经过拦截器，在此会有不同的页面操做会对结果进行修饰，如JSP,FreeMarker等，拦截器释放后，回到页面响应</p><h2 id="两者的区别"><a href="#两者的区别" class="headerlink" title="两者的区别"></a>两者的区别</h2><p>1.机制:spring mvc的入口是servlet,而struts2是filter,这样就导致了二者的机制不同.<br>2.性能设计 :spring mvc 是基于方法的拦截;struts2是基于类的拦截.springmvc处理更快.<br>3.设计思想:struts2更加符合oop(面向对象编程)的编程思想,spring在servlet上扩展。<br>4.拦截:struts2自己的interceptor机制,spring mvc用的是独立的AOP方式.这样导致struts的配置文件量还是比spring mvc大.<br>5.spring mvc属于spring的一部分,与spring框架的契合度更高,更稳定.</p><h1 id="数据库交互框架"><a href="#数据库交互框架" class="headerlink" title="数据库交互框架"></a>数据库交互框架</h1><p>Hibernate：<br>1.Hibernate的DAO层开发比MyBatis简单，Mybatis需要维护SQL和结果映射。<br>2.Hibernate对对象的维护和缓存要比MyBatis好，对增删改查的对象的维护要方便。<br>3.Hibernate数据库移植性很好，MyBatis的数据库移植性不好，不同的数据库需要写不同SQL。<br>4.Hibernate有更好的二级缓存机制，可以使用第三方缓存。MyBatis本身提供的缓存机制不佳。</p><p>Mybatis<br>1.MyBatis可以进行更为细致的SQL优化，可以减少查询字段。<br>2.MyBatis容易掌握，而Hibernate门槛较高。</p><h1 id="利用Eclipse搭建ssm项目"><a href="#利用Eclipse搭建ssm项目" class="headerlink" title="利用Eclipse搭建ssm项目"></a>利用Eclipse搭建ssm项目</h1><p>1.创建Dynamic Web Project</p><p><img src="/upload/pasted-463.png" alt="upload successful"></p><p>2.src下新建包，包名一般是域名加上层</p><p><img src="/upload/pasted-464.png" alt="upload successful"></p><p><img src="/upload/pasted-465.png" alt="upload successful"></p><p>3.创建包，并导入配置文件<br><img src="/upload/pasted-466.png" alt="upload successful"></p><p>4.修改webContent下的文件夹目录</p><p><img src="/upload/pasted-467.png" alt="upload successful"></p><p>5.在一个eclipse导入一个tomcat，并将项目置于其中，基本的搭建就算完成了</p><h1 id="简单的业务逻辑"><a href="#简单的业务逻辑" class="headerlink" title="简单的业务逻辑"></a>简单的业务逻辑</h1><h2 id="form表单"><a href="#form表单" class="headerlink" title="form表单"></a>form表单</h2><p>form表单介绍:<br>1.用于对页面数据的整合提交技术.<br>2.常见提交方式:get/post<br>3.常见属性<br>  1.action<br>  2.method<br>  3.enctype=”multipart/form-data”<br>  4.id<br>4.常见提交的标签<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>5.如何将参数传到后台?<br>  标签中name属性对应后台接收参数,value属性对应参数值</p><p>常用的input标签<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span>  :定义单行的输入字段</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span>  :定义可点击按钮</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span> :定义复选框</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span>  :文件上传</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span>  :定义隐藏的输入字段</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"image"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span>  :定义图像形式的提交按钮</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span>  :定义密码字段</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span>  :定义单选按钮</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"reset"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span>  :定义重置按钮</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span>  :定义提交按钮</span><br></pre></td></tr></table></figure></p><p>select的使用<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;select name=""&gt;</span><br><span class="line">     &lt;option value ="1"&gt;吉林&lt;/option&gt;</span><br><span class="line">     &lt;option value ="2"&gt;长春&lt;/option&gt;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></p><p>前台与后台的对应<br><img src="/upload/pasted-471.png" alt="upload successful"></p><h2 id="前后端的数据交互"><a href="#前后端的数据交互" class="headerlink" title="前后端的数据交互"></a>前后端的数据交互</h2><p>1.说明<br>    数据经过controller处理后已经封装到view对象中.EL表达式与JSTL表达式可以提取view对象中的数据<br>2.页面展示形式<br>    EL表达式+JSTL表达式<br>    EL:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;pojo对象中属性&#125;</span><br><span class="line">$&#123;pojo对象中属性.属性&#125;</span><br></pre></td></tr></table></figure><p>JSTL:<br>JSTL是apache对EL表达式的扩展（也就是说JSTL依赖EL），JSTL是标签语言<br>1.core：核心标签库，我们学习的重点；</p><p><img src="/upload/pasted-459.png" alt="upload successful"><br>2.fmt：格式化标签库，只需要学习两个标签即可  </p><p><img src="/upload/pasted-461.png" alt="upload successful"></p><h2 id="后台代码编写"><a href="#后台代码编写" class="headerlink" title="后台代码编写"></a>后台代码编写</h2><p><img src="/upload/pasted-468.png" alt="upload successful"></p><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><p>@Component 在类定义之前添加@Component注解，他会被spring容器识别，并转为bean。<br>@Repository 对Dao实现类进行注解 (特殊的@Component)<br>@Service 用于对业务逻辑层进行注解， (特殊的@Component)<br>@Controller 用于控制层注解 ， (特殊的@Component)<br>@Autowired与@Resource：用来对对象进行装配注入，只不过@Autowired按byType自动注入，而@Resource默认按 byName自动注入<br>@RequestMapping：用于处理请求地址映射，可以作用于类和方法上。包含参数有路径，请求的method方式，参数，header等<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span> (value= <span class="string">"testParams"</span> , params=&#123; <span class="string">"param1=value1"</span> , <span class="string">"param2"</span> , <span class="string">"!param3"</span> &#125;)</span><br></pre></td></tr></table></figure></p><p>@PathVariable 处理部分路径的值<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/user/&#123;userId&#125;/roles/&#123;roleId&#125;"</span>,method = RequestMethod.GET)  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getLogin</span><span class="params">(@PathVariable(<span class="string">"userId"</span>)</span> String userId, <span class="comment">//取出请求URL中的变量值作为参数值 </span></span></span><br><span class="line"><span class="function">         @<span class="title">PathVariable</span><span class="params">(<span class="string">"roleId"</span>)</span> String roleId)</span>&#123;  </span><br><span class="line">         System.out.println(<span class="string">"User Id : "</span> + userId);  </span><br><span class="line">         System.out.println(<span class="string">"Role Id : "</span> + roleId);  </span><br><span class="line">         <span class="keyword">return</span> <span class="string">"hello"</span>;  </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></p><p>@ResponseBody 注解在Controller的方法上，表明返回的结果是一个json</p><h1 id="附：配置文件"><a href="#附：配置文件" class="headerlink" title="附：配置文件"></a>附：配置文件</h1><p>src下的配置：<br>db.properties<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://localhost:3306/ccxqjjyxypt?characterEncoding=utf-8&amp;allowMultiQueries=true</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=root</span><br></pre></td></tr></table></figure></p><p>log4j.properties<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">log4j.rootLogger=info, stdout</span><br><span class="line">#log4j.rootLogger=debug, stdout</span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m%n</span><br></pre></td></tr></table></figure></p><p>mybatis-config.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" </span></span><br><span class="line"><span class="meta">"http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--批量配置别名 针对所有的pojo类,进行别名设置 根据自己的pojo所在的全路径 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"cn.ccxqjjyxypt.console.pojo"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>spring-config.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span> <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:task</span>=<span class="string">"http://www.springframework.org/schema/task"</span> <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans-4.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/mvc </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context-4.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop/spring-aop-4.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx/spring-tx-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/task</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/task/spring-task-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://code.alibabatech.com/schema/dubbo        </span></span></span><br><span class="line"><span class="tag"><span class="string">http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--设置:加载目录config下所有的spring配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">"classpath:config/*.xml"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>springmvc-console.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span> <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:task</span>=<span class="string">"http://www.springframework.org/schema/task"</span> <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans-4.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/mvc </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context-4.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop/spring-aop-4.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx/spring-tx-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/task</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/task/spring-task-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://code.alibabatech.com/schema/dubbo        </span></span></span><br><span class="line"><span class="tag"><span class="string">http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--1.设置扫描Controller --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"cn.ccxqjjyxypt.console.controller"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--2.设置springMVC 映射器,适配器,通过注解驱动 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置文件上传解析器 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxUploadSize"</span> <span class="attr">value</span>=<span class="string">"5368709120"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--3.设置springmvc的视图解析器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"viewResolver"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/console"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 拦截器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 多个拦截器，顺序执行 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/**"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">"/**/*.css"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">"/**/*.js"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">"/**/*.png"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">"/**/*.gif"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">"/**/*.jpg"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">"/**/*.jpeg"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">"/login/login.do"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">"/login/appLogin.do"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">"/appBeihu.do"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">"/appBeihuKg.do"</span>/&gt;</span></span><br><span class="line">     </span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">"/appChangde.do"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">"/appChangdekg.do"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">"/appGaoxin.do"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">"/appGaoxinCz.do"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">"/appGaoxinkg.do"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">"/appGaoxinWx.do"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">"/ceshi.do"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">"/gaoXinMap.do"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">"/beiHuMap.do"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">"/changDeMap.do"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">"/kongGangMap.do"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">     </span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">"/appKonggang.do"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">"/appKonggangKg.do"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"cn.ccxqjjyxypt.console.interceptor.LoginInterceptor"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>config下的配置文件<br>applicationContext-mapper.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span> <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:task</span>=<span class="string">"http://www.springframework.org/schema/task"</span> <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans-4.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/mvc </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context-4.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop/spring-aop-4.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx/spring-tx-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/task</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/task/spring-task-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://code.alibabatech.com/schema/dubbo        </span></span></span><br><span class="line"><span class="tag"><span class="string">http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置spring接管mybatis工作 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--1.设置:加载外部资源文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注入配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"locations"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>classpath:db.properties<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--2.设置数据资源管理:针对数据库连接 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.driver&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--3.设置SqlSessionFactory管理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"sqlSessionFactory"</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.SqlSessionFactoryBean"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注入数据源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--加载mybatis全局配置文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"configLocation"</span> <span class="attr">value</span>=<span class="string">"classpath:mybatis-config.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--4.设置批量代理对象管理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.mybatis.spring.mapper.MapperScannerConfigurer"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"basePackage"</span> <span class="attr">value</span>=<span class="string">"cn.ccxqjjyxypt.console.dao"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>application-service.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span> <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:task</span>=<span class="string">"http://www.springframework.org/schema/task"</span> <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans-4.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/mvc </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context-4.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop/spring-aop-4.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx/spring-tx-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/task</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/task/spring-task-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://code.alibabatech.com/schema/dubbo        </span></span></span><br><span class="line"><span class="tag"><span class="string">http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--设置:通过Spring管理依赖注入,扫描@Service --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"cn.ccxqjjyxypt.console.service"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>application-tx.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span> <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:task</span>=<span class="string">"http://www.springframework.org/schema/task"</span> <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/beans/spring-beans-4.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/mvc </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/context/spring-context-4.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/aop/spring-aop-4.0.xsd </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx </span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/tx/spring-tx-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://www.springframework.org/schema/task</span></span></span><br><span class="line"><span class="tag"><span class="string">   http://www.springframework.org/schema/task/spring-task-4.0.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">http://code.alibabatech.com/schema/dubbo        </span></span></span><br><span class="line"><span class="tag"><span class="string">http://code.alibabatech.com/schema/dubbo/dubbo.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--设置:spring对事物的管理 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--1.设置事务管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span></span></span><br><span class="line"><span class="tag"><span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注入数据源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--2.通知事物管理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>查找（散列表）</title>
      <link href="/2018/02/17/%EF%BC%88%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%89/"/>
      <url>/2018/02/17/%EF%BC%88%E6%95%A3%E5%88%97%E8%A1%A8%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="散列表（Hash-Table）"><a href="#散列表（Hash-Table）" class="headerlink" title="散列表（Hash Table）"></a>散列表（Hash Table）</h1><h2 id="一般思路"><a href="#一般思路" class="headerlink" title="一般思路"></a>一般思路</h2><p>前面讲的几种符号表的实现情况总结</p><p><img src="/upload/pasted-202.png" alt="upload successful"><br>是否有一种更快的方式来查找，插入键值对？<br>回答是有的，但是应当转变数据存储的思路<br>现在引入“索引”（Index）的概念，可以将键存入键-索引表当中（索引实际上和键有某种函数转换关系）<br>而这种转换关系就是哈希函数（Hash function）<br>这个过程所需要解决的问题是</p><ul><li>解决hash转换的计算问题</li><li>解决能够判定两个键值相等的方法</li><li>解决冲突情况：当两个键有相同的索引时</li></ul><h2 id="哈希的计算问题"><a href="#哈希的计算问题" class="headerlink" title="哈希的计算问题"></a>哈希的计算问题</h2><h3 id="基本要求"><a href="#基本要求" class="headerlink" title="基本要求"></a>基本要求</h3><p>哈希计算应当满足三个条件</p><ul><li>一致性：等价的键必然产生相等的索引值</li><li>高效性：计算方便</li><li>均匀性：均匀的散列所有的键</li></ul><h3 id="java实现"><a href="#java实现" class="headerlink" title="java实现"></a>java实现</h3><p>实际情况中，对于不同类型的键，还要产生不同的哈希计算方法<br>java中hash的实现：所有的java类都继承一个hashcode()方法，这个方法返回一个32位的int<br>这个方法要和equals()一致，也就是说，如果x.equals(y)，x.hashcode()==y.hashcode(),也就是说，对于自定义类型，应当同时重写hashcode()和equals()。默认的实现是返回内存地址<br>几种类型的实现<br>Integer类型直接返回值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public final class Integer</span><br><span class="line">&#123;</span><br><span class="line">    private final int value;</span><br><span class="line">    ...</span><br><span class="line">    public int hashCode()</span><br><span class="line">    &#123; return value; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>布尔类型，返回两个特定的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public final class Boolean</span><br><span class="line">&#123;</span><br><span class="line">   private final boolean value;</span><br><span class="line">   ...</span><br><span class="line">   public int hashCode()</span><br><span class="line">   &#123;</span><br><span class="line">   if (value) return 1231;</span><br><span class="line">   else return 1237;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>double 返回前32位和后32位的异或结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  public final class Double</span><br><span class="line">&#123;</span><br><span class="line">   private final double value;</span><br><span class="line">   ...</span><br><span class="line">   public int hashCode()</span><br><span class="line">   &#123;</span><br><span class="line">   long bits = doubleToLongBits(value);</span><br><span class="line">   return (int) (bits ^ (bits &gt;&gt;&gt; 32));</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>把string当成一个大数处理，每一位乘、加，采用的是Horner方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public final class String</span><br><span class="line">&#123;</span><br><span class="line">   private final char[] s;</span><br><span class="line">   ...</span><br><span class="line">   public int hashCode()</span><br><span class="line">   &#123;</span><br><span class="line">   int hash = 0;</span><br><span class="line">   for (int i = 0; i &lt; length(); i++)</span><br><span class="line">   hash = s[i] + (31 * hash);</span><br><span class="line">   return hash;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于一般的自定义类型，可以按照以下方法写hashcode()</p><ul><li>对每一个有意义的位采取31x+y的累加策略（像horner那种累加方法）</li><li>如果域是基本类型，则用其包装类的hashcode</li><li>如果为null，返回0</li><li>如果是个一般的引用类型，用它的hashcode（它本身已经定义好了）</li><li>如果是个数组，则对数组中的每个元素进行hash计算然后组合（也可以Arrays.deepHashCode()）<h3 id="将hashcode转换为一个数组索引"><a href="#将hashcode转换为一个数组索引" class="headerlink" title="将hashcode转换为一个数组索引"></a>将hashcode转换为一个数组索引</h3>对于索引，我们不可能让其在-2^31到2^31-1之间，因此，这里采用的是取余操作<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private int hash(Key key)</span><br><span class="line">&#123; return (key.hashCode() &amp; 0x7fffffff) % M; &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="冲突处理问题"><a href="#冲突处理问题" class="headerlink" title="冲突处理问题"></a>冲突处理问题</h2><h3 id="拉链法"><a href="#拉链法" class="headerlink" title="拉链法"></a>拉链法</h3><h4 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h4><p>对于每个索引位置，我们“绑定”一个链表<br>hash：把键和在0到M-1之间的数字i绑定（数组索引）<br>插入：在第i个链表头插入新数据<br>搜索：遍历第i个链表</p><p><img src="/upload/pasted-203.png" alt="upload successful"></p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>假设我们使用的散列函数能够均匀并独立的将所有键分摊于0到M-1之间，，在一张含有 M个链表和N个键的散列表中，任意一条链表中的的键的数量在N/M的常数因子范围内的概率无限趋近于1</li><li>在一张含有M条链表和N个键的散列表中，未命中查找和插入的操作所需的比较次数为~N/M</li></ul><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">public class SeparateChainingHashST&lt;Key, Value&gt; &#123;</span><br><span class="line">    private static final int INIT_CAPACITY = 4;</span><br><span class="line"></span><br><span class="line">    private int n; //键值对的个数</span><br><span class="line">    private int m; //哈希表的大小</span><br><span class="line">    private SequentialSearchST&lt;Key, Value&gt;[] st;  //链表的数组</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Initializes an empty symbol table.</span><br><span class="line">     */</span><br><span class="line">    public SeparateChainingHashST() &#123;</span><br><span class="line">        this(INIT_CAPACITY);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Initializes an empty symbol table with &#123;@code m&#125; chains.</span><br><span class="line">     * @param m the initial number of chains</span><br><span class="line">     */</span><br><span class="line">    public SeparateChainingHashST(int m) &#123;</span><br><span class="line">        this.m = m;</span><br><span class="line">        st = (SequentialSearchST&lt;Key, Value&gt;[]) new SequentialSearchST[m];</span><br><span class="line">        for (int i = 0; i &lt; m; i++)</span><br><span class="line">            st[i] = new SequentialSearchST&lt;Key, Value&gt;();</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    // resize the hash table to have the given number of chains,</span><br><span class="line">    // rehashing all of the keys</span><br><span class="line">    private void resize(int chains) &#123;</span><br><span class="line">        SeparateChainingHashST&lt;Key, Value&gt; temp = new SeparateChainingHashST&lt;Key, Value&gt;(chains);</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (Key key : st[i].keys()) &#123;</span><br><span class="line">                temp.put(key, st[i].get(key));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        this.m  = temp.m;</span><br><span class="line">        this.n  = temp.n;</span><br><span class="line">        this.st = temp.st;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // hash value between 0 and m-1</span><br><span class="line">    private int hash(Key key) &#123;</span><br><span class="line">        return (key.hashCode() &amp; 0x7fffffff) % m;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the number of key-value pairs in this symbol table.</span><br><span class="line">     *</span><br><span class="line">     * @return the number of key-value pairs in this symbol table</span><br><span class="line">     */</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return n;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns true if this symbol table is empty.</span><br><span class="line">     *</span><br><span class="line">     * @return &#123;@code true&#125; if this symbol table is empty;</span><br><span class="line">     *         &#123;@code false&#125; otherwise</span><br><span class="line">     */</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return size() == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns true if this symbol table contains the specified key.</span><br><span class="line">     *</span><br><span class="line">     * @param  key the key</span><br><span class="line">     * @return &#123;@code true&#125; if this symbol table contains &#123;@code key&#125;;</span><br><span class="line">     *         &#123;@code false&#125; otherwise</span><br><span class="line">     * @throws IllegalArgumentException if &#123;@code key&#125; is &#123;@code null&#125;</span><br><span class="line">     */</span><br><span class="line">    public boolean contains(Key key) &#123;</span><br><span class="line">        if (key == null) throw new IllegalArgumentException(&quot;argument to contains() is null&quot;);</span><br><span class="line">        return get(key) != null;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the value associated with the specified key in this symbol table.</span><br><span class="line">     *</span><br><span class="line">     * @param  key the key</span><br><span class="line">     * @return the value associated with &#123;@code key&#125; in the symbol table;</span><br><span class="line">     *         &#123;@code null&#125; if no such value</span><br><span class="line">     * @throws IllegalArgumentException if &#123;@code key&#125; is &#123;@code null&#125;</span><br><span class="line">     */</span><br><span class="line">    public Value get(Key key) &#123;</span><br><span class="line">        if (key == null) throw new IllegalArgumentException(&quot;argument to get() is null&quot;);</span><br><span class="line">        int i = hash(key);</span><br><span class="line">        return st[i].get(key);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Inserts the specified key-value pair into the symbol table, overwriting the old </span><br><span class="line">     * value with the new value if the symbol table already contains the specified key.</span><br><span class="line">     * Deletes the specified key (and its associated value) from this symbol table</span><br><span class="line">     * if the specified value is &#123;@code null&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @param  key the key</span><br><span class="line">     * @param  val the value</span><br><span class="line">     * @throws IllegalArgumentException if &#123;@code key&#125; is &#123;@code null&#125;</span><br><span class="line">     */</span><br><span class="line">    public void put(Key key, Value val) &#123;</span><br><span class="line">        if (key == null) throw new IllegalArgumentException(&quot;first argument to put() is null&quot;);</span><br><span class="line">        if (val == null) &#123;</span><br><span class="line">            delete(key);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // double table size if average length of list &gt;= 10</span><br><span class="line">        if (n &gt;= 10*m) resize(2*m);</span><br><span class="line"></span><br><span class="line">        int i = hash(key);</span><br><span class="line">        if (!st[i].contains(key)) n++;</span><br><span class="line">        st[i].put(key, val);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Removes the specified key and its associated value from this symbol table     </span><br><span class="line">     * (if the key is in this symbol table).    </span><br><span class="line">     *</span><br><span class="line">     * @param  key the key</span><br><span class="line">     * @throws IllegalArgumentException if &#123;@code key&#125; is &#123;@code null&#125;</span><br><span class="line">     */</span><br><span class="line">    public void delete(Key key) &#123;</span><br><span class="line">        if (key == null) throw new IllegalArgumentException(&quot;argument to delete() is null&quot;);</span><br><span class="line"></span><br><span class="line">        int i = hash(key);</span><br><span class="line">        if (st[i].contains(key)) n--;</span><br><span class="line">        st[i].delete(key);</span><br><span class="line"></span><br><span class="line">        // halve table size if average length of list &lt;= 2</span><br><span class="line">        if (m &gt; INIT_CAPACITY &amp;&amp; n &lt;= 2*m) resize(m/2);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    // return keys in symbol table as an Iterable</span><br><span class="line">    public Iterable&lt;Key&gt; keys() &#123;</span><br><span class="line">        Queue&lt;Key&gt; queue = new Queue&lt;Key&gt;();</span><br><span class="line">        for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">            for (Key key : st[i].keys())</span><br><span class="line">                queue.enqueue(key);</span><br><span class="line">        &#125;</span><br><span class="line">        return queue;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线性探测法的散列表"><a href="#线性探测法的散列表" class="headerlink" title="线性探测法的散列表"></a>线性探测法的散列表</h3><h4 id="一般概念"><a href="#一般概念" class="headerlink" title="一般概念"></a>一般概念</h4><p>实现散列表的另一种方式就是用大小为M的数组直接保存N个键值对，其中M&gt;N，我们利用数组中的空位解决冲突问题，这种方式叫做开放地址散列表<br>开放地址方式中最简单的方式是线性探测法，当发生冲突（一个键的散列值已经被另一个键站了）时，我们就在下一个位置放置（索引+1）<br>哈希方法：把键和在0到M-1之间的数字i绑定（数组索引）<br>插入方法：如果index i为空的话，放置，如果不为空，则放置i+1,i+2……</p><p><img src="/upload/5.gif" alt="upload successful"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 从零开始的算法征程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 查找算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找（B树）</title>
      <link href="/2018/02/16/%EF%BC%88B%E6%A0%91%EF%BC%89/"/>
      <url>/2018/02/16/%EF%BC%88B%E6%A0%91%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="B树（B-树）"><a href="#B树（B-树）" class="headerlink" title="B树（B-树）"></a>B树（B-树）</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在实际应用的场景中，为了查找一个数据，我们可能需要处理连续的数据存储块。可能是4千或者更多的数据，甚至是整个文件系统，对于外部系统，不同于内部系统，我们需要需要尽快的定位数据所在的页</p><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>对于一般的二叉平衡树，可能每个结点只有两三个键，但是对于B树，每个结点可以有很多键，比如一页（操作系统中的概念），B-树是一种特殊的2-3树，每个结点允许有M-1个键<br>几条基本要求：</p><ul><li>根节点至少有两个子节点</li><li>每个节点有M-1个key，并且以升序排列</li><li>位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间</li><li>其它节点至少有M/2个子节点<br>在实际应用时，一般在外部结点（叶子结点）存数据，而内部结点是外部结点的索引，用以进行搜索<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2>同一般的平衡二叉树查找是一样的逐层查找<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2>同2-3树的插入，一旦结点中的键的数量超过预定数量，则将键进行分开，分成两个键</li></ul><p><img src="/upload/btreebuild.gif" alt="upload successful"></p><h2 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h2><p>一次查找或者插入需要logm-1N到logm/2N<br>在实际情况中，假设M=1024,N=62000000000<br>则所需次不超过4</p><h1 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h1><p>B+树是对B树的一种变形树，它与B树的差异在于：</p><ul><li>有k个子结点的结点必然有k个关键码； </li><li>非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。</li><li>树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。</li></ul><p><img src="/upload/Bplustreebuild.gif" alt="upload successful"><br>B和B+树的区别在于，B+树的非叶子结点只包含导航信息，不包含实际的值，所有的叶子结点和相连的节点使用链表相连，便于区间查找和遍历。</p><p>B+ 树的优点在于：</p><ul><li>由于B+树在内部节点上不包含数据信息，因此在内存页中能够存放更多的key。 数据存放的更加紧密，具有更好的空间局部性。因此访问叶子节点上关联的数据也具有更好的缓存命中率。</li><li>B+树的叶子结点都是相链的，因此对整棵树的便利只需要一次线性遍历叶子结点即可。而且由于数据顺序排列并且相连，所以便于区间查找和搜索。而B树则需要进行每一层的递归遍历。相邻的元素可能在内存中不相邻，所以缓存命中性没有B+树好。</li></ul><p>但是B树也有优点，其优点在于，由于B树的每一个节点都包含key和value，因此经常访问的元素可能离根节点更近，因此访问也更迅速。下面是B 树和B+树的区别图：</p><p><img src="/upload/pasted-195.png" alt="upload successful"></p><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><p>他通过对每个节点存储个数的扩展，使得对连续的数据能够进行较快的定位和访问，能够有效减少查找时间，提高存储的空间局部性从而减少IO操作。他广泛用于文件系统及数据库中，如：</p><ul><li>Windows：HPFS文件系统</li><li>Mac：HFS，HFS+文件系统</li><li>Linux：ResiserFS，XFS，Ext3FS，JFS文件系统</li><li>数据库：ORACLE，MYSQL，SQLSERVER等中</li></ul><p>附： <a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></p>]]></content>
      
      
      <categories>
          
          <category> 从零开始的算法征程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 查找算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找（红黑树）</title>
      <link href="/2018/02/15/%EF%BC%88%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%89/"/>
      <url>/2018/02/15/%EF%BC%88%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="平衡查找树（红黑树，2-3树，Balance-Search-Tree）"><a href="#平衡查找树（红黑树，2-3树，Balance-Search-Tree）" class="headerlink" title="平衡查找树（红黑树，2-3树，Balance Search Tree）"></a>平衡查找树（红黑树，2-3树，Balance Search Tree）</h1><h2 id="2-3查找树"><a href="#2-3查找树" class="headerlink" title="2-3查找树"></a>2-3查找树</h2><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><p>一棵标准的二叉查找树的一个结点是2-结点（有两个孩子和一个键值对），现在引入3-结点，每个结点包含两个键值对和三个孩子<br>一棵完美平衡的2-3树所有空链接到根的距离是一样的<br><img src="/upload/pasted-168.png" alt="upload successful"></p><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>和一般的二叉查找树区别不大<br>只不过是处理3-结点时有一个分叉的问题，左中右<br><img src="/upload/pasted-169.png" alt="upload successful"></p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>分情况讨论<br>对于2-结点，若插入的结点的父节点是2-结点，则直接将此2-结点变为3-结点</p><p><img src="/upload/pasted-170.png" alt="upload successful"></p><p>对于3-结点<br>首先将新键加入到3-结点中，生成一个临时的4-结点，然后把中间的键上移到父节点，使父节点成为3-结点，并且把剩下的两个键分开，成为两个2-结点，如果父节点原来就是3-结点，则重复此过程</p><p><img src="/upload/pasted-171.png" alt="upload successful"><img src="/upload/pasted-172.png" alt="upload successful"></p><h3 id="情况分析"><a href="#情况分析" class="headerlink" title="情况分析"></a>情况分析</h3><p><img src="/upload/pasted-173.png" alt="upload successful"><br>之所以要从二叉搜索树衍生出这种2-3结构的树，是因为它能保证较好的平衡性和有序性<br>对于插入算法，分解一个4-结点的变换是局部的：除了相关的链接和结点之外不必修改或检查树的其他部分，每次变换，变更的链接数量不会超过一个很小的常数。而这种局部的操作并不会影响全局的有序性和平衡性，从空链接到根结点的距离是不会改变的，即使是根结点分成三个2-结点时，所有距离+1，因此，即使是在最坏情况，它也能保证lgn</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h3 id="一般概念"><a href="#一般概念" class="headerlink" title="一般概念"></a>一般概念</h3><p>红黑树实际上是表达2-3查找树的一种二叉查找树<br>主要问题是替换3-结点,因此引入红链和黑链，红链将两个2-结点连起来构成一个3-结点，黑链则是2-3树种的普通结点链接</p><p><img src="/upload/pasted-178.png" alt="upload successful"><br>在红黑树中，应当满足  </p><ul><li>红链接皆为左链接（作为左孩子出现）</li><li>没有任何一个结点和两个红链接相连</li><li>该树是完美黑色平衡的。即任何结点到根结点的路径上黑链接的数量是相等的</li></ul><p>一棵红黑树是和一棵2-3树一一对应的</p><p><img src="/upload/pasted-179.png" alt="upload successful"></p><h3 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h3><p>由于是从一般的搜索二叉树演变过来的，所以查找操作是一摸一样的</p><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p>对于2-结点和3-结点的转换，需要涉及到红链接左转和红链接右转，变色的操作，见代码部分<br>对于2-3树，在一个2-结点插入后，会生成有个3-结点，若是向左插入，则生成一个3-结点，若是向右插入，则需要进行旋转</p><ul><li>首先进行查找二叉树的标准插入</li><li>如果新链接指向右，则进行左旋转</li></ul><p><img src="/upload/pasted-184.png" alt="upload successful"></p><p><img src="/upload/pasted-185.png" alt="upload successful"></p><p><img src="/upload/pasted-183.png" alt="upload successful"><br>插入两个结点：需要变色操作</p><p><img src="/upload/pasted-186.png" alt="upload successful"></p><p><img src="/upload/pasted-187.png" alt="upload successful"></p><p><img src="/upload/pasted-188.png" alt="upload successful"><br>对于一个3-结点，插入过程<br>-1 先进行平衡二叉树的标准插入<br>-2 通过旋转，使4-结点变成3-结点（如果需要）<br>-3 通过变色使红链接向上一级<br>-4 通过旋转，使红链接指向左（如果需要）</p><p><img src="/upload/pasted-189.png" alt="upload successful"><br>实现思路：</p><p><img src="/upload/pasted-190.png" alt="upload successful"><br>右孩子黑，左孩子红：左旋操作<br>左孩子，左孩子的左孩子红：右旋操作<br>两个孩子都红：变色操作</p><h3 id="效率对比"><a href="#效率对比" class="headerlink" title="效率对比"></a>效率对比</h3><p>由于红黑树能保持平衡，即使在最坏的情况下树高为2lgn，因此不论查找还是插入都有较高的效率<br><img src="/upload/pasted-191.png" alt="upload successful"></p>]]></content>
      
      
      <categories>
          
          <category> 从零开始的算法征程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 查找算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找（二叉查找树）</title>
      <link href="/2018/02/14/%EF%BC%882%EF%BC%89/"/>
      <url>/2018/02/14/%EF%BC%882%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="二叉查找树（Binary-Search-tree）"><a href="#二叉查找树（Binary-Search-tree）" class="headerlink" title="二叉查找树（Binary Search tree）"></a>二叉查找树（Binary Search tree）</h1><h2 id="一般概念"><a href="#一般概念" class="headerlink" title="一般概念"></a>一般概念</h2><p><img src="/upload/pasted-147.png" alt="upload successful"><br>所谓二叉查找树，是一种基于二叉树查找的数据结构，不同的是，每个节点是一个键值对，且结点间也是有序存在的，而且要求某结点的左子树是包含所有键值小于当前结点的键值的结点所构成的，右子树则是大于该结点的结点(不同于堆，堆是要求某结点要大于他的两个孩子)</p><h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p><img src="/upload/pasted-148.png" alt="upload successful"><br>递归查找方式：如果树为空，返回null，如果不相等且当前结点无子树，查找不命中返回null，如果等于当前结点的key(第一个应该是根结点)，则查找命中吗，返回当前结点的key，如果查找的结点小于当前结点，继续递归查找左子树，大于则递归查找右子树</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p><img src="/upload/pasted-149.png" alt="upload successful"><br>如果小，走左子树，如果大，走右子树，如果相等，新值替换旧值，如果空，插入新结点</p><h3 id="一般情况分析"><a href="#一般情况分析" class="headerlink" title="一般情况分析"></a>一般情况分析</h3><p><img src="/upload/pasted-151.png" alt="upload successful"><br>查找树算法的效率和树的形状是有直接关系的，而树的形状又和插入数据的顺序有关<br>对于随机key构建出来的树，查找击中的需要 ~2lnN次比较<br>插入和查找失败需要 ~2lnN次比较</p><h3 id="有序化方法"><a href="#有序化方法" class="headerlink" title="有序化方法"></a>有序化方法</h3><p><img src="/upload/pasted-164.png" alt="upload successful"></p><p><img src="/upload/pasted-165.png" alt="upload successful"></p><ul><li>min()方法和max()方法：如果根结点的左子树为空，则最小的key就是root，如果左子树不为空，则最小的就是左子树中最小的key一种递归方法，max也类似</li><li>向上取整（floor）和向下取整(ceiling)：如果给定的键key小于二叉查找树的根结点的键，那么小于等于key的最大键floor(key)一定在根结点的左子树中，如果给定的键key大于二叉查找树的根结点，那么只有当根节点右子树中存在小于等于key的结点时，小于等于key的最大键才会出现在右子树，否则根节点就是小于等于key的最大键（递归）</li><li><p>选择个数 和node的一个域有关，直接计算即可</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>对于删除最小结点，是很好处理的，如果最小结点（左子树为空）无右子树，直接删除就行，如果有右子树，要把这个右子树链接到其左子树上<br><img src="/upload/pasted-166.png" alt="upload successful"><br>对于既有左子树又有右子树的任一点进行删除，可采用Hibbard方法:</p></li><li><p>将要删除的结点的索引存到t</p></li><li>让x指向它的后继结点min（t.right）(右子树中最小结点)</li><li>将x的右子树（本来是所有结点都大于k.key的子树）设为deleteMin(t.right)，也就是在删除后所有结点仍然大于x.key的子树</li><li>将x的左子树设为t.left(其下所有结点都小于它的被删除结点和它的后继结点)</li><li>递归调用，修正父节点链接，并将由此结点到根结点的所有结点的计数器减1</li></ul><p><img src="/upload/pasted-167.png" alt="upload successful"></p><h3 id="效率对比"><a href="#效率对比" class="headerlink" title="效率对比"></a>效率对比</h3><p><img src="/upload/pasted-153.png" alt="upload successful"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br></pre></td><td class="code"><pre><span class="line">ublic class BST&lt;Key extends Comparable&lt;Key&gt;, Value&gt; &#123;</span><br><span class="line">    private Node root;             // 二叉搜索树的根结点</span><br><span class="line"></span><br><span class="line">    private class Node &#123;</span><br><span class="line">        private Key key;           // 键</span><br><span class="line">        private Value val;         // 值</span><br><span class="line">        private Node left, right;  // 左右子树</span><br><span class="line">        private int size;          // 计数器，记录子树的结点树</span><br><span class="line"></span><br><span class="line">        public Node(Key key, Value val, int size) &#123;</span><br><span class="line">            this.key = key;</span><br><span class="line">            this.val = val;</span><br><span class="line">            this.size = size;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 初始化</span><br><span class="line">     */</span><br><span class="line">    public BST() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判空</span><br><span class="line">     * @return &#123;@code true&#125; if this symbol table is empty; &#123;@code false&#125; otherwise</span><br><span class="line">     */</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return size() == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回符号表键值对个数</span><br><span class="line">     * @return the number of key-value pairs in this symbol table</span><br><span class="line">     */</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return size(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //返回以x为根结点的子树的结点个数和</span><br><span class="line">    private int size(Node x) &#123;</span><br><span class="line">        if (x == null) return 0;</span><br><span class="line">        else return x.size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 看该符号表是否包含当前key</span><br><span class="line">     *</span><br><span class="line">     * @param  key the key</span><br><span class="line">     * @return &#123;@code true&#125; if this symbol table contains &#123;@code key&#125; and</span><br><span class="line">     *         &#123;@code false&#125; otherwise</span><br><span class="line">     * @throws IllegalArgumentException if &#123;@code key&#125; is &#123;@code null&#125;</span><br><span class="line">     */</span><br><span class="line">    public boolean contains(Key key) &#123;</span><br><span class="line">        if (key == null) throw new IllegalArgumentException(&quot;argument to contains() is null&quot;);</span><br><span class="line">        return get(key) != null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回与该键关联的值</span><br><span class="line">     * 此为接口函数</span><br><span class="line">     *</span><br><span class="line">     * @param  key the key</span><br><span class="line">     * @return the value associated with the given key if the key is in the symbol table</span><br><span class="line">     *         and &#123;@code null&#125; if the key is not in the symbol table</span><br><span class="line">     * @throws IllegalArgumentException if &#123;@code key&#125; is &#123;@code null&#125;</span><br><span class="line">     */</span><br><span class="line">    public Value get(Key key) &#123;</span><br><span class="line">        return get(root, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //此为递归用的内部函数</span><br><span class="line">    private Value get(Node x, Key key) &#123;</span><br><span class="line">        //上来先处理终点情况和特殊情况</span><br><span class="line">        if (key == null) throw new IllegalArgumentException(&quot;calls get() with a null key&quot;);</span><br><span class="line">        if (x == null) return null;</span><br><span class="line">        int cmp = key.compareTo(x.key);</span><br><span class="line">        if      (cmp &lt; 0) return get(x.left, key);</span><br><span class="line">        else if (cmp &gt; 0) return get(x.right, key);</span><br><span class="line">        else              return x.val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 插入新键值对，如果该键不存在</span><br><span class="line">     * 更新该键值对如果该键存在</span><br><span class="line">     * 删除该键值对如果value为null</span><br><span class="line">     * 接口方法</span><br><span class="line">     *</span><br><span class="line">     * @param  key the key</span><br><span class="line">     * @param  val the value</span><br><span class="line">     * @throws IllegalArgumentException if &#123;@code key&#125; is &#123;@code null&#125;</span><br><span class="line">     */</span><br><span class="line">    public void put(Key key, Value val) &#123;</span><br><span class="line">        if (key == null) throw new IllegalArgumentException(&quot;calls put() with a null key&quot;);</span><br><span class="line">        if (val == null) &#123;</span><br><span class="line">            delete(key);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        root = put(root, key, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //内部方法，递归调用，方法有些巧妙</span><br><span class="line">    private Node put(Node x, Key key, Value val) &#123;</span><br><span class="line">        if (x == null) return new Node(key, val, 1);</span><br><span class="line">        int cmp = key.compareTo(x.key);</span><br><span class="line">        if      (cmp &lt; 0) x.left  = put(x.left,  key, val);</span><br><span class="line">        else if (cmp &gt; 0) x.right = put(x.right, key, val);</span><br><span class="line">        else              x.val   = val;</span><br><span class="line">        x.size = 1 + size(x.left) + size(x.right);</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除最小key的键值对</span><br><span class="line">     *</span><br><span class="line">     * @throws NoSuchElementException if the symbol table is empty</span><br><span class="line">     */</span><br><span class="line">    public void deleteMin() &#123;</span><br><span class="line">        if (isEmpty()) throw new NoSuchElementException(&quot;Symbol table underflow&quot;);</span><br><span class="line">        root = deleteMin(root);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Node deleteMin(Node x) &#123;</span><br><span class="line">        if (x.left == null) return x.right;</span><br><span class="line">        x.left = deleteMin(x.left);</span><br><span class="line">        x.size = size(x.left) + size(x.right) + 1;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除最大键</span><br><span class="line">     *</span><br><span class="line">     * @throws NoSuchElementException if the symbol table is empty</span><br><span class="line">     */</span><br><span class="line">    public void deleteMax() &#123;</span><br><span class="line">        if (isEmpty()) throw new NoSuchElementException(&quot;Symbol table underflow&quot;);</span><br><span class="line">        root = deleteMax(root);</span><br><span class="line">      </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Node deleteMax(Node x) &#123;</span><br><span class="line">        if (x.right == null) return x.left;</span><br><span class="line">        x.right = deleteMax(x.right);</span><br><span class="line">        x.size = size(x.left) + size(x.right) + 1;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除给定键的键值对    </span><br><span class="line">     * (if the key is in this symbol table).    </span><br><span class="line">     *</span><br><span class="line">     * @param  key the key</span><br><span class="line">     * @throws IllegalArgumentException if &#123;@code key&#125; is &#123;@code null&#125;</span><br><span class="line">     */</span><br><span class="line">    public void delete(Key key) &#123;</span><br><span class="line">        if (key == null) throw new IllegalArgumentException(&quot;calls delete() with a null key&quot;);</span><br><span class="line">        root = delete(root, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Node delete(Node x, Key key) &#123;</span><br><span class="line">        //如果没有孩子，返回null</span><br><span class="line">        if (x == null) return null;</span><br><span class="line"></span><br><span class="line">        int cmp = key.compareTo(x.key);</span><br><span class="line">        if      (cmp &lt; 0) x.left  = delete(x.left,  key);</span><br><span class="line">        else if (cmp &gt; 0) x.right = delete(x.right, key);</span><br><span class="line">        else &#123;</span><br><span class="line">            //如果是只有一个孩子，直接返回孩子即可·</span><br><span class="line">            if (x.right == null) return x.left;</span><br><span class="line">            if (x.left  == null) return x.right;</span><br><span class="line">            //若有两个孩子</span><br><span class="line">            //设当前结点为t</span><br><span class="line">            Node t = x;</span><br><span class="line">            //原来的x为t的右子树中最小的结点</span><br><span class="line">            x = min(t.right);</span><br><span class="line">            //x现在的右子树为删除原来t的右子树的最小结点</span><br><span class="line">            x.right = deleteMin(t.right);</span><br><span class="line">            x.left = t.left;</span><br><span class="line">        &#125; </span><br><span class="line">        x.size = size(x.left) + size(x.right) + 1;</span><br><span class="line">        return x;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回最小键</span><br><span class="line">     *</span><br><span class="line">     * @return the smallest key in the symbol table</span><br><span class="line">     * @throws NoSuchElementException if the symbol table is empty</span><br><span class="line">     */</span><br><span class="line">    public Key min() &#123;</span><br><span class="line">        if (isEmpty()) throw new NoSuchElementException(&quot;calls min() with empty symbol table&quot;);</span><br><span class="line">        return min(root).key;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    private Node min(Node x) &#123; </span><br><span class="line">        //最小键的左子树肯定null，不为null则继续找</span><br><span class="line">        if (x.left == null) return x; </span><br><span class="line">        else                return min(x.left); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回最大键</span><br><span class="line">     *</span><br><span class="line">     * @return the largest key in the symbol table</span><br><span class="line">     * @throws NoSuchElementException if the symbol table is empty</span><br><span class="line">     */</span><br><span class="line">    public Key max() &#123;</span><br><span class="line">        if (isEmpty()) throw new NoSuchElementException(&quot;calls max() with empty symbol table&quot;);</span><br><span class="line">        return max(root).key;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    private Node max(Node x) &#123;</span><br><span class="line">        if (x.right == null) return x; </span><br><span class="line">        else                 return max(x.right); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 向上取整</span><br><span class="line">     *</span><br><span class="line">     * @param  key the key</span><br><span class="line">     * @return the largest key in the symbol table less than or equal to &#123;@code key&#125;</span><br><span class="line">     * @throws NoSuchElementException if there is no such key</span><br><span class="line">     * @throws IllegalArgumentException if &#123;@code key&#125; is &#123;@code null&#125;</span><br><span class="line">     */</span><br><span class="line">    public Key floor(Key key) &#123;</span><br><span class="line">        if (key == null) throw new IllegalArgumentException(&quot;argument to floor() is null&quot;);</span><br><span class="line">        if (isEmpty()) throw new NoSuchElementException(&quot;calls floor() with empty symbol table&quot;);</span><br><span class="line">        Node x = floor(root, key);</span><br><span class="line">        if (x == null) return null;</span><br><span class="line">        else return x.key;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    private Node floor(Node x, Key key) &#123;</span><br><span class="line">        if (x == null) return null;</span><br><span class="line">        int cmp = key.compareTo(x.key);</span><br><span class="line">        if (cmp == 0) return x;</span><br><span class="line">        if (cmp &lt;  0) return floor(x.left, key);</span><br><span class="line">        Node t = floor(x.right, key); </span><br><span class="line">        if (t != null) return t;</span><br><span class="line">        else return x; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    public Key floor2(Key key) &#123;</span><br><span class="line">        return floor2(root, key, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Key floor2(Node x, Key key, Key best) &#123;</span><br><span class="line">        if (x == null) return best;</span><br><span class="line">        int cmp = key.compareTo(x.key);</span><br><span class="line">        if      (cmp  &lt; 0) return floor2(x.left, key, best);</span><br><span class="line">        else if (cmp  &gt; 0) return floor2(x.right, key, x.key);</span><br><span class="line">        else               return x.key;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the smallest key in the symbol table greater than or equal to &#123;@code key&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @param  key the key</span><br><span class="line">     * @return the smallest key in the symbol table greater than or equal to &#123;@code key&#125;</span><br><span class="line">     * @throws NoSuchElementException if there is no such key</span><br><span class="line">     * @throws IllegalArgumentException if &#123;@code key&#125; is &#123;@code null&#125;</span><br><span class="line">     */</span><br><span class="line">    public Key ceiling(Key key) &#123;</span><br><span class="line">        if (key == null) throw new IllegalArgumentException(&quot;argument to ceiling() is null&quot;);</span><br><span class="line">        if (isEmpty()) throw new NoSuchElementException(&quot;calls ceiling() with empty symbol table&quot;);</span><br><span class="line">        Node x = ceiling(root, key);</span><br><span class="line">        if (x == null) return null;</span><br><span class="line">        else return x.key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private Node ceiling(Node x, Key key) &#123;</span><br><span class="line">        if (x == null) return null;</span><br><span class="line">        int cmp = key.compareTo(x.key);</span><br><span class="line">        if (cmp == 0) return x;</span><br><span class="line">        if (cmp &lt; 0) &#123; </span><br><span class="line">            Node t = ceiling(x.left, key); </span><br><span class="line">            if (t != null) return t;</span><br><span class="line">            else return x; </span><br><span class="line">        &#125; </span><br><span class="line">        return ceiling(x.right, key); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Return the key in the symbol table whose rank is &#123;@code k&#125;.</span><br><span class="line">     * This is the (k+1)st smallest key in the symbol table.</span><br><span class="line">     *</span><br><span class="line">     * @param  k the order statistic</span><br><span class="line">     * @return the key in the symbol table of rank &#123;@code k&#125;</span><br><span class="line">     * @throws IllegalArgumentException unless &#123;@code k&#125; is between 0 and</span><br><span class="line">     *        &lt;em&gt;n&lt;/em&gt;–1</span><br><span class="line">     */</span><br><span class="line">    public Key select(int k) &#123;</span><br><span class="line">        if (k &lt; 0 || k &gt;= size()) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;argument to select() is invalid: &quot; + k);</span><br><span class="line">        &#125;</span><br><span class="line">        Node x = select(root, k);</span><br><span class="line">        return x.key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Return key of rank k. </span><br><span class="line">    private Node select(Node x, int k) &#123;</span><br><span class="line">        if (x == null) return null; </span><br><span class="line">        int t = size(x.left); </span><br><span class="line">        if      (t &gt; k) return select(x.left,  k); </span><br><span class="line">        else if (t &lt; k) return select(x.right, k-t-1); </span><br><span class="line">        else            return x; </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Return the number of keys in the symbol table strictly less than &#123;@code key&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @param  key the key</span><br><span class="line">     * @return the number of keys in the symbol table strictly less than &#123;@code key&#125;</span><br><span class="line">     * @throws IllegalArgumentException if &#123;@code key&#125; is &#123;@code null&#125;</span><br><span class="line">     */</span><br><span class="line">    public int rank(Key key) &#123;</span><br><span class="line">        if (key == null) throw new IllegalArgumentException(&quot;argument to rank() is null&quot;);</span><br><span class="line">        return rank(key, root);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    // Number of keys in the subtree less than key.</span><br><span class="line">    private int rank(Key key, Node x) &#123;</span><br><span class="line">        if (x == null) return 0; </span><br><span class="line">        int cmp = key.compareTo(x.key); </span><br><span class="line">        if      (cmp &lt; 0) return rank(key, x.left); </span><br><span class="line">        else if (cmp &gt; 0) return 1 + size(x.left) + rank(key, x.right); </span><br><span class="line">        else              return size(x.left); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns all keys in the symbol table as an &#123;@code Iterable&#125;.</span><br><span class="line">     * To iterate over all of the keys in the symbol table named &#123;@code st&#125;,</span><br><span class="line">     * use the foreach notation: &#123;@code for (Key key : st.keys())&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @return all keys in the symbol table</span><br><span class="line">     */</span><br><span class="line">    public Iterable&lt;Key&gt; keys() &#123;</span><br><span class="line">        if (isEmpty()) return new Queue&lt;Key&gt;();</span><br><span class="line">        return keys(min(), max());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns all keys in the symbol table in the given range,</span><br><span class="line">     * as an &#123;@code Iterable&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @param  lo minimum endpoint</span><br><span class="line">     * @param  hi maximum endpoint</span><br><span class="line">     * @return all keys in the symbol table between &#123;@code lo&#125; </span><br><span class="line">     *         (inclusive) and &#123;@code hi&#125; (inclusive)</span><br><span class="line">     * @throws IllegalArgumentException if either &#123;@code lo&#125; or &#123;@code hi&#125;</span><br><span class="line">     *         is &#123;@code null&#125;</span><br><span class="line">     */</span><br><span class="line">    public Iterable&lt;Key&gt; keys(Key lo, Key hi) &#123;</span><br><span class="line">        if (lo == null) throw new IllegalArgumentException(&quot;first argument to keys() is null&quot;);</span><br><span class="line">        if (hi == null) throw new IllegalArgumentException(&quot;second argument to keys() is null&quot;);</span><br><span class="line"></span><br><span class="line">        Queue&lt;Key&gt; queue = new Queue&lt;Key&gt;();</span><br><span class="line">        keys(root, queue, lo, hi);</span><br><span class="line">        return queue;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    private void keys(Node x, Queue&lt;Key&gt; queue, Key lo, Key hi) &#123; </span><br><span class="line">        if (x == null) return; </span><br><span class="line">        int cmplo = lo.compareTo(x.key); </span><br><span class="line">        int cmphi = hi.compareTo(x.key); </span><br><span class="line">        if (cmplo &lt; 0) keys(x.left, queue, lo, hi); </span><br><span class="line">        if (cmplo &lt;= 0 &amp;&amp; cmphi &gt;= 0) queue.enqueue(x.key); </span><br><span class="line">        if (cmphi &gt; 0) keys(x.right, queue, lo, hi); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the number of keys in the symbol table in the given range.</span><br><span class="line">     *</span><br><span class="line">     * @param  lo minimum endpoint</span><br><span class="line">     * @param  hi maximum endpoint</span><br><span class="line">     * @return the number of keys in the symbol table between &#123;@code lo&#125; </span><br><span class="line">     *         (inclusive) and &#123;@code hi&#125; (inclusive)</span><br><span class="line">     * @throws IllegalArgumentException if either &#123;@code lo&#125; or &#123;@code hi&#125;</span><br><span class="line">     *         is &#123;@code null&#125;</span><br><span class="line">     */</span><br><span class="line">    public int size(Key lo, Key hi) &#123;</span><br><span class="line">        if (lo == null) throw new IllegalArgumentException(&quot;first argument to size() is null&quot;);</span><br><span class="line">        if (hi == null) throw new IllegalArgumentException(&quot;second argument to size() is null&quot;);</span><br><span class="line"></span><br><span class="line">        if (lo.compareTo(hi) &gt; 0) return 0;</span><br><span class="line">        if (contains(hi)) return rank(hi) - rank(lo) + 1;</span><br><span class="line">        else              return rank(hi) - rank(lo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the height of the BST (for debugging).</span><br><span class="line">     *</span><br><span class="line">     * @return the height of the BST (a 1-node tree has height 0)</span><br><span class="line">     */</span><br><span class="line">    public int height() &#123;</span><br><span class="line">        return height(root);</span><br><span class="line">    &#125;</span><br><span class="line">    private int height(Node x) &#123;</span><br><span class="line">        if (x == null) return -1;</span><br><span class="line">        return 1 + Math.max(height(x.left), height(x.right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the keys in the BST in level order (for debugging).</span><br><span class="line">     *</span><br><span class="line">     * @return the keys in the BST in level order traversal</span><br><span class="line">     */</span><br><span class="line">    public Iterable&lt;Key&gt; levelOrder() &#123;</span><br><span class="line">        Queue&lt;Key&gt; keys = new Queue&lt;Key&gt;();</span><br><span class="line">        Queue&lt;Node&gt; queue = new Queue&lt;Node&gt;();</span><br><span class="line">        queue.enqueue(root);</span><br><span class="line">        while (!queue.isEmpty()) &#123;</span><br><span class="line">            Node x = queue.dequeue();</span><br><span class="line">            if (x == null) continue;</span><br><span class="line">            keys.enqueue(x.key);</span><br><span class="line">            queue.enqueue(x.left);</span><br><span class="line">            queue.enqueue(x.right);</span><br><span class="line">        &#125;</span><br><span class="line">        return keys;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  /*************************************************************************</span><br><span class="line">    *  Check integrity of BST data structure.</span><br><span class="line">    ***************************************************************************/</span><br><span class="line">    private boolean check() &#123;</span><br><span class="line">        if (!isBST())            StdOut.println(&quot;Not in symmetric order&quot;);</span><br><span class="line">        if (!isSizeConsistent()) StdOut.println(&quot;Subtree counts not consistent&quot;);</span><br><span class="line">        if (!isRankConsistent()) StdOut.println(&quot;Ranks not consistent&quot;);</span><br><span class="line">        return isBST() &amp;&amp; isSizeConsistent() &amp;&amp; isRankConsistent();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // does this binary tree satisfy symmetric order?</span><br><span class="line">    // Note: this test also ensures that data structure is a binary tree since order is strict</span><br><span class="line">    private boolean isBST() &#123;</span><br><span class="line">        return isBST(root, null, null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // is the tree rooted at x a BST with all keys strictly between min and max</span><br><span class="line">    // (if min or max is null, treat as empty constraint)</span><br><span class="line">    // Credit: Bob Dondero&apos;s elegant solution</span><br><span class="line">    private boolean isBST(Node x, Key min, Key max) &#123;</span><br><span class="line">        if (x == null) return true;</span><br><span class="line">        if (min != null &amp;&amp; x.key.compareTo(min) &lt;= 0) return false;</span><br><span class="line">        if (max != null &amp;&amp; x.key.compareTo(max) &gt;= 0) return false;</span><br><span class="line">        return isBST(x.left, min, x.key) &amp;&amp; isBST(x.right, x.key, max);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    // are the size fields correct?</span><br><span class="line">    private boolean isSizeConsistent() &#123; return isSizeConsistent(root); &#125;</span><br><span class="line">    private boolean isSizeConsistent(Node x) &#123;</span><br><span class="line">        if (x == null) return true;</span><br><span class="line">        if (x.size != size(x.left) + size(x.right) + 1) return false;</span><br><span class="line">        return isSizeConsistent(x.left) &amp;&amp; isSizeConsistent(x.right);</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    // check that ranks are consistent</span><br><span class="line">    private boolean isRankConsistent() &#123;</span><br><span class="line">        for (int i = 0; i &lt; size(); i++)</span><br><span class="line">            if (i != rank(select(i))) return false;</span><br><span class="line">        for (Key key : keys())</span><br><span class="line">            if (key.compareTo(select(rank(key))) != 0) return false;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 从零开始的算法征程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 查找算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找（一般无序链表，二分查找的数组）</title>
      <link href="/2018/02/13/%E6%89%BE/"/>
      <url>/2018/02/13/%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="符号表（Symbol-Table）"><a href="#符号表（Symbol-Table）" class="headerlink" title="符号表（Symbol Table）"></a>符号表（Symbol Table）</h1><h3 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h3><p>存储键值对，能够插入（insert）键值对，能够通过键直接查找到值（search）</p><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p><img src="/upload/pasted-142.png" alt="upload successful"></p><h3 id="规定"><a href="#规定" class="headerlink" title="规定"></a>规定</h3><ul><li>值不可为null</li><li>键不可为null</li><li>put()将用新值替换旧值</li><li>get()返回null 如果没有该键<br>键和值的要求</li><li>值可以是任何一般类型</li><li>键必须实现comparable接口，实现compareTo方法</li><li>键要实现equals来比较是否相同</li><li>键要实现hashCode()来保证键的唯一性</li><li>键要用不可改变的类型（比如String，Integer，java.io.File,Double）</li></ul><p>补充：如何说x,y,z是相等的</p><ul><li>自反性：x.equals(x) ==true</li><li>对称性 x.equals(y)==true</li><li>传递性 x.equals(y)==y.equals(z)==true ,则x.equals(y)==true</li><li>非空 x.equals(null)==false</li></ul><p>一个重写equals的实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean equals(Object other)&#123;</span><br><span class="line">    //一个地址下的肯定相等</span><br><span class="line">    if (other == this) return true;</span><br><span class="line">    if (other == null) return false;</span><br><span class="line">    //类要一致</span><br><span class="line">    if (other.getClass() != this.getClass()) return false;</span><br><span class="line">    //要支持强转</span><br><span class="line">    Date that = (Date) other;</span><br><span class="line">    //满足特殊规则</span><br><span class="line">    return (this.month == that.month) &amp;&amp; (this.day == that.day) &amp;&amp; (this.year == that.year);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="符号表的实现"><a href="#符号表的实现" class="headerlink" title="符号表的实现"></a>符号表的实现</h3><h4 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h4><p>用一个链表存放键值对结点<br><img src="/upload/pasted-143.png" alt="upload successful"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">public class SequentialSearchST&lt;Key, Value&gt; &#123;</span><br><span class="line">    private int n;           // 键值对个数</span><br><span class="line">    private Node first;      // 键值对链表储存的结点</span><br><span class="line"></span><br><span class="line">   //结点内部类</span><br><span class="line">    private class Node &#123;</span><br><span class="line">        private Key key;</span><br><span class="line">        private Value val;</span><br><span class="line">        private Node next;</span><br><span class="line"></span><br><span class="line">        public Node(Key key, Value val, Node next)  &#123;</span><br><span class="line">            this.key  = key;</span><br><span class="line">            this.val  = val;</span><br><span class="line">            this.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 如果含有该键值，返回true</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    public boolean contains(Key key) &#123;</span><br><span class="line">        if (key == null) throw new IllegalArgumentException(&quot;argument to contains() is null&quot;);</span><br><span class="line">        return get(key) != null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回与键值相等的结点</span><br><span class="line">     */</span><br><span class="line">    public Value get(Key key) &#123;</span><br><span class="line">        if (key == null) throw new IllegalArgumentException(&quot;argument to get() is null&quot;); </span><br><span class="line">        //遍历进行查找</span><br><span class="line">        for (Node x = first; x != null; x = x.next) &#123;</span><br><span class="line">            if (key.equals(x.key))</span><br><span class="line">                return x.val;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *添加新的键值对</span><br><span class="line">     */</span><br><span class="line">    public void put(Key key, Value val) &#123;</span><br><span class="line">        if (key == null) throw new IllegalArgumentException(&quot;first argument to put() is null&quot;); </span><br><span class="line">        //当值为空时，进行延时删除</span><br><span class="line">        if (val == null) &#123;</span><br><span class="line">            delete(key);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        //遍历结点，看看是否击中</span><br><span class="line">        for (Node x = first; x != null; x = x.next) &#123;</span><br><span class="line">            if (key.equals(x.key)) &#123;</span><br><span class="line">            //击中的情况下更新值</span><br><span class="line">                x.val = val;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        //未击中则添加新的结点</span><br><span class="line">        first = new Node(key, val, first);</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除某键值对   </span><br><span class="line">     */</span><br><span class="line">    public void delete(Key key) &#123;</span><br><span class="line">        if (key == null) throw new IllegalArgumentException(&quot;argument to delete() is null&quot;); </span><br><span class="line">        first = delete(first, key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 递归方法删除结点</span><br><span class="line">    // warning: function call stack too large if table is large</span><br><span class="line">    private Node delete(Node x, Key key) &#123;</span><br><span class="line">        if (x == null) return null;</span><br><span class="line">        //终止条件</span><br><span class="line">        if (key.equals(x.key)) &#123;</span><br><span class="line">            n--;</span><br><span class="line">            return x.next;</span><br><span class="line">        &#125;</span><br><span class="line">        x.next = delete(x.next, key);</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将所有的key放入queue并返回迭代器</span><br><span class="line">    public Iterable&lt;Key&gt; keys()  &#123;</span><br><span class="line">        Queue&lt;Key&gt; queue = new Queue&lt;Key&gt;();</span><br><span class="line">        for (Node x = first; x != null; x = x.next)</span><br><span class="line">            queue.enqueue(x.key);</span><br><span class="line">        return queue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="二分查找数组"><a href="#二分查找数组" class="headerlink" title="二分查找数组"></a>二分查找数组</h4><p>用两个数组，一个装键，保持有序，一个装值</p><p><img src="/upload/pasted-144.png" alt="upload successful"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br></pre></td><td class="code"><pre><span class="line">public class BinarySearchST&lt;Key extends Comparable&lt;Key&gt;, Value&gt; &#123;</span><br><span class="line">    private static final int INIT_CAPACITY = 2;</span><br><span class="line">    private Key[] keys;</span><br><span class="line">    private Value[] vals;</span><br><span class="line">    private int n = 0;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 初始化两个有序数组</span><br><span class="line">     */</span><br><span class="line">    public BinarySearchST() &#123;</span><br><span class="line">        this(INIT_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**用定长数组初始化</span><br><span class="line">     */</span><br><span class="line">    public BinarySearchST(int capacity) &#123; </span><br><span class="line">        keys = (Key[]) new Comparable[capacity]; </span><br><span class="line">        vals = (Value[]) new Object[capacity]; </span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    // 扩容（缩容）函数</span><br><span class="line">    private void resize(int capacity) &#123;</span><br><span class="line">        Key[]   tempk = (Key[])   new Comparable[capacity];</span><br><span class="line">        Value[] tempv = (Value[]) new Object[capacity];</span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            tempk[i] = keys[i];</span><br><span class="line">            tempv[i] = vals[i];</span><br><span class="line">        &#125;</span><br><span class="line">        vals = tempv;</span><br><span class="line">        keys = tempk;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回size</span><br><span class="line">     */</span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 判空</span><br><span class="line">     */</span><br><span class="line">    public boolean isEmpty() &#123;</span><br><span class="line">        return size() == 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Does this symbol table contain the given key?</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">    public boolean contains(Key key) &#123;</span><br><span class="line">        if (key == null) throw new IllegalArgumentException(&quot;argument to contains() is null&quot;);</span><br><span class="line">        return get(key) != null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the value associated with the given key in this symbol table.</span><br><span class="line">     *</span><br><span class="line">     * @param  key the key</span><br><span class="line">     * @return the value associated with the given key if the key is in the symbol table</span><br><span class="line">     *         and &#123;@code null&#125; if the key is not in the symbol table</span><br><span class="line">     * @throws IllegalArgumentException if &#123;@code key&#125; is &#123;@code null&#125;</span><br><span class="line">     */</span><br><span class="line">    public Value get(Key key) &#123;</span><br><span class="line">        if (key == null) throw new IllegalArgumentException(&quot;argument to get() is null&quot;); </span><br><span class="line">        if (isEmpty()) return null;</span><br><span class="line">        //二分查找到键在键数组中的索引</span><br><span class="line">        int i = rank(key); </span><br><span class="line">        if (i &lt; n &amp;&amp; keys[i].compareTo(key) == 0) return vals[i];</span><br><span class="line">        return null;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回严格小于当全部key的key的数量</span><br><span class="line">     *</span><br><span class="line">     * @param  key the key</span><br><span class="line">     * @return the number of keys in the symbol table strictly less than &#123;@code key&#125;</span><br><span class="line">     * @throws IllegalArgumentException if &#123;@code key&#125; is &#123;@code null&#125;</span><br><span class="line">     */</span><br><span class="line">    public int rank(Key key) &#123;</span><br><span class="line">        if (key == null) throw new IllegalArgumentException(&quot;argument to rank() is null&quot;); </span><br><span class="line"></span><br><span class="line">        int lo = 0, hi = n-1; </span><br><span class="line">        while (lo &lt;= hi) &#123; </span><br><span class="line">            int mid = lo + (hi - lo) / 2; </span><br><span class="line">            int cmp = key.compareTo(keys[mid]);</span><br><span class="line">            if      (cmp &lt; 0) hi = mid - 1; </span><br><span class="line">            else if (cmp &gt; 0) lo = mid + 1; </span><br><span class="line">            else return mid; </span><br><span class="line">        &#125; </span><br><span class="line">        return lo;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *插入一个新的键值对 </span><br><span class="line">     * 如果键已经存在则用新的值替换旧值</span><br><span class="line">     * 如果当前值为空，则删除该键值对</span><br><span class="line">     *</span><br><span class="line">     * @param  key the key</span><br><span class="line">     * @param  val the value</span><br><span class="line">     * @throws IllegalArgumentException if &#123;@code key&#125; is &#123;@code null&#125;</span><br><span class="line">     */</span><br><span class="line">    public void put(Key key, Value val)  &#123;</span><br><span class="line">        if (key == null) throw new IllegalArgumentException(&quot;first argument to put() is null&quot;); </span><br><span class="line"></span><br><span class="line">        if (val == null) &#123;</span><br><span class="line">            delete(key);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int i = rank(key);</span><br><span class="line"></span><br><span class="line">        // key is already in table</span><br><span class="line">        if (i &lt; n &amp;&amp; keys[i].compareTo(key) == 0) &#123;</span><br><span class="line">            vals[i] = val;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // insert new key-value pair</span><br><span class="line">        if (n == keys.length) resize(2*keys.length);</span><br><span class="line"></span><br><span class="line">        // 所有在这个新插入的键值对后面的键值对滞后，给新的键值对挪地方</span><br><span class="line">        for (int j = n; j &gt; i; j--)  &#123;</span><br><span class="line">            keys[j] = keys[j-1];</span><br><span class="line">            vals[j] = vals[j-1];</span><br><span class="line">        &#125;</span><br><span class="line">        keys[i] = key;</span><br><span class="line">        vals[i] = val;</span><br><span class="line">        n++;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *删除当前key的键值对，如果该键值对存在的话</span><br><span class="line">     * @param  key the key</span><br><span class="line">     * @throws IllegalArgumentException if &#123;@code key&#125; is &#123;@code null&#125;</span><br><span class="line">     */</span><br><span class="line">    public void delete(Key key) &#123;</span><br><span class="line">        if (key == null) throw new IllegalArgumentException(&quot;argument to delete() is null&quot;); </span><br><span class="line">        if (isEmpty()) return;</span><br><span class="line"></span><br><span class="line">        // compute rank</span><br><span class="line">        int i = rank(key);</span><br><span class="line"></span><br><span class="line">        // key not in table</span><br><span class="line">        if (i == n || keys[i].compareTo(key) != 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int j = i; j &lt; n-1; j++)  &#123;</span><br><span class="line">            keys[j] = keys[j+1];</span><br><span class="line">            vals[j] = vals[j+1];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        n--;</span><br><span class="line">        keys[n] = null;  // 等待垃圾回收机制处理</span><br><span class="line">        vals[n] = null;</span><br><span class="line"></span><br><span class="line">        // resize if 1/4 full</span><br><span class="line">        if (n &gt; 0 &amp;&amp; n == keys.length/4) resize(keys.length/2);</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 删除最小键值对</span><br><span class="line">     *</span><br><span class="line">     * @throws NoSuchElementException if the symbol table is empty</span><br><span class="line">     */</span><br><span class="line">    public void deleteMin() &#123;</span><br><span class="line">        if (isEmpty()) throw new NoSuchElementException(&quot;Symbol table underflow error&quot;);</span><br><span class="line">        delete(min());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Removes the largest key and associated value from this symbol table.</span><br><span class="line">     *</span><br><span class="line">     * @throws NoSuchElementException if the symbol table is empty</span><br><span class="line">     */</span><br><span class="line">    public void deleteMax() &#123;</span><br><span class="line">        if (isEmpty()) throw new NoSuchElementException(&quot;Symbol table underflow error&quot;);</span><br><span class="line">        delete(max());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   /***************************************************************************</span><br><span class="line">    *  有序符号表方法</span><br><span class="line">    ***************************************************************************/</span><br><span class="line"></span><br><span class="line">   /**</span><br><span class="line">     * 返回最小key</span><br><span class="line">     *</span><br><span class="line">     * @return the smallest key in this symbol table</span><br><span class="line">     * @throws NoSuchElementException if this symbol table is empty</span><br><span class="line">     */</span><br><span class="line">    public Key min() &#123;</span><br><span class="line">        if (isEmpty()) throw new NoSuchElementException(&quot;called min() with empty symbol table&quot;);</span><br><span class="line">        return keys[0]; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回最大键</span><br><span class="line">     *</span><br><span class="line">     * @return the largest key in this symbol table</span><br><span class="line">     * @throws NoSuchElementException if this symbol table is empty</span><br><span class="line">     */</span><br><span class="line">    public Key max() &#123;</span><br><span class="line">        if (isEmpty()) throw new NoSuchElementException(&quot;called max() with empty symbol table&quot;);</span><br><span class="line">        return keys[n-1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回第k小的键</span><br><span class="line">     *</span><br><span class="line">     * @param  k the order statistic</span><br><span class="line">     * @return the &#123;@code k&#125;th smallest key in this symbol table</span><br><span class="line">     * @throws IllegalArgumentException unless &#123;@code k&#125; is between 0 and</span><br><span class="line">     *        &lt;em&gt;n&lt;/em&gt;–1</span><br><span class="line">     */</span><br><span class="line">    public Key select(int k) &#123;</span><br><span class="line">        if (k &lt; 0 || k &gt;= size()) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;called select() with invalid argument: &quot; + k);</span><br><span class="line">        &#125;</span><br><span class="line">        return keys[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 返回与当前键相等或者小于当前键的最大键</span><br><span class="line">     *</span><br><span class="line">     * @param  key the key</span><br><span class="line">     * @return the largest key in this symbol table less than or equal to &#123;@code key&#125;</span><br><span class="line">     * @throws NoSuchElementException if there is no such key</span><br><span class="line">     * @throws IllegalArgumentException if &#123;@code key&#125; is &#123;@code null&#125;</span><br><span class="line">     */</span><br><span class="line">    public Key floor(Key key) &#123;</span><br><span class="line">        if (key == null) throw new IllegalArgumentException(&quot;argument to floor() is null&quot;); </span><br><span class="line">        int i = rank(key);</span><br><span class="line">        if (i &lt; n &amp;&amp; key.compareTo(keys[i]) == 0) return keys[i];</span><br><span class="line">        if (i == 0) return null;</span><br><span class="line">        //小于当前键的最大键</span><br><span class="line">        else return keys[i-1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns the number of keys in this symbol table in the specified range.</span><br><span class="line">     *</span><br><span class="line">     * @param lo minimum endpoint</span><br><span class="line">     * @param hi maximum endpoint</span><br><span class="line">     * @return the number of keys in this symbol table between &#123;@code lo&#125; </span><br><span class="line">     *         (inclusive) and &#123;@code hi&#125; (inclusive)</span><br><span class="line">     * @throws IllegalArgumentException if either &#123;@code lo&#125; or &#123;@code hi&#125;</span><br><span class="line">     *         is &#123;@code null&#125;</span><br><span class="line">     */</span><br><span class="line">    public int size(Key lo, Key hi) &#123;</span><br><span class="line">        if (lo == null) throw new IllegalArgumentException(&quot;first argument to size() is null&quot;); </span><br><span class="line">        if (hi == null) throw new IllegalArgumentException(&quot;second argument to size() is null&quot;); </span><br><span class="line"></span><br><span class="line">        if (lo.compareTo(hi) &gt; 0) return 0;</span><br><span class="line">        if (contains(hi)) return rank(hi) - rank(lo) + 1;</span><br><span class="line">        else              return rank(hi) - rank(lo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns all keys in this symbol table as an &#123;@code Iterable&#125;.</span><br><span class="line">     * To iterate over all of the keys in the symbol table named &#123;@code st&#125;,</span><br><span class="line">     * use the foreach notation: &#123;@code for (Key key : st.keys())&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @return all keys in this symbol table</span><br><span class="line">     */</span><br><span class="line">    public Iterable&lt;Key&gt; keys() &#123;</span><br><span class="line">        return keys(min(), max());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Returns all keys in this symbol table in the given range,</span><br><span class="line">     * as an &#123;@code Iterable&#125;.</span><br><span class="line">     *</span><br><span class="line">     * @param lo minimum endpoint</span><br><span class="line">     * @param hi maximum endpoint</span><br><span class="line">     * @return all keys in this symbol table between &#123;@code lo&#125; </span><br><span class="line">     *         (inclusive) and &#123;@code hi&#125; (inclusive)</span><br><span class="line">     * @throws IllegalArgumentException if either &#123;@code lo&#125; or &#123;@code hi&#125;</span><br><span class="line">     *         is &#123;@code null&#125;</span><br><span class="line">     */</span><br><span class="line">    public Iterable&lt;Key&gt; keys(Key lo, Key hi) &#123;</span><br><span class="line">        if (lo == null) throw new IllegalArgumentException(&quot;first argument to keys() is null&quot;); </span><br><span class="line">        if (hi == null) throw new IllegalArgumentException(&quot;second argument to keys() is null&quot;); </span><br><span class="line"></span><br><span class="line">        Queue&lt;Key&gt; queue = new Queue&lt;Key&gt;(); </span><br><span class="line">        if (lo.compareTo(hi) &gt; 0) return queue;</span><br><span class="line">        for (int i = rank(lo); i &lt; rank(hi); i++) </span><br><span class="line">            queue.enqueue(keys[i]);</span><br><span class="line">        if (contains(hi)) queue.enqueue(keys[rank(hi)]);</span><br><span class="line">        return queue; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>两种方法的对比，可以看见，尽管有序数组的二分查找能够保证查找速度，但随着问题规模的增大，它的插入效率反倒是很低，这就需要一种更好的结构来解决查找和插入两方面的问题<br><img src="/upload/pasted-145.png" alt="upload successful"></p>]]></content>
      
      
      <categories>
          
          <category> 从零开始的算法征程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 查找算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java与基本数据结构</title>
      <link href="/2018/02/12/va%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2018/02/12/va%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><h3 id="一般概念"><a href="#一般概念" class="headerlink" title="一般概念"></a>一般概念</h3><p>队列是数据结构中比较重要的一种类型，它支持 FIFO，尾部添加、头部删除（先进队列的元素先出队列），跟我们生活中的排队类似。</p><h3 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h3><p>单队列，即用一个数组实现的队列</p><p><img src="/upload/pasted-129.png" alt="upload successful"><br>每添加一个队列，队尾向后移动一位，当添加四个元素后<br><img src="/upload/pasted-130.png" alt="upload successful"><br>前两个元素出队后</p><p><img src="/upload/pasted-131.png" alt="upload successful"><br>所谓“假溢出”就是对于当前队列，当想再添加两个元素时，却溢出了，但实际上当前数组是还有空位的</p><p><img src="/upload/pasted-132.png" alt="upload successful"></p><p>而利用循环队列，避免了假溢出的问题<br>对于循环队列，添加新元素时，rear不是单纯的+1 而是<strong>rear = (rear - size) % size</strong>,对于上面的实例，<strong>rear = ( 5 - 5) % 5 = 0</strong> </p><p><img src="/upload/pasted-133.png" alt="upload successful"><br>判满的条件<strong>(rear - front) % size = 1。</strong></p><h3 id="java中的queue"><a href="#java中的queue" class="headerlink" title="java中的queue"></a>java中的queue</h3><p>Java 集合中的 Queue 继承自 Collection 接口 ，Deque, LinkedList, PriorityQueue, BlockingQueue 等类都实现了它。 Queue 用来存放 等待处理元素 的集合，这种场景一般用于缓冲、并发访问。 除了继承 Collection 接口的一些方法，Queue 还添加了额外的 添加、删除、查询操作。</p><p><img src="/upload/pasted-134.png" alt="upload successful"><br>对于提供的两种向队尾插入元素的方法，当插入add(null) 会抛异常，而offer()只会返回false</p><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p><img src="/upload/pasted-135.png" alt="upload successful"></p><h3 id="一般概念-1"><a href="#一般概念-1" class="headerlink" title="一般概念"></a>一般概念</h3><p>Set 继承于 Collection 接口，是一个<strong>不允许出现重复元素，并且无序</strong>的集合，主要 HashSet 和 TreeSet 两大实现类。<br>在判断重复元素的时候，Set 集合会调用 <strong>hashCode()和 equal()</strong>方法来实现。</p><p>HashSet 是哈希表结构，主要利用 HashMap 的 key 来存储元素，计算插入元素的 hashCode 来获取元素在集合中的位置；</p><p>TreeSet 是红黑树结构，每一个元素都是树中的一个节点，插入的元素都会进行排序；</p><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><p>HashSet实现Set接口，底层由HashMap来实现，为哈希表结构，新增元素相当于HashMap的key，value默认为一个固定的Object<br>当有元素插入的时候，会计算元素的hashCode值，将元素插入到哈希表对应的位置中来<br>它继承于AbstractSet，实现了Set, Cloneable, Serializable接口。</p><ul><li>HashSet继承AbstractSet类，获得了Set接口大部分的实现，减少了实现此接口所需的工作，实际上是又继承了AbstractCollection类；</li><li>HashSet实现了Set接口，获取Set接口的方法，可以自定义具体实现，也可以继承AbstractSet类中的实现；</li><li>HashSet实现Cloneable，得到了clone()方法，可以实现克隆功能；</li><li>HashSet实现Serializable，表示可以被序列化，通过序列化去传输，典型的应用就是hessian协议。</li></ul><p>具有如下特点：</p><ul><li><p>不允许出现重复因素；</p></li><li><p>允许插入Null值；</p></li><li><p>元素无序（添加顺序和遍历顺序不一致）；</p></li><li><p>线程不安全，若2个线程同时操作HashSet，必须通过代码实现同步；</p></li></ul><ul><li><p>HashSet没有get()方法，remove元素时通过hashcode的值来删除</p></li><li><p>HashSet不允许添加重复元素的具体解释：<br>HashSey 的add方法实际上是调用HashMap的put()方法<br>在向HashMap中添加元素时，先判断key的hashCode值是否相同，如果相同，则调用equals()、==进行判断，若相同则覆盖原有元素；如果不同，则直接向Map中添加元素；</p><h3 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h3><p>从名字上可以看出，此集合的实现和树结构有关。与HashSet集合类似，TreeSet也是基于Map来实现，具体实现TreeMap(后面讲解)，其底层结构为红黑树（特殊的二叉查找树）；<br>与HashSet不同的是，TreeSet具有排序功能，分为自然排序(123456)和自定义排序两类，默认是自然排序；在程序中，我们可以按照任意顺序将元素插入到集合中，等到遍历时TreeSet会按照一定顺序输出–倒序或者升序；</p></li></ul><p>它继承AbstractSet，实现NavigableSet, Cloneable, Serializable接口。<br>（1）与HashSet同理，TreeSet继承AbstractSet类，获得了Set集合基础实现操作；<br>（2）TreeSet实现NavigableSet接口，而NavigableSet又扩展了SortedSet接口。这两个接口主要定义了搜索元素的能力，例如给定某个元素，查找该集合中比给定元素大于、小于、等于的元素集合，或者比给定元素大于、小于、等于的元素个数；简单地说，实现NavigableSet接口使得TreeSet具备了元素搜索功能；<br>（3）TreeSet实现Cloneable接口，意味着它也可以被克隆；<br>（4）TreeSet实现了Serializable接口，可以被序列化，可以使用hessian协议来传输；</p><p>具有如下特点：</p><ul><li><p>对插入的元素进行排序，是一个有序的集合（主要与HashSet的区别）;</p></li><li><p>底层使用红黑树结构，而不是哈希表结构；</p></li><li><p>允许插入Null值；</p></li><li><p>不允许插入重复元素；</p></li><li><p>线程不安全；</p></li></ul><p>TreeSet自然排序和自定义排序的具体方法<br>TreeSet在调用add()时，会调用TreeMap的put()方法，在put方法中会调用到compare(key, key)方法，进行key大小的比较；对于string integer等原生类型，已经实现了comparable接口，而对于自定义类型，需要先实现comparable接口，否则会抛异常</p><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="一般概念-2"><a href="#一般概念-2" class="headerlink" title="一般概念"></a>一般概念</h3><p>在 List 中，用户可以<strong>精确控制列表中每个元素的插入位置</strong>，另外用户可以<strong>通过整数索引（列表中的位置）访问元素</strong>，并搜索列表中的元素。 与 Set 不同，List 通常<strong>允许重复的元素</strong>。 另外 List 是有序集合而 Set 是无序集合。</p><h3 id="常见实现类"><a href="#常见实现类" class="headerlink" title="常见实现类"></a>常见实现类</h3><p>ArrayList 是一个数组队列，相当于动态数组。它由数组实现，随机访问效率高，随机插入、随机删除效率低。</p><p>LinkedList 是一个双向链表。它也可以被当作堆栈、队列或双端队列进行操作。LinkedList随机访问效率低，但随机插入、随机删除效率高。</p><p>Vector 是矢量队列，和ArrayList一样，它也是一个动态数组，由数组实现。但是ArrayList是非线程安全的，而Vector是线程安全的。</p><p>Stack 是栈，它继承于Vector。它的特性是：先进后出(FILO, First In Last Out)。</p><h3 id="ArrayList-LinkedList"><a href="#ArrayList-LinkedList" class="headerlink" title="ArrayList,LinkedList"></a>ArrayList,LinkedList</h3><h3 id="Vector-Stack"><a href="#Vector-Stack" class="headerlink" title="Vector Stack"></a>Vector Stack</h3><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2>]]></content>
      
      
      <categories>
          
          <category> 从零开始的算法征程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进阶的排序算法（归并，快排，堆排）</title>
      <link href="/2018/02/08/%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%BD%92%E5%B9%B6%EF%BC%8C%E5%BF%AB%E6%8E%92%EF%BC%8C%E5%A0%86%E6%8E%92%EF%BC%89/"/>
      <url>/2018/02/08/%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%EF%BC%88%E5%BD%92%E5%B9%B6%EF%BC%8C%E5%BF%AB%E6%8E%92%EF%BC%8C%E5%A0%86%E6%8E%92%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<hr><h1 id="进阶的排序算法"><a href="#进阶的排序算法" class="headerlink" title="进阶的排序算法"></a>进阶的排序算法</h1><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>归并排序是基于分治思想而设计的：一个大的需要排序的数组，在处理上是把它从中间分成两个小的排序数组，两个小的排序数组再分成两个更小的数组……直到每个数组不能再继续划分了（lo&gt;=hi的时候），这个时候再两两小数组进行原地（in place）归并……最终归并成一个数组<br><img src="/upload/pasted-99.png" alt="upload successful"></p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>自顶向下的方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//</span><br><span class="line">public class Merge &#123;</span><br><span class="line">    // 不可实例化</span><br><span class="line">    private Merge() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    // 将a[lo..mid](有序) 和a[mid..hi]（有序）利用中间数组aux进行归并</span><br><span class="line">    private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) &#123;</span><br><span class="line">    //初始应满足a[lo..mid] 和a[mid..hi]都是有序的</span><br><span class="line"></span><br><span class="line">        // 把a复制到aux</span><br><span class="line">        for (int k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">            aux[k] = a[k]; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 进行原地归并</span><br><span class="line">        int i = lo, j = mid+1;</span><br><span class="line">        for (int k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">            //当[lo..mid已经全部排入数组中</span><br><span class="line">            if      (i &gt; mid)              a[k] = aux[j++];</span><br><span class="line">            //当[mid..hi]已经全部排入数组中</span><br><span class="line">            else if (j &gt; hi)               a[k] = aux[i++];</span><br><span class="line">            else if (aux[j]&gt;aux[i]) a[k] = aux[j++];</span><br><span class="line">            else                           a[k] = aux[i++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将a[lo..hi]进行归并排序 利用辅助数组aux[lo..hi]</span><br><span class="line">    private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) &#123;</span><br><span class="line">        if (hi &lt;= lo) return;</span><br><span class="line">        int mid = lo + (hi - lo) / 2;</span><br><span class="line">        sort(a, aux, lo, mid);</span><br><span class="line">        sort(a, aux, mid + 1, hi);</span><br><span class="line">        merge(a, aux, lo, mid, hi);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将一个数组进行升序排序</span><br><span class="line">     * @param a the array to be sorted</span><br><span class="line">     */</span><br><span class="line">    public static void sort(Comparable[] a) &#123;</span><br><span class="line">        //注意是在这里创建辅助函数，而不是在递归过程中</span><br><span class="line">        Comparable[] aux = new Comparable[a.length];</span><br><span class="line">        sort(a, aux, 0, a.length-1);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>自底向上的方式：从小数组（数组长度为1）开始归并到大数组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class MergeBU &#123;</span><br><span class="line"></span><br><span class="line">    // This class should not be instantiated.</span><br><span class="line">    private MergeBU() &#123; &#125;</span><br><span class="line"></span><br><span class="line">    // stably merge a[lo..mid] with a[mid+1..hi] using aux[lo..hi]</span><br><span class="line">    private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) &#123; //和上面的相同</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Rearranges the array in ascending order, using the natural order.</span><br><span class="line">     * @param a the array to be sorted</span><br><span class="line">     */</span><br><span class="line">    public static void sort(Comparable[] a) &#123;</span><br><span class="line">        int n = a.length;</span><br><span class="line">        Comparable[] aux = new Comparable[n];</span><br><span class="line">        for (int len = 1; len &lt; n; len *= 2) &#123;</span><br><span class="line">            for (int lo = 0; lo &lt; n-len; lo += len+len) &#123;</span><br><span class="line">                int mid  = lo+len-1;</span><br><span class="line">                int hi = Math.min(lo+len+len-1, n-1);</span><br><span class="line">                merge(a, aux, lo, mid, hi);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="图形演示"><a href="#图形演示" class="headerlink" title="图形演示"></a>图形演示</h3><p><img src="/upload/4.gif" alt="upload successful"></p><p><img src="/upload/pasted-101.png" alt="upload successful"></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>对于N数组，自顶向下的归并排序需要1/2NlgN到NlgN次比较</li><li>对于N数组，自顶向下的归并排序需要访问数组6NlgN（两次复制，两次将排好的元素移动回去，最多两次比较）次</li></ul><p><img src="/upload/pasted-100.png" alt="upload successful"></p><ul><li><p>需要空间N(辅助数组)</p><h3 id="算法改进"><a href="#算法改进" class="headerlink" title="算法改进"></a>算法改进</h3></li><li>对于特别小的数组，运用归并排序太复杂，所以可以设定一个cutoff值，进行插入排序</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) &#123;</span><br><span class="line"> </span><br><span class="line">    //对阈值进行判断，如果满足条件就进行</span><br><span class="line">    if (hi &lt;= lo+CUTOFF-1)&#123;</span><br><span class="line">    Insertion.sort(a,lo,hi)</span><br><span class="line">    return;</span><br><span class="line">    &#125;</span><br><span class="line">    int mid = lo + (hi - lo) / 2;</span><br><span class="line">    sort(a, aux, lo, mid);</span><br><span class="line">    sort(a, aux, mid + 1, hi);</span><br><span class="line">    merge(a, aux, lo, mid, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在merge之前如果两个数组已经是有顺序的，则跳过merge</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) &#123;</span><br><span class="line">    if (hi &lt;= lo) return;</span><br><span class="line">    int mid = lo + (hi - lo) / 2;</span><br><span class="line">    sort(a, aux, lo, mid);</span><br><span class="line">    sort(a, aux, mid + 1, hi);</span><br><span class="line">    //只需判断前一部分是否大于后一部分</span><br><span class="line">    if(a[mid+1]&lt;a[mid]) return ;</span><br><span class="line">    merge(a, aux, lo, mid, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>减少复制到aux的花销</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 将a[lo..mid](有序) 和a[mid..hi]（有序）利用中间数组aux进行归并</span><br><span class="line">private static void merge(Comparable[] a, Comparable[] aux, int lo, int mid, int hi) &#123;</span><br><span class="line">//初始应满足a[lo..mid] 和a[mid..hi]都是有序的</span><br><span class="line"></span><br><span class="line">     //取消复制到aux</span><br><span class="line"></span><br><span class="line">    // 进行原地归并</span><br><span class="line">    int i = lo, j = mid+1;</span><br><span class="line">    for (int k = lo; k &lt;= hi; k++) &#123;</span><br><span class="line">        //当[lo..mid已经全部排入数组中</span><br><span class="line">        if      (i &gt; mid)              aux[k] = a[j++];//注意变化</span><br><span class="line">        //当[mid..hi]已经全部排入数组中</span><br><span class="line">        else if (j &gt; hi)               aux[k] = a[i++];</span><br><span class="line">        else if (aux[j]&gt;aux[i])        aux[k] = a[j++];</span><br><span class="line">        else                           aux[k] = a[i++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    // 将a[lo..hi]进行归并排序 利用辅助数组aux[lo..hi]</span><br><span class="line">private static void sort(Comparable[] a, Comparable[] aux, int lo, int hi) &#123;</span><br><span class="line">    if (hi &lt;= lo) return;</span><br><span class="line">    int mid = lo + (hi - lo) / 2;</span><br><span class="line">    sort(aux, a, lo, mid);</span><br><span class="line">    sort(aux, a, mid + 1, hi);</span><br><span class="line">    merge(a, aux, lo, mid, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>快速排序是一种基于分治思想的排序算法，它将一个数组分成两个子数组，将两部分进行独立的排序<br>首先选择切分点（partition），然后动用两个指针进行操作，一个在开始，一个在结尾，开头移动的遇见比切分点大的值以后停止，结尾指针向前移动，遇见比切分点小的值以后停止，然后开头指针和结尾指针交换位置，交换位置后继续以上操作，小指针大于等于大指针，最后相遇时，再把切分点和大指针交换，此时，就满足了左边的值全部小于切分点，右边的值全部大于切分点</p><h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//对子数组进行切分，使其 a[lo..j-1] &lt;= a[j] &lt;= a[j+1..hi]</span><br><span class="line">   // 返回切分位置j</span><br><span class="line">   private static int partition(Comparable[] a, int lo, int hi) &#123;</span><br><span class="line">       int i = lo;</span><br><span class="line">       int j = hi + 1;</span><br><span class="line">       Comparable v = a[lo];</span><br><span class="line">       while (true) &#123; </span><br><span class="line"></span><br><span class="line">           //找到小指针需要交换的位置（左侧元素大于等于切分元素）</span><br><span class="line">           while (less(a[++i], v)) &#123;</span><br><span class="line">               if (i == hi) break;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // 找到大指针需要交换的位置（右侧元素小于等于切分元素）</span><br><span class="line">           while (less(v, a[--j])) &#123;</span><br><span class="line">               if (j == lo) break;      // redundant since a[lo] acts as sentinel</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           //检查是否指针越界</span><br><span class="line">           if (i &gt;= j) break;</span><br><span class="line"></span><br><span class="line">           exch(a, i, j);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       // 把切分值置于a[j]</span><br><span class="line">       exch(a, lo, j);</span><br><span class="line"></span><br><span class="line">       // 此时满足 a[lo .. j-1] &lt;= a[j] &lt;= a[j+1 .. hi]</span><br><span class="line">       return j;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>进行排序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static void sort(Comparable[] a, int lo, int hi) &#123; </span><br><span class="line">       if (hi &lt;= lo) return;</span><br><span class="line">       int j = partition(a, lo, hi);</span><br><span class="line">       sort(a, lo, j-1);</span><br><span class="line">       sort(a, j+1, hi);</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>内循环操作较少，只是用一个递增的数组索引和一个定值比较</li><li>比较次数较少【有数学方法可证】</li><li>缺点：切分不平衡时会低效，比如第一次切分点选的是最小的第二次选的是第二小的，此时需要n^2/2次比较</li></ul><h3 id="算法改进-1"><a href="#算法改进-1" class="headerlink" title="算法改进"></a>算法改进</h3><ul><li>小数组换用别的方法（插入排序）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (hi &lt;= lo) return;</span><br></pre></td></tr></table></figure></li></ul><p>改为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (hi &lt;= lo+M) &#123;Insertion.sort(a,lo,hi);return;&#125;</span><br></pre></td></tr></table></figure></p><p>M在5到15之间</p><ul><li>重复元素较多时<br>三向切分的快速排序,此法规避了对与切分元素相等的元素操作</li></ul><p><img src="/upload/pasted-125.png" alt="upload successful"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private static void sort(Comparable[] a, int lo, int hi) &#123; </span><br><span class="line">    if (hi &lt;= lo) return;</span><br><span class="line">    int lt = lo, gt = hi;</span><br><span class="line">    Comparable v = a[lo];</span><br><span class="line">    int i = lo + 1;</span><br><span class="line">    while (i &lt;= gt) &#123;</span><br><span class="line">        int cmp = a[i].compareTo(v);</span><br><span class="line">        if      (cmp &lt; 0) exch(a, lt++, i++);</span><br><span class="line">        else if (cmp &gt; 0) exch(a, i, gt--);</span><br><span class="line">        else              i++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // a[lo..lt-1] &lt; v = a[lt..gt] &lt; a[gt+1..hi]. </span><br><span class="line">    sort(a, lo, lt-1);</span><br><span class="line">    sort(a, gt+1, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img src="/upload/pasted-124.png" alt="upload successful"></p><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h4><p>二叉堆是一棵堆有序的二叉树，所谓堆有序的二叉树，是指在一棵二叉树中，每个节点都小于等它的父节点。任意结点向上，我们可以得到一个非递减数列，任意结点向下，可得到一个非递增数列。可以用一棵完全二叉树进行表示，先定根结点，然后一层一层的由上到下，由左到右，这样数组就可以表示<br>用数组索引进行访问：a[k] 向上一层就是a[k/2]，向下一层就是a[k<em>2]或者a[k</em>2+1]</p><h4 id="堆有序化"><a href="#堆有序化" class="headerlink" title="堆有序化"></a>堆有序化</h4><p>当某个结点大于其父节点时，可以进行上浮操作<br><img src="/upload/pasted-126.png" alt="upload successful"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void swim(int k) &#123;</span><br><span class="line">   while (k &gt; 1 &amp;&amp; less(k/2, k)) &#123;</span><br><span class="line">      exch(k, k/2);</span><br><span class="line">      k = k/2;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当某个结点小于其子节点时，可以采用下沉操作</p><p><img src="/upload/pasted-127.png" alt="upload successful"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void sink(int k) &#123;</span><br><span class="line">   while (2*k &lt;= N) &#123;</span><br><span class="line">      int j = 2*k;</span><br><span class="line">      if (j &lt; N &amp;&amp; less(j, j+1)) j++;</span><br><span class="line">      if (!less(k, j)) break;</span><br><span class="line">      exch(k, j);</span><br><span class="line">      k = j;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="堆排序-1"><a href="#堆排序-1" class="headerlink" title="堆排序"></a>堆排序</h4><p>堆排序可以分为 构造堆 和 下沉排序两个步骤<br>对于构造堆，可以采用从左向右的上浮操作，但是更好的方式是从右向左的下沉操作，因为一旦一个结点的两个子结点已经是堆了，那么对于该节点来说，一旦进行下沉操作，仍然能够保证堆结构</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public static void sort(Comparable[] pq) &#123;</span><br><span class="line">       int n = pq.length;</span><br><span class="line">       //第一个循环构造堆</span><br><span class="line">       for (int k = n/2; k &gt;= 1; k--)</span><br><span class="line">           sink(pq, k, n);</span><br><span class="line">       //第二个循环下沉排序</span><br><span class="line">       while (n &gt; 1) &#123;</span><br><span class="line">           exch(pq, 1, n--);</span><br><span class="line">           sink(pq, 1, n);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">private static void sink(Comparable[] pq, int k, int n) &#123;</span><br><span class="line">       while (2*k &lt;= n) &#123;</span><br><span class="line">           int j = 2*k;</span><br><span class="line">           if (j &lt; n &amp;&amp; less(pq, j, j+1)) j++;</span><br><span class="line">           if (!less(pq, k, j)) break;</span><br><span class="line">           exch(pq, k, j);</span><br><span class="line">           k = j;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h3><p><img src="/upload/pasted-128.png" alt="upload successful"></p><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><ul><li>堆构建需要小于等于2N次比较和交换</li><li>堆排序需要小于等于2NlgN次比较和交换</li><li>是能同时满足原地且最坏情况仍然是NlogN的排序<br>希尔排序需要额外的空间，快速排序最坏情况是平方级别</li><li>内循环比快排的操作多</li><li>缓存应用较少</li><li>不稳定</li></ul>]]></content>
      
      
      <categories>
          
          <category> 从零开始的算法征程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三种基本排序的总结（选择，插入，希尔）</title>
      <link href="/2018/02/07/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%BB%E7%BB%93/"/>
      <url>/2018/02/07/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%9A%84%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="基本排序算法的学习"><a href="#基本排序算法的学习" class="headerlink" title="基本排序算法的学习"></a>基本排序算法的学习</h1><h2 id="选择排序-selection-sort"><a href="#选择排序-selection-sort" class="headerlink" title="选择排序 (selection sort)"></a>选择排序 (selection sort)</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>首先找出最小的元素，放在开头，然后再在剩下的里面找出第二小的元素，放在第二位置，一直重复，直到数组有序，正是因为不停的需要“选择”出最小的元素，所以才会被叫做“选择排序”</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> int n = a.length;</span><br><span class="line"> for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">     int min = i;//首先把当前位置的元素记做最小</span><br><span class="line">     for (int j = i+1; j &lt; n; j++) &#123;//在后续的数中“选择”出最小</span><br><span class="line">         if (a[j]&lt;a[min]) min = j;</span><br><span class="line">     &#125;</span><br><span class="line">     swap(a[i], a[min])//将实际最小元素换到当前位置</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图形演示"><a href="#图形演示" class="headerlink" title="图形演示"></a>图形演示</h3><p><img src="/upload/1.gif" alt="upload successful"></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>时间：需要比较n^2/2次（累加和）以及n次交换,需要平方级时间</li><li>与输入序列有序程度无关</li></ul><h2 id="插入排序-insertion-sort"><a href="#插入排序-insertion-sort" class="headerlink" title="插入排序(insertion sort)"></a>插入排序(insertion sort)</h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>插入排序，顾名思义就是不断的向上插入置合适位置，当前位置的元素不断的和前一个比若是小了，就交换位置，直到到了前一个数小于等于当前数的时候</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> int n = a.length;</span><br><span class="line"> for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">//对于j，只是要求其不断的和前一个比，若是小了就交换位置，直到到达目标位置</span><br><span class="line">     for (int j = i; j &gt; 0 &amp;&amp; a[j]&lt;a[j-1]; j--) &#123;</span><br><span class="line">         swap(a[j], a[j-1]);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="图形演示-1"><a href="#图形演示-1" class="headerlink" title="图形演示"></a>图形演示</h3><p><img src="/upload/2.gif" alt="upload successful"></p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>对于插入排序，平均需要N^2/4次比较和N^2/4次交换，最坏情况下是N^2/2次比较和N^2/2次交换，最好情况是N-1次比较和0次交换</li><li>交换次数和逆序数对一致，比较次数大于等于逆序数对数量，小于等于逆序数对数量+数组大小-1<h3 id="算法改进"><a href="#算法改进" class="headerlink" title="算法改进"></a>算法改进</h3>只需将内循环中将较大的元素都向右移动而不是交换两个元素，这样能使访问数组的次数减半</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int N = a.length;</span><br><span class="line">for (int i = 1; i &lt; N; i++) &#123;</span><br><span class="line">int t = a[i];</span><br><span class="line">for (int j = i; j &gt; 0 &amp;&amp; t&lt;a[j-1]; j--) &#123;</span><br><span class="line">a[j] = a[j-1]; //大的右移</span><br><span class="line">&#125;</span><br><span class="line">a[j] = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="希尔排序（shell-sort）"><a href="#希尔排序（shell-sort）" class="headerlink" title="希尔排序（shell sort）"></a>希尔排序（shell sort）</h2><h3 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h3><p>由于插入排序是相邻元素进行交换的，如果遇上最坏情况，需要移动n-1次。希尔排序则是弥补这种缺陷，交换不相邻的元素以对数组的局部进行排序，并最终用插入排序将局部有序的数组进行排序<br>希尔排序的思想是使任意间隔h的元素都是有序的，h有序到1有序（插入排序）递减<br>通常用Kruth的3K+1作为递减的依据</p><h3 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">int n = a.length;</span><br><span class="line">// 3x+1 increment sequence:  1, 4, 13, 40, 121, 364, 1093, ... </span><br><span class="line">int h = 1;</span><br><span class="line">while (h &lt; n/3) h = 3*h + 1; </span><br><span class="line"></span><br><span class="line">while (h &gt;= 1) &#123;</span><br><span class="line">    // h-sort the array</span><br><span class="line">    for (int i = h; i &lt; n; i++) &#123;</span><br><span class="line">        for (int j = i; j &gt;= h &amp;&amp; a[j]&lt;a[j-h]; j -= h) &#123;</span><br><span class="line">            swap(a[j],a[j-h]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    h /= 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图形演示-2"><a href="#图形演示-2" class="headerlink" title="图形演示"></a>图形演示</h3><p><img src="/upload/pasted-78.png" alt="upload successful"><br><img src="/upload/3.gif" alt="upload successful"></p><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><p>3x+1的希尔排序的最坏情况是O(N^(3/2))</p>]]></content>
      
      
      <categories>
          
          <category> 从零开始的算法征程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javaweb入门：三层架构</title>
      <link href="/2018/01/10/javaweb3levels/"/>
      <url>/2018/01/10/javaweb3levels/</url>
      
        <content type="html"><![CDATA[<h1 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h1><p>MVC 是一种使用 MVC（Model View Controller 模型-视图-控制器）设计创建 Web 应用程序的模式</p><ul><li>Model（模型）。是应用程序中用于处理应用程序数据逻辑的部分。</li><li>View（视图）。是应用程序中处理数据显示的部分。</li><li>Controller（控制器）是应用程序中处理用户交互的部分。</li></ul><h1 id="JavaEE的MVC-三层架构"><a href="#JavaEE的MVC-三层架构" class="headerlink" title="JavaEE的MVC-三层架构"></a>JavaEE的MVC-三层架构</h1><p>web层：收集页面的数据，封装数据，指定响应jsp页面（与客户端进行对接交互）<br>service层：顾名思义 来进行复杂业务处理和运算的<br>dao层 ：这层主要是与数据库进行交互</p><p><img src="/upload/pasted-454.png" alt="upload successful"></p><h1 id="具体实验"><a href="#具体实验" class="headerlink" title="具体实验"></a>具体实验</h1><p>开发时的项目架构</p><p><img src="/upload/pasted-455.png" alt="upload successful"><br>配置好MySQL，Tomcat，导入相关的包</p><p>第一层：web层–servlet类<br>首先先将请求传至service的进行业务操作，创建一个service对象和一个存储数据的集合list，进入service的findAllProduct方法（）<br>里面通过操作，拿取出并存储数据，然后转发给jsp页面进行显示。<br>先将数据存储到request域中，在转发给jsp页面。</p><p><img src="/upload/pasted-456.png" alt="upload successful"><br>第二层：service层<br>由于我们此demo中没有什么特别的业务操作，所以就只有调用dao层的方法，进入dao层。<br><img src="/upload/pasted-457.png" alt="upload successful"></p><p>第三层：dao层<br>利用QueryRunner核心类通过dbutils来用SQL语句操作数据库，拿取到所有的数据存储到list集合中，再依次将list return回我们的web层进行数据的交互。<br><img src="/upload/pasted-458.png" alt="upload successful"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博文——关于博客的博文</title>
      <link href="/2018/01/02/hello-world/"/>
      <url>/2018/01/02/hello-world/</url>
      
        <content type="html"><![CDATA[<p>花了一下午时间，终于搞好了这个基于hexo的博客系统，也搞了自己的域名，现在终于可以愉快的玩耍了<br>搭建这个博客，也是参考了许多地方，现在稍微总结一下这个博客的搭建过程，只要肯用心，还是能够做出很高（hua）雅（shao）的博客的</p><h2 id="1-环境搭建（Windows）"><a href="#1-环境搭建（Windows）" class="headerlink" title="1.环境搭建（Windows）"></a>1.环境搭建（Windows）</h2><h3 id="1-node-js"><a href="#1-node-js" class="headerlink" title="1.node.js"></a>1.node.js</h3><p>官网直接下载即可<br><img src="/upload/pasted-2.png" alt="upload successful"></p><h3 id="2-Git-bash"><a href="#2-Git-bash" class="headerlink" title="2. Git bash"></a>2. Git bash</h3><p>也是直接下载即可<br><img src="/upload/pasted-3.png" alt="upload successful"></p><h3 id="3-hexo"><a href="#3-hexo" class="headerlink" title="3.hexo"></a>3.hexo</h3><p>首先创建一个文件夹，用以装载博客的内容，以后所有关于博客的操作都将基于这个这个文件夹下，然后把gitbash开到当前目录下，比如我是D:/blogContent 输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> D:/blogContent</span><br></pre></td></tr></table></figure></p><p>打开如图<br><img src="/upload/pasted-4.png" alt="upload successful"><br>然后输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g hexo</span><br></pre></td></tr></table></figure></p><p>再输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure></p><p>进行初始化</p><h2 id="2-GItHub准备"><a href="#2-GItHub准备" class="headerlink" title="2.GItHub准备"></a>2.GItHub准备</h2><p>这里讲的是以GitHub作为博客所在的服务器的设置方式</p><h3 id="1-申请账号"><a href="#1-申请账号" class="headerlink" title="1.申请账号"></a>1.申请账号</h3><p>跟别的申请账号区别不大</p><h3 id="2-创建一个新的repo"><a href="#2-创建一个新的repo" class="headerlink" title="2.创建一个新的repo"></a>2.创建一个新的repo</h3><p><img src="/upload/pasted-5.png" alt="upload successful"><br>点击New<br>注意命名，要按照图上的要求<br><img src="/upload/pasted-6.png" alt="upload successful"></p><h3 id="3-设置ssh"><a href="#3-设置ssh" class="headerlink" title="3.设置ssh"></a>3.设置ssh</h3><p>在git bash中输入<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"youremail@example.com</span></span><br></pre></td></tr></table></figure></p><p>会在本地生成一个ssh文件，然后在本地找到id_rsa.pub（一般是在c盘用户文件夹下），用记事本打开，Ctrl+A,Cthl+C<br><img src="/upload/pasted-7.png" alt="upload successful"><br>然后打开登录的github，点右上角的头像,点击setting<br><img src="/upload/pasted-8.png" alt="upload successful"><br>点击ssh的设置，创建新的ssh<br><img src="/upload/pasted-9.png" alt="upload successful"></p><p><img src="/upload\pasted-10.png" alt="upload successful"></p><h2 id="3-博客文件内容和git-repo绑定"><a href="#3-博客文件内容和git-repo绑定" class="headerlink" title="3.博客文件内容和git repo绑定"></a>3.博客文件内容和git repo绑定</h2><p>打开本地博客地址下的设置文件,用记事本打开，如果有sublime更好，如图</p><p><img src="/upload/pasted-11.png" alt="upload successful"><br>在这个文件的最下面加上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/YourGithubName/YourgitgubName.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line">server:</span><br><span class="line">  port: 5000</span><br><span class="line">  compress: true</span><br><span class="line">  header: true</span><br></pre></td></tr></table></figure></p><p>本来hexo的博客默认端口是4000的，但是如果安装了福晰阅读器的话那个端口就被占了所以这里改成5000</p><h2 id="4-本地预览和上传"><a href="#4-本地预览和上传" class="headerlink" title="4.本地预览和上传"></a>4.本地预览和上传</h2><h3 id="1-本地预览"><a href="#1-本地预览" class="headerlink" title="1. 本地预览"></a>1. 本地预览</h3><p>在git bash上输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate(可简写为 g)</span><br><span class="line">hexo server(可简写为 s)</span><br></pre></td></tr></table></figure></p><p>然后在浏览器上输入localhost：5000（也可以是上面自己设置的其他端口）。就可以看见博客的基本形态，默认有一篇博文hello world，如果没有出现，可能的原因是端口被占了，改下端口号</p><h3 id="2-上传github"><a href="#2-上传github" class="headerlink" title="2.上传github"></a>2.上传github</h3><p>先进行安装在bash上输入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p><p>然后执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo generate</span><br><span class="line">hexo deploy(可简写为d)</span><br></pre></td></tr></table></figure></p><p>第一次上传会需要输入GitHub的账号密码</p><h3 id="3-网络预览"><a href="#3-网络预览" class="headerlink" title="3.网络预览"></a>3.网络预览</h3><p>浏览器输入<a href="http://yourgithubname.github.io" target="_blank" rel="noopener">http://yourgithubname.github.io</a> 就可以看见了</p><h2 id="5-绑定个人域名"><a href="#5-绑定个人域名" class="headerlink" title="5.绑定个人域名"></a>5.绑定个人域名</h2><p>如果觉得上面那个名字太low（比如我）,那么就可以自己买个域名改上<br>首先在阿里云或者别的地方买个域名，但是在这之前一定要把要求的信息弄好（实名制，邮箱）<br>买域名的话，挑便宜的买就好了，有人说要是买cn,com的除了实名制意外还需要备案，据说要花上几天，但是我买的top，实名制很快，不需要备案，很快就搞定了<br>假设已经买了个人域名</p><h3 id="1-获取博客的IP（就是git上的ip）"><a href="#1-获取博客的IP（就是git上的ip）" class="headerlink" title="1.获取博客的IP（就是git上的ip）"></a>1.获取博客的IP（就是git上的ip）</h3><p>打开控制台（win+r输入cmd）<br><img src="/upload/pasted-12.png" alt="upload successful"><br>输入ping yourgithubname.github.io 可以获得IP地址</p><p><img src="/upload/pasted-13.png" alt="upload successful"></p><h3 id="2-域名解析设置"><a href="#2-域名解析设置" class="headerlink" title="2.域名解析设置"></a>2.域名解析设置</h3><p>点击解析<br><img src="/upload/pasted-14.png" alt="upload successful"><br>点击新手引导<br><img src="/upload/pasted-15.png" alt="upload successful"><br>把刚才的ip地址输上去<br><img src="/upload/pasted-16.png" alt="upload successful"></p><h3 id="3-github设置"><a href="#3-github设置" class="headerlink" title="3.github设置"></a>3.github设置</h3><p>点击设置为博客的repo,进入以后点击settings<br><img src="/upload/pasted-17.png" alt="upload successful"><br>进入以后直接往下翻找到Custom domain<br><img src="/upload/pasted-19.png" alt="upload successful"><br>点击save<br>至此你就可以通过自己的域名访问博客了</p>]]></content>
      
      
      <categories>
          
          <category> 攻略技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>qwe</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<p>什么都没有</p>]]></content>
      
    </entry>
    
    
  
</search>
